page,block,heading,content,avgFontSize,height,width,textLength,x0,y0,x1,y1,isBold,isItalic
1,1,H1,The Java Language Specification,30,52.74,244.65,31,129.68,151.99,374.33,204.73,FALSE,FALSE
17,1,H2,Introduction,30,16.74,148.32,12,283.68,149.29,432,166.03,FALSE,FALSE
29,1,H2,Grammars,30,16.74,126.63,8,305.37,149.29,432,166.03,FALSE,FALSE
35,1,H2,Lexical Structure,30,16.74,207.45,17,224.55,149.29,432,166.03,FALSE,FALSE
71,1,H2,"Types, Values, and Variables",30,16.74,352.41,28,79.59,149.29,432,166.03,FALSE,FALSE
125,1,H2,Conversions and Contexts,30,16.74,315,24,117,149.29,432,166.03,FALSE,FALSE
165,1,H2,Names,30,16.74,83.31,5,348.69,149.29,432,166.03,FALSE,FALSE
225,1,H2,Packages and Modules,30,16.74,274.95,20,157.05,149.29,432,166.03,FALSE,FALSE
253,1,H2,Classes,30,16.74,90,7,342,149.29,432,166.03,FALSE,FALSE
359,1,H2,Interfaces,30,16.74,118.26,10,313.74,149.29,432,166.03,FALSE,FALSE
417,1,H2,Arrays,30,16.74,81.63,6,350.37,149.29,432,166.03,FALSE,FALSE
429,1,H2,Exceptions,30,16.74,133.32,10,298.68,149.29,432,166.03,FALSE,FALSE
443,1,H2,Execution,30,16.74,121.65,9,310.35,149.29,432,166.03,FALSE,FALSE
467,1,H2,Binary Compatibility,30,16.74,255.87,20,176.13,149.29,432,166.03,FALSE,FALSE
499,1,H2,"Blocks, Statements, and Patterns",30,50.74,288.33,32,143.67,149.29,432,200.03,FALSE,FALSE
583,1,H2,Expressions,30,16.74,144.99,11,287.01,149.29,432,166.03,FALSE,FALSE
747,1,H2,Definite Assignment,30,16.74,249.15,19,182.85,149.29,432,166.03,FALSE,FALSE
775,1,H2,Threads and Locks,30,16.74,228.27,17,203.73,149.29,432,166.03,FALSE,FALSE
803,1,H2,Type Inference,30,16.74,182.4,14,249.6,149.29,432,166.03,FALSE,FALSE
841,1,H2,Syntax,30,16.74,83.34,6,348.66,149.29,432,166.03,FALSE,FALSE
1,2,BODY,Java SE 23 Edition,24,13.2,184.66,18,159.67,220.74,344.33,233.94,FALSE,TRUE
3,0,H1,Table of Contents,24,13.39,171.98,17,260.02,88.59,432,101.98,FALSE,FALSE
871,0,BODY,Appendix A. Limited License Grant,24,13.39,347.28,33,84.72,88.59,432,101.98,FALSE,FALSE
417,0,H1,CHAPTER10,20,26.78,146.67,9,285.33,103.33,432,130.12,FALSE,FALSE
429,0,H1,CHAPTER11,20,26.78,146.67,9,285.33,103.33,432,130.12,FALSE,FALSE
443,0,H1,CHAPTER12,20,26.78,146.67,9,285.33,103.33,432,130.12,FALSE,FALSE
467,0,H1,CHAPTER13,20,26.78,146.67,9,285.33,103.33,432,130.12,FALSE,FALSE
499,0,H1,CHAPTER14,20,26.78,146.67,9,285.33,103.33,432,130.12,FALSE,FALSE
583,0,H1,CHAPTER15,20,26.78,146.67,9,285.33,103.33,432,130.12,FALSE,FALSE
747,0,H1,CHAPTER16,20,26.78,146.67,9,285.33,103.33,432,130.12,FALSE,FALSE
775,0,H1,CHAPTER17,20,26.78,146.67,9,285.33,103.33,432,130.12,FALSE,FALSE
803,0,H1,CHAPTER18,20,26.78,146.67,9,285.33,103.33,432,130.12,FALSE,FALSE
841,0,H1,CHAPTER19,20,26.78,146.67,9,285.33,103.33,432,130.12,FALSE,FALSE
1,3,BODY,James Gosling Bill Joy Guy Steele Gilad Bracha Alex Buckley Daniel Smith Gavin Bierman,18,142.04,110.48,86,196.76,270.19,307.24,412.24,FALSE,FALSE
1,4,BODY,2024-08-21,18,10.04,83.99,10,210.01,522.19,293.99,532.24,FALSE,FALSE
17,0,H1,CHAPTER1,16.5,26.78,122.67,8,309.33,103.33,432,130.12,FALSE,FALSE
29,0,H1,CHAPTER2,16.5,26.78,122.67,8,309.33,103.33,432,130.12,FALSE,FALSE
35,0,H1,CHAPTER3,16.5,26.78,122.67,8,309.33,103.33,432,130.12,FALSE,FALSE
71,0,H1,CHAPTER4,16.5,26.78,122.67,8,309.33,103.33,432,130.12,FALSE,FALSE
125,0,H1,CHAPTER5,16.5,26.78,122.67,8,309.33,103.33,432,130.12,FALSE,FALSE
165,0,H1,CHAPTER6,16.5,26.78,122.67,8,309.33,103.33,432,130.12,FALSE,FALSE
225,0,H1,CHAPTER7,16.5,26.78,122.67,8,309.33,103.33,432,130.12,FALSE,FALSE
253,0,H1,CHAPTER8,16.5,26.78,122.67,8,309.33,103.33,432,130.12,FALSE,FALSE
359,0,H1,CHAPTER9,16.5,26.78,122.67,8,309.33,103.33,432,130.12,FALSE,FALSE
1,0,BODY,®,15,8.37,11.4,1,237.13,145.99,248.53,154.36,FALSE,FALSE
26,5,BODY,1.7References,13,7.49,86.88,13,72,358.56,158.88,366.06,TRUE,FALSE
30,4,BODY,2.4Grammar Notation,13,7.49,134.2,19,72,275.56,206.2,283.06,TRUE,FALSE
99,3,BODY,4.9Intersection Types,13,7.49,129.16,21,72,217.56,201.16,225.06,TRUE,FALSE
153,2,BODY,5.4String Contexts,13,7.49,113.27,18,72,77.56,185.27,85.06,TRUE,FALSE
232,2,BODY,7.4Package Declarations,13,7.49,145.76,23,72,77.56,217.76,85.06,TRUE,FALSE
234,6,BODY,7.5Import Declarations,13,7.49,139.26,22,72,364.56,211.26,372.06,TRUE,FALSE
408,7,BODY,9.8Functional Interfaces,13,7.49,145.04,24,72,386.56,217.04,394.06,TRUE,FALSE
412,4,BODY,9.9Function Types,13,7.49,112.57,17,72,292.56,184.57,300.06,TRUE,FALSE
422,4,BODY,10.5Array Store Exception,13,7.49,158.39,25,72,263.56,230.39,271.06,TRUE,FALSE
430,3,BODY,11.1The Kinds and Causes of Exceptions,13,7.49,235.37,38,72,280.56,307.37,288.06,TRUE,FALSE
443,3,BODY,12.1Java Virtual Machine Startup,13,7.49,199.94,32,72,417.86,271.94,425.36,TRUE,FALSE
459,6,BODY,12.6Finalization of Class Instances,13,7.49,201.4,35,72,361.56,273.4,369.06,TRUE,FALSE
468,3,BODY,13.1The Form of a Binary,13,7.49,154.08,24,72,433.56,226.08,441.06,TRUE,FALSE
586,3,BODY,15.4Floating-point Expressions,13,7.49,181.91,30,72,234.56,253.91,242.06,TRUE,FALSE
618,2,BODY,15.10Array Creation and Access Expressions,13,7.49,259.51,42,72,77.56,331.51,85.06,TRUE,FALSE
678,8,BODY,15.14Postfix Expressions,13,7.49,147.23,24,72,547.56,219.23,555.06,TRUE,FALSE
680,7,BODY,15.15Unary Operators,13,7.49,134.93,20,72,451.56,206.93,459.06,TRUE,FALSE
686,4,BODY,15.17Multiplicative Operators,13,7.49,177.54,29,72,289.56,249.54,297.06,TRUE,FALSE
691,4,BODY,15.18Additive Operators,13,7.49,147.22,23,72,299.56,219.22,307.06,TRUE,FALSE
696,2,BODY,15.19Shift Operators,13,7.49,126.27,20,72,77.56,198.27,85.06,TRUE,FALSE
697,3,BODY,15.20Relational Operators,13,7.49,156.6,25,72,265.56,228.6,273.06,TRUE,FALSE
701,3,BODY,15.21Equality Operators,13,7.49,147.23,23,72,125.56,219.23,133.06,TRUE,FALSE
703,5,BODY,15.22Bitwise and Logical Operators,13,7.49,208.61,34,72,444.56,280.61,452.06,TRUE,FALSE
753,3,BODY,16.1Definite Assignment and Expressions,13,7.49,238.96,39,72,231.56,310.96,239.06,TRUE,FALSE
760,4,BODY,16.2Definite Assignment and Statements,13,7.49,233.87,38,72,452.56,305.87,460.06,TRUE,FALSE
769,3,BODY,16.3Definite Assignment and Parameters,13,7.49,236.75,38,72,476.56,308.75,484.06,TRUE,FALSE
770,2,BODY,16.4Definite Assignment and Array Initializers,13,7.49,269.62,46,72,77.56,341.62,85.06,TRUE,FALSE
771,1,BODY,16.6Definite Assignment and Anonymous Classes,13,7.49,282.65,45,72,77.56,354.65,85.06,TRUE,FALSE
771,3,BODY,16.7Definite Assignment and Member Classes and Interfaces,13,7.49,346.88,57,72,208.56,418.88,216.06,TRUE,FALSE
771,5,BODY,16.8Definite Assignment and Static Initializers,13,7.49,267.46,47,72,364.56,339.46,372.06,TRUE,FALSE
772,2,BODY,"16.9Definite Assignment, Constructors, and Instance",13,7.49,302.12,51,72,227.56,374.12,235.06,TRUE,FALSE
772,3,BODY,Initializers,13,7.49,59.94,12,112,242.56,171.94,250.06,TRUE,FALSE
780,3,BODY,17.3Sleep and Yield,13,7.49,119.43,19,72,382.56,191.43,390.06,TRUE,FALSE
9,4,BODY,10Arrays401,12.36,8.54,85.99,11,70,176.83,155.99,185.37,TRUE,FALSE
9,9,BODY,12Execution427,12.29,8.54,101.34,14,70,434.83,171.34,443.37,TRUE,FALSE
9,6,BODY,11Exceptions413,12.27,8.54,106,15,70,305.83,176,314.37,TRUE,FALSE
12,3,BODY,15Expressions567,12.25,8.54,111.34,16,70,176.83,181.34,185.37,TRUE,FALSE
5,3,BODY,6Names149,12.22,8.54,77.66,9,77,209.83,154.66,218.37,TRUE,FALSE
16,6,BODY,19Syntax825 ALimited License Grant855,12.22,33.54,166.66,37,70,242.83,236.66,276.37,TRUE,FALSE
15,8,BODY,18Type Inference787,12.21,8.54,127.65,19,70,503.83,197.65,512.37,TRUE,FALSE
3,3,BODY,2Grammars13,12.18,8.54,93.65,11,77,256.83,170.65,265.37,TRUE,FALSE
6,11,BODY,8Classes237,12.18,8.54,80.33,11,77,470.83,157.33,479.37,TRUE,FALSE
15,3,BODY,17Threads and Locks759,12.18,8.54,148.69,22,70,209.83,218.69,218.37,TRUE,FALSE
14,7,BODY,16Definite Assignment731,12.17,8.54,153.66,24,70,308.83,223.66,317.37,TRUE,FALSE
10,3,BODY,13Binary Compatibility451,12.16,8.54,159.68,25,70,165.83,229.68,174.37,TRUE,FALSE
3,1,BODY,1Introduction1,12.14,8.54,96.34,14,77,149.83,173.34,158.37,TRUE,FALSE
8,4,BODY,9Interfaces343,12.14,8.54,94.31,14,77,187.83,171.31,196.37,TRUE,FALSE
11,2,BODY,"14Blocks, Statements, and Patterns483",12.11,8.54,218.32,37,70,143.83,288.32,152.37,TRUE,FALSE
548,4,BODY,14.16The continue Statement,12.11,7.49,174.9,27,72,287.56,246.9,295.06,TRUE,FALSE
3,5,BODY,3Lexical Structure19,12.1,8.54,126.65,20,77,330.83,203.65,339.37,TRUE,FALSE
6,7,BODY,7Packages and Modules209,12.08,8.54,159.68,24,77,220.83,236.68,229.37,TRUE,FALSE
4,7,BODY,5Conversions and Contexts109,12.07,8.54,177,28,77,451.83,254,460.37,TRUE,FALSE
3,9,BODY,"4Types, Values, and Variables55",12.06,8.54,186.02,31,77,580.83,263.02,589.37,TRUE,FALSE
23,6,BODY,1.5Preview Features A preview feature is:,12,36.64,122.63,41,72,555.56,194.63,592.2,FALSE,FALSE
70,6,BODY,"3.11Separators Twelve tokens, formed from ASCII characters, are the separators (punctuators).",12,36.64,353.75,93,72,303.56,425.75,340.2,FALSE,FALSE
70,8,BODY,"3.12Operators 38 tokens, formed from ASCII characters, are the operators.",12,36.64,266.08,73,72,426.56,338.08,463.2,FALSE,FALSE
279,6,BODY,8.3Field Declarations The variables of a class are introduced by field declarations.,12,36.64,265.78,84,72,565.56,337.78,602.2,FALSE,FALSE
509,5,BODY,14.6The Empty Statement An empty statement does nothing.,12,36.64,154.79,56,72,356.56,226.79,393.2,FALSE,FALSE
509,8,BODY,14.7Labeled Statements Statements may have label prefixes.,12,36.64,159.17,58,72,490.56,231.17,527.2,FALSE,FALSE
630,9,BODY,15.12Method Invocation Expressions A method invocation expression is used to invoke a class or instance method.,12,36.64,340.66,111,72,502.56,412.66,539.2,FALSE,FALSE
553,3,BODY,14.19The synchronized Statement,11.84,7.49,200.49,31,72,357.56,272.49,365.06,TRUE,FALSE
40,2,BODY,3.4Line Terminators A Java compiler next divides the sequence of Unicode input characters into lines by recognizing line terminators.,11.67,49.64,359.99,133,72,77.56,431.99,127.2,FALSE,FALSE
42,7,BODY,"3.6White Space White space is defined as the ASCII space character, horizontal tab character, form feed character, and line terminator characters (§3.4).",11.67,49.64,360.01,153,72,351.56,432.01,401.2,FALSE,FALSE
44,3,BODY,"3.8Identifiers An identifier is an unlimited-length sequence of Java letters and Java digits, the first of which must be a Java letter.",11.67,49.64,360,135,72,131.56,432,181.2,FALSE,FALSE
72,4,BODY,4.2Primitive Types and Values A primitive type is predefined by the Java programming language and named by its reserved keyword (§3.9):,11.67,49.64,359.99,135,72,246.56,431.99,296.2,FALSE,FALSE
80,3,BODY,"4.3Reference Types and Values There are four kinds of reference types: class types (§8.1), interface types (§9.1), type variables (§4.4), and array types (§10.1).",11.67,49.64,360,162,72,495.56,432,545.2,FALSE,FALSE
107,4,BODY,"4.11Where Types Are Used Types are used in most kinds of declaration and in certain kinds of expression. Specifically, there are 17 type contexts where types are used:",11.67,49.64,359.99,167,72,407.56,431.99,457.2,FALSE,FALSE
128,5,BODY,5.1Kinds of Conversion Specific type conversions in the Java programming language are divided into 12 kinds.,11.67,49.64,360,108,72,439.56,432,489.2,FALSE,FALSE
230,2,BODY,7.3Compilation Units CompilationUnit is the goal symbol (§2.1) for the syntactic grammar (§2.3) of Java programs. It is defined by the following production:,11.67,49.64,360,156,72,77.56,432,127.2,FALSE,FALSE
240,3,BODY,7.6Top Level Class and Interface Declarations A top level class or interface declaration declares a top level class (§8.1) or a top level interface (§9.1).,11.67,49.64,360,155,72,451.56,432,501.2,FALSE,FALSE
325,3,BODY,"8.6Instance Initializers An instance initializer declared in a class is executed when an instance of the class is created (§12.5, §15.9, §8.8.7.1).",11.67,49.64,360.01,147,72,241.56,432.01,291.2,FALSE,FALSE
326,4,BODY,"8.8Constructor Declarations A constructor is used in the creation of an object that is an instance of a class (§12.5, §15.9).",11.67,49.64,360,125,72,309.56,432,359.2,FALSE,FALSE
338,2,BODY,"8.9Enum Classes An enum declaration specifies a new enum class, a restricted kind of class that defines a small set of named class instances.",11.67,49.64,360,141,72,77.56,432,127.2,FALSE,FALSE
347,2,BODY,"8.10Record Classes A record declaration specifies a new record class, a restricted kind of class that defines a simple aggregate of values.",11.67,49.64,359.99,139,72,77.56,431.99,127.2,FALSE,FALSE
465,2,BODY,"12.8Program Exit A program consists of one or more threads of execution. A thread is either a non- daemon thread, a daemon thread, or a shutdown hook.",11.67,49.64,359.99,150,72,77.56,431.99,127.2,FALSE,FALSE
477,2,BODY,13.4Evolution of Classes This section describes the effects of changes to the declaration of a class and its members and constructors on pre-existing binaries.,11.67,49.64,360,159,72,77.56,432,127.2,FALSE,FALSE
494,7,BODY,13.5Evolution of Interfaces This section describes the impact of changes to the declaration of an interface and its members on pre-existing binaries.,11.67,49.64,360.01,149,72,535.56,432.01,585.2,FALSE,FALSE
501,3,BODY,"14.2Blocks A block is a sequence of statements, local variable declaration statements, and local class and interface declarations within braces.",11.67,49.64,360.01,144,72,311.56,432.01,361.2,FALSE,FALSE
504,2,BODY,14.4Local Variable Declarations A local variable declaration declares and optionally initializes one or more local variables (§4.12.3).,11.67,49.64,360,135,72,125.56,432,175.2,FALSE,FALSE
511,4,BODY,14.8Expression Statements Certain kinds of expressions may be used as statements by following them with semicolons.,11.67,49.64,359.99,115,72,147.56,431.99,197.2,FALSE,FALSE
569,3,BODY,14.22Unreachable Statements It is a compile-time error if a statement cannot be executed because it is unreachable.,11.67,49.64,359.99,115,72,135.56,431.99,185.2,FALSE,FALSE
593,3,BODY,"15.7Evaluation Order The Java programming language guarantees that the operands of operators appear to be evaluated in a specific evaluation order, namely, from left to right.",11.67,49.64,359.99,175,72,356.56,431.99,406.2,FALSE,FALSE
603,6,BODY,15.9Class Instance Creation Expressions A class instance creation expression is used to create new objects that are instances of classes.,11.67,49.64,360.01,137,72,486.56,432.01,536.2,FALSE,FALSE
729,12,BODY,15.27Lambda Expressions A lambda expression is like a method: it provides a list of formal parameters and a body - an expression or block - expressed in terms of those parameters.,11.67,49.64,359.99,179,72,527.56,431.99,577.2,FALSE,FALSE
745,2,BODY,15.29Constant Expressions ConstantExpression: Expression,11.67,49.62,159.51,56,72,77.56,231.51,127.18,FALSE,TRUE
770,4,BODY,16.5Definite Assignment and Enum Constants The rules determining when a variable is definitely assigned or definitely unassigned before an enum constant (§8.9.1) are given in §16.8.,11.67,49.64,359.99,181,72,259.56,431.99,309.2,FALSE,FALSE
776,3,BODY,"17.2Wait Sets and Notification Every object, in addition to having an associated monitor, has an associated wait set. A wait set is a set of threads.",11.67,49.64,360,149,72,538.56,432,588.2,FALSE,FALSE
804,4,BODY,"18.1Concepts and Notation This section defines inference variables, constraint formulas, and bounds, as the terms will be used throughout this chapter. It also presents notation.",11.67,49.64,360,178,72,436.56,432,486.2,FALSE,FALSE
823,3,BODY,"18.5Uses of Inference Using the inference processes defined above, the following analyses are performed at compile time.",11.67,49.64,360.01,120,72,175.56,432.01,225.2,FALSE,FALSE
625,10,BODY,"15.11Field Access Expressions A field access expression may access a field of an object or array, a reference to which is the value of either an expression or the special keyword super.",11.62,49.64,360,185,72,459.56,432,509.2,FALSE,FALSE
546,5,BODY,14.15The break Statement A break statement transfers control out of an enclosing statement.,11.61,36.64,291.57,91,72,232.56,363.57,269.2,FALSE,FALSE
450,11,BODY,12.4Initialization of Classes and Interfaces Initialization of a class consists of executing its static initializers and the initializers for static fields (class variables) declared in the class.,11.6,49.64,360,196,72,547.56,432,597.2,FALSE,FALSE
48,4,BODY,"3.10Literals A literal is the source code representation of a value of a primitive type (§4.2), the String type (§4.3.3), or the null type (§4.1).",11.58,49.64,360,146,72,539.56,432,589.2,FALSE,FALSE
512,3,BODY,"14.9The if Statement The if statement allows conditional execution of a statement or a conditional choice of two statements, executing one or the other but not both.",11.55,49.64,360,165,72,155.56,432,205.2,FALSE,FALSE
707,3,BODY,15.25Conditional Operator ? : The conditional operator ? : uses the boolean value of one expression to decide which of two other expressions should be evaluated.,11.54,49.64,359.99,161,72,144.56,431.99,194.2,FALSE,FALSE
705,5,BODY,"15.23Conditional-And Operator && The conditional-and operator && is like & (§15.22.2), but evaluates its right-hand operand only if the value of its left-hand operand is true.",11.53,49.64,360,175,72,334.56,432,384.2,FALSE,FALSE
706,3,BODY,"15.24Conditional-Or Operator || The conditional-or operator || operator is like | (§15.22.2), but evaluates its right- hand operand only if the value of its left-hand operand is false.",11.53,49.64,360.01,184,72,240.56,432.01,290.2,FALSE,FALSE
40,6,BODY,3.5Input Elements and Tokens The input characters and line terminators that result from Unicode escape processing (§3.3) and then input line recognition (§3.4) are reduced to a sequence of input elements.,11.5,62.64,360,204,72,403.09,432,465.73,FALSE,FALSE
226,3,BODY,7.1Package Members The members of a package are its subpackages and all the top level classes (§8 (Classes)) and top level interfaces (§9 (Interfaces)) declared in all the compilation units (§7.3) of the package.,11.5,62.64,360.01,212,72,202.56,432.01,265.2,FALSE,FALSE
255,3,BODY,"8.1Class Declarations A class declaration specifies a class. There are three kinds of class declarations: normal class declarations, enum declarations (§8.9), and record declarations (§8.10).",11.5,68.64,360,191,72,176.56,432,245.2,FALSE,FALSE
325,6,BODY,"8.7Static Initializers A static initializer declared in a class is executed when the class is initialized (§12.4.2). Together with any field initializers for class variables (§8.3.2), static initializers may be used to initialize the class variables of the class.",11.5,62.64,360,263,72,529.56,432,592.2,FALSE,FALSE
360,3,BODY,9.1Interface Declarations An interface declaration specifies an interface. There are two kinds of interface declarations: normal interface declarations and annotation interface declarations (§9.6).,11.5,68.64,360,197,72,234.56,432,303.2,FALSE,FALSE
423,5,BODY,"10.6Array Initializers An array initializer may be specified in a field declaration (§8.3, §9.3) or local variable declaration (§14.4), or as part of an array creation expression (§15.10.1), to create an array and provide some initial values.",11.5,62.64,360,242,72,325.56,432,388.2,FALSE,FALSE
575,13,BODY,"14.30Patterns A pattern describes a test that can be performed on a value. Patterns appear as operands of statements and expressions, which provide the values to be tested. Patterns declare zero or more local variables, also known as pattern variables.",11.5,62.64,360,252,72,539.56,432,602.2,FALSE,FALSE
378,2,BODY,"9.6Annotation Interfaces An annotation interface declaration specifies an annotation interface, a specialized kind of interface. To distinguish an annotation interface declaration from a normal interface declaration, the keyword interface is preceded by an at sign (@).",11.43,62.64,360.01,269,72,77.56,432.01,140.2,FALSE,FALSE
536,5,BODY,14.13The do Statement The do statement executes a Statement and an Expression repeatedly until the value of the Expression is false.,11.43,49.64,360.01,132,72,363.56,432.01,413.2,FALSE,FALSE
46,3,BODY,"3.9Keywords 51 character sequences, formed from ASCII characters, are reserved for use as keywords and cannot be used as identifiers (§3.8). Another 17 character sequences, also formed from ASCII characters, may be interpreted as keywords or as other tokens, depending on the context in which they appear.",11.4,75.64,360,305,72,145.56,432,221.2,FALSE,FALSE
71,3,BODY,"4.1The Kinds of Types and Values There are two kinds of types in the Java programming language: primitive types (§4.2) and reference types (§4.3). There are, correspondingly, two kinds of data values that can be stored in variables, passed as arguments, returned by methods, and operated on: primitive values (§4.2) and reference values (§4.3).",11.4,75.64,360,344,72,456.86,432,532.5,FALSE,FALSE
86,3,BODY,"4.4Type Variables A type variable is an unqualified identifier used as a type in class, interface, method, and constructor bodies. A type variable is introduced by the declaration of a type parameter of a generic class, interface, method, or constructor (§8.1.2, §9.1.2, §8.4.4, §8.8.4).",11.4,81.64,360,287,72,227.56,432,309.2,FALSE,FALSE
397,6,BODY,"9.7Annotations An annotation is a marker which associates information with a program element, but has no effect at run time. An annotation denotes a specific instance of an annotation interface (§9.6) and usually provides values for the elements of that interface.",11.4,75.64,360,264,72,503.83,432,579.47,FALSE,FALSE
502,1,BODY,14.3Local Class and Interface Declarations A local class is a nested class (§8 (Classes)) whose declaration is immediately contained by a block (§14.2). A local interface is a nested interface (§9 (Interfaces)) whose declaration is immediately contained by a block.,11.4,81.64,360,265,72,77.56,432,159.2,FALSE,FALSE
599,2,BODY,"15.8Primary Expressions Primary expressions include most of the simplest kinds of expressions, from which all others are constructed: literals, object creations, field accesses, method invocations, method references, and array accesses. A parenthesized expression is also treated syntactically as a primary expression.",11.4,75.64,360.01,318,72,77.56,432.01,153.2,FALSE,FALSE
664,9,BODY,15.13Method Reference Expressions A method reference expression is used to refer to the invocation of a method without actually performing the invocation. Certain forms of method reference expression also allow class instance creation (§15.9) or array creation (§15.10) to be treated as if it were a method invocation.,11.4,75.64,360,318,72,520.56,432,596.2,FALSE,FALSE
820,3,BODY,"18.4Resolution Given a bound set that does not contain the bound false, a subset of the inference variables mentioned by the bound set may be resolved. This means that a satisfactory instantiation may be added to the set for each inference variable, until all the requested variables have instantiations.",11.4,75.64,360.01,304,72,527.56,432.01,603.2,FALSE,FALSE
516,3,BODY,"14.11The switch Statement The switch statement transfers control to one of several statements or expressions, depending on the value of an expression.",11.38,49.64,360,150,72,279.56,432,329.2,FALSE,FALSE
550,4,BODY,"14.17The return Statement A return statement returns control to the invoker of a method (§8.4, §15.12) or constructor (§8.8, §15.9).",11.38,49.64,360,132,72,287.56,432,337.2,FALSE,FALSE
716,6,BODY,"15.26Assignment Operators There are 12 assignment operators; all are syntactically right-associative (they group right-to-left). Thus, a=b=c means a=(b=c), which assigns the value of c to b and then assigns the value of b to a.",11.38,62.64,360,227,72,325.56,432,388.2,FALSE,FALSE
568,2,BODY,14.21The yield Statement A yield statement transfers control by causing an enclosing switch expression (§15.28) to produce a specified value.,11.36,49.64,360,141,72,77.56,432,127.2,FALSE,FALSE
93,5,BODY,"4.7Reifiable Types Because some type information is erased during compilation, not all types are available at run time. Types that are completely available at run time are known as reifiable types. A type is reifiable if and only if one of the following holds: •It refers to a non-generic class or interface type declaration.",11.33,100.64,360,325,72,492.56,432,593.2,FALSE,FALSE
187,4,BODY,"6.4Shadowing and Obscuring A local variable (§14.4), formal parameter (§8.4.1, §8.8.1, §15.27.1), exception parameter (§14.20), local class, or local interface (§14.3) can only be referred to using a simple name, not a qualified name (§6.2). Some declarations are not permitted within the scope of a local variable declaration, formal parameter declaration, exception parameter declaration, local",11.33,94.64,360,396,72,494.69,432,589.33,FALSE,FALSE
243,3,BODY,7.7Module Declarations A module declaration specifies a new named module. A named module specifies dependences on other modules to define the universe of classes and interfaces available to its own code; and specifies which of its packages are exported or opened in order to populate the universe of classes and interfaces available to other modules which specify a dependence on it.,11.33,88.64,360.01,383,72,299.56,432.01,388.2,FALSE,FALSE
418,4,BODY,"10.2Array Variables A variable of array type holds a reference to an object. Declaring a variable of array type does not create an array object or allocate any space for array components. It creates only the variable itself, which can contain a reference to an array. However, the initializer part of a declarator (§8.3, §9.3, §14.4.1) may create an array, a reference to which then becomes the initial value of the variable.",11.33,88.64,360.01,425,72,464.56,432.01,553.2,FALSE,FALSE
591,3,BODY,"15.6Normal and Abrupt Completion of Evaluation Every expression has a normal mode of evaluation in which certain computational steps are carried out. The following sections describe the normal mode of evaluation for each kind of expression. If all the steps are carried out without an exception being thrown, the expression is said to complete normally.",11.33,94.64,360.01,353,72,504.56,432.01,599.2,FALSE,FALSE
535,3,BODY,14.12The while Statement The while statement executes an Expression and a Statement repeatedly until the value of the Expression is false.,11.32,49.64,360,138,72,165.56,432,215.2,FALSE,FALSE
432,6,BODY,"11.2Compile-Time Checking of Exceptions The Java programming language requires that a program contains handlers for checked exceptions which can result from execution of a method or constructor (§8.4.6, §8.8.5). This compile-time checking for the presence of exception handlers is designed to reduce the number of exceptions which are not properly handled. For each checked exception which is a possible result, the throws clause for the method",11.31,88.64,360.01,444,72,500.56,432.01,589.2,FALSE,FALSE
507,8,BODY,"14.5Statements There are many kinds of statements in the Java programming language. Most correspond to statements in the C and C++ languages, but some are unique. As in C and C++, the if statement of the Java programming language suffers from the so-called 'dangling else problem,' illustrated by this misleadingly formatted example:",11.31,94.64,360.01,333,72,506.56,432.01,601.2,FALSE,FALSE
685,2,BODY,"15.16Cast Expressions A cast expression converts, at run time, a value of one numeric type to a similar value of another numeric type; or confirms, at compile time, that the type of an expression is boolean; or checks, at run time, that a reference value refers to an object either whose class is compatible with a specified reference type or list of reference types, or which embodies a value of a primitive type.",11.3,88.64,360,414,72,77.56,432,166.2,FALSE,FALSE
30,3,BODY,"2.3The Syntactic Grammar The syntactic grammar for the Java programming language is given in Chapters 4, 6-10, 14, and 15. This grammar has as its terminal symbols the tokens defined by the lexical grammar. It defines a set of productions, starting from the goal symbol CompilationUnit (§7.3), that describe how sequences of tokens can form syntactically correct programs. For convenience, the syntactic grammar is presented all together in Chapter 19.",11.29,107.64,360,452,72,131.56,432,239.2,FALSE,FALSE
421,4,BODY,"10.4Array Access A component of an array is accessed by an array access expression (§15.10.3) that consists of an expression whose value is an array reference followed by an indexing expression enclosed by [ and ], as in A[i]. All arrays are 0-origin. An array with length n can be indexed by the integers 0 to n-1.",11.28,94.64,360,315,72,294.56,432,389.2,FALSE,FALSE
146,5,BODY,5.2Assignment Contexts Assignment contexts allow the value of an expression to be assigned (§15.26) to a variable; the type of the expression must be converted to the type of the variable. Assignment contexts allow the use of one of the following: •an identity conversion (§5.1.1) •a widening primitive conversion (§5.1.2) •a widening reference conversion (§5.1.5) •a widening reference conversion followed by an unboxing conversion,11.25,144.64,360,432,72,455.56,432,600.2,FALSE,FALSE
227,6,BODY,"7.2Host Support for Modules and Packages Each host system determines how modules, packages, and compilation units are created and stored. Each host system determines which compilation units are observable in a particular compilation (§7.3). Each host system also determines which observable compilation units are associated with a module. The observability of compilation units associated with a module determines which modules are observable (§7.7.3) and which packages are visible within those modules (§7.4.3).",11.25,120.64,360.01,513,72,323.56,432.01,444.2,FALSE,FALSE
22,7,BODY,"1.3Notation Throughout this specification, we refer to classes and interfaces drawn from the Java SE Platform API. Whenever we refer to a class or interface (other than those declared in an example) using a single identifier N, the intended reference is to the class or interface named N in the package java.lang. We use the canonical name (§6.7) for classes or interfaces from packages other than java.lang.",11.24,88.64,360,408,72,512.56,432,601.2,FALSE,FALSE
538,10,BODY,14.14The for Statement The for statement has two forms: •The basic for statement. •The enhanced for statement,11.24,74.64,149.1,109,72,514.56,221.1,589.2,FALSE,FALSE
554,9,BODY,"14.20The try statement A try statement executes a block. If a value is thrown and the try statement has one or more catch clauses that can catch it, then control will be transferred to the first such catch clause. If the try statement has a finally clause, then another",11.24,62.64,360,269,72,540.56,432,603.2,FALSE,FALSE
42,9,BODY,3.7Comments There are two kinds of comments: •/* text */ A traditional comment: all the text from the ASCII characters /* to the ASCII characters */ is ignored (as in C and C++).,11.23,87.64,360,178,72,513.96,432,601.6,FALSE,FALSE
29,4,BODY,"2.2The Lexical Grammar A lexical grammar for the Java programming language is given in §3 (Lexical Structure). This grammar has as its terminal symbols the characters of the Unicode character set. It defines a set of productions, starting from the goal symbol Input (§3.5), that describe how sequences of Unicode characters (§3.1) are translated into a sequence of input elements (§3.2). These input elements, with white space (§3.6) and comments (§3.7) discarded, form the terminal symbols for the syntactic grammar for the Java programming language and are called tokens (§3.5). These tokens are the identifiers (§3.8),",11.22,133.64,360,621,72,458.86,432,592.5,FALSE,FALSE
781,4,BODY,"17.4Memory Model A memory model describes, given a program and an execution trace of that program, whether the execution trace is a legal execution of the program. The Java programming language memory model works by examining each read in an execution trace and checking that the write observed by that read is valid according to certain rules. The memory model describes possible behaviors of a program. An implementation is free to produce any code it likes, as long as all resulting executions of a program produce a result that can be predicted by the memory model.",11.22,133.64,360.02,569,72,167.56,432.02,301.2,FALSE,FALSE
421,3,BODY,"10.3Array Creation An array is created by an array creation expression (§15.10.1) or an array initializer (§10.6). An array creation expression specifies the element type, the number of levels of nested arrays, and the length of the array for at least one of the levels of nesting. The array's length is available as a final instance variable length. An array initializer creates an array and provides initial values for all its components.",11.21,126.64,360,440,72,131.56,432,258.2,FALSE,FALSE
29,3,BODY,"2.1Context-Free Grammars A context-free grammar consists of a number of productions. Each production has an abstract symbol called a nonterminal as its left-hand side, and a sequence of one or more nonterminal and terminal symbols as its right-hand side. For each grammar, the terminal symbols are drawn from a specified alphabet. Starting from a sentence consisting of a single distinguished nonterminal, called the goal symbol, a given context-free grammar specifies a language, namely, the set of possible sequences of terminal symbols that can result from repeatedly replacing any nonterminal in the sequence with a right-hand side of a production for which the nonterminal is the left-hand side.",11.2,146.64,360.01,700,72,275.86,432.01,422.5,FALSE,FALSE
36,6,BODY,"3.2Lexical Translations A raw Unicode character stream is translated into a sequence of tokens, using the following three lexical translation steps, which are applied in turn: 1.A translation of Unicode escapes (§3.3) in the raw stream of Unicode characters to the corresponding Unicode character. A Unicode escape of the form \uxxxx, where xxxx is a hexadecimal value, represents the UTF-16 code unit whose encoding is xxxx. This translation step allows any program to be expressed using only ASCII characters.",11.2,120.64,360,511,72,359.56,432,480.2,FALSE,FALSE
294,3,BODY,"8.4Method Declarations A method declares executable code that can be invoked, passing a fixed number of values as arguments. MethodDeclaration: {MethodModifier} MethodHeader MethodBody MethodHeader: Result MethodDeclarator [Throws] TypeParameters {Annotation} Result MethodDeclarator [Throws] MethodDeclarator: Identifier ( [ReceiverParameter ,] [FormalParameterList] ) [Dims]",11.19,173.62,359.99,376,72,425.56,431.99,599.18,FALSE,TRUE
801,3,BODY,"17.6Word Tearing One consideration for implementations of the Java Virtual Machine is that every field and array element is considered distinct; updates to one field or element must not interact with reads or updates of any other field or element. In particular, two threads that update adjacent elements of a byte array separately must not interfere or interact and do not need synchronization to ensure sequential consistency. Some processors do not provide the ability to write to a single byte. It would be illegal to implement byte array updates on such a processor by simply reading an entire word, updating the appropriate byte, and then writing the entire word back to memory. This problem is sometimes known as word tearing, and on processors that cannot easily update a single byte in isolation some other approach will be required.",11.18,159.64,360.01,842,72,196.56,432.01,356.2,FALSE,FALSE
112,3,BODY,"4.12Variables A variable is a storage location and has an associated type, sometimes called its compile-time type, that is either a primitive type (§4.2) or a reference type (§4.3). A variable's value is changed by an assignment (§15.26) or by a prefix or postfix + + (increment) or -- (decrement) operator (§15.14.2, §15.14.3, §15.15.1, §15.15.2). Compatibility of the value of a variable with its type is guaranteed by the design of the Java programming language, as long as a program does not give rise to compile- time unchecked warnings (§4.12.2). Default values (§4.12.5) are compatible and all assignments to a variable are checked for assignment compatibility (§5.2), usually at compile time, but, in a single case involving arrays, a run-time check is made (§10.5).",11.17,165.64,360.01,774,72,361.56,432.01,527.2,FALSE,FALSE
213,3,BODY,"6.6Access Control The Java programming language provides mechanisms for access control, to prevent the users of a package or class from depending on unnecessary details of the implementation of that package or class. If access is permitted, then the accessed entity is said to be accessible. Note that accessibility is a static property that can be determined at compile time; it depends only on types and declaration modifiers. Qualified names are a means of access to members of packages, classes, interfaces, type parameters, and reference types. When the name of such a member is classified from its context (§6.5.1) as a qualified type name (denoting a member of a package, class, interface, or type parameter) or a qualified expression name (denoting a member of a reference type), access control is applied.",11.17,178.64,360.01,814,72,279.56,432.01,458.2,FALSE,FALSE
513,3,BODY,"14.10The assert Statement An assertion is an assert statement containing a boolean expression. An assertion is either enabled or disabled. If an assertion is enabled, execution of the assertion causes evaluation of the boolean expression and an error is reported if the expression evaluates to false. If the assertion is disabled, execution of the assertion has no effect whatsoever.",11.17,88.64,360.01,383,72,306.56,432.01,395.2,FALSE,FALSE
37,4,BODY,"3.3Unicode Escapes A compiler for the Java programming language ('Java compiler') first recognizes Unicode escapes in its raw input, translating the ASCII characters \u followed by four hexadecimal digits to a raw input character which denotes the UTF-16 code unit (§3.1) for the indicated hexadecimal value. One Unicode escape can represent characters in the range U+0000 to U+FFFF; representing supplementary characters in the range U+010000 to U+10FFFF requires two consecutive Unicode escapes. All other characters in the compiler's raw input are recognized as raw input characters and passed unchanged. This translation step results in a sequence of Unicode input characters, all of which are raw input characters (any Unicode escapes having been reduced to raw input characters).",11.16,172.64,360.01,785,72,238.56,432.01,411.2,FALSE,FALSE
95,3,BODY,"4.8Raw Types To facilitate interfacing with non-generic legacy code, it is possible to use as a type the erasure (§4.6) of a parameterized type (§4.5) or the erasure of an array type (§10.1) whose element type is a parameterized type. Such a type is called a raw type. More precisely, a raw type is defined to be one of: •The reference type that is formed by taking the name of a generic class or interface declaration without an accompanying type argument list. •An array type whose element type is a raw type. •The name of an inner member class of a raw type R that is not inherited from a superclass or superinterface of R. The type of a non-generic class or interface is not a raw type.",11.16,196.64,360,690,72,125.56,432,322.2,FALSE,FALSE
741,3,BODY,"15.28switch Expressions A switch expression transfers control to one of several statements or expressions, depending on the value of an expression; all possible values of that expression must be handled, and all of the several statements and expressions must produce a value for the result of the switch expression.",11.15,75.64,360,315,72,255.56,432,331.2,FALSE,FALSE
446,5,BODY,"12.2Loading of Classes and Interfaces Loading refers to the process of finding the binary form of a class or interface with a particular name, perhaps by computing it on the fly, but more typically by retrieving a binary representation previously computed from source code by a Java compiler, and constructing, from that binary form, a Class object to represent the class or interface (§1.4). The precise semantics of loading are given in Chapter 5 of The Java Virtual Machine Specification, Java SE 23 Edition. Here we present an overview of the process from the viewpoint of the Java programming language. The binary representation of a class or interface is normally the class file format described in Chapter 4 of The Java Virtual Machine Specification, Java SE 23 Edition, but other representations are possible, provided they meet the requirements specified in §13.1.",11.14,191.64,360.01,873,72,403.56,432.01,595.2,FALSE,FALSE
475,3,BODY,"13.2What Binary Compatibility Is and Is Not A change to a type is binary compatible with (equivalently, does not break binary compatibility with) pre-existing binaries if pre-existing binaries that previously linked without error will continue to link without error. Binaries are compiled to rely on the accessible members and constructors of other classes and interfaces. To preserve binary compatibility, a class or interface should treat its accessible members and constructors, their existence and behavior, as a contract with its users. The Java programming language is designed to prevent additions to contracts and accidental name collisions from breaking binary compatibility. Specifically, addition of more methods overloading a particular method name does not break compatibility with pre-existing binaries. The method signature that the pre-existing binary will use for method lookup is chosen by the overload resolution algorithm at compile time (§15.12.2).",11.14,204.64,360.01,969,72,215.56,432.01,420.2,FALSE,FALSE
151,3,BODY,"5.3Invocation Contexts Invocation contexts allow an argument value in a method or constructor invocation (§8.8.7.1, §15.9, §15.12) to be assigned to a corresponding formal parameter. Strict invocation contexts allow the use of one of the following: •an identity conversion (§5.1.1) •a widening primitive conversion (§5.1.2) •a widening reference conversion (§5.1.5) Loose invocation contexts allow a more permissive set of conversions, because they are only used for a particular invocation if no applicable declaration can be found using strict invocation contexts. Loose invocation contexts allow the use of one of the following: •an identity conversion (§5.1.1) •a widening primitive conversion (§5.1.2) •a widening reference conversion (§5.1.5) •a widening reference conversion followed by an unboxing conversion",11.13,259.64,360.01,816,72,331.56,432.01,591.2,FALSE,FALSE
176,3,BODY,"6.3Scope of a Declaration The scope of a declaration is the region of the program within which the entity declared by the declaration can be referred to using a simple name, provided it is not shadowed (§6.4.1). A declaration is said to be in scope at a particular point in a program if and only if the declaration's scope includes that point. The scope of the declaration of an observable top level package (§7.4.3) is all observable compilation units associated with modules to which the package is uniquely visible (§7.4.3). The declaration of a package that is not observable is never in scope. The declaration of a subpackage is never in scope. The package java is always in scope. The scope of a class or interface imported by a single-type-import declaration (§7.5.1) or a type-import-on-demand declaration (§7.5.2) is the module declaration (§7.7) and all the class and interface declarations (§8.1, §9.1) of the compilation",11.12,241.64,360,932,72,339.56,432,581.2,FALSE,FALSE
584,3,BODY,"15.2Forms of Expressions Expressions can be broadly categorized into one of the following syntactic forms: •Expression names (§6.5.6) •Primary expressions (§15.8 - §15.13) •Unary operator expressions (§15.14 - §15.16) •Binary operator expressions (§15.17 - §15.24, and §15.26) •Ternary operator expressions (§15.25) •Lambda expressions (§15.27) •switch expressions (§15.28) Precedence among operators is managed by a hierarchy of grammar productions. The lowest precedence operator is the arrow of a lambda expression (->), followed by the assignment operators. Thus, all expressions are syntactically included in the LambdaExpression and AssignmentExpression nonterminals:",11.12,227.64,360.01,673,72,240.56,432.01,468.2,FALSE,FALSE
583,3,BODY,"15.1Evaluation, Denotation, and Result When an expression in a program is evaluated (executed), the result denotes one of three things: •A variable (§4.12) (in C, this would be called an lvalue) •A value (§4.2, §4.3) •Nothing (the expression is said to be void) If an expression denotes a variable, and a value is required for use in further evaluation, then the value of that variable is used. In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression. An expression denotes nothing if and only if it is a method invocation (§15.12) that invokes a method that does not return a value, that is, a method declared void (§8.4). Such an expression can be used only as an expression statement (§14.8) or as the single expression of a lambda body (§15.27.2), because every other context in which an expression can appear requires the expression to denote something. An expression statement or lambda body that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded.",11.11,261.64,360.01,1103,72,333.86,432.01,595.5,FALSE,FALSE
166,3,BODY,"6.1Declarations A declaration introduces one of the following entities into a program: •A module, declared in a module declaration (§7.7) •A package, declared in a package declaration (§7.4) •An imported class or interface, declared in a single-type-import declaration or a type-import-on-demand declaration (§7.5.1, §7.5.2) •An imported static member, declared in a single-static-import declaration or a static-import-on-demand declaration (§7.5.3, §7.5.4) •A class, declared by a normal class declaration (§8.1), an enum declaration (§8.9), or a record declaration (§8.10) •An interface, declared by a normal interface declaration (§9.1) or an annotation interface declaration (§9.6). •A type parameter, declared as part of the declaration of a generic class, interface, method, or constructor (§8.1.2, §9.1.2, §8.4.4, §8.8.4)",11.1,234.64,360.01,828,72,118.56,432.01,353.2,FALSE,FALSE
585,3,BODY,"15.3Type of an Expression If an expression denotes a variable or a value, then the expression has a type known at compile time. The type of a standalone expression can be determined entirely from the contents of the expression; in contrast, the type of a poly expression may be influenced by the expression's target type (§5 (Conversions and Contexts)). The rules for determining the type of an expression are explained separately below for each kind of expression. The value of an expression is assignment compatible (§5.2) with the type of the expression, unless heap pollution occurs (§4.12.2). Likewise, the value stored in a variable is always compatible with the type of the variable, unless heap pollution occurs. In other words, the value of an expression whose type is T is always suitable for assignment to a variable of type T. Note that if the type of an expression is a class type which names the class C, then the declaration of class C as final or sealed (§8.1.1.2) has implications for the value of the expression:",11.1,242.64,360.01,1030,72,329.56,432.01,572.2,FALSE,FALSE
802,4,BODY,"17.7Non-Atomic Treatment of double and long For the purposes of the Java programming language memory model, a single write to a non-volatile long or double value is treated as two separate writes: one to each 32-bit half. This can result in a situation where a thread sees the first 32 bits of a 64-bit value from one write, and the second 32 bits from another write. Writes and reads of volatile long and double values are always atomic. Writes to and reads of references are always atomic, regardless of whether they are implemented as 32-bit or 64-bit values.",11.1,126.64,360.01,562,72,247.56,432.01,374.2,FALSE,FALSE
153,4,BODY,"5.5Casting Contexts Casting contexts allow the operand of a cast expression (§15.16) to be converted to the type explicitly named by the cast operator. Compared to assignment contexts and invocation contexts, casting contexts allow the use of more of the conversions defined in §5.1, and allow more combinations of those conversions. If the expression is of a primitive type, then a casting context allows the use of one of the following: •an identity conversion (§5.1.1) •a widening primitive conversion (§5.1.2) •a narrowing primitive conversion (§5.1.3) •a widening and narrowing primitive conversion (§5.1.4) •a boxing conversion (§5.1.7) •a boxing conversion followed by a widening reference conversion (§5.1.5) If the expression is of a reference type, then a casting context allows the use of one of the following: •an identity conversion (§5.1.1) •a widening reference conversion (§5.1.5) •a widening reference conversion followed by an unboxing conversion •a widening reference conversion followed by an unboxing conversion, then followed by a widening primitive conversion •a narrowing reference conversion (§5.1.6) •a narrowing reference conversion followed by an unboxing conversion",11.09,380.64,360.01,1194,72,208.56,432.01,589.2,FALSE,FALSE
159,5,BODY,"5.6Numeric Contexts Numeric contexts apply to the operands of arithmetic operators, array creation and access expressions, conditional expressions, and the result expressions of switch expressions. An expression appears in a numeric arithmetic context if the expression is one of the following: •The operand of a unary plus operator +, unary minus operator -, or bitwise complement operator ~ (§15.15.3, §15.15.4, §15.15.5) •An operand of a multiplicative operator *, /, or % (§15.17) •An operand of an addition or subtraction operator for numeric types + or - (§15.18.2) •An operand of a shift operator <<, >>, or >>> (§15.19). Operands of these shift operators are treated separately rather than as a group. A long shift distance (right operand) does not promote the value being shifted (left operand) to long.",11.09,222.64,360.01,812,72,378.56,432.01,601.2,FALSE,FALSE
163,6,BODY,"5.7Testing Contexts Testing contexts allow the operand of a pattern match operator (§15.20.2), or the selector expression of a switch expression or statement that has at least one pattern case label associated with its switch block (§14.11.1) to be converted to a type as part of the process of pattern matching. As pattern matching is an inherently conditional process (§14.30.2), it is expected that a testing context will make use of conversions that may fail at run time. Testing contexts use similar conversions for reference types as casting contexts except that they do not permit narrowing reference conversions that are unchecked (§5.1.6.2). If the expression is of a primitive type, then a testing context allows the use of an identity conversion (§5.1.1). If the expression is of a reference type, then a testing context allows the use of one of the following: •an identity conversion (§5.1.1) •a widening reference conversion (§5.1.5) •a narrowing reference conversion that is checked (§5.1.6.2) If the expression has the null type, then the expression may be converted to any reference type.",11.09,299.64,360.01,1104,72,301.56,432.01,601.2,FALSE,FALSE
195,3,BODY,"6.5Determining the Meaning of a Name The meaning of a name depends on the context in which it is used. The determination of the meaning of a name requires three steps: •First, context causes a name syntactically to fall into one of seven categories: ModuleName, PackageName, TypeName, ExpressionName, MethodName, PackageOrTypeName, or AmbiguousName. TypeName and MethodName are less expressive than the other five categories, because they are denoted with TypeIdentifier and UnqualifiedMethodIdentifier, respectively (§3.8). •Second, a name that is initially classified by its context as an AmbiguousName or as a PackageOrTypeName is then reclassified to be a PackageName, TypeName, or ExpressionName. •Third, the resulting category then dictates the final determination of the meaning of the name (or a compile-time error if the name has no meaning). ModuleName: Identifier ModuleName . Identifier PackageName: Identifier PackageName . Identifier",11.09,316.62,360.01,947,72,257.56,432.01,574.18,FALSE,FALSE
324,3,BODY,"8.5Member Class and Interface Declarations A member class is a class whose declaration is directly enclosed in the body of another class or interface declaration (§8.1.7, §9.1.5). A member interface is an interface whose declaration is directly enclosed in the body of another class or interface declaration. A member class may be a normal class (§8.1), an enum class (§8.9), or a record class (§8.10). A member interface may be a normal interface (§9.1) or an annotation interface (§9.6). The accessibility of a member class or interface declaration in the body of a class declaration is specified by its access modifier, or by §6.6 if lacking an access modifier. The rules for modifiers of a member class declaration in the body of a class declaration are specified in §8.1.1. The rules for modifiers of a member interface declaration in the body of a class declaration are specified in §9.1.1. The scope and shadowing of a member class or interface is specified in §6.3 and §6.4.1. If a class declares a member class or interface with a certain name, then the declaration of the member class or interface is said to hide any and all accessible declarations of member classes and interfaces with the same name in superclasses and superinterfaces of the class.",11.09,344.64,360.01,1261,72,165.56,432.01,510.2,FALSE,FALSE
366,8,BODY,"9.2Interface Members The members of an interface are: •Members declared in the body of the interface declaration (§9.1.5). •Members inherited from any direct superinterface types (§9.1.3). •If an interface has no direct superinterface types, then the interface implicitly declares a public abstract member method m with signature s, return type r, and throws clause t corresponding to each public instance method m with signature s, return type r, and throws clause t declared in Object (§4.3.2),",11.09,132.64,360,496,72,450.56,432,583.2,FALSE,FALSE
818,3,BODY,"18.3Incorporation As bound sets are generated and grown during inference, it is possible that new bounds can be inferred based on the assertions of the original bounds. The process of incorporation identifies these new bounds and adds them to the bound set. Incorporation can happen in two scenarios. One scenario is that the bound set contains complementary pairs of bounds; this implies new constraint formulas, as specified in §18.3.1. The other scenario is that the bound set contains a bound involving capture conversion; this implies new bounds and may imply new constraint formulas, as specified in §18.3.2. In both scenarios, any new constraint formulas are reduced, and any new bounds are added to the bound set. This may trigger further incorporation; ultimately, the set will reach a fixed point and no further bounds can be inferred. If incorporation of a bound set has reached a fixed point, and the set does not contain the bound false, then the bound set has the following properties: •For each combination of a proper lower bound L and a proper upper bound U of an inference variable, L <: U. •If every inference variable mentioned by a bound has an instantiation, the bound is satisfied by the corresponding substitution.",11.09,268.64,360.01,1238,72,311.56,432.01,580.2,FALSE,FALSE
418,2,BODY,"10.1Array Types Array types are used in declarations and in cast expressions (§15.16). An array type is written as the name of an element type followed by some number of empty pairs of square brackets []. The number of bracket pairs indicates the depth of array nesting. Each bracket pair in an array type may be annotated by type annotations (§9.7.4). An annotation applies to the bracket pair (or ellipsis, in a variable arity parameter declaration) that follows it. The element type of an array may be any type, whether primitive or reference. In particular: •Arrays with an interface type as the element type are allowed. An element of such an array may have as its value a null reference or an instance of any type that implements the interface. •Arrays with an abstract class type as the element type are allowed. An element of such an array may have as its value a null reference or an instance of any subclass of the abstract class that is not itself abstract. An array's length is not part of its type. The supertypes of an array type are specified in §4.10.3.",11.07,298.64,360.01,1069,72,77.56,432.01,376.2,FALSE,FALSE
427,11,BODY,"10.9An Array of Characters Is Not a String In the Java programming language, unlike C, an array of char is not a String, and neither a String nor an array of char is terminated by '\u0000' (the NUL character). A String object is immutable, that is, its contents never change, while an array of char has mutable elements.",11.07,94.64,360,320,72,430.56,432,525.2,FALSE,FALSE
93,4,BODY,"4.6Type Erasure Type erasure is a mapping from types (possibly including parameterized types and type variables) to types (that are never parameterized types or type variables). We write |T| for the erasure of type T. The erasure mapping is defined as follows: •The erasure of a parameterized type (§4.5) G<T1,...,Tn> is |G|. •The erasure of a nested type T.C is |T|.C. •The erasure of an array type T[] is |T|[]. •The erasure of a type variable (§4.4) is the erasure of its leftmost bound. •The erasure of every other type is the type itself. Type erasure also maps the signature (§8.4.2) of a constructor or method to a signature that has no parameterized types or type variables. The erasure of a constructor or method signature s is a signature consisting of the same name as s and the erasures of all the formal parameter types given in s. The return type of a method (§8.4.5) and the type parameters of a generic method or constructor (§8.4.4, §8.8.4) also undergo erasure if the method or constructor's signature is erased. The erasure of the signature of a generic method has no type parameters.",11.06,279.64,360.01,1103,72,176.56,432.01,456.2,FALSE,FALSE
18,2,BODY,"1.1Organization of the Specification Chapter 2 describes grammars and the notation used to present the lexical and syntactic grammars for the language. Chapter 3 describes the lexical structure of the Java programming language, which is based on C and C++. The language is written in the Unicode character set. It supports the writing of Unicode characters on systems that support only ASCII. Chapter 4 describes types, values, and variables. Types are subdivided into primitive types and reference types. The primitive types are defined to be the same on all machines and in all implementations, and are various sizes of two's-complement integers, IEEE 754 floating-point numbers, a boolean type, and a Unicode character char type. Values of the primitive types do not share state. Reference types are the class types, the interface types, and the array types. The reference types are implemented by dynamically created objects that are either instances of classes or arrays. Many references to each object can exist. All objects (including arrays) support the methods of the class Object, which is the (single) root of the class hierarchy. A predefined String class supports Unicode character strings. Classes exist for wrapping primitive values inside of objects. In many cases, wrapping and unwrapping is performed automatically by the compiler (in which case, wrapping is called boxing, and unwrapping is called unboxing). Classes and interfaces may be generic, that is, they may be parameterized by reference types. Parameterized types of such classes and interfaces may then be invoked with specific type arguments. Variables are typed storage locations. A variable of a primitive type holds a value of that exact primitive type. A variable of a class type can hold a null reference or a reference to an object that is an instance of the named class or any subclass of that class. A variable of an interface type can hold a null reference or a reference to an instance of any class that implements the named interface. A variable of an array type can hold a null reference or a reference to an array. A variable of class type Object can hold a null reference or a reference to any object, whether class instance or array. Chapter 5 describes conversions and numeric promotions. Conversions change the compile-time type and, sometimes, the value of an expression. These conversions include the boxing and unboxing conversions between primitive types and reference types. Numeric promotions are used to convert the operands of a numeric operator to a common type where an operation can be performed. There are no",11.04,514.64,360.01,2617,72,77.56,432.01,592.2,FALSE,FALSE
275,3,BODY,"8.2Class Members The members of a class are all of the following: •Members inherited from its direct superclass type (§8.1.4), except in the class Object, which has no direct superclass type •Members inherited from any direct superinterface types (§8.1.5) •Members declared in the body of the class (§8.1.7) Members of a class that are declared private are not inherited by subclasses of that class. Only members of a class that are declared protected or public are inherited by subclasses declared in a package other than the one in which the class is declared. Constructors, static initializers, and instance initializers are not members and therefore are not inherited. We use the phrase the type of a member to denote: •For a field, its type. •For a method, an ordered 4-tuple (known as a method type) consisting of: –type parameters: the declarations of any type parameters of the method member (§8.4.4). –parameter types: a list of the types of the formal parameters of the method member (§8.4.1). –return type: the return type of the method member (§8.4.5). –throws clause: exception types declared in the throws clause of the method member (§8.4.6).",11.04,374.64,360,1157,72,125.56,432,500.2,FALSE,FALSE
590,3,BODY,"15.5Expressions and Run-Time Checks If the type of an expression is a primitive type, then the value of the expression is of that same primitive type. If the type of an expression is a reference type, then the class of the referenced object, or even whether the value is a reference to an object rather than null, is not necessarily known at compile time. There are a few places in the Java programming language where the actual class of a referenced object affects program execution in a manner that cannot be deduced from the type of the expression. They are as follows: •Method invocation (§15.12). The particular method used for an invocation o.m(...) is chosen based on the methods that are part of the class or interface that is the type of o. For instance methods, the class of the object referenced by the run-time value of o participates because a subclass may override a specific method already declared in a parent class so that this overriding method is invoked. (The overriding method may or may not choose to further invoke the original overridden m method.) •The instanceof operator (§15.20.2). An expression whose type is a reference type may be tested using instanceof to find out whether the class of the object referenced by the run-time value of the expression may be converted to some other reference type. •Casting (§15.16). The class of the object referenced by the run-time value of the operand expression might not be compatible with the type specified by the cast operator. For reference types, this may require a run-time check that throws an exception if the class of the referenced object, as determined at run time, cannot be converted to the target type. •Assignment to an array component of reference type (§10.5, §15.13, §15.26.1). The type-checking rules allow the array type S[] to be treated as a subtype of",11.04,391.64,360.01,1843,72,195.56,432.01,587.2,FALSE,FALSE
841,2,BODY,"THIS chapter repeats the syntactic grammar given in Chapters 4, 6-10, 14, and 15, as well as key parts of the lexical grammar from Chapter 3, using the notation from §2.4.",11.04,32.14,359.99,171,72,220.36,431.99,252.5,FALSE,FALSE
221,3,BODY,"6.7Fully Qualified Names and Canonical Names Every primitive type, named package, top level class, and top level interface has a fully qualified name: •The fully qualified name of a primitive type is the keyword for that primitive type, namely byte, short, char, int, long, float, double, or boolean. •The fully qualified name of a named package that is not a subpackage of a named package is its simple name. •The fully qualified name of a named package that is a subpackage of another named package consists of the fully qualified name of the containing package, followed by '.', followed by the simple (member) name of the subpackage. •The fully qualified name of a top level class or top level interface that is declared in an unnamed package is the simple name of the class or interface. •The fully qualified name of a top level class or top level interface that is declared in a named package consists of the fully qualified name of the package, followed by '.', followed by the simple name of the class or interface. Each member class, member interface, and array type may have a fully qualified name: •A member class or member interface M of another class or interface C has a fully qualified name if and only if C has a fully qualified name. In that case, the fully qualified name of M consists of the fully qualified name of C, followed by '.', followed by the simple name of M.",11.03,331.64,360.01,1388,72,209.56,432.01,541.2,FALSE,FALSE
377,3,BODY,"9.5Member Class and Interface Declarations An interface body (§9.1.5) may contain declarations of member classes and member interfaces (§8.5). Every member class or interface declaration in the body of an interface declaration is implicitly public and static (§9.1.1.3). It is permitted to redundantly specify either or both of these modifiers. It is a compile-time error if a member class or interface declaration in an interface has the modifier protected or private. The rules for modifiers of a member class declaration in the body of an interface declaration are specified in §8.1.1. The rules for modifiers of a member interface declaration in the body of an interface declaration are specified in §9.1.1. If an interface declares a member class or interface with a certain name, then the declaration of the member class or interface is said to hide any and all accessible declarations of member classes and interface with the same name in superinterfaces of the interface. An interface inherits from its direct superinterfaces all the member classes and interfaces of the direct superinterfaces that are not hidden by a declaration in the interface. It is possible for an interface to inherit more than one member class or interface with the same name. Such a situation does not in itself cause a compile-time error. However, any attempt within the body of the interface to refer to any such member class or interface by its simple name will result in a compile-time error, because the reference is ambiguous. There might be several paths by which the same member class or interface declaration is inherited from an interface. In such a situation, the member class or interface is considered to be inherited only once, and it may be referred to by its simple name without ambiguity.",11.03,422.64,360.01,1789,72,131.56,432.01,554.2,FALSE,FALSE
438,3,BODY,"11.3Run-Time Handling of an Exception When an exception is thrown (§14.18), control is transferred from the code that caused the exception to the nearest dynamically enclosing catch clause, if any, of a try statement (§14.20) that can handle the exception. A statement or expression is dynamically enclosed by a catch clause if it appears within the try block of the try statement of which the catch clause is a part, or if the caller of the statement or expression is dynamically enclosed by the catch clause. The caller of a statement or expression depends on where it occurs: •If within a method, then the caller is the method invocation expression (§15.12) that was executed to cause the method to be invoked. •If within a constructor or an instance initializer or the initializer for an instance variable, then the caller is the class instance creation expression (§15.9) or the method invocation of newInstance that was executed to cause an object to be created. •If within a static initializer or an initializer for a static variable, then the caller is the expression that used the class or interface so as to cause it to be initialized (§12.4). Whether a particular catch clause can handle an exception is determined by comparing the class of the object that was thrown to the catchable exception classes of the catch clause. The catch clause can handle the exception if one of its catchable exception classes is the class of the exception or a superclass of the class of the exception.",11.02,345.64,360.01,1495,72,135.56,432.01,481.2,FALSE,FALSE
448,3,BODY,"12.3Linking of Classes and Interfaces Linking is the process of taking a binary form of a class or interface and combining it into the run-time state of the Java Virtual Machine, so that it can be executed. A class or interface is always loaded before it is linked. The precise semantics of linking are given in Chapter 5 of The Java Virtual Machine Specification, Java SE 23 Edition. Here we present an overview of the process from the viewpoint of the Java programming language. Three different activities are involved in linking: verification, preparation, and resolution of symbolic references. This specification allows an implementation flexibility as to when linking activities (and, because of recursion, loading) take place, provided that the semantics of the Java programming language are respected, that a class or interface is completely verified and prepared before it is initialized, and that errors detected during linkage are thrown at a point in the program where some action is taken by the program that might require linkage to the class or interface involved in the error. For example, an implementation may choose to resolve each symbolic reference in a class or interface individually, only when it is used (lazy or late resolution), or to resolve them all at once while the class is being verified (static resolution). This means that the resolution process may continue, in some implementations, after a class or interface has been initialized. Because linking involves the allocation of new data structures, it may fail with an OutOfMemoryError.",11.01,326.64,360.01,1570,72,175.56,432.01,502.2,FALSE,FALSE
803,2,BODY,"A variety of compile-time analyses require reasoning about types that are not yet known. Principal among these are generic method applicability testing (§18.5.1) and generic method invocation type inference (§18.5.2). In general, we refer to the process of reasoning about unknown types as type inference. At a high level, type inference can be decomposed into three processes: •Reduction takes a compatibility assertion about an expression or type, called a constraint formula, and reduces it to a set of bounds on inference variables. Often, a constraint formula reduces to other constraint formulas, which must be recursively reduced. A procedure is followed to identify these additional constraint formulas and, ultimately, to express via a bound set the conditions under which the choices for inferred types would render each constraint formula true. •Incorporation maintains a set of inference variable bounds, ensuring that these are consistent as new bounds are added. Because the bounds on one variable can sometimes impact the possible choices for another variable, this process propagates bounds between such interdependent variables. •Resolution examines the bounds on an inference variable and determines an instantiation that is compatible with those bounds. It also decides the order in which interdependent inference variables are to be resolved. These processes interact closely: reduction can trigger incorporation; incorporation may lead to further reduction; and resolution may cause further incorporation. •§18.1 more precisely defines the concepts used as intermediate results and the notation used to express them. •§18.2 describes reduction in detail. •§18.3 describes incorporation in detail.",11.01,366.14,360.01,1717,72,220.36,432.01,586.5,FALSE,FALSE
3,11,BODY,iii,11,6.34,9.17,3,458.83,625.59,468,631.93,TRUE,FALSE
4,13,BODY,iv,11,6.34,8.56,2,36,625.59,44.56,631.93,TRUE,FALSE
5,12,BODY,v,11,6.34,5.5,1,462.5,625.59,468,631.93,TRUE,FALSE
6,16,BODY,vi,11,6.34,8.56,2,36,625.59,44.56,631.93,TRUE,FALSE
7,13,BODY,vii,11,6.34,11.62,3,456.38,625.59,468,631.93,TRUE,FALSE
8,15,BODY,viii,11,6.34,14.67,4,36,625.59,50.67,631.93,TRUE,FALSE
9,11,BODY,ix,11,6.34,8.56,2,459.44,625.59,468,631.93,TRUE,FALSE
10,9,BODY,x,11,6.34,5.5,1,36,625.59,41.5,631.93,TRUE,FALSE
11,15,BODY,xi,11,6.34,8.56,2,459.44,625.59,468,631.93,TRUE,FALSE
12,8,BODY,xii,11,6.34,11.62,3,36,625.59,47.62,631.93,TRUE,FALSE
13,16,BODY,xiii,11,6.34,14.67,4,453.33,625.59,468,631.93,TRUE,FALSE
14,11,BODY,xiv,11,6.34,14.06,3,36,625.59,50.06,631.93,TRUE,FALSE
15,12,BODY,xv,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
16,7,BODY,xvi,11,6.34,14.06,3,36,625.59,50.06,631.93,TRUE,FALSE
17,3,BODY,"THE Java programming language is a general-purpose, concurrent, class- based, object-oriented language. It is designed to be simple enough that many programmers can achieve fluency in the language. The Java programming language is related to C and C++ but is organized rather differently, with a number of aspects of C and C++ omitted and a few ideas from other languages included. It is intended to be a production language, not a research language, and so, as C. A. R. Hoare suggested in his classic paper on language design, the design has avoided including new and untested features. The Java programming language is strongly and statically typed. This specification clearly distinguishes between the compile-time errors that can and must be detected at compile time, and those that occur at run time. Compile time normally consists of translating programs into a machine-independent byte code representation. Run-time activities include loading and linking of the classes needed to execute a program, optional machine code generation and dynamic optimization of the program, and actual program execution. The Java programming language is a relatively high-level language, in that details of the machine representation are not available through the language. It includes automatic storage management, typically using a garbage collector, to avoid the safety problems of explicit deallocation (as in C's free or C++'s delete). High-performance garbage-collected implementations can have bounded pauses to support systems programming and real-time applications. The language does not include any unsafe constructs, such as array accesses without index checking, since such unsafe constructs would cause a program to behave in an unspecified way. The Java programming language is normally compiled to the bytecode instruction set and binary format defined in The Java Virtual Machine Specification, Java SE 23 Edition.",11,349.14,360.01,1919,72,220.36,432.01,569.5,FALSE,FALSE
17,4,BODY,1,11,6.34,5.5,1,462.5,625.59,468,631.93,TRUE,FALSE
18,3,BODY,2,11,6.34,5.5,1,36,625.59,41.5,631.93,TRUE,FALSE
19,3,BODY,3,11,6.34,5.5,1,462.5,625.59,468,631.93,TRUE,FALSE
20,3,BODY,4,11,6.34,5.5,1,36,625.59,41.5,631.93,TRUE,FALSE
21,3,BODY,5,11,6.34,5.5,1,462.5,625.59,468,631.93,TRUE,FALSE
22,2,BODY,"not automatically initialize local variables in order to avoid masking programming errors. Chapter 17 describes the semantics of threads and locks, which are based on the monitor-based concurrency originally introduced with the Mesa programming language. The Java programming language specifies a memory model for shared- memory multiprocessors that supports high-performance implementations. Chapter 18 describes a variety of type inference algorithms used to test applicability of generic methods and to infer types in a generic method invocation. Chapter 19 presents a syntactic grammar for the language.",11,128.14,360.01,607,72,76.06,432.01,204.2,FALSE,FALSE
22,8,BODY,6,11,6.34,5.5,1,36,625.59,41.5,631.93,TRUE,FALSE
23,2,BODY,"A cross-reference within this specification is shown as (§x.y). Occasionally, we refer to concepts in the The Java Virtual Machine Specification, Java SE 23 Edition via cross-references of the form (JVMS §x.y). Non-normative text, designed to clarify the normative text of this specification, is given in smaller, indented text.",11,64.14,360,328,72,76.06,432,140.2,FALSE,FALSE
23,7,BODY,7,11,6.34,5.5,1,462.5,625.59,468,631.93,TRUE,FALSE
24,6,BODY,8,11,6.34,5.5,1,36,625.59,41.5,631.93,TRUE,FALSE
25,2,BODY,"•If preview features are enabled, then any source code reference to a class or interface declared using a preview language feature causes a preview warning, unless one of the following is true: –The reference appears in a declaration that is annotated to suppress preview warnings (§9.6.4.5). –The reference appears in an import declaration (§7.5).",11,83.14,360,348,72,76.06,432,159.2,FALSE,FALSE
25,5,BODY,9,11,6.34,5.5,1,462.5,625.59,468,631.93,TRUE,FALSE
26,2,BODY,"•If preview features are enabled, then any source code reference to a normal preview API element causes a preview warning, unless one of the following is true: –The declaration where the reference appears is within the same module as the declaration of the normal preview API element. –The reference appears in a declaration that is annotated to suppress preview warnings. –The reference appears in an import declaration.",11,115.14,360,421,72,76.06,432,191.2,FALSE,FALSE
26,15,BODY,10,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
27,13,BODY,11,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
29,5,BODY,13,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
30,2,BODY,"keywords (§3.9), literals (§3.10), separators (§3.11), and operators (§3.12) of the Java programming language.",11,19.14,360,110,72,76.06,432,95.2,FALSE,FALSE
30,9,BODY,The syntax {x} on the right-hand side of a production denotes zero or more occurrences of x.,11,19.14,360,92,72,511.06,432,530.2,FALSE,FALSE
30,12,BODY,14,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
31,3,BODY,"The syntax [x] on the right-hand side of a production denotes zero or one occurrences of x. That is, x is an optional symbol. The alternative which contains the optional symbol actually defines two alternatives: one that omits the optional symbol and one that includes it.",11,45.14,360,272,72,118.06,432,163.2,FALSE,FALSE
31,15,BODY,15,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
32,4,BODY,A very long right-hand side may be continued on a second line by clearly indenting the second line.,11,19.14,360,99,72,200.06,432,219.2,FALSE,FALSE
32,8,BODY,The phrase (one of) on the right-hand side of a production signifies that each of the symbols on the following line or lines is an alternative definition.,11,19.14,360.01,154,72,324.06,432.01,343.2,FALSE,FALSE
32,13,BODY,"When an alternative in a production appears to be a token, it represents the sequence of characters that would make up such a token.",11,19.14,360.01,132,72,507.06,432.01,526.2,FALSE,FALSE
32,15,BODY,16,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
33,4,BODY,The right-hand side of a production may specify that certain expansions are not permitted by using the phrase 'but not' and then indicating the expansions to be excluded.,11,32.14,360,170,72,137.06,432,169.2,FALSE,FALSE
33,6,BODY,"Finally, a few nonterminals are defined by a narrative phrase in roman type where it would be impractical to list all the alternatives.",11,19.14,360.01,135,72,249.28,432.01,268.42,FALSE,FALSE
33,9,BODY,17,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
35,4,BODY,19,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
36,2,BODY,"(U+D800 to U+DBFF), and the second from the low-surrogates range (U+DC00 to U+DFFF). For characters in the range U+0000 to U+FFFF, the values of code points and UTF-16 code units are the same. The Java programming language represents text in sequences of 16-bit code units, using the UTF-16 encoding.",11,64.14,360.01,300,72,76.06,432.01,140.2,FALSE,FALSE
36,4,BODY,"This specification uses the terms code point and UTF-16 code unit where the representation is relevant, and the generic term character where the representation is irrelevant to the discussion. Except for comments (§3.7), identifiers (§3.8), and the contents of character literals, string literals, and text blocks (§3.10.4, §3.10.5, §3.10.6), all input elements (§3.5) in a program are formed only from ASCII characters (or Unicode escapes (§3.3) which result in ASCII characters).",11,90.14,360,481,72,201.06,432,291.2,FALSE,FALSE
36,7,BODY,2.A translation of the Unicode stream resulting from step 1 into a stream of input,11,6.14,360.01,82,72,493.06,432.01,499.2,FALSE,FALSE
36,8,BODY,characters and line terminators (§3.4).,11,6.14,167.4,39,90,506.06,257.4,512.2,FALSE,FALSE
36,9,BODY,"3.A translation of the stream of input characters and line terminators resulting from step 2 into a sequence of input elements (§3.5) which, after white space (§3.6) and comments (§3.7) are discarded, comprise the tokens that are the terminal symbols of the syntactic grammar (§2.3).",11,45.14,360,283,72,525.06,432,570.2,FALSE,FALSE
36,10,BODY,"The longest possible translation is used at each step, even if the result does not ultimately make a correct program while another lexical translation would. There",11,19.14,359.99,163,72,583.06,431.99,602.2,FALSE,FALSE
36,11,BODY,20,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
37,6,BODY,21,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
38,2,BODY,RawInputCharacter: any Unicode character,11,19.14,108.96,40,90,76.13,198.96,95.27,FALSE,FALSE
38,10,BODY,22,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
39,5,BODY,23,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
40,3,BODY,"LineTerminator: the ASCII LF character, also known as 'newline' the ASCII CR character, also known as 'return' the ASCII CR character followed by the ASCII LF character InputCharacter: UnicodeInputCharacter but not CR or LF",11,82.53,277.3,223,90,145.13,367.3,227.66,FALSE,FALSE
40,5,BODY,"The result is a sequence of line terminators and input characters, which are the terminal symbols for the third step in the tokenization process.",11,19.14,360,145,72,347.59,432,366.73,FALSE,FALSE
40,7,BODY,Input: {InputElement} [Sub] InputElement: WhiteSpace Comment Token,11,82.05,105.88,66,90,483.66,195.88,565.71,FALSE,TRUE
40,8,BODY,24,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
41,2,BODY,"Token: Identifier Keyword Literal Separator Operator Sub: the ASCII SUB character, also known as 'control-Z'",11,108.14,243.21,108,90,76.13,333.21,184.27,FALSE,TRUE
41,3,BODY,"Those input elements that are not white space or comments are tokens. The tokens are the terminal symbols of the syntactic grammar (§2.3). White space (§3.6) and comments (§3.7) can serve to separate tokens that, if adjacent, might be tokenized in another manner.",11,51.14,360,263,72,202.2,432,253.33,FALSE,FALSE
41,6,BODY,25,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
42,8,BODY,"WhiteSpace: the ASCII SP character, also known as 'space' the ASCII HT character, also known as 'horizontal tab' the ASCII FF character, also known as 'form feed' LineTerminator",11,58.45,255.73,177,90,419.13,345.73,477.57,FALSE,FALSE
42,10,BODY,26,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
43,5,BODY,27,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
44,2,BODY,"The lexical grammar implies that comments do not occur within character literals, string literals, or text blocks (§3.10.4, §3.10.5, §3.10.6).",11,19.14,360.01,142,72,76.06,432.01,95.2,FALSE,FALSE
44,4,BODY,Identifier: IdentifierChars but not a ReservedKeyword or BooleanLiteral or NullLiteral IdentifierChars: JavaLetter {JavaLetterOrDigit} JavaLetter: any Unicode character that is a 'Java letter' JavaLetterOrDigit: any Unicode character that is a 'Java letter-or-digit',11,143.53,283.15,266,90,199.13,373.15,342.66,FALSE,TRUE
44,7,BODY,"Letters and digits may be drawn from the entire Unicode character set, which supports most writing scripts in use in the world today, including the large sets for Chinese, Japanese, and Korean. This allows programmers to use identifiers in their programs that are written in their native languages. Two identifiers are the same only if, after ignoring characters that are ignorable, the identifiers have the same Unicode character for each letter",11,77.14,360.01,446,72,524.59,432.01,601.73,FALSE,FALSE
44,8,BODY,28,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
45,4,BODY,"An identifier never has the same spelling (Unicode character sequence) as a reserved keyword (§3.9), a boolean literal (§3.10.3) or the null literal (§3.10.8), due to the rules of tokenization (§3.5). However, an identifier may have the same spelling as a contextual keyword, because the tokenization of a sequence of input characters as an identifier or a contextual keyword depends on where the sequence appears in the program. To facilitate the recognition of contextual keywords, the syntactic grammar (§2.3) sometimes disallows certain identifiers by defining a production to accept only a subset of identifiers. The subsets are as follows:",11,116.14,360,645,72,349.06,432,465.2,FALSE,FALSE
45,6,BODY,29,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
46,5,BODY,30,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
47,3,BODY,"During the reduction of input characters to input elements (§3.5), a sequence of input characters that notionally matches a contextual keyword is reduced to a contextual keyword if and only if both of the following conditions hold: 1.The sequence is recognized as a terminal specified in a suitable context of the",11,51.14,360,313,72,216.06,432,267.2,FALSE,FALSE
47,9,BODY,31,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
48,2,BODY,2.The sequence is not immediately preceded or immediately followed by an input,11,6.14,360,78,72,76.06,432,82.2,FALSE,FALSE
48,5,BODY,32,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
49,2,BODY,Literal: IntegerLiteral FloatingPointLiteral BooleanLiteral CharacterLiteral StringLiteral TextBlock NullLiteral,11,97.05,101.68,112,90,76.13,191.68,173.18,FALSE,TRUE
49,3,BODY,"3.10.1Integer Literals An integer literal may be expressed in decimal (base 10), hexadecimal (base 16), octal (base 8), or binary (base 2).",11,40.11,359.99,139,72,199.09,431.99,239.2,FALSE,FALSE
49,7,BODY,33,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
50,3,BODY,34,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
51,4,BODY,35,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
52,5,BODY,36,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
53,4,BODY,37,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
54,4,BODY,38,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
55,9,BODY,39,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
56,10,BODY,"3.10.2Floating-Point Literals A floating-point literal has the following parts: a whole-number part, a decimal or hexadecimal point (represented by an ASCII period character), a fraction part, an exponent, and a type suffix. A floating-point literal may be expressed in decimal (base 10) or hexadecimal (base 16).",11,85.11,360.01,313,72,502.09,432.01,587.2,FALSE,FALSE
56,11,BODY,40,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
57,4,BODY,41,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
58,8,BODY,42,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
59,9,BODY,43,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
60,9,BODY,44,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
61,3,BODY,3.10.5String Literals A string literal consists of zero or more characters enclosed in double quotes. Characters such as newlines may be represented by escape sequences (§3.10.7).,11,40.11,360,179,72,293.09,432,333.2,FALSE,FALSE
61,8,BODY,45,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
62,9,BODY,46,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
63,5,BODY,"3.10.6Text Blocks A text block consists of zero or more characters enclosed by opening and closing delimiters. Characters may be represented by escape sequences (§3.10.7), but the newline and double quote characters that must be represented with escape sequences in a string literal (§3.10.5) may be represented directly in a text block.",11,66.11,360,337,72,351.09,432,417.2,FALSE,FALSE
63,7,BODY,47,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
64,7,BODY,48,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
65,6,BODY,49,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
66,2,BODY,necessary to escape at least one of the double quote characters in order to avoid mimicking the closing delimiter.,11,19.14,359.99,114,72,76.06,431.99,95.2,FALSE,FALSE
66,10,BODY,50,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
67,5,BODY,"The string represented by a text block is not the literal sequence of characters in the content. Instead, the string represented by a text block is the result of applying the following transformations to the content, in order: 1.Line terminators are normalized to the ASCII LF character, as follows:",11,51.14,360.01,299,72,300.56,432.01,351.7,FALSE,FALSE
67,6,BODY,•An ASCII CR character followed by an ASCII LF character is translated to an ASCII LF character. •An ASCII CR character is translated to an ASCII LF character.,11,38.14,342,159,90,364.56,432,402.7,FALSE,FALSE
67,8,BODY,on the characters resulting from step 1.,11,6.14,171.38,40,90,428.56,261.38,434.7,FALSE,FALSE
67,9,BODY,"3.Escape sequences are interpreted, as if by execution of",11,6.14,359.99,57,72,447.56,431.99,453.7,FALSE,FALSE
67,11,BODY,"When this specification says that a text block contains a particular character or sequence of characters, or that a particular character or sequence of characters is in a text block, it means that the string represented by the text block (as opposed to the literal sequence of characters in the content) contains the character or sequence of characters.",11,58.14,360.01,353,72,479.56,432.01,537.7,FALSE,FALSE
67,14,BODY,51,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
68,10,BODY,52,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
69,2,BODY,"3.10.7Escape Sequences In character literals, string literals, and text blocks (§3.10.4, §3.10.5, §3.10.6), the escape sequences allow for the representation of some nongraphic characters without using Unicode escapes (§3.3), as well as the single quote, double quote, and backslash characters.",11,66.11,360,294,72,76.09,432,142.2,FALSE,FALSE
69,6,BODY,53,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
70,2,BODY,"character denoted by the Unicode escape in the EscapeSequence grammar. The line continuation escape sequence has no corresponding Unicode escape, so is interpreted by replacing it with nothing. The line continuation escape sequence can appear in a text block, but cannot appear in a character literal or a string literal because each disallows a LineTerminator.",11,64.14,360,361,72,76.06,432,140.2,FALSE,FALSE
70,5,BODY,A null literal is always of the null type (§4.1).,11,6.14,201.34,49,72,261.06,273.34,267.2,FALSE,FALSE
70,10,BODY,54,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
71,4,BODY,Type: PrimitiveType ReferenceType,11,32.05,75.36,33,90,550.43,165.36,582.48,FALSE,TRUE
71,5,BODY,55,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
72,7,BODY,56,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
73,5,BODY,57,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
74,6,BODY,58,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
75,10,BODY,59,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
76,9,BODY,"Except for NaN, floating-point values are ordered. Arranged from smallest to largest, they are negative infinity, negative finite nonzero values, negative and positive zero, positive finite nonzero values, and positive infinity. IEEE 754 allows multiple distinct NaN values for each of its binary32 and binary64 floating-point formats. However, the Java SE Platform generally treats NaN values of a given floating-point type as though collapsed into a single canonical value, and hence this specification normally refers to an arbitrary NaN as though to a canonical value.",11,103.14,360.01,572,72,334.06,432.01,437.2,FALSE,FALSE
76,12,BODY,60,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
77,4,BODY,61,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
78,5,BODY,62,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
79,7,BODY,63,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
80,4,BODY,64,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
81,5,BODY,65,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
82,3,BODY,"4.3.1Objects An object is a class instance or an array. The reference values (often just references) are pointers to these objects, and a special null reference, which refers to no object. A class instance is explicitly created by a class instance creation expression (§15.9). An array is explicitly created by an array creation expression (§15.10.1). Other expressions may implicitly create a class instance (§12.5) or an array (§10.6).",11,116.11,360,437,72,134.09,432,250.2,FALSE,FALSE
82,6,BODY,66,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
83,8,BODY,67,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
84,8,BODY,68,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
85,4,BODY,"4.3.4When Reference Types Are the Same Two reference types are the same compile-time type if they are declared in compilation units associated with the same module (§7.3), and they have the same binary name (§13.1), and their type arguments, if any, are the same, applying this definition recursively. When two reference types are the same, they are sometimes said to be the same class or the same interface. At run time, several reference types with the same binary name may be loaded simultaneously by different class loaders. These types may or may not represent",11,130.11,360,565,72,462.09,432,592.2,FALSE,FALSE
85,5,BODY,69,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
86,2,BODY,"the same type declaration. Even if two such types do represent the same type declaration, they are considered distinct. Two reference types are the same run-time type if: •They are both class or both interface types, are defined by the same class loader, and have the same binary name (§13.1), in which case they are sometimes said to be the same run-time class or the same run-time interface. •They are both array types, and their component types are the same run-time type (§10 (Arrays)).",11,115.14,360.01,490,72,76.06,432.01,191.2,FALSE,FALSE
86,6,BODY,70,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
87,6,BODY,71,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
88,5,BODY,72,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
89,3,BODY,4.5.1Type Arguments of Parameterized Types Type arguments may be either reference types or wildcards. Wildcards are useful in situations where only partial knowledge about the type parameter is required.,11,40.11,360,203,72,243.09,432,283.2,FALSE,FALSE
89,7,BODY,73,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
90,6,BODY,74,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
91,10,BODY,75,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
92,6,BODY,76,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
93,6,BODY,77,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
94,4,BODY,An intersection type is not reifiable.,11,6.14,158.26,38,72,226.06,230.26,232.2,FALSE,FALSE
94,6,BODY,78,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
95,6,BODY,79,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
96,7,BODY,"The use of raw types is allowed only as a concession to compatibility of legacy code. The use of raw types in code written after the introduction of generics into the Java programming language is strongly discouraged. It is possible that future versions of the Java programming language will disallow the use of raw types. To make sure that potential violations of the typing rules are always flagged, some accesses to members of a raw type will result in compile-time unchecked warnings. The rules for compile-time unchecked warnings when accessing members or constructors of raw types are as follows:",11,103.14,360.01,602,72,495.06,432.01,598.2,FALSE,FALSE
96,8,BODY,80,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
97,4,BODY,81,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
98,8,BODY,82,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
99,6,BODY,83,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
100,6,BODY,84,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
101,3,BODY,4.10.3Subtyping among Array Types The following rules define the direct supertype relation among array types:,11,27.11,329.93,109,72,561.09,401.93,588.2,FALSE,FALSE
101,4,BODY,85,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
102,6,BODY,86,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
103,5,BODY,87,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
104,4,BODY,88,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
105,5,BODY,89,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
106,5,BODY,90,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
107,5,BODY,91,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
108,3,BODY,§8.1.5),11,6.14,31.16,7,100,108.06,131.16,114.2,FALSE,FALSE
108,5,BODY,of an annotation interface (§9.6.1),11,6.14,150.29,35,100,159.06,250.29,165.2,FALSE,FALSE
108,7,BODY,"class, interface, method, or constructor (§8.1.2, §9.1.2, §8.4.4, §8.8.4)",11,6.14,307.34,73,100,210.06,407.34,216.2,FALSE,FALSE
108,8,BODY,"6.The type in a field declaration of a class or interface (§8.3, §9.3), including",11,6.14,350,81,82,229.06,432,235.2,FALSE,FALSE
108,9,BODY,an enum constant (§8.9.1),11,6.14,114.56,25,100,242.06,214.56,248.2,FALSE,FALSE
108,10,BODY,"7.The type in a formal parameter declaration of a method, constructor, or",11,6.14,349.99,73,82,261.06,431.99,267.2,FALSE,FALSE
108,11,BODY,"lambda expression (§8.4.1, §8.8.1, §9.4, §15.27.1) 8.The type of the receiver parameter of a method (§8.4) 9.The type in a local variable declaration in either a statement (§14.4.2,",11,44.14,350,181,82,274.06,432,318.2,FALSE,FALSE
108,12,BODY,"§14.14.1, §14.14.2, §14.20.3) or a pattern (§14.30.1) 10.A type in an exception parameter declaration (§14.20) 11.The type in a record component declaration of a record class (§8.10.1) •In expressions: 12.A type in the explicit type argument list to an explicit constructor invocation statement, class instance creation expression, method invocation expression, or method reference expression (§8.8.7.1, §15.9, §15.12, §15.13)",11,108.14,360.01,426,72,325.06,432.01,433.2,FALSE,FALSE
108,13,BODY,"13.In an unqualified class instance creation expression, as the class type to be instantiated (§15.9) or as the direct superclass type or direct superinterface type of an anonymous class to be instantiated (§15.9.5)",11,32.14,350,215,82,446.06,432,478.2,FALSE,FALSE
108,15,BODY,for a member method or as the class type or array type to construct.,11,6.14,296.93,68,100,561.06,396.93,567.2,FALSE,FALSE
108,16,BODY,"Also, types are used as:",11,6.14,103.57,24,72,580.06,175.57,586.2,FALSE,FALSE
108,17,BODY,92,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
109,3,BODY,93,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
110,3,BODY,94,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
111,5,BODY,95,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
112,4,BODY,4.12.1Variables of Primitive Type A variable of a primitive type always holds a primitive value of that exact primitive type.,11,40.11,360,125,72,553.09,432,593.2,FALSE,FALSE
112,5,BODY,96,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
113,7,BODY,97,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
114,4,BODY,The variable will always refer to an object that is an instance of a class that represents the parameterized type.,11,19.14,359.99,114,72,468.06,431.99,487.2,FALSE,FALSE
114,6,BODY,98,11,6.34,11,2,36,625.59,47,631.93,TRUE,FALSE
115,4,BODY,2.An instance variable is a field declared within a class declaration without using,11,6.14,360.01,83,72,317.06,432.01,323.2,FALSE,FALSE
115,6,BODY,"3.Array components are unnamed variables that are created and initialized to default values (§4.12.5) whenever a new object that is an array is created (§10 (Arrays), §15.10.2). The array components effectively cease to exist when the array is no longer referenced.",11,45.14,360.01,265,72,433.06,432.01,478.2,FALSE,FALSE
115,7,BODY,4.Method parameters (§8.4.1) name argument values passed to a method.,11,6.14,333.28,69,72,491.06,405.28,497.2,FALSE,FALSE
115,8,BODY,"For every parameter declared in a method declaration, a new parameter variable is created each time that method is invoked (§15.12). The new variable is initialized with the corresponding argument value from the method invocation. The method parameter effectively ceases to exist when the execution of the body of the method is complete.",11,58.14,342.01,337,90,510.06,432.01,568.2,FALSE,FALSE
115,9,BODY,99,11,6.34,11,2,457,625.59,468,631.93,TRUE,FALSE
116,2,BODY,5.Constructor parameters (§8.8.1) name argument values passed to a,11,6.14,360,66,72,76.06,432,82.2,FALSE,FALSE
116,3,BODY,"constructor. For every parameter declared in a constructor declaration, a new parameter variable is created each time a class instance creation expression (§15.9) or explicit constructor invocation (§8.8.7) invokes that constructor. The new variable is initialized with the corresponding argument value from the creation expression or constructor invocation. The constructor parameter effectively ceases to exist when the execution of the body of the constructor is complete. 6.Lambda parameters (§15.27.1) name argument values passed to a lambda",11,109.14,360.01,546,72,89.06,432.01,198.2,FALSE,FALSE
116,4,BODY,"expression body (§15.27.2). For every parameter declared in a lambda expression, a new parameter variable is created each time a method implemented by the lambda body is invoked (§15.12). The new variable is initialized with the corresponding argument value from the method invocation. The lambda parameter effectively ceases to exist when the execution of the lambda expression body is complete.",11,77.14,342.01,396,90,205.06,432.01,282.2,FALSE,FALSE
116,7,BODY,100,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
117,6,BODY,101,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
118,8,BODY,102,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
119,5,BODY,103,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
120,7,BODY,"4.12.6Types, Classes, and Interfaces In the Java programming language, every variable and every expression has a type that can be determined at compile time. The type may be a primitive type or a reference type. Reference types include class types and interface types. Reference",11,53.11,360.01,278,72,550.09,432.01,603.2,FALSE,FALSE
120,8,BODY,104,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
121,4,BODY,105,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
122,2,BODY,"2.Type variables (§4.4) and type arguments (§4.5.1) are not reified at run time. As a result, the same class or interface at run time represents multiple parameterized types (§4.5) from compile time. Specifically, all compile-time parameterizations of a given generic type (§8.1.2, §9.1.2) share a single run- time representation.",11,58.14,360,330,72,76.06,432,134.2,FALSE,FALSE
122,7,BODY,106,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
123,3,BODY,107,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
125,3,BODY,109,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
126,3,BODY,"The conversions possible in the Java programming language are grouped into several broad categories: •Identity conversions •Widening primitive conversions •Narrowing primitive conversions •Widening reference conversions •Narrowing reference conversions •Boxing conversions •Unboxing conversions •Unchecked conversions •Capture conversions •String conversions There are seven kinds of conversion contexts in which poly expressions may be influenced by context or implicit conversions may occur. Each kind of context has different rules for poly expression typing and allows conversions in some of the categories above but not others. The contexts are: •Assignment contexts (§5.2, §15.26), in which an expression's value is bound to a named variable. Primitive and reference types are subject to widening, values may be boxed or unboxed, and some primitive constant expressions may be subject to narrowing. An unchecked conversion may also occur.",11,325.14,360.01,944,72,241.06,432.01,566.2,FALSE,FALSE
126,4,BODY,110,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
127,4,BODY,111,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
128,6,BODY,5.1.1Identity Conversion A conversion from a type to that same type is permitted for any type.,11,27.11,303.68,94,72,515.09,375.68,542.2,FALSE,FALSE
128,8,BODY,112,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
129,4,BODY,113,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
130,9,BODY,114,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
131,9,BODY,2.In the second step:,11,6.14,100.18,21,72,461.06,172.18,467.2,FALSE,FALSE
131,12,BODY,115,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
132,2,BODY,"Despite the fact that overflow, underflow, or other loss of information may occur, a narrowing primitive conversion never results in a run-time exception (§11.1.1).",11,19.14,360,164,72,76.06,432,95.2,FALSE,FALSE
132,10,BODY,116,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
133,8,BODY,117,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
134,4,BODY,118,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
135,11,BODY,119,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
136,7,BODY,120,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
137,5,BODY,The categorization of an unchecked narrowing reference conversion is as follows:,11,6.14,360.01,80,72,591.2,432.01,597.33,FALSE,FALSE
137,6,BODY,121,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
138,3,BODY,122,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
139,6,BODY,123,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
140,5,BODY,124,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
141,7,BODY,"5.1.8Unboxing Conversion Unboxing conversion treats expressions of a reference type as expressions of a corresponding primitive type. Specifically, the following eight conversions are called the unboxing conversions:",11,53.11,360,216,72,533.09,432,586.2,FALSE,FALSE
141,8,BODY,125,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
142,3,BODY,126,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
143,7,BODY,127,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
144,7,BODY,128,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
145,6,BODY,129,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
146,4,BODY,5.1.12Forbidden Conversions Any conversion that is not explicitly allowed is forbidden.,11,27.11,256.34,87,72,392.09,328.34,419.2,FALSE,FALSE
146,6,BODY,130,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
147,4,BODY,"Finally, a value of the null type (the null reference is the only such value) may be assigned to any reference type, resulting in a null reference of that type. It is a compile-time error if the chain of conversions contains two parameterized types that are not in the subtype relation (§4.10).",11,51.14,360,294,72,440.06,432,491.2,FALSE,FALSE
147,7,BODY,131,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
148,11,BODY,132,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
149,6,BODY,133,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
150,7,BODY,134,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
151,4,BODY,135,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
152,4,BODY,136,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
153,5,BODY,137,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
154,3,BODY,138,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
155,6,BODY,139,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
156,16,BODY,140,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
157,5,BODY,141,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
158,6,BODY,142,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
159,6,BODY,143,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
160,3,BODY,(§5.1.8).,11,6.14,37.58,9,90,370.06,127.58,376.2,FALSE,FALSE
160,4,BODY,144,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
161,3,BODY,145,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
162,3,BODY,Unary numeric promotion consists of applying numeric promotion to a single expression that occurs in a numeric arithmetic context or a numeric array context. Binary numeric promotion consists of applying numeric promotion to a pair of expressions that occur in a numeric arithmetic context. General numeric promotion consists of applying numeric promotion to all the expressions that occur in a numeric choice context.,11,83.14,360,418,72,140.06,432,223.2,FALSE,FALSE
162,10,BODY,146,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
163,7,BODY,147,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
164,3,BODY,148,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
165,3,BODY,149,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
166,2,BODY,Fully qualified and canonical names (§6.7) are also discussed in this chapter.,11,6.14,338.2,78,72,76.06,410.2,82.2,FALSE,FALSE
166,4,BODY,150,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
167,4,BODY,151,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
168,4,BODY,152,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
169,7,BODY,153,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
170,6,BODY,154,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
171,9,BODY,155,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
172,6,BODY,156,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
173,4,BODY,157,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
174,4,BODY,Not all identifiers in a program are a part of a name. Identifiers are also used in the following situations:,11,19.14,359.99,109,72,566.06,431.99,585.2,FALSE,FALSE
174,5,BODY,158,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
175,4,BODY,159,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
176,4,BODY,160,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
177,3,BODY,161,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
178,8,BODY,162,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
179,13,BODY,"The scope of a pattern variable declaration (that is, a local variable declared by a pattern) is the part of the program that might be executed after the matching of a value against the pattern has succeeded (§14.30.2). It is determined by considering",11,32.14,360,251,72,571.06,432,603.2,FALSE,FALSE
179,14,BODY,163,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
180,2,BODY,"the program points where the pattern variable is definitely matched in a region beginning with the pattern that declares the pattern variable. The remainder of this section is devoted to a precise explanation of the words 'definitely matched'. The analysis takes into account the structure of statements and expressions, with a special treatment for the boolean expression operators and certain statement forms.",11,77.14,360.01,411,72,76.06,432.01,153.2,FALSE,FALSE
180,4,BODY,"The analysis relies on the technical term 'introduced by', which has the following form: •a pattern variable is introduced by an expression when true •a pattern variable is introduced by an expression when false •a pattern variable is introduced by a statement",11,76.14,360.01,260,72,214.06,432.01,290.2,FALSE,FALSE
180,7,BODY,164,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
181,6,BODY,165,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
182,6,BODY,166,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
183,4,BODY,6.3.2Scope for Pattern Variables in Statements Only a few kinds of statements play a significant role in determining the scope of pattern variables.,11,40.11,359.99,148,72,552.49,431.99,592.6,FALSE,FALSE
183,5,BODY,167,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
184,4,BODY,"Also, in certain circumstances, a pattern variable can be introduced by a statement itself, rather than by an expression within the statement. A pattern variable introduced by a statement is in scope at the following statements in the enclosing block.",11,45.14,360.01,251,72,239.06,432.01,284.2,FALSE,FALSE
184,7,BODY,168,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
185,7,BODY,169,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
186,4,BODY,170,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
187,5,BODY,171,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
188,2,BODY,"class declaration, or local interface declaration because it would be impossible to distinguish between the declared entities using only simple names.",11,19.14,360,150,72,76.06,432,95.2,FALSE,FALSE
188,6,BODY,172,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
189,10,BODY,173,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
190,7,BODY,174,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
191,4,BODY,175,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
192,8,BODY,176,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
193,8,BODY,177,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
194,4,BODY,"6.4.2Obscuring A simple name may occur in contexts where it may potentially be interpreted as the name of a variable, a type, or a package. In these situations, the rules of §6.5.2 specify that a variable will be chosen in preference to a type, and that a type will be chosen in preference to a package. Thus, it is may sometimes be impossible to refer to a type or package via its simple name, even though its declaration is in scope and not shadowed. We say that such a declaration is obscured. Obscuring is distinct from shadowing (§6.4.1) and hiding (§8.3, §8.4.8.2, §8.5, §9.3, §9.5). There is no obscuring between the name of a module and the name of a variable, type, or package; thus, modules may share names with variables, types, and packages, though it is not necessarily recommended to name a module after a package it contains.",11,182.11,360.01,840,72,137.09,432.01,319.2,FALSE,FALSE
194,6,BODY,178,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
195,4,BODY,179,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
196,4,BODY,180,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
197,3,BODY,§9.1.4).,11,6.14,33.91,8,100,184.06,133.91,190.2,FALSE,FALSE
197,5,BODY,(§15.11.2),11,6.14,45.83,10,100,292.06,145.83,298.2,FALSE,FALSE
197,7,BODY,invocation expression (§15.12),11,6.14,136.56,30,100,324.06,236.56,330.2,FALSE,FALSE
197,9,BODY,181,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
198,3,BODY,of an annotation interface (§9.6.1),11,6.14,150.29,35,100,159.06,250.29,165.2,FALSE,FALSE
198,5,BODY,"interface, method, or constructor (§8.1.2, §9.1.2, §8.4.4, §8.8.4) 6.The type in a field declaration of a class or interface (§8.3, §9.3) 7.The type in a formal parameter declaration of a method, constructor, or",11,44.14,349.99,211,82,210.06,431.99,254.2,FALSE,FALSE
198,6,BODY,"lambda expression (§8.4.1, §8.8.1, §9.4, §15.27.1) 8.The type of the receiver parameter of a method (§8.4) 9.The type in a local variable declaration in either a statement (§14.4.2,",11,44.14,350,181,82,261.06,432,305.2,FALSE,FALSE
198,7,BODY,"§14.14.1, §14.14.2, §14.20.3) or a pattern (§14.30.1) 10.A type in an exception parameter declaration (§14.20) 11.The type in a record component declaration of a record class (§8.10.1) 12.In an explicit type argument list to an explicit constructor invocation statement or class instance creation expression or method invocation expression (§8.8.7.1, §15.9, §15.12)",11,89.14,350,365,82,312.06,432,401.2,FALSE,FALSE
198,8,BODY,"13.In an unqualified class instance creation expression, either as the class type to be instantiated (§15.9) or as the direct superclass or direct superinterface of an anonymous class to be instantiated (§15.9.5)",11,32.14,349.99,212,82,414.06,431.99,446.2,FALSE,FALSE
198,11,BODY,182,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
199,4,BODY,183,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
200,3,BODY,"6.5.2Reclassification of Contextually Ambiguous Names An AmbiguousName is then reclassified as follows. If the AmbiguousName is a simple name, consisting of a single Identifier, then: •If the Identifier appears within the scope of a declaration (§6.3) denoting either a local variable, formal parameter, exception parameter, or field with that name (§14.4, §8.4.1, §8.8.1, §15.27.1, §14.20, §8.3), then the AmbiguousName is reclassified as an ExpressionName. •Otherwise, if the Identifier is a valid TypeIdentifier (§3.8) and appears within the scope of a declaration denoting a class, interface, or type parameter with that name (§8.1, §9.1, §8.4.4, §8.8.4), then the AmbiguousName is reclassified as a TypeName. •Otherwise, the AmbiguousName is reclassified as a PackageName. A later step determines whether or not a package of that name actually exists. If the AmbiguousName is a qualified name, consisting of a name, a '.', and an Identifier, then the name to the left of the '.' is first reclassified, for it is itself an AmbiguousName. There is then a choice: •If the name to the left of the '.' is reclassified as a PackageName, then: –If the Identifier is a valid TypeIdentifier, and there is a package whose name is the name to the left of the '.', and that package contains a declaration of a type whose name is the same as the Identifier, then this AmbiguousName is reclassified as a TypeName. –Otherwise, this AmbiguousName is reclassified as a PackageName. A later step determines whether or not a package of that name actually exists.",11,348.11,360,1548,72,245.09,432,593.2,FALSE,FALSE
200,4,BODY,184,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
201,11,BODY,185,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
202,3,BODY,"6.5.3Meaning of Module Names and Package Names The module name M, whether simple or qualified, denotes the module (if any) with that name.",11,40.11,360.01,138,72,187.09,432.01,227.2,FALSE,FALSE
202,7,BODY,186,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
203,5,BODY,187,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
204,3,BODY,"The meaning of the type name is the in-scope class, interface, or type parameter.",11,6.14,354.35,81,72,108.06,426.35,114.2,FALSE,FALSE
204,8,BODY,188,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
205,9,BODY,189,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
206,7,BODY,190,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
207,9,BODY,191,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
208,6,BODY,192,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
209,5,BODY,193,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
210,5,BODY,194,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
211,14,BODY,195,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
212,2,BODY,"6.5.7Meaning of Method Names The meaning of a name classified as a MethodName is determined as follows. 6.5.7.1Simple Method Names A simple method name appears in the context of a method invocation expression (§15.12). The simple method name consists of a single UnqualifiedMethodIdentifier which specifies the name of the method to be invoked. The rules of method invocation require that the UnqualifiedMethodIdentifier denotes a method that is in scope at the point of the method invocation. The rules also prohibit (§15.12.3) a reference to an instance method occurring in a static context (§8.1.3), or in a nested class or interface other than an inner class of the class or interface which declares the instance method.",11,165.24,360.01,724,72,76.09,432.01,241.33,FALSE,FALSE
212,7,BODY,196,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
213,5,BODY,197,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
214,4,BODY,198,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
215,3,BODY,•An array type is accessible if and only if its element type is accessible.,11,6.14,320.39,75,72,447.06,392.39,453.2,FALSE,FALSE
215,9,BODY,199,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
216,11,BODY,200,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
217,9,BODY,201,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
218,11,BODY,202,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
219,7,BODY,203,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
220,9,BODY,204,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
221,4,BODY,205,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
222,6,BODY,206,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
223,8,BODY,207,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
225,3,BODY,209,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
226,7,BODY,210,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
227,4,BODY,"The hierarchical naming structure for packages is intended to be convenient for organizing related packages in a conventional manner, but has no significance in itself other than the prohibition against a package having a subpackage with the same simple name as a top level class or interface (§7.6) declared in that package.",11,45.14,360,325,72,180.06,432,225.2,FALSE,FALSE
227,8,BODY,211,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
228,2,BODY,"In simple implementations of the Java SE Platform, packages and compilation units may be stored in a local file system. Other implementations may store them using a distributed file system or some form of database. If a host system stores packages and compilation units in a database, then the database must not impose the optional restrictions (§7.6) on compilation units permissible in file-based implementations.",11,77.14,360.01,415,72,76.06,432.01,153.2,FALSE,FALSE
228,4,BODY,"Systems that use a database must, however, provide an option to convert a program to a form that obeys the restrictions, for purposes of export to file-based implementations.",11,32.14,360,174,72,204.06,432,236.2,FALSE,FALSE
228,8,BODY,212,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
229,9,BODY,213,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
230,3,BODY,CompilationUnit: OrdinaryCompilationUnit ModularCompilationUnit OrdinaryCompilationUnit: [PackageDeclaration] {ImportDeclaration} {TopLevelClassOrInterfaceDeclaration},11,82.05,204.25,167,90,145.13,294.25,227.18,FALSE,TRUE
230,4,BODY,ModularCompilationUnit: {ImportDeclaration} ModuleDeclaration,11,19.05,191.42,61,90,245.13,281.42,264.18,FALSE,TRUE
230,6,BODY,214,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
231,5,BODY,"Classes and interfaces declared in different ordinary compilation units can refer to each other, circularly. A Java compiler must arrange to compile all such classes and interfaces at the same time.",11,32.14,360.01,198,72,530.06,432.01,562.2,FALSE,FALSE
231,6,BODY,215,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
232,4,BODY,7.4.1Named Packages A package declaration in an ordinary compilation unit specifies the name (§6.2) of the package to which the compilation unit belongs.,11,40.11,360,153,72,153.09,432,193.2,FALSE,FALSE
232,7,BODY,216,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
233,8,BODY,217,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
234,8,BODY,ImportDeclaration: SingleTypeImportDeclaration TypeImportOnDemandDeclaration SingleStaticImportDeclaration StaticImportOnDemandDeclaration,11,58.05,168.87,138,90,477.13,258.87,535.18,FALSE,TRUE
234,9,BODY,"•A single-type-import declaration (§7.5.1) imports a single named class or interface, by mentioning its canonical name (§6.7).",11,19.14,360,126,72,553.06,432,572.2,FALSE,FALSE
234,10,BODY,218,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
235,4,BODY,"7.5.1Single-Type-Import Declarations A single-type-import declaration imports a single class or interface by giving its canonical name, making it available under a simple name in the module, class, and interface declarations of the compilation unit in which the single-type-import declaration appears.",11,66.11,360,301,72,328.09,432,394.2,FALSE,FALSE
235,6,BODY,"The TypeName must be the canonical name of a class or interface (§6.7). The class or interface must be either a member of a named package, or a member of a class or interface whose outermost lexically enclosing class or interface declaration (§8.1.3) is a member of a named package, or a compile-time error occurs. It is a compile-time error if the named class or interface is not accessible (§6.6). If two single-type-import declarations in the same compilation unit attempt to import classes or interfaces with the same simple name, then a compile-time error occurs, unless the two classes or interface are the same, in which case the duplicate declaration is ignored.",11,141.14,360.01,670,72,449.06,432.01,590.2,FALSE,FALSE
235,7,BODY,219,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
236,12,BODY,220,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
237,11,BODY,"7.5.2Type-Import-on-Demand Declarations A type-import-on-demand declaration allows all accessible classes and interfaces of a named package, class, or interface to be imported as needed.",11,40.11,360,186,72,511.09,432,551.2,FALSE,FALSE
237,13,BODY,221,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
238,7,BODY,222,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
239,2,BODY,"available under their simple name in the module, class, and interface declarations of the compilation unit in which the single-static-import declaration appears.",11,19.14,360,161,72,76.06,432,95.2,FALSE,FALSE
239,6,BODY,223,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
240,6,BODY,224,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
241,8,BODY,225,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
242,8,BODY,An implementation of the Java SE Platform must keep track of classes and interfaces within packages by the combination of their enclosing module names and their binary names (§13.1). Multiple ways of naming a class or interface must be expanded to binary names to make sure that such names are understood as referring to the same class or interface.,11,58.14,360.01,349,72,430.06,432.01,488.2,FALSE,FALSE
242,11,BODY,"If and only if packages are stored in a file system (§7.2), the host system may choose to enforce the restriction that it is a compile-time error if a class or interface",11,19.14,360.01,169,72,583.06,432.01,602.2,FALSE,FALSE
242,12,BODY,226,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
243,6,BODY,227,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
244,3,BODY,228,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
245,6,BODY,229,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
246,5,BODY,"If resolution succeeds, then its result specifies the modules that are read by the current module. The modules read by the current module determine which ordinary compilation units are visible to the current module (§7.3). The types declared in",11,32.14,360.01,244,72,557.06,432.01,589.2,FALSE,FALSE
246,6,BODY,230,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
247,2,BODY,those ordinary compilation units (and only those ordinary compilation units) may be accessible to code in the current module (§6.6).,11,19.14,360,132,72,76.06,432,95.2,FALSE,FALSE
247,11,BODY,231,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
248,8,BODY,232,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
249,4,BODY,233,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
250,5,BODY,234,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
251,2,BODY,"7.7.5Unnamed Modules An observable ordinary compilation unit that the host system does not associate with a named module (§7.3) is associated with an unnamed module. Unnamed modules are provided by the Java SE Platform in recognition of the fact that programs developed prior to Java SE 9 could not declare named modules. In addition, the reasons for the Java SE Platform providing unnamed packages (§7.4.2) are largely applicable to unnamed modules. An implementation of the Java SE Platform must support at least one unnamed module. An implementation may support more than one unnamed module, but is not required to do so. Which ordinary compilation units are associated with each unnamed module is determined by the host system. The host system may associate ordinary compilation units in a named package with an unnamed module. The rules for unnamed modules are designed to maximize their interoperation with named modules, as follows: •An unnamed module reads every observable module (§7.7.6).",11,239.11,360.01,998,72,76.09,432.01,315.2,FALSE,FALSE
251,4,BODY,•An unnamed module exports every package whose ordinary compilation units are associated with that unnamed module. •An unnamed module opens every package whose ordinary compilation units are associated with that unnamed module.,11,51.14,360.01,227,72,452.06,432.01,503.2,FALSE,FALSE
251,5,BODY,7.7.6Observability of a Module A module is observable if at least one of the following is true: •A modular compilation unit containing the declaration of the module is observable (§7.3).,11,59.11,360,186,72,529.09,432,588.2,FALSE,FALSE
251,6,BODY,235,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
252,2,BODY,•An ordinary compilation unit associated with the module is observable.,11,6.14,324.08,71,72,76.06,396.08,82.2,FALSE,FALSE
252,3,BODY,236,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
253,3,BODY,237,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
254,2,BODY,238,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
255,2,BODY,"Static initializers (§8.7) are blocks of executable code that may be used to help initialize a class. Constructors (§8.8) are similar to methods, but cannot be invoked directly by a method call; they are used to initialize new class instances. Like methods, they may be overloaded (§8.8.8).",11,64.14,360.01,290,72,76.06,432.01,140.2,FALSE,FALSE
255,5,BODY,A class is also implicitly declared by a class instance creation expression (§15.9.5) and an enum constant that ends with a class body (§8.9.1). The TypeIdentifier in a class declaration specifies the name of the class. It is a compile-time error if a class has the same simple name as any of its enclosing classes or interfaces. The scope and shadowing of a class declaration is specified in §6.3 and §6.4.1.,11,89.14,360.01,409,72,376.06,432.01,465.2,FALSE,FALSE
255,6,BODY,8.1.1Class Modifiers A class declaration may include class modifiers.,11,27.11,212.33,69,72,491.09,284.33,518.2,FALSE,FALSE
255,8,BODY,239,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
256,5,BODY,240,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
257,12,BODY,241,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
258,6,BODY,242,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
259,6,BODY,8.1.2Generic Classes and Type Parameters A class is generic if the class declaration declares one or more type variables (§4.4). These type variables are known as the type parameters of the class. The type parameter section follows the class name and is delimited by angle brackets.,11,59.11,360,282,72,502.35,432,561.47,FALSE,FALSE
259,8,BODY,243,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
260,8,BODY,244,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
261,7,BODY,245,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
262,7,BODY,246,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
263,6,BODY,247,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
264,8,BODY,248,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
265,7,BODY,249,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
266,8,BODY,250,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
267,3,BODY,251,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
268,2,BODY,"A class is said to be a direct subclass of its direct superclass, and a subclass of each of its superclasses.",11,19.14,360,109,72,76.06,432,95.2,FALSE,FALSE
268,10,BODY,252,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
269,12,BODY,253,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
270,5,BODY,254,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
271,10,BODY,255,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
272,11,BODY,256,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
273,7,BODY,257,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
274,5,BODY,"8.1.7Class Body and Member Declarations A class body may contain declarations of members of the class, that is, fields (§8.3), methods (§8.4), classes, and interfaces (§8.5). A class body may also contain instance initializers (§8.6), static initializers (§8.7), and declarations of constructors (§8.8) for the class.",11,72.11,360,317,72,246.09,432,318.2,FALSE,FALSE
274,9,BODY,258,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
275,4,BODY,"Fields, methods, member classes, and member interfaces of a class may have the same name, since they are used in different contexts and are disambiguated by different lookup procedures (§6.5). However, this is discouraged as a matter of style.",11,45.14,360,243,72,513.06,432,558.2,FALSE,FALSE
275,7,BODY,259,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
276,11,BODY,260,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
277,11,BODY,261,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
278,11,BODY,262,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
279,7,BODY,263,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
280,3,BODY,264,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
281,4,BODY,"Each declarator in a FieldDeclaration declares one field. The declarator must include an Identifier, or a compile-time error occurs. The Identifier may be used in a name to refer to the field. More than one field may be declared in a single FieldDeclaration by using more than one declarator; the FieldModifiers and UnannType apply to all the declarators in the declaration. The FieldModifier clause is described in §8.3.1. The declared type of a field is denoted by UnannType if no bracket pairs appear in UnannType and VariableDeclaratorId, and is specified by §10.2 otherwise. The scope and shadowing of a field declaration is specified in §6.3 and §6.4.1. It is a compile-time error for the body of a class declaration to declare two fields with the same name. If a class declares a field with a certain name, then the declaration of that field is said to hide any and all accessible declarations of fields with the same name in superclasses, and superinterfaces of the class.",11,224.14,360.01,980,72,228.06,432.01,452.2,FALSE,FALSE
281,8,BODY,265,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
282,8,BODY,266,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
283,10,BODY,267,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
284,3,BODY,8.3.1Field Modifiers,11,6.34,104.41,20,72,135.09,176.41,141.43,TRUE,FALSE
284,8,BODY,268,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
285,13,BODY,269,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
286,11,BODY,270,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
287,9,BODY,271,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
288,8,BODY,272,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
289,10,BODY,273,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
290,7,BODY,274,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
291,11,BODY,275,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
292,12,BODY,276,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
293,9,BODY,277,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
294,4,BODY,278,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
295,5,BODY,279,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
296,2,BODY,It is a compile-time error for the body of a class declaration to declare as members two methods with override-equivalent signatures (§8.4.2). The declaration of a method that returns an array is allowed to place some or all of the bracket pairs that denote the array type after the formal parameter list. This syntax is supported for compatibility with early versions of the Java programming language. It is very strongly recommended that this syntax is not used in new code.,11,77.14,360.01,476,72,76.06,432.01,153.2,FALSE,FALSE
296,7,BODY,280,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
297,2,BODY,"A formal parameter of a method or constructor may be a variable arity parameter, indicated by an ellipsis following the type. At most one variable arity parameter is permitted for a method or constructor. It is a compile-time error if a variable arity parameter appears anywhere in the list of parameter specifiers except the last position.",11,58.14,360,340,72,76.06,432,134.2,FALSE,FALSE
297,5,BODY,281,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
298,4,BODY,282,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
299,8,BODY,283,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
300,6,BODY,8.4.3Method Modifiers,11,6.34,117.24,21,72,241.09,189.24,247.43,TRUE,FALSE
300,11,BODY,284,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
301,11,BODY,285,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
302,7,BODY,286,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
303,5,BODY,287,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
304,9,BODY,288,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
305,7,BODY,289,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
306,6,BODY,290,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
307,6,BODY,291,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
308,7,BODY,292,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
309,2,BODY,"8.4.7Method Body A method body is either a block of code that implements the method or simply a semicolon, indicating the lack of an implementation.",11,40.11,359.99,148,72,76.09,431.99,116.2,FALSE,FALSE
309,9,BODY,293,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
310,8,BODY,294,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
311,5,BODY,295,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
312,9,BODY,296,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
313,7,BODY,297,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
314,7,BODY,298,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
315,13,BODY,299,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
316,5,BODY,"The access modifier of an overriding or hiding method must provide at least as much access as the overridden or hidden method, as follows:",11,19.14,360,138,72,557.06,432,576.2,FALSE,FALSE
316,6,BODY,300,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
317,12,BODY,301,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
318,11,BODY,302,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
319,8,BODY,8.4.8.4Inheriting Methods with Override-Equivalent Signatures It is possible for a class to inherit multiple methods with override-equivalent signatures (§8.4.2).,11,39.2,360,162,72,555.13,432,594.33,FALSE,FALSE
319,9,BODY,303,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
320,8,BODY,304,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
321,8,BODY,305,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
322,7,BODY,306,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
323,8,BODY,307,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
324,6,BODY,308,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
325,2,BODY,"It is possible for a class to inherit more than one member class or interface with the same name, either from its superclass and superinterfaces or from its superinterfaces alone. Such a situation does not in itself cause a compile-time error. However, any attempt within the body of the class to refer to any such member class or interface by its simple name will result in a compile-time error, because the reference is ambiguous. There might be several paths by which the same member class or interface declaration is inherited from an interface. In such a situation, the member class or interface is considered to be inherited only once, and it may be referred to by its simple name without ambiguity.",11,129.14,360.01,705,72,76.06,432.01,205.2,FALSE,FALSE
325,4,BODY,InstanceInitializer: Block,11,19.05,84.33,26,90,309.13,174.33,328.18,FALSE,TRUE
325,7,BODY,309,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
326,6,BODY,SimpleTypeName: TypeIdentifier,11,19.05,80.65,30,90,464.13,170.65,483.18,FALSE,TRUE
326,7,BODY,"The rules in this section apply to constructors in all class declarations, including enum declarations and record declarations. However, special rules apply to enum declarations with regard to constructor modifiers, constructor bodies, and default constructors; these rules are stated in §8.9.2. Special rules also apply to record declarations with regard to constructors, as stated in §8.10.4. The SimpleTypeName in the ConstructorDeclarator must be the simple name of the class that contains the constructor declaration, or a compile-time error occurs.",11,90.14,360,554,72,501.06,432,591.2,FALSE,FALSE
326,8,BODY,310,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
327,2,BODY,"In all other respects, a constructor declaration looks just like a method declaration that has no result (§8.4.5). Constructor declarations are not members. They are never inherited and therefore are not subject to hiding or overriding. Constructors are invoked by class instance creation expressions (§15.9), by the conversions and concatenations caused by the string concatenation operator + (§15.18.1), and by explicit constructor invocations from other constructors (§8.8.7). Access to constructors is governed by access modifiers (§6.6), so it is possible to prevent class instantiation by declaring an inaccessible constructor (§8.8.10). Constructors are never invoked by method invocation expressions (§15.12).",11,154.14,360,717,72,76.06,432,230.2,FALSE,FALSE
327,8,BODY,311,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
328,5,BODY,8.8.2Constructor Signature It is a compile-time error to declare two constructors with override-equivalent signatures (§8.4.2) in a class. It is a compile-time error to declare two constructors whose signatures have the same erasure (§4.6) in a class.,11,72.11,360,251,72,363.09,432,435.2,FALSE,FALSE
328,6,BODY,8.8.3Constructor Modifiers,11,6.34,138.01,26,72,461.09,210.01,467.43,TRUE,FALSE
328,9,BODY,312,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
329,2,BODY,"In a normal class declaration, a constructor declaration with no access modifiers has package access.",11,19.14,360,101,72,76.06,432,95.2,FALSE,FALSE
329,4,BODY,"8.8.4Generic Constructors A constructor is generic if it declares one or more type variables (§4.4). These type variables are known as the type parameters of the constructor. The form of the type parameter section of a generic constructor is identical to the type parameter section of a generic class (§8.1.2). It is possible for a constructor to be generic independently of whether the class the constructor is declared in is itself generic. A generic constructor declaration defines a set of constructors, one for each possible invocation of the type parameter section by type arguments. Type arguments may not need to be provided explicitly when a generic constructor is invoked, as they can often by inferred (§18 (Type Inference)). The scope and shadowing of a constructor's type parameter is specified in §6.3 and §6.4.1.",11,194.11,360.01,827,72,367.09,432.01,561.2,FALSE,FALSE
329,5,BODY,313,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
330,2,BODY,"References to a constructor's type parameter from an explicit constructor invocation statement or a nested class or interface are restricted, as specified in §6.5.5.1.",11,32.14,360,167,72,76.06,432,108.2,FALSE,FALSE
330,5,BODY,8.8.7Constructor Body The first statement of a constructor body may be an explicit invocation of another constructor of the same class or of the direct superclass (§8.8.7.1).,11,40.11,360,174,72,266.09,432,306.2,FALSE,FALSE
330,10,BODY,314,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
331,4,BODY,8.8.7.1Explicit Constructor Invocations,11,6.14,184.47,39,72,242.13,256.47,248.27,FALSE,TRUE
331,8,BODY,315,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
332,2,BODY,the newly created object's immediately enclosing instance with respect to the direct superclass (§8.1.3). This may be necessary when the superclass is an inner class.,11,32.14,340,166,92,76.06,432,108.2,FALSE,FALSE
332,4,BODY,316,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
333,8,BODY,317,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
334,2,BODY,as an explicit constructor invocation statement or is provided implicitly. (An alternate constructor invocation does not perform this additional implicit execution.),11,32.14,342,165,90,76.06,432,108.2,FALSE,FALSE
334,11,BODY,318,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
335,7,BODY,8.8.8Constructor Overloading Overloading of constructors is identical in behavior to overloading of methods (§8.4.9). The overloading is resolved at compile time by each class instance creation expression (§15.9).,11,53.11,360,213,72,453.09,432,506.2,FALSE,FALSE
335,8,BODY,"8.8.9Default Constructor If a class contains no constructor declarations, then a default constructor is implicitly declared. The form of the default constructor for a top level class, member class, or local class is as follows:",11,53.11,360,227,72,532.09,432,585.2,FALSE,FALSE
335,9,BODY,319,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
336,11,BODY,320,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
337,10,BODY,321,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
338,6,BODY,An enum class has no instances other than those defined by its enum constants. It is a compile-time error to attempt to explicitly instantiate an enum class (§15.9.1).,11,19.14,360,167,72,534.06,432,553.2,FALSE,FALSE
338,8,BODY,322,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
339,3,BODY,8.9.1Enum Constants The body of an enum declaration may contain enum constants. An enum constant defines an instance of the enum class.,11,40.11,360,135,72,147.09,432,187.2,FALSE,FALSE
339,7,BODY,323,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
340,4,BODY,"8.9.2Enum Body Declarations In addition to enum constants, the body of an enum declaration may contain constructor and member declarations as well as instance and static initializers.",11,40.11,360,183,72,230.09,432,270.2,FALSE,FALSE
340,8,BODY,324,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
341,11,BODY,325,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
342,6,BODY,326,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
343,10,BODY,327,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
344,9,BODY,328,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
345,6,BODY,329,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
346,7,BODY,330,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
347,6,BODY,"8.10.1Record Components The record components of a record class, if any, are specified in the header of a record declaration. Each record component consists of a type (optionally preceded by one or more annotations) and an identifier that specifies the name of the record component. A record component corresponds to two members of the record",11,66.11,360.01,342,72,519.09,432.01,585.2,FALSE,FALSE
347,7,BODY,331,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
348,4,BODY,"A record component may be a variable arity record component, indicated by an ellipsis following the type. At most one variable arity record component is permitted for a record class. It is a compile-time error if a variable arity record component appears anywhere in the list of record components except the last position. The rules concerning annotation modifiers for a record component are specified in §9.7.4 and §9.7.5.",11,90.14,360.01,423,72,343.06,432.01,433.2,FALSE,FALSE
348,8,BODY,332,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
349,4,BODY,8.10.2Record Body Declarations The body of a record declaration may contain constructor and member declarations as well as static initializers.,11,40.11,360.01,143,72,400.09,432.01,440.2,FALSE,FALSE
349,6,BODY,333,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
350,5,BODY,334,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
351,4,BODY,"The scope and shadowing of the component field and the accessor method are specified in §6.3 and §6.4.1. (The record component to which they correspond is not a declaration, so has no scope of its own.) Record classes may explicitly declare instance methods other than accessor methods, but may not explicitly declare instance variables (§8.10.2). Explicit declarations of class methods and class variables are permitted. All members of record classes, including implicitly declared members, are subject to the usual rules for member declarations in a class (§8.3, §8.4, §8.5).",11,109.14,360,577,72,485.06,432,594.2,FALSE,FALSE
351,5,BODY,335,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
352,2,BODY,"All of the rules concerning inheritance that apply to normal classes apply to record classes. In particular, record classes may inherit members from superinterfaces, although a superinterface method will never be inherited as an accessor method because the record class will always declare, explicitly or implicitly, an accessor method that overrides the superinterface method.",11,58.14,360.01,377,72,76.06,432.01,134.2,FALSE,FALSE
352,5,BODY,336,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
353,5,BODY,337,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
354,5,BODY,"8.10.4Record Constructor Declarations To ensure proper initialization of its record components, a record class does not implicitly declare a default constructor (§8.8.9). Instead, a record class has a canonical constructor, declared explicitly or implicitly, that initializes all the component fields of the record class. There are two ways to explicitly declare a canonical constructor in a record declaration: by declaring a normal constructor with a suitable signature (§8.10.4.1) or by declaring a compact constructor (§8.10.4.2).",11,111.11,360,534,72,319.09,432,430.2,FALSE,FALSE
354,8,BODY,338,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
355,3,BODY,339,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
356,5,BODY,340,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
357,2,BODY,"8.10.4.2Compact Canonical Constructors A compact constructor declaration is a succinct form of constructor declaration, only available in a record declaration. It declares the canonical constructor of a record class without requiring the record components of the class to be manually repeated as formal parameters of the constructor.",11,65.2,360,333,72,76.13,432,141.33,FALSE,FALSE
357,6,BODY,341,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
358,2,BODY,must be definitely assigned and moreover not definitely unassigned at the end of the compact constructor (§8.3.1.2).,11,19.14,350.01,116,82,76.06,432.01,95.2,FALSE,FALSE
358,4,BODY,"After the last statement, if any, in the body of the compact constructor has completed normally (§14.1), all component fields of the record class are implicitly initialized to the values of the corresponding formal parameters. The component fields are initialized in the order that the corresponding record components are declared in the record header.",11,58.14,360.01,352,72,156.06,432.01,214.2,FALSE,FALSE
358,7,BODY,342,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
359,3,BODY,343,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
360,5,BODY,The TypeIdentifier in an interface declaration specifies the name of the interface. It is a compile-time error if an interface has the same simple name as any of its enclosing classes or interfaces. The scope and shadowing of an interface declaration is specified in §6.3 and §6.4.1.,11,57.14,360,283,72,421.06,432,478.2,FALSE,FALSE
360,6,BODY,9.1.1Interface Modifiers An interface declaration may include interface modifiers.,11,27.11,252.03,82,72,504.09,324.03,531.2,FALSE,FALSE
360,8,BODY,344,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
361,7,BODY,345,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
362,5,BODY,9.1.2Generic Interfaces and Type Parameters An interface is generic if the interface declaration declares one or more type variables (§4.4). These type variables are known as the type parameters of the interface. The type parameter section follows the interface name and is delimited by angle brackets.,11,72.11,360,302,72,320.22,432,392.33,FALSE,FALSE
362,8,BODY,346,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
363,7,BODY,347,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
364,5,BODY,348,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
365,7,BODY,349,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
366,5,BODY,"9.1.5Interface Body and Member Declarations An interface body may contain declarations of members of the interface, that is, fields (§9.3), methods (§9.4), classes, and interfaces (§9.5).",11,40.11,359.99,187,72,211.09,431.99,251.2,FALSE,FALSE
366,9,BODY,350,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
367,5,BODY,351,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
368,6,BODY,352,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
369,2,BODY,"There might be several paths by which the same field declaration is inherited from an interface. In such a situation, the field is considered to be inherited only once, and it may be referred to by its simple name without ambiguity.",11,32.14,360,232,72,76.06,432,108.2,FALSE,FALSE
369,9,BODY,"9.3.1Initialization of Fields in Interfaces Every declarator in a field declaration of an interface must have a variable initializer, or a compile-time error occurs.",11,40.11,360,165,72,563.09,432,603.2,FALSE,FALSE
369,10,BODY,353,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
370,8,BODY,354,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
371,4,BODY,355,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
372,5,BODY,356,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
373,7,BODY,357,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
374,6,BODY,358,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
375,5,BODY,359,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
376,8,BODY,360,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
377,2,BODY,"If a method is declared to have a return type (§8.4.5), then a compile-time error occurs if the body of the method can complete normally (§14.1).",11,19.14,360,145,72,76.06,432,95.2,FALSE,FALSE
377,4,BODY,361,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
378,4,BODY,"Unless explicitly modified in this section and its subsections, all of the rules that apply to normal interface declarations (§9.1) apply to annotation interface declarations.",11,32.14,360,175,72,228.06,432,260.2,FALSE,FALSE
378,8,BODY,"It is a compile-time error if an annotation interface declaration appears directly or indirectly in the body of a local class, local interface, or anonymous class declaration (§14.3, §15.9.5).",11,32.14,360,192,72,413.06,432,445.2,FALSE,FALSE
378,10,BODY,362,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
379,3,BODY,An annotation interface is never generic (§9.1.2).,11,6.14,216.58,50,72,256.06,288.58,262.2,FALSE,FALSE
379,9,BODY,363,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
380,2,BODY,"9.6.1Annotation Interface Elements The body of an annotation interface declaration may contain method declarations, each of which defines an element of the annotation interface. An annotation interface has no elements other than those defined by the methods declared explicitly in the annotation interface declaration.",11,66.11,360,318,72,76.09,432,142.2,FALSE,FALSE
380,8,BODY,"The return type of a method declared in the body of annotation interface must be one of the following, or a compile-time error occurs:",11,19.14,359.99,134,72,568.06,431.99,587.2,FALSE,FALSE
380,9,BODY,364,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
381,8,BODY,365,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
382,13,BODY,366,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
383,9,BODY,367,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
384,4,BODY,"It is a compile-time error if the type of the element is not commensurate (§9.7) with the default value specified. Default values are not compiled into annotations, but rather applied dynamically at the time annotations are read. Thus, changing a default value affects annotations even in classes that were compiled before the change was made (presuming these annotations lack an explicit value for the defaulted element).",11,77.14,360,422,72,228.06,432,305.2,FALSE,FALSE
384,9,BODY,368,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
385,7,BODY,369,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
386,11,BODY,An annotation interface can be the containing annotation interface of at most one annotation interface.,11,19.14,359.99,103,72,455.06,431.99,474.2,FALSE,FALSE
386,13,BODY,An annotation interface cannot specify itself as its containing annotation interface.,11,6.14,360.01,85,72,535.06,432.01,541.2,FALSE,FALSE
386,15,BODY,370,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
387,11,BODY,371,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
388,8,BODY,372,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
389,5,BODY,2.Package declarations (§7.4.1),11,6.14,148.13,31,72,481.2,220.13,487.33,FALSE,FALSE
389,8,BODY,373,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
390,2,BODY,"4.Method declarations (including elements of annotation interfaces) (§8.4.3,",11,6.14,360,76,72,76.06,432,82.2,FALSE,FALSE
390,4,BODY,5.Constructor declarations (§8.8.3),11,6.14,163.42,35,72,127.06,235.42,133.2,FALSE,FALSE
390,6,BODY,"6.Type parameter declarations of generic classes, interfaces, methods, and",11,6.14,360,74,72,165.06,432,171.2,FALSE,FALSE
390,8,BODY,"7.Field declarations (including enum constants) (§8.3.1, §9.3, §8.9.1)",11,6.14,314.36,70,72,216.06,386.36,222.2,FALSE,FALSE
390,11,BODY,"9.Local variable declarations in statements (§14.4.2, §14.14.1, §14.14.2,",11,6.14,360,73,72,292.06,432,298.2,FALSE,FALSE
390,13,BODY,10.Record component declarations (§8.10.1),11,6.14,200.38,42,72,343.06,272.38,349.2,FALSE,FALSE
390,16,BODY,374,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
391,5,BODY,375,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
392,10,BODY,376,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
393,8,BODY,377,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
394,5,BODY,378,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
395,5,BODY,379,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
396,7,BODY,380,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
397,7,BODY,381,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
398,2,BODY,"There are three kinds of annotations. The first kind is the most general, while the other kinds are merely shorthands for the first kind.",11,19.14,359.99,137,72,76.06,431.99,95.2,FALSE,FALSE
398,3,BODY,Annotation: NormalAnnotation MarkerAnnotation SingleElementAnnotation,11,45.05,122.44,69,90,113.13,212.44,158.18,FALSE,TRUE
398,4,BODY,"Normal annotations are described in §9.7.1, marker annotations in §9.7.2, and single element annotations in §9.7.3. Annotations may appear at various syntactic locations in a program, as described in §9.7.4. The number of annotations of the same interface that may appear at a location is determined by the interface declaration, as described in §9.7.5.",11,58.14,360,353,72,176.06,432,234.2,FALSE,FALSE
398,5,BODY,9.7.1Normal Annotations A normal annotation specifies the name of an annotation interface and optionally a list of comma-separated element-value pairs. Each pair contains an element value that is associated with an element of the annotation interface (§9.6.1).,11,53.11,360,260,72,260.09,432,313.2,FALSE,FALSE
398,7,BODY,382,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
399,5,BODY,383,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
400,3,BODY,"A normal annotation must contain an element-value pair for every element of the corresponding annotation interface, except for those elements with default values, or a compile-time error occurs. A normal annotation may, but is not required to, contain element-value pairs for elements with default values.",11,64.14,360,305,72,138.06,432,202.2,FALSE,FALSE
400,11,BODY,384,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
401,2,BODY,9.7.2Marker Annotations A marker annotation is a shorthand designed for use with marker annotation interfaces (§9.6.1).,11,40.11,360,119,72,76.09,432,116.2,FALSE,FALSE
401,4,BODY,It is shorthand for the normal annotation:,11,6.14,180.87,42,72,171.06,252.87,177.2,FALSE,FALSE
401,6,BODY,"It is legal to use marker annotations for annotation interfaces with elements, so long as all the elements have default values (§9.6.2).",11,19.14,360,136,72,213.06,432,232.2,FALSE,FALSE
401,16,BODY,385,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
402,12,BODY,"9.7.4Where Annotations May Appear A declaration annotation is an annotation that applies to a declaration, and whose annotation interface is applicable in the declaration context (§9.6.4.1) represented by that declaration; or an annotation that applies to a class, interface, or type parameter declaration, and whose annotation interface is applicable in type contexts (§4.11). A type annotation is an annotation that applies to a type (or any part of a type), and whose annotation interface is applicable in type contexts.",11,111.11,360,523,72,443.09,432,554.2,FALSE,FALSE
402,14,BODY,386,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
403,6,BODY,"It is possible for an annotation to appear at a syntactic location in a program where it could plausibly apply to a declaration, or a type, or both. This can happen in any of the six declaration contexts where modifiers immediately precede the type of the declared entity: •Method declarations (including elements of annotation interfaces) •Constructor declarations •Field declarations (including enum constants) •Formal and exception parameter declarations •Local variable declarations •Record component declarations The grammar of the Java programming language unambiguously treats annotations at these locations as modifiers for a declaration (§8.3), but that is purely a syntactic matter. Whether an annotation applies to the declaration or to the type of the declared entity - and thus, whether the annotation is a declaration annotation or a type annotation - depends on the applicability of the annotation's interface:",11,230.14,360.01,925,72,340.06,432.01,570.2,FALSE,FALSE
403,7,BODY,387,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
404,5,BODY,388,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
405,4,BODY,389,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
406,6,BODY,390,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
407,8,BODY,391,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
408,9,BODY,392,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
409,2,BODY,"In addition to the usual process of creating an interface instance by declaring and instantiating a class (§15.9), instances of functional interfaces can be created with method reference expressions and lambda expressions (§15.13, §15.27).",11,32.14,360,239,72,76.06,432,108.2,FALSE,FALSE
409,13,BODY,393,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
410,12,BODY,394,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
411,11,BODY,395,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
412,2,BODY,The declaration of a functional interface allows a functional interface type to be used in a program. There are four kinds of functional interface type: •The type of a non-generic (§6.1) functional interface •A parameterized type that is a parameterization (§4.5) of a generic functional interface •The raw type (§4.8) of a generic functional interface •An intersection type (§4.9) that induces a notional functional interface,11,108.14,360,426,72,76.06,432,184.2,FALSE,FALSE
412,9,BODY,396,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
413,7,BODY,397,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
414,15,BODY,398,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
415,13,BODY,399,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
416,8,BODY,400,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
417,3,BODY,401,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
418,6,BODY,402,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
419,5,BODY,"The array type of a variable depends on the bracket pairs that may appear as part of the type at the beginning of a variable declaration, or as part of the declarator for the variable, or both. Specifically, in the declaration of a field, formal parameter, local variable, or record component (§8.3, §8.4.1, §9.3, §9.4, §14.4.1, §14.14.2, §15.27.1, §8.10.1), the array type of the variable is denoted by: •the element type that appears at the beginning of the declaration; then, •any bracket pairs that follow the variable's Identifier in the declarator (not applicable for a variable arity parameter or a record component); then, •any bracket pairs that appear in the type at the beginning of the declaration (where the ellipsis of a variable arity parameter or variable arity record component is treated as a bracket pair). The return type of a method (§8.4.5) may be an array type. The precise array type depends on the bracket pairs that may appear as part of the type at the beginning of the method declaration, or after the method's formal parameter list, or both. The array type is denoted by: •the element type that appears in the Result; then, •any bracket pairs that follow the formal parameter list; then, •any bracket pairs that appear in the Result. We do not recommend 'mixed notation' in array variable declarations, where bracket pairs appear on both the type and in declarators; nor in method declarations, where bracket pairs appear both before and after the formal parameter list.",11,314.14,360.01,1499,72,242.06,432.01,556.2,FALSE,FALSE
419,8,BODY,403,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
420,17,BODY,404,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
421,2,BODY,(§5.2). This may result in a run-time exception on a later assignment; see §10.5 for a discussion.,11,19.14,360,98,72,76.06,432,95.2,FALSE,FALSE
421,10,BODY,405,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
422,8,BODY,406,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
423,9,BODY,407,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
424,8,BODY,408,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
425,9,BODY,409,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
426,12,BODY,410,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
427,13,BODY,411,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
429,3,BODY,413,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
430,5,BODY,414,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
431,5,BODY,415,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
432,4,BODY,The Java SE Platform permits a small but bounded amount of execution to occur before an asynchronous exception is thrown.,11,19.14,359.99,121,72,301.06,431.99,320.2,FALSE,FALSE
432,7,BODY,416,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
433,5,BODY,417,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
434,5,BODY,418,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
435,4,BODY,419,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
436,8,BODY,420,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
437,4,BODY,421,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
438,6,BODY,422,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
439,2,BODY,"All exceptions (synchronous and asynchronous) are precise: when the transfer of control takes place, all effects of the statements executed and expressions evaluated before the point from which the exception is thrown must appear to have taken place. No expressions, statements, or parts thereof that occur after the point from which the exception is thrown may appear to have been evaluated.",11,58.14,360.01,392,72,76.06,432.01,134.2,FALSE,FALSE
439,7,BODY,423,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
440,6,BODY,424,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
441,4,BODY,425,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
443,5,BODY,427,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
444,8,BODY,428,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
445,4,BODY,429,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
446,6,BODY,430,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
447,4,BODY,431,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
448,4,BODY,"12.3.1Verification of the Binary Representation Verification ensures that the binary representation of a class or interface is structurally correct. For example, it checks that every instruction has a valid operation code; that every branch instruction branches to the start of some other instruction, rather than into the middle of an instruction; that every method is",11,66.11,360,369,72,528.09,432,594.2,FALSE,FALSE
448,5,BODY,432,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
449,6,BODY,433,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
450,12,BODY,434,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
451,2,BODY,Initialization of an interface consists of executing the initializers for fields (constants) declared in the interface.,11,19.14,359.99,119,72,76.06,431.99,95.2,FALSE,FALSE
451,5,BODY,"The intent is that a class or interface has a set of initializers that put it in a consistent state, and that this state is the first state that is observed by other classes. The static initializers and class variable initializers are executed in textual order, and may not refer to class variables declared in the class whose declarations appear textually after the use, even though these class variables are in scope (§8.3.3). This restriction is designed to detect, at compile time, most circular or otherwise malformed initializations. The fact that initialization code is unrestricted allows examples to be constructed where the value of a class variable can be observed when it still has its initial default",11,116.14,360.01,713,72,475.06,432.01,591.2,FALSE,FALSE
451,6,BODY,435,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
452,2,BODY,"value, before its initializing expression is evaluated, but such examples are rare in practice. (Such examples can be also constructed for instance variable initialization (§12.5).) The full power of the Java programming language is available in these initializers; programmers must exercise some care. This power places an extra burden on code generators, but this burden would arise in any case because the Java programming language is concurrent (§12.4.2).",11,71.14,360.01,459,72,76.06,432.01,147.2,FALSE,FALSE
452,12,BODY,436,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
453,8,BODY,"12.4.2Detailed Initialization Procedure Because the Java programming language is multithreaded, initialization of a class or interface requires careful synchronization, since some other thread may be trying to initialize the same class or interface at the same time. There is also the possibility that initialization of a class or interface may be requested recursively as part of the initialization of that class or interface; for example, a variable initializer in class A",11,79.11,360.01,474,72,518.09,432.01,597.2,FALSE,FALSE
453,9,BODY,437,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
454,12,BODY,438,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
455,4,BODY,defining class loader.,11,6.14,93.79,22,90,250.06,183.79,256.2,FALSE,FALSE
455,5,BODY,"9.Next, execute either the class variable initializers and static initializers of the class, or the field initializers of the interface, in textual order, as though they were a single block.",11,32.14,359.99,190,72,269.06,431.99,301.2,FALSE,FALSE
455,9,BODY,439,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
456,4,BODY,440,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
457,2,BODY,"Otherwise, all the instance variables in the new object, including those declared in superclasses, are initialized to their default values (§4.12.5). Just before a reference to the newly created object is returned as the result, the indicated constructor is processed to initialize the new object using the following procedure: 1.Assign the arguments for the constructor to newly created parameter variables",11,83.14,360.01,407,72,76.06,432.01,159.2,FALSE,FALSE
457,3,BODY,for this constructor invocation.,11,6.14,135.65,32,90,166.06,225.65,172.2,FALSE,FALSE
457,6,BODY,"4.Execute the instance initializers and instance variable initializers for this class, assigning the values of instance variable initializers to the corresponding instance variables, in the left-to-right order in which they appear textually in the source code for the class. If execution of any of these initializers results in an exception, then no further initializers are processed and this procedure completes abruptly with that same exception. Otherwise, continue with step 5. 5.Execute the rest of the body of this constructor. If that execution completes abruptly, then this procedure completes abruptly for the same reason. Otherwise, this procedure completes normally.",11,116.14,360,677,72,366.06,432,482.2,FALSE,FALSE
457,7,BODY,"Unlike C++, the Java programming language does not specify altered rules for method dispatch during the creation of a new class instance. If methods are invoked that are overridden in subclasses in the object being initialized, then these overriding methods are used, even before the new object is completely initialized.",11,45.14,360.01,321,72,495.06,432.01,540.2,FALSE,FALSE
457,10,BODY,441,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
458,12,BODY,442,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
459,9,BODY,443,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
460,8,BODY,444,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
461,4,BODY,445,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
462,4,BODY,"12.6.2Interaction with the Memory Model It must be possible for the memory model (§17.4) to decide when it can commit actions that take place in a finalizer. This section describes the interaction of finalization with the memory model. Each execution has a number of reachability decision points, labeled di. Each action either comes-before di or comes-after di. Other than as explicitly mentioned, the comes-before ordering described in this section is unrelated to all other orderings in the memory model. If r is a read that sees a write w and r comes-before di, then w must come-before di. If x and y are synchronization actions on the same variable or monitor such that so(x, y) (§17.4.4) and y comes-before di, then x must come-before di. At each reachability decision point, some set of objects are marked as unreachable, and some subset of those objects are marked as finalizable. These reachability decision points are also the points at which references are checked, enqueued, and",11,207.11,360.01,990,72,395.09,432.01,602.2,FALSE,FALSE
462,5,BODY,446,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
463,3,BODY,447,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
464,3,BODY,448,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
465,7,BODY,situation.),11,6.14,44.31,11,90,358.06,134.31,364.2,FALSE,FALSE
465,8,BODY,"4.The Java Virtual Machine implementation recognized an external event as requesting termination of the Java Virtual Machine, and all of the shutdown hooks which consequently were started by the Java Virtual Machine, if any, have terminated. The nature of the event is outside the scope of this specification, but is necessarily something that a Java Virtual Machine implementation can handle reliably. An example is receiving a signal from the operating system.",11,90.14,360,462,72,377.06,432,467.2,FALSE,FALSE
465,9,BODY,5.An external event occurred that the Java Virtual Machine implementation,11,6.14,360,73,72,480.06,432,486.2,FALSE,FALSE
465,10,BODY,"cannot handle. (No shutdown hooks are started in this situation.) The nature of the event is outside the scope of this specification, but is necessarily something that a Java Virtual Machine implementation cannot recognize or recover from in any way. Examples include a fatal error occurring in the process running the implementation, or power being removed from the computer running the implementation.",11,77.14,342.01,403,90,493.06,432.01,570.2,FALSE,FALSE
465,11,BODY,"Upon program exit, any daemon or non-daemon thread that has not yet terminated will execute no further Java code. The current method of the thread does not",11,19.14,360.01,155,72,583.06,432.01,602.2,FALSE,FALSE
465,12,BODY,449,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
466,4,BODY,450,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
467,3,BODY,451,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
468,2,BODY,"•When an entire package is updated, deleting package access fields, methods, or constructors of classes and interfaces in the package. •Reordering the fields, methods, or constructors in an existing class or interface declaration. •Moving a method upward in the class hierarchy. •Reordering the list of direct superinterfaces of a class or interface. •Inserting new class or interface types in the type hierarchy. This chapter specifies minimum standards for binary compatibility guaranteed by all implementations. The Java programming language guarantees compatibility when binaries of classes and interfaces are mixed that are not known to be from compatible sources, but whose sources have been modified in the compatible ways described here. Note that we are discussing compatibility between releases of an application. A discussion of compatibility among releases of the Java SE Platform is beyond the scope of this chapter. We encourage development systems to provide facilities that alert developers to the impact of changes on pre-existing binaries that cannot be recompiled. This chapter first specifies some properties that any binary format for the Java programming language must have (§13.1). It next defines binary compatibility, explaining what it is and what it is not (§13.2). It finally enumerates a large set of possible changes to packages (§13.3), classes (§13.4), and interfaces (§13.5), specifying which of these changes are guaranteed to preserve binary compatibility and which are not.",11,321.14,360.01,1509,72,76.06,432.01,397.2,FALSE,FALSE
468,5,BODY,452,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
469,2,BODY,"1.The class or interface must be named by its binary name, which must meet the",11,6.14,360,78,72,76.06,432,82.2,FALSE,FALSE
469,4,BODY,"2.A reference to another class or interface must be symbolic, using the binary",11,6.14,360,78,72,449.06,432,455.2,FALSE,FALSE
469,5,BODY,name of the class or interface.,11,6.14,131.96,31,90,462.06,221.96,468.2,FALSE,FALSE
469,6,BODY,3.A reference to a field that is a constant variable (§4.12.4) must be resolved at,11,6.14,360,82,72,481.06,432,487.2,FALSE,FALSE
469,8,BODY,453,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
470,6,BODY,454,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
471,3,BODY,"A reference to a method must be resolved at compile time to a symbolic reference to the qualifying class or interface of the method invocation, plus",11,19.14,341.99,148,90,487.06,431.99,506.2,FALSE,FALSE
471,4,BODY,455,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
472,5,BODY,superclass of this class.,11,6.14,102.65,25,90,589.06,192.65,595.2,FALSE,FALSE
472,6,BODY,456,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
473,2,BODY,"2.A symbolic reference to each direct superinterface, if any. 3.A specification of each field declared in the class or interface, given as the simple name of the field and a symbolic reference to the erasure of the type of the field.",11,51.14,360,233,72,76.06,432,127.2,FALSE,FALSE
473,3,BODY,"4.If it is a class, then the erased signature of each constructor, as described above. 5.For each method declared in the class or interface (excluding, for an interface, its implicitly declared methods (§9.2)), its erased signature and return type, as described above.",11,51.14,360,268,72,140.06,432,191.2,FALSE,FALSE
473,4,BODY,6.The code needed to implement the class or interface:,11,6.14,250.17,54,72,204.06,322.17,210.2,FALSE,FALSE
473,5,BODY,"•For an interface, code for the field initializers and the implementation of each method with a block body (§9.4.3). •For a class, code for the field initializers, the instance and static initializers, the implementation of each method with a block body (§8.4.7), and the implementation of each constructor.",11,64.14,342,307,90,223.06,432,287.2,FALSE,FALSE
473,6,BODY,7.Every class or interface must contain sufficient information to recover its,11,6.14,359.99,77,72,300.06,431.99,306.2,FALSE,FALSE
473,7,BODY,canonical name (§6.7).,11,6.14,100.8,22,90,313.06,190.8,319.2,FALSE,FALSE
473,8,BODY,8.Every member class or interface must have sufficient information to recover,11,6.14,360,77,72,332.06,432,338.2,FALSE,FALSE
473,9,BODY,its source-level access modifier (§6.6).,11,6.14,170.46,40,90,345.06,260.46,351.2,FALSE,FALSE
473,10,BODY,9.Every nested class or interface must have a symbolic reference to its,11,6.14,359.99,71,72,364.06,431.99,370.2,FALSE,FALSE
473,11,BODY,immediately enclosing class or interface (§8.1.3).,11,6.14,217.51,50,90,377.06,307.51,383.2,FALSE,FALSE
473,12,BODY,"10.Every class or interface must contain symbolic references to all of its member classes and interfaces (§8.5, §9.5), and to all other nested classes and interfaces declared within its body.",11,32.14,360,191,72,396.06,432,428.2,FALSE,FALSE
473,13,BODY,"11.A construct emitted by a Java compiler must be marked as synthetic if it does not correspond to a construct declared explicitly or implicitly in source code, unless the emitted construct is a class initialization method (JVMS §2.9).",11,32.14,360,235,72,441.06,432,473.2,FALSE,FALSE
473,15,BODY,457,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
474,4,BODY,458,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
475,5,BODY,"Binary compatibility is not the same as source compatibility. In particular, the example in §13.4.6 shows that a set of compatible binaries can be produced from sources that will not compile all together. This example is typical: a new declaration is added, changing the meaning of a name in an unchanged part of the source code, while the pre-existing binary for that unchanged part of the source code retains the fully-qualified, previous meaning of the name. Producing a consistent set of source code requires providing a qualified name or field access expression corresponding to the previous meaning.",11,97.14,360.01,605,72,501.06,432.01,598.2,FALSE,FALSE
475,6,BODY,459,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
476,3,BODY,460,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
477,7,BODY,461,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
478,9,BODY,462,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
479,5,BODY,"If a change to the direct superclass or the set of direct superinterfaces results in any class or interface no longer being a superclass or superinterface, respectively, then linkage errors may result if pre-existing binaries are loaded with the binary of the modified class. Such changes are not recommended for widely distributed classes.",11,45.14,360.01,340,72,309.06,432.01,354.2,FALSE,FALSE
479,13,BODY,463,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
480,9,BODY,"13.4.5Class Type Parameters Adding or deleting a type parameter of a class does not, in itself, have any implications for binary compatibility. If such a type parameter is used in the type of a field or method, that may have the normal implications of changing the aforementioned type. Renaming a type parameter of a class has no effect with respect to pre-existing binaries.",11,104.11,360.01,375,72,476.09,432.01,580.2,FALSE,FALSE
480,10,BODY,464,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
481,2,BODY,"Changing the first bound of a type parameter of a class may change the erasure (§4.6) of any member that uses that type parameter in its own type, and this may affect binary compatibility. The change of such a bound is analogous to the change of the first bound of a type parameter of a method or constructor (§13.4.13). Changing any other bound has no effect on binary compatibility.",11,64.14,360.01,384,72,76.06,432.01,140.2,FALSE,FALSE
481,13,BODY,465,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
482,13,BODY,466,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
483,12,BODY,467,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
484,11,BODY,468,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
485,12,BODY,469,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
486,12,BODY,470,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
487,9,BODY,"13.4.12Method and Constructor Declarations Adding a method or constructor to a class will not break compatibility with any pre-existing binaries, even in the case where a class could no longer be recompiled because an invocation previously referenced a method or constructor of a superclass with an incompatible type. The previously compiled class with such a reference will continue to reference the method or constructor declared in a superclass.",11,92.11,360,448,72,492.09,432,584.2,FALSE,FALSE
487,10,BODY,471,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
488,3,BODY,"13.4.13Method and Constructor Type Parameters Adding or deleting a type parameter of a method or constructor does not, in itself, have any implications for binary compatibility. If such a type parameter is used in the type of the method or constructor, that may have the normal implications of changing the aforementioned type. Renaming a type parameter of a method or constructor has no effect with respect to pre-existing binaries. Changing the first bound of a type parameter of a method or constructor may change the erasure (§4.6) of any member that uses that type parameter in its own type, and this may affect binary compatibility. Specifically:",11,149.11,360.01,652,72,411.09,432.01,560.2,FALSE,FALSE
488,4,BODY,472,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
489,2,BODY,"•If the type parameter is used as the type of a field, the effect is as if the field were deleted and a field with the same name, whose type is the new erasure of the type variable, were added. •If the type parameter is used as the type of any formal parameter of a method, but not as the return type, the effect is as if that method were deleted, and replaced with a new method that is identical except for the types of the aforementioned formal parameters, which now have the new erasure of the type parameter as their type. •If the type parameter is used as a return type of a method, but not as the type of any formal parameter of the method, the effect is as if that method were deleted, and replaced with a new method that is identical except for the return type, which is now the new erasure of the type parameter. •If the type parameter is used as a return type of a method and as the type of one or more formal parameters of the method, the effect is as if that method were deleted, and replaced with a new method that is identical except for the return type, which is now the new erasure of the type parameter, and except for the types of the aforementioned formal parameters, which now have the new erasure of the type parameter as their types. Changing any other bound has no effect on binary compatibility.",11,264.14,360.01,1319,72,76.06,432.01,340.2,FALSE,FALSE
489,4,BODY,473,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
490,11,BODY,474,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
491,12,BODY,475,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
492,6,BODY,"13.4.23Method and Constructor Overloading Adding new methods or constructors that overload existing methods or constructors does not break compatibility with pre-existing binaries. The signature to be used for each invocation was determined when these existing binaries were compiled; therefore newly added methods or constructors will not be used, even if their signatures are both applicable and more specific than the signature originally chosen.",11,92.11,360,449,72,495.09,432,587.2,FALSE,FALSE
492,7,BODY,476,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
493,2,BODY,"While adding a new overloaded method or constructor may cause a compile-time error the next time a class or interface is compiled because there is no method or constructor that is most specific (§15.12.2.5), no such error occurs when a program is executed, because no overload resolution is done at execution time.",11,45.14,360,314,72,76.06,432,121.2,FALSE,FALSE
493,14,BODY,"13.4.24Method Overriding If an instance method is added to a subclass and it overrides a method in a superclass, then the subclass method will be found by method invocations in pre- existing binaries, and these binaries are not impacted. If a class method is added to a class, then this method will not be found unless the qualifying class of the method invocation is the subclass.",11,85.11,360.02,381,72,518.09,432.02,603.2,FALSE,FALSE
493,15,BODY,477,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
494,2,BODY,"13.4.25Static Initializers Adding, deleting, or changing a static initializer (§8.7) of a class does not impact pre-existing binaries.",11,40.11,360,134,72,76.09,432,116.2,FALSE,FALSE
494,3,BODY,13.4.26Evolution of Enum Classes Adding or reordering enum constants in an enum class will not break compatibility with pre-existing binaries.,11,40.11,360.01,142,72,142.09,432.01,182.2,FALSE,FALSE
494,6,BODY,"13.4.27Evolution of Record Classes Adding, deleting, changing, or reordering record components in a record class may break compatibility with pre-existing binaries that are not recompiled; such a change is not recommended for widely distributed record classes. More precisely, adding, deleting, changing, or reordering record components may change the corresponding implicit declarations of component fields and accessor methods, as well as changing the signature and implementation of the canonical constructor and other supporting methods, with consequences specified in §13.4.8 and §13.4.12. In all other respects, the binary compatibility rules for record classes are identical to those for normal classes.",11,156.11,360.01,710,72,343.09,432.01,499.2,FALSE,FALSE
494,8,BODY,478,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
495,9,BODY,479,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
496,11,BODY,13.5.5Interface Type Parameters The effects of changes to the type parameters of an interface are the same as those of analogous changes to the type parameters of a class.,11,40.11,360,171,72,563.09,432,603.2,FALSE,FALSE
496,12,BODY,480,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
497,8,BODY,481,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
498,5,BODY,"13.5.8Annotation Interfaces Annotation interfaces behave exactly like any other interface. Adding or deleting an element from an annotation interface is analogous to adding or deleting a method. There are important considerations governing other changes to annotation interfaces, such as making an annotation interface repeatable (§9.6.3), but these have no effect on the linkage of binaries by the Java Virtual Machine. Rather, such changes affect the behavior of reflective APIs in the Java SE Platform that reveal the presence of annotations in a program. The API specifications describe their behavior when various changes are made to the underlying annotation interfaces (§1.4). Adding or deleting annotations has no effect on the correct linkage of the binary representations of programs in the Java programming language.",11,163.11,360,827,72,209.09,432,372.2,FALSE,FALSE
498,6,BODY,482,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
499,3,BODY,483,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
500,1,BODY,"be composed from one or more other values, denoted by variable declarations. Pattern matching attempts to extract one or more values from a given value, as if to decompose it, and uses the extracted values to initialize the variables declared by the pattern.",11,45.14,360,258,72,76.06,432,121.2,FALSE,FALSE
500,3,BODY,484,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
501,5,BODY,"A block is executed by executing each of the local variable declaration statements and other statements in order from first to last (left to right). If all of these block statements complete normally, then the block completes normally. If any of these block statements complete abruptly for any reason, then the block completes abruptly for the same reason.",11,58.14,360,357,72,516.06,432,574.2,FALSE,FALSE
501,6,BODY,485,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
502,6,BODY,486,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
503,6,BODY,487,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
504,6,BODY,488,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
505,6,BODY,"14.4.1Local Variable Declarators and Types Each declarator in a local variable declaration declares one local variable. If the declarator includes an Identifier then this is the name of the local variable, otherwise the local variable is unnamed (§6.1).",11,53.11,360,253,72,550.09,432,603.2,FALSE,FALSE
505,7,BODY,489,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
506,3,BODY,"The scope and shadowing of a local variable declaration is specified in §6.3 and §6.4. References to a local variable from a nested class or interface, or a lambda expression, are restricted, as specified in §6.5.6.1.",11,51.14,360,217,72,326.06,432,377.2,FALSE,FALSE
506,8,BODY,490,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
507,3,BODY,14.4.2Local Variable Declaration Statements A local variable declaration statement consists of a local variable declaration.,11,27.11,344.31,124,72,135.09,416.31,162.2,FALSE,FALSE
507,5,BODY,"Every local variable declaration statement is immediately contained by a block, whereas other kinds of statement (§14.5) may be immediately contained by either a block or another statement. In the containing block, local variable declaration statements may be intermixed freely with other kinds of statements and with local class and interface declarations. A local variable declaration statement is an executable statement. Every time it is executed, the declarators are processed in order from left to right. If a declarator has an initializer, the initializer is evaluated and its value is assigned to the variable.",11,109.14,360.01,618,72,217.06,432.01,326.2,FALSE,FALSE
507,7,BODY,"Each initializer (except the first) is evaluated only if evaluation of the preceding initializer completes normally. Execution of the local variable declaration statement completes normally only if evaluation of the last initializer completes normally. If none of the declarators in a local variable declaration statement have an initializer, then executing the statement always completes normally.",11,83.14,360,398,72,387.06,432,470.2,FALSE,FALSE
507,9,BODY,491,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
508,4,BODY,Statement: StatementWithoutTrailingSubstatement LabeledStatement IfThenStatement IfThenElseStatement WhileStatement ForStatement StatementNoShortIf: StatementWithoutTrailingSubstatement LabeledStatementNoShortIf IfThenElseStatementNoShortIf WhileStatementNoShortIf ForStatementNoShortIf StatementWithoutTrailingSubstatement: Block EmptyStatement ExpressionStatement AssertStatement SwitchStatement DoStatement BreakStatement ContinueStatement ReturnStatement SynchronizedStatement ThrowStatement TryStatement YieldStatement,11,366.05,182.95,523,90,234.13,272.95,600.18,FALSE,TRUE
508,5,BODY,492,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
509,7,BODY,Execution of an empty statement always completes normally.,11,6.14,270.69,58,72,448.06,342.69,454.2,FALSE,FALSE
509,10,BODY,493,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
510,6,BODY,494,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
511,6,BODY,"An expression statement is executed by evaluating the expression; if the expression has a value, the value is discarded. Execution of the expression statement completes normally if and only if evaluation of the expression completes normally.",11,51.14,360.01,241,72,367.06,432.01,418.2,FALSE,FALSE
511,10,BODY,495,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
512,7,BODY,496,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
513,6,BODY,497,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
514,5,BODY,498,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
515,4,BODY,499,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
516,8,BODY,500,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
517,4,BODY,501,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
518,7,BODY,502,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
519,5,BODY,503,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
520,7,BODY,504,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
521,8,BODY,505,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
522,8,BODY,506,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
523,5,BODY,507,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
524,5,BODY,508,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
525,5,BODY,509,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
526,5,BODY,510,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
527,6,BODY,511,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
528,3,BODY,512,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
529,6,BODY,513,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
530,6,BODY,514,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
531,7,BODY,515,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
532,7,BODY,516,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
533,8,BODY,517,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
534,8,BODY,518,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
535,7,BODY,519,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
536,8,BODY,520,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
537,3,BODY,"•If execution of the Statement completes abruptly, see §14.13.1.",11,6.14,287.4,64,72,236.06,359.4,242.2,FALSE,FALSE
537,6,BODY,521,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
538,11,BODY,522,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
539,2,BODY,ForStatement: BasicForStatement EnhancedForStatement ForStatementNoShortIf: BasicForStatementNoShortIf EnhancedForStatementNoShortIf,11,82.05,157.27,132,90,76.13,247.27,158.18,FALSE,TRUE
539,5,BODY,523,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
540,5,BODY,524,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
541,5,BODY,"sequence from left to right; their values, if any, are discarded. If the ForUpdate part is not present, no action is taken.",11,25.14,270.96,123,100,309.2,370.96,334.33,FALSE,FALSE
541,10,BODY,525,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
542,8,BODY,526,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
543,3,BODY,527,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
544,4,BODY,528,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
545,8,BODY,529,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
546,8,BODY,530,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
547,7,BODY,531,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
548,8,BODY,532,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
549,7,BODY,533,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
550,7,BODY,534,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
551,6,BODY,535,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
552,5,BODY,536,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
553,7,BODY,537,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
554,10,BODY,538,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
555,6,BODY,539,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
556,4,BODY,540,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
557,7,BODY,541,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
558,7,BODY,542,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
559,7,BODY,543,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
560,7,BODY,544,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
561,7,BODY,545,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
562,5,BODY,546,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
563,5,BODY,547,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
564,4,BODY,then the resource is first converted to a local variable declaration by the following translation:,11,19.14,360,98,72,220.2,432,239.33,FALSE,FALSE
564,9,BODY,548,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
565,4,BODY,549,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
566,4,BODY,550,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
567,8,BODY,551,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
568,9,BODY,552,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
569,9,BODY,553,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
570,4,BODY,554,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
571,6,BODY,555,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
572,3,BODY,556,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
573,7,BODY,557,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
574,10,BODY,558,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
575,14,BODY,559,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
576,2,BODY,"The process of testing a value against a pattern is known as pattern matching. If a value successfully matches a pattern, then the process of pattern matching initializes the pattern variables, if any, declared by the pattern. Pattern variables are only in scope (§6.3) where pattern matching succeeds and thus the pattern variables will have been initialized. It is not possible to use a pattern variable that has not been initialized.",11,77.14,360,436,72,76.06,432,153.2,FALSE,FALSE
576,3,BODY,"14.30.1Kinds of Patterns A type pattern is used to test whether a value is an instance of the type appearing in the pattern. A record pattern is used to test whether a value is an instance of a record class type and, if it is, to recursively perform pattern matching on the record component values.",11,66.11,360,298,72,179.09,432,245.2,FALSE,FALSE
576,7,BODY,560,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
577,5,BODY,561,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
578,7,BODY,"A record pattern consists of a ReferenceType and a component pattern list containing component patterns, if any. If ReferenceType is not a record class type (§8.10) then a compile-time error occurs. If the ReferenceType is a raw type, then the type of the record pattern is inferred, as described in §18.5.5. It is a compile-time error if no type can be inferred for the record pattern. If the ReferenceType (or any part of it) is annotated then a compile-time error occurs.",11,109.14,360.01,474,72,325.06,432.01,434.2,FALSE,FALSE
578,9,BODY,"Otherwise, the type of the record pattern is ReferenceType. The length of the record pattern's component pattern list must be the same as the length of the record component list in the declaration of the record class named by ReferenceType otherwise a compile-time error occurs. A record pattern does not directly declare any pattern variables itself, but may contain declarations of pattern variables in the component pattern list. It is a compile-time error if a record pattern contains more than one declaration of a pattern variable with the same name.",11,115.14,360.01,556,72,475.06,432.01,590.2,FALSE,FALSE
578,10,BODY,562,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
579,5,BODY,563,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
580,4,BODY,•Every value matches a match-all pattern.,11,6.14,189.62,41,72,288.06,261.62,294.2,FALSE,FALSE
580,6,BODY,564,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
581,5,BODY,565,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
583,4,BODY,567,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
584,4,BODY,Expression: LambdaExpression AssignmentExpression,11,32.05,109.61,49,90,486.13,199.61,518.18,FALSE,TRUE
584,5,BODY,"When some expressions appear in certain contexts, they are considered poly expressions. The following forms of expressions may be poly expressions: •Parenthesized expressions (§15.8.5) •Class instance creation expressions (§15.9)",11,57.14,360,229,72,536.06,432,593.2,FALSE,FALSE
584,6,BODY,568,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
585,4,BODY,569,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
586,5,BODY,570,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
587,6,BODY,"The Java programming language requires support of IEEE 754 subnormal floating- point numbers and gradual underflow, which make it easier to prove desirable properties of particular numerical algorithms. Floating-point operations do not 'flush to zero' if the calculated result is a subnormal number. The result of a floating-point operator of the Java programming language must match the result of the corresponding IEEE 754 operation on the same operands. For finite results, this implies the sign, significand, and exponent of the floating- point result must all be those specified by IEEE 754.",11,103.14,360,596,72,433.06,432,536.2,FALSE,FALSE
587,8,BODY,571,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
588,5,BODY,572,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
589,2,BODY,"•The round toward zero rounding policy applies to (i) conversion of a floating- point value to an integer value (§5.1.3), and (ii) floating-point remainder (§15.17.3). Under the round toward zero rounding policy, inexact results are rounded to the nearest representable value that is not greater in magnitude than the infinitely precise result. For conversion to integer, the round toward zero rounding policy is equivalent to truncation where fractional significand bits are discarded. The round toward zero rounding policy corresponds to the roundTowardZero rounding-direction attribute for binary arithmetic in IEEE 754.",11,116.14,360,623,72,76.06,432,192.2,FALSE,FALSE
589,4,BODY,"The Java programming language requires that every floating-point operator rounds its floating-point result to the result precision. The rounding policy used for each floating-point operator is either round to nearest or round toward zero, as specified above.",11,45.14,360.01,258,72,247.06,432.01,292.2,FALSE,FALSE
589,6,BODY,573,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
590,4,BODY,574,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
591,4,BODY,575,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
592,3,BODY,576,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
593,2,BODY,"A method invocation expression can also result in an exception being thrown if an exception occurs that causes execution of the method body to complete abruptly. A class instance creation expression can also result in an exception being thrown if an exception occurs that causes execution of the constructor to complete abruptly. Various linkage and virtual machine errors may also occur during the evaluation of an expression. By their nature, such errors are difficult to predict and difficult to handle. If an exception occurs, then evaluation of one or more expressions may be terminated before all steps of their normal mode of evaluation are complete; such expressions are said to complete abruptly. If evaluation of an expression requires evaluation of a subexpression, then abrupt completion of the subexpression always causes the immediate abrupt completion of the expression itself, with the same reason, and all succeeding steps in the normal mode of evaluation are not performed. The terms 'complete normally' and 'complete abruptly' are also applied to the execution of statements (§14.1). A statement may complete abruptly for a variety of reasons, not just because an exception is thrown.",11,244.14,360.01,1203,72,76.06,432.01,320.2,FALSE,FALSE
593,5,BODY,"15.7.1Evaluate Left-Hand Operand First The left-hand operand of a binary operator appears to be fully evaluated before any part of the right-hand operand is evaluated. If the operator is a compound-assignment operator (§15.26.2), then evaluation of the left-hand operand includes both remembering the variable that the left-hand operand denotes and fetching and saving that variable's value for use in the implied binary operation.",11,98.11,360.01,431,72,484.09,432.01,582.2,FALSE,FALSE
593,6,BODY,577,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
594,2,BODY,"If evaluation of the left-hand operand of a binary operator completes abruptly, no part of the right-hand operand appears to have been evaluated.",11,19.14,360,145,72,76.06,432,95.2,FALSE,FALSE
594,15,BODY,578,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
595,9,BODY,579,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
596,8,BODY,15.7.3Evaluation Respects Parentheses and Precedence The Java programming language respects the order of evaluation indicated explicitly by parentheses and implicitly by operator precedence.,11,40.11,359.99,190,72,245.09,431.99,285.2,FALSE,FALSE
596,10,BODY,"In the case of floating-point calculations, this rule applies also for infinity and not- a-number (NaN) values.",11,19.14,360.01,111,72,376.06,432.01,395.2,FALSE,FALSE
596,12,BODY,"Specifically, floating-point calculations that appear to be mathematically associative are unlikely to be computationally associative. Such computations must not be naively reordered.",11,32.14,360.01,183,72,446.06,432.01,478.2,FALSE,FALSE
596,14,BODY,580,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
597,5,BODY,"In contrast, integer addition and multiplication are provably associative in the Java programming language.",11,19.14,360,107,72,204.06,432,223.2,FALSE,FALSE
597,7,BODY,"15.7.4Argument Lists are Evaluated Left-to-Right In a method or constructor invocation or class instance creation expression, argument expressions may appear within the parentheses, separated by commas. Each argument expression appears to be fully evaluated before any part of any argument expression to its right. If evaluation of an argument expression completes abruptly, no part of any argument expression to its right appears to have been evaluated.",11,98.11,360,454,72,301.09,432,399.2,FALSE,FALSE
597,13,BODY,581,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
598,7,BODY,"15.7.5Evaluation Order for Other Expressions The order of evaluation for some expressions is not completely covered by these general rules, because these expressions may raise exceptional conditions at times that must be specified. See the detailed explanations of evaluation order for the following kinds of expressions: •class instance creation expressions (§15.9.4) •array creation expressions (§15.10.2) •array access expressions (§15.10.4) •method invocation expressions (§15.12.4) •method reference expressions (§15.13.3) •assignments involving array components (§15.26) •lambda expressions (§15.27.4)",11,199.11,360.01,607,72,342.09,432.01,541.2,FALSE,FALSE
598,8,BODY,582,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
599,4,BODY,583,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
600,3,BODY,"15.8.1Lexical Literals A literal (§3.10) denotes a fixed, unchanging value.",11,27.11,226.68,75,72,157.09,298.68,184.2,FALSE,FALSE
600,8,BODY,584,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
601,7,BODY,585,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
602,7,BODY,586,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
603,8,BODY,587,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
604,10,BODY,588,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
605,2,BODY,"•Unqualified class instance creation expressions begin with the keyword new. An unqualified class instance creation expression may be used to create an instance of a class, regardless of whether the class is a top level (§7.6), member (§8.5, §9.5), local (§14.3), or anonymous class (§15.9.5). •Qualified class instance creation expressions begin with a Primary expression or an ExpressionName. A qualified class instance creation expression enables the creation of instances of inner member classes and their anonymous subclasses. Both unqualified and qualified class instance creation expressions may optionally end with a class body. Such a class instance creation expression declares an anonymous class (§15.9.5) and creates an instance of it. A class instance creation expression is a poly expression (§15.2) if it uses the diamond form for type arguments to the class, and it appears in an assignment context or an invocation context (§5.2, §5.3). Otherwise, it is a standalone expression. We say that a class is instantiated when an instance of the class is created by a class instance creation expression. Class instantiation involves determining the class to be instantiated (§15.9.1), the enclosing instances (if any) of the newly created instance (§15.9.2), and the constructor to be invoked to create the new instance (§15.9.3).",11,289.14,360.01,1340,72,76.06,432.01,365.2,FALSE,FALSE
605,4,BODY,589,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
606,3,BODY,590,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
607,4,BODY,591,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
608,5,BODY,592,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
609,4,BODY,593,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
610,3,BODY,594,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
611,3,BODY,595,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
612,4,BODY,596,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
613,5,BODY,597,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
614,4,BODY,598,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
615,9,BODY,599,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
616,7,BODY,600,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
617,3,BODY,601,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
618,3,BODY,15.10.1Array Creation Expressions An array creation expression is used to create new arrays (§10 (Arrays)).,11,27.11,320.12,107,72,110.09,392.12,137.2,FALSE,FALSE
618,8,BODY,"The type of each dimension expression within a DimExpr must be a type that is convertible (§5.1.8) to an integral type, or a compile-time error occurs.",11,19.14,360,151,72,556.06,432,575.2,FALSE,FALSE
618,9,BODY,602,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
619,6,BODY,603,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
620,15,BODY,604,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
621,13,BODY,605,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
622,7,BODY,15.10.3Array Access Expressions An array access expression refers to a variable that is a component of an array.,11,27.11,346.08,112,72,384.09,418.08,411.2,FALSE,FALSE
622,9,BODY,"An array access expression contains two subexpressions, the array reference expression (before the left bracket) and the index expression (within the brackets).",11,19.14,360,160,72,492.06,432,511.2,FALSE,FALSE
622,12,BODY,606,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
623,7,BODY,607,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
624,14,BODY,608,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
625,12,BODY,609,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
626,2,BODY,"The meaning of a field access expression is determined using the same rules as for qualified names (§6.5.6.2), but limited by the fact that an expression cannot denote a package, class type, or interface type. It is also possible to refer to a field of the current instance or current class by using a simple name (§6.5.6.1).",11,64.14,360.01,325,72,76.06,432.01,140.2,FALSE,FALSE
626,4,BODY,610,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
627,3,BODY,"Note that only the type of the Primary expression, not the class of the actual object referred to at run time, is used in determining which field to use.",11,19.14,360.01,153,72,262.06,432.01,281.2,FALSE,FALSE
627,9,BODY,611,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
628,11,BODY,612,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
629,7,BODY,613,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
630,10,BODY,614,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
631,3,BODY,"Resolving a method name at compile time is more complicated than resolving a field name because of the possibility of method overloading. Invoking a method at run time is also more complicated than accessing a field because of the possibility of instance method overriding. Determining the method that will be invoked by a method invocation expression involves several steps. The following three sections describe the compile-time processing of a method invocation. The determination of the type of the method invocation expression is specified in §15.12.3. The exception types that a method invocation expression can throw are specified in §11.2.1. It is a compile-time error if the name to the left of the rightmost '.' that occurs before the ( in a MethodInvocation cannot be classified as a TypeName or an ExpressionName (§6.5.2). If TypeArguments is present to the left of Identifier, then it is a compile-time error if any of the type arguments are wildcards (§4.5.1). A method invocation expression is a poly expression if all of the following are true: •The invocation appears in an assignment context or an invocation context (§5.2, §5.3). •If the invocation is qualified (that is, any form of MethodInvocation except for the first), then the invocation elides TypeArguments to the left of the Identifier. •The method to be invoked, as determined by the following subsections, is generic (§8.4.4) and has a return type that mentions at least one of the method's type parameters. Otherwise, the method invocation expression is a standalone expression.",11,359.14,360.01,1559,72,215.06,432.01,574.2,FALSE,FALSE
631,4,BODY,615,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
632,4,BODY,"–Otherwise, the method declaration may be in scope due to one or more single- static-import or static-import-on-demand declarations. There is no type to search, as the method to be invoked is determined later (§15.12.2.1).",11,32.14,350,222,82,344.06,432,376.2,FALSE,FALSE
632,6,BODY,616,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
633,5,BODY,617,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
634,5,BODY,"15.12.2Compile-Time Step 2: Determine Method Signature The second step searches the type determined in the previous step for member methods. This step uses the name of the method and the argument expressions to locate methods that are both accessible and applicable, that is, declarations that can be correctly invoked on the given arguments. There may be more than one such method, in which case the most specific one is chosen. The descriptor (signature plus return type) of the most specific method is the one used at run time to perform the method dispatch. Certain argument expressions that contain implicitly typed lambda expressions (§15.27.1) or inexact method references (§15.13.1) are ignored by the applicability tests, because their meaning cannot be determined until the invocation's target type is selected. On the other hand, it is only argument expressions - not the invocation's target type - that influence the applicability tests, even if the method invocation expression is a poly expression.",11,195.11,360.01,1012,72,381.09,432.01,576.2,FALSE,FALSE
634,6,BODY,618,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
635,2,BODY,"The process of determining applicability begins by determining the potentially applicable methods (§15.12.2.1). Then, to ensure compatibility with the Java programming language prior to Java SE 5.0, the process continues in three phases: 1.The first phase performs overload resolution without permitting boxing or unboxing conversion, or the use of variable arity method invocation. If no applicable method is found during this phase then processing continues to the second phase.",11,90.14,360.01,480,72,76.06,432.01,166.2,FALSE,FALSE
635,4,BODY,"2.The second phase performs overload resolution while allowing boxing and unboxing, but still precludes the use of variable arity method invocation. If no applicable method is found during this phase then processing continues to the third phase.",11,45.14,360.01,245,72,271.06,432.01,316.2,FALSE,FALSE
635,6,BODY,"3.The third phase allows overloading to be combined with variable arity methods,",11,6.14,360,80,72,361.06,432,367.2,FALSE,FALSE
635,7,BODY,"boxing, and unboxing.",11,6.14,99,21,90,374.06,189,380.2,FALSE,FALSE
635,8,BODY,"A method is applicable if it is applicable by one of strict invocation (the first phase, §15.12.2.2), loose invocation (the second phase, §15.12.2.3), or variable arity invocation (the third phase, §15.12.2.4). Deciding whether a method is applicable will, in the case of generic methods (§8.4.4), require an analysis of the type arguments. Type arguments may be passed explicitly or implicitly; if they are passed implicitly, then bounds of the type arguments must be inferred from the argument expressions (§18 (Type Inference)). If several applicable methods have been identified during one of the three phases of applicability testing, then the most specific one is chosen, as specified in §15.12.2.5.",11,129.14,360.01,705,72,393.06,432.01,522.2,FALSE,FALSE
635,10,BODY,619,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
636,7,BODY,620,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
637,9,BODY,621,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
638,11,BODY,622,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
639,8,BODY,623,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
640,10,BODY,"15.12.2.1Identify Potentially Applicable Methods The type determined by compile-time step 1 (§15.12.1) is searched for all member methods that are potentially applicable to this method invocation; members inherited from superclasses and superinterfaces are included in this search. In addition, if the form of the method invocation expression is MethodName - that is, a single Identifier - then the search for potentially applicable methods also examines all member methods that are imported by single-static-import declarations and static-import-on-demand declarations of the compilation unit where the method invocation occurs (§7.5.3, §7.5.4) and that are not shadowed at the point where the method invocation appears.",11,136.2,360,721,72,444.13,432,580.33,FALSE,FALSE
640,11,BODY,624,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
641,2,BODY,A member method is potentially applicable to a method invocation if and only if all of the following are true: •The name of the member is identical to the name of the method in the method invocation. •The member is accessible (§6.6) to the class or interface in which the method invocation appears.,11,83.14,360,298,72,76.06,432,159.2,FALSE,FALSE
641,6,BODY,"If the search does not yield at least one method that is potentially applicable, then a compile-time error occurs.",11,19.14,359.99,114,72,582.06,431.99,601.2,FALSE,FALSE
641,7,BODY,625,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
642,5,BODY,626,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
643,3,BODY,15.12.2.2Phase 1: Identify Matching Arity Methods Applicable by Strict,11,6.14,326.83,70,72,120.13,398.83,126.27,FALSE,TRUE
643,4,BODY,Invocation,11,6.05,47.05,10,125,133.26,172.05,139.31,FALSE,TRUE
643,6,BODY,627,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
644,4,BODY,15.12.2.3Phase 2: Identify Matching Arity Methods Applicable by Loose,11,6.14,329.28,69,72,245.13,401.28,251.27,FALSE,TRUE
644,5,BODY,Invocation,11,6.05,47.05,10,125,258.26,172.05,264.31,FALSE,TRUE
644,7,BODY,628,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
645,3,BODY,629,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
646,3,BODY,630,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
647,3,BODY,631,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
648,6,BODY,632,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
649,3,BODY,633,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
650,8,BODY,634,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
651,6,BODY,635,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
652,4,BODY,636,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
653,4,BODY,"The compile-time parameter types and compile-time result are determined as follows: •If the compile-time declaration for the method invocation is not a signature polymorphic method, then: –The compile-time parameter types are the types of the formal parameters of the compile-time declaration. –The compile-time result is the result of the invocation type of the compile- time declaration (§15.12.2.6).",11,115.14,360,402,72,190.06,432,305.2,FALSE,FALSE
653,6,BODY,A method is signature polymorphic if all of the following are true:,11,6.14,292.39,67,72,568.06,364.39,574.2,FALSE,FALSE
653,7,BODY,637,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
654,3,BODY,"15.12.4Run-Time Evaluation of Method Invocation At run time, method invocation requires five steps. First, a target reference may be computed. Second, the argument expressions are evaluated. Third, the accessibility of the method to be invoked is checked. Fourth, the actual code for the method to be executed is located. Fifth, a new activation frame is created, synchronization is performed if necessary, and control is transferred to the method code. 15.12.4.1Compute Target Reference (If Necessary) There are six cases to consider, depending on the form of the method invocation:",11,126.24,360.01,583,72,472.09,432.01,598.33,FALSE,FALSE
654,4,BODY,638,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
655,7,BODY,639,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
656,11,BODY,640,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
657,5,BODY,641,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
658,7,BODY,642,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
659,5,BODY,643,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
660,9,BODY,644,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
661,6,BODY,645,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
662,8,BODY,646,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
663,5,BODY,647,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
664,10,BODY,648,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
665,4,BODY,649,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
666,4,BODY,650,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
667,6,BODY,"15.13.1Compile-Time Declaration of a Method Reference The compile-time declaration of a method reference expression is the method to which the expression refers. In special cases, the compile-time declaration does not actually exist, but is a notional method that represents a class instance creation or an array creation. The choice of compile-time declaration depends on a function",11,66.11,360.01,383,72,537.09,432.01,603.2,FALSE,FALSE
667,7,BODY,651,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
668,3,BODY,652,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
669,4,BODY,653,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
670,3,BODY,654,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
671,4,BODY,655,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
672,2,BODY,the method reference expression as if it were an unqualified class instance creation expression).,11,19.14,360.01,97,72,76.06,432.01,95.2,FALSE,FALSE
672,6,BODY,656,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
673,5,BODY,657,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
674,4,BODY,658,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
675,5,BODY,659,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
676,3,BODY,660,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
677,2,BODY,"evaluation of the method invocation expression is as specified in §15.12.4.3, §15.12.4.4, and §15.12.4.5, where: –The invocation mode is derived from the compile-time declaration as specified in §15.12.3. –The target reference is the value of ExpressionName or Primary, as determined when the method reference expression was evaluated. –The arguments to the method invocation expression are the formal parameters of the invocation method.",11,115.14,350.01,438,82,76.06,432.01,191.2,FALSE,FALSE
677,3,BODY,"•If the form is ReferenceType :: [TypeArguments] Identifier, the body of the invocation method similarly has the effect of a method invocation expression for a compile-time declaration which is the compile-time declaration of the method reference expression. Run-time evaluation of the method invocation expression is as specified in §15.12.4.3, §15.12.4.4, and §15.12.4.5, where: –The invocation mode is derived from the compile-time declaration as specified in §15.12.3. –If the compile-time declaration is an instance method, then the target reference is the first formal parameter of the invocation method. Otherwise, there is no target reference. –If the compile-time declaration is an instance method, then the arguments to the method invocation expression (if any) are the second and subsequent formal parameters of the invocation method. Otherwise, the arguments to the method invocation expression are the formal parameters of the invocation method.",11,206.14,360.01,958,72,204.06,432.01,410.2,FALSE,FALSE
677,5,BODY,661,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
678,10,BODY,662,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
679,2,BODY,"grammar to avoid certain ambiguities. They become interchangeable only here, at the level of precedence of postfix expressions.",11,19.14,360,127,72,76.06,432,95.2,FALSE,FALSE
679,3,BODY,PostfixExpression: Primary ExpressionName PostIncrementExpression PostDecrementExpression,11,58.05,126.7,89,90,113.13,216.7,171.18,FALSE,TRUE
679,4,BODY,15.14.1Expression Names The rules for evaluating expression names are given in §6.5.6.,11,27.11,273.72,86,72,197.09,345.72,224.2,FALSE,FALSE
679,7,BODY,"The result of the postfix expression must be a variable of a type that is convertible (§5.1.8) to a numeric type, or a compile-time error occurs. The type of the postfix increment expression is the type of the variable. The result of the postfix increment expression is not a variable, but a value. At run time, if evaluation of the operand expression completes abruptly, then the postfix increment expression completes abruptly for the same reason and no incrementation occurs. Otherwise, the value 1 is added to the value of the variable and the sum is stored back into the variable. Before the addition, binary numeric promotion (§5.6) is performed on the value 1 and the value of the variable. If necessary, the sum is narrowed by a narrowing primitive conversion (§5.1.3) and/ or subjected to boxing conversion (§5.1.7) to the type of the variable before it is stored. The value of the postfix increment expression is the value of the variable before the new value is stored.",11,174.14,360.01,980,72,332.06,432.01,506.2,FALSE,FALSE
679,10,BODY,663,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
680,4,BODY,"The result of the postfix expression must be a variable of a type that is convertible (§5.1.8) to a numeric type, or a compile-time error occurs. The type of the postfix decrement expression is the type of the variable. The result of the postfix decrement expression is not a variable, but a value. At run time, if evaluation of the operand expression completes abruptly, then the postfix decrement expression completes abruptly for the same reason and no decrementation occurs. Otherwise, the value 1 is subtracted from the value of the variable and the difference is stored back into the variable. Before the subtraction, binary numeric promotion (§5.6) is performed on the value 1 and the value of the variable. If necessary, the difference is narrowed by a narrowing primitive conversion (§5.1.3) and/or subjected to boxing conversion (§5.1.7) to the type of the variable before it is stored. The value of the postfix decrement expression is the value of the variable before the new value is stored.",11,174.14,360.01,1003,72,158.06,432.01,332.2,FALSE,FALSE
680,10,BODY,664,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
681,7,BODY,665,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
682,7,BODY,666,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
683,7,BODY,667,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
684,4,BODY,"•If the operand is an infinity, the result is the infinity of opposite sign. •If the operand is a zero, the result is the zero of opposite sign.",11,25.14,313.4,144,72,240.06,385.4,265.2,FALSE,FALSE
684,7,BODY,668,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
685,5,BODY,"The parentheses and the type or list of types they contain are sometimes called the cast operator. If the cast operator contains a list of types, that is, a ReferenceType followed by one or more AdditionalBound terms, then all of the following must be true, or a compile-time error occurs: •ReferenceType must denote a class or interface type. •The erasures (§4.6) of all the listed types must be pairwise different. •No two listed types may be subtypes of different parameterizations of the same generic interface. The target type for the casting context (§5.5) introduced by the cast expression is either the PrimitiveType or the ReferenceType (if not followed by AdditionalBound terms) appearing in the cast operator, or the intersection type denoted by the ReferenceType and AdditionalBound terms appearing in the cast operator. The type of a cast expression is the result of applying capture conversion (§5.1.10) to this target type.",11,224.14,360.01,938,72,299.06,432.01,523.2,FALSE,FALSE
685,7,BODY,669,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
686,7,BODY,"The multiplicative operators have the same precedence and are syntactically left- associative (they group left-to-right). The type of each of the operands of a multiplicative operator must be a type that is convertible (§5.1.8) to a primitive numeric type, or a compile-time error occurs. Binary numeric promotion is performed on the operands (§5.6).",11,70.14,360.01,350,72,420.06,432.01,490.2,FALSE,FALSE
686,10,BODY,670,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
687,2,BODY,"15.17.1Multiplication Operator * The binary * operator performs multiplication, producing the product of its operands. Multiplication is a commutative operation if the operand expressions have no side effects. Integer multiplication is associative when the operands are all of the same type. Floating-point multiplication is not associative. If an integer multiplication overflows, then the result is the low-order bits of the mathematical product as represented in some sufficiently large two's-complement format. As a result, if overflow occurs, then the sign of the result may not be the same as the sign of the mathematical product of the two operand values. The result of a floating-point multiplication is determined by the rules of IEEE 754 arithmetic: •If either operand is NaN, the result is NaN. •If the result is not NaN, the sign of the result is positive if both operands have the same sign, and negative if the operands have different signs. •Multiplication of an infinity by a zero results in NaN. •Multiplication of an infinity by a finite value results in a signed infinity. The sign is determined by the rule stated above. •In the remaining cases, where neither an infinity nor NaN is involved, the exact mathematical product is computed. If the magnitude of the product is too large to represent, we say the operation overflows; the result is then an infinity of appropriate sign. Otherwise, the product is rounded to the nearest representable value using the round to nearest rounding policy (§15.4). The Java programming language requires support of gradual underflow as defined by IEEE 754. Despite the fact that overflow, underflow, or loss of information may occur, evaluation of a multiplication operator * never throws a run-time exception.",11,443.11,360.01,1766,72,76.09,432.01,519.2,FALSE,FALSE
687,4,BODY,671,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
688,3,BODY,672,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
689,6,BODY,673,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
690,6,BODY,674,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
691,8,BODY,675,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
692,17,BODY,676,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
693,9,BODY,677,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
694,9,BODY,678,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
695,3,BODY,679,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
696,7,BODY,680,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
697,6,BODY,The relational operators are syntactically left-associative (they group left-to-right).,11,6.14,360,87,72,435.06,432,441.2,FALSE,FALSE
697,10,BODY,681,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
698,2,BODY,Binary numeric promotion is performed on the operands (§5.6).,11,6.14,280.46,61,72,76.06,352.46,82.2,FALSE,FALSE
698,8,BODY,682,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
699,7,BODY,683,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
700,8,BODY,684,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
701,6,BODY,The equality operators are syntactically left-associative (they group left-to-right).,11,6.14,357.12,85,72,243.06,429.12,249.2,FALSE,FALSE
701,11,BODY,685,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
702,4,BODY,•Positive zero and negative zero are considered equal.,11,6.14,243.38,54,72,242.06,315.38,248.2,FALSE,FALSE
702,8,BODY,686,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
703,8,BODY,687,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
704,10,BODY,688,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
705,8,BODY,689,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
706,6,BODY,690,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
707,7,BODY,"There are three kinds of conditional expressions, classified according to the second and third operand expressions: boolean conditional expressions, numeric conditional expressions, and reference conditional expressions. The classification rules are as follows:",11,45.14,360,261,72,441.06,432,486.2,FALSE,FALSE
707,8,BODY,691,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
708,7,BODY,"•Otherwise, the conditional expression is a reference conditional expression.",11,6.14,342.38,77,72,574.06,414.38,580.2,FALSE,FALSE
708,8,BODY,692,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
709,24,BODY,693,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
710,2,BODY,"Table 15.25-B. Conditional expression type (Primitive 3rd operand, Part II)",11,6.34,354.44,75,72,76.09,426.44,82.43,TRUE,FALSE
710,24,BODY,694,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
711,2,BODY,"Table 15.25-C. Conditional expression type (Reference 3rd operand, Part I)",11,6.34,353.8,74,72,76.09,425.8,82.43,TRUE,FALSE
711,24,BODY,695,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
712,2,BODY,"Table 15.25-D. Conditional expression type (Reference 3rd operand, Part II)",11,6.34,358.08,75,72,76.09,430.08,82.43,TRUE,FALSE
712,24,BODY,696,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
713,2,BODY,"Table 15.25-E. Conditional expression type (Reference 3rd operand, Part III)",11,6.34,360,76,72,76.09,432,82.43,TRUE,FALSE
713,49,BODY,697,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
714,2,BODY,"The chosen operand expression is then evaluated and the resulting value is converted to the type of the conditional expression as determined by the rules stated below. This conversion may include boxing or unboxing conversion (§5.1.7, §5.1.8). The operand expression not chosen is not evaluated for that particular evaluation of the conditional expression.",11,83.14,360.01,356,72,76.06,432.01,159.2,FALSE,FALSE
714,5,BODY,698,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
715,2,BODY,"•Otherwise, general numeric promotion (§5.6) is applied to the second and third operands, and the type of the conditional expression is the promoted type of the second and third operands.",11,32.14,360,187,72,76.06,432,108.2,FALSE,FALSE
715,6,BODY,699,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
716,8,BODY,700,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
717,4,BODY,701,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
718,3,BODY,702,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
719,5,BODY,"Otherwise, three steps are required: •First, the left-hand operand is evaluated to produce a variable. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the right-hand operand is not evaluated and no assignment occurs. •Otherwise, the right-hand operand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs. •Otherwise, the value of the right-hand operand is converted to the type of the left-hand variable, and the result of the conversion is stored into the variable.",11,128.14,360.01,624,72,210.06,432.01,338.2,FALSE,FALSE
719,8,BODY,703,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
720,3,BODY,704,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
721,4,BODY,705,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
722,3,BODY,706,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
723,8,BODY,"At run time, the expression is evaluated in one of two ways. If the left-hand operand expression is not an array access expression, then: •First, the left-hand operand is evaluated to produce a variable. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the right-hand operand is not evaluated and no assignment occurs. •Otherwise, the value of the left-hand operand is saved and then the right-hand operand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs. •Otherwise, the saved value of the left-hand variable and the value of the right-hand operand are used to perform the binary operation indicated by the compound assignment operator. If this operation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs. •Otherwise, the result of the binary operation is converted to the type of the left- hand variable, and the result of the conversion is stored into the variable.",11,218.14,360.01,1094,72,377.06,432.01,595.2,FALSE,FALSE
723,9,BODY,707,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
724,5,BODY,708,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
725,6,BODY,709,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
726,3,BODY,710,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
727,3,BODY,711,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
728,6,BODY,712,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
729,13,BODY,713,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
730,5,BODY,714,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
731,4,BODY,"15.27.1Lambda Parameters The formal parameters of a lambda expression, if any, are specified by either a parenthesized list of comma-separated normal parameter specifiers, or a parenthesized list of comma-separated concise parameter specifiers, or a single concise parameter specifier without parentheses.",11,66.11,360,305,72,497.09,432,563.2,FALSE,FALSE
731,6,BODY,715,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
732,6,BODY,716,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
733,5,BODY,717,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
734,2,BODY,A lambda expression where all the formal parameters have declared types is said to be explicitly typed. A lambda expression where all the formal parameters have inferred types is said to be implicitly typed. A lambda expression with no formal parameters is explicitly typed.,11,45.14,360,274,72,76.06,432,121.2,FALSE,FALSE
734,4,BODY,It is a compile-time error if a lambda expression declares a formal parameter with a declared type and a formal parameter with an inferred type.,11,19.14,359.99,144,72,202.06,431.99,221.2,FALSE,FALSE
734,8,BODY,718,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
735,2,BODY,ConciseLambdaParameter may be used as a simple name in the lambda body to refer to the formal parameter.,11,19.14,359.99,104,72,76.06,431.99,95.2,FALSE,FALSE
735,3,BODY,"15.27.2Lambda Body A lambda body is either a single expression or a block (§14.2). Like a method body, a lambda body describes code that will be executed whenever an invocation occurs.",11,40.11,360,184,72,121.09,432,161.2,FALSE,FALSE
735,4,BODY,LambdaBody: Expression Block,11,32.05,62.33,28,90,179.13,152.33,211.18,FALSE,TRUE
735,9,BODY,719,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
736,8,BODY,720,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
737,3,BODY,721,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
738,4,BODY,722,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
739,6,BODY,723,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
740,5,BODY,724,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
741,8,BODY,725,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
742,5,BODY,726,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
743,4,BODY,727,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
744,5,BODY,728,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
745,5,BODY,729,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
746,4,BODY,730,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
747,3,BODY,731,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
748,11,BODY,732,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
749,10,BODY,733,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
750,8,BODY,"In order to precisely specify all the cases of definite assignment, the rules in this section define several technical terms: •whether a variable is definitely assigned before a statement or expression •whether a variable is definitely unassigned before a statement or expression •whether a variable is definitely assigned after a statement or expression •whether a variable is definitely unassigned after a statement or expression For boolean-valued expressions, the last two are refined into four cases:",11,114.14,360,505,72,485.06,432,599.2,FALSE,FALSE
750,9,BODY,734,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
751,1,BODY,"•whether a variable is definitely assigned after the expression when true •whether a variable is definitely unassigned after the expression when true •whether a variable is definitely assigned after the expression when false •whether a variable is definitely unassigned after the expression when false Here, when true and when false refer to the value of the expression.",11,82.14,335.67,370,72,76.06,407.67,158.2,FALSE,FALSE
751,9,BODY,735,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
752,5,BODY,736,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
753,7,BODY,737,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
754,7,BODY,738,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
755,4,BODY,739,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
756,3,BODY,740,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
757,5,BODY,741,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
758,7,BODY,742,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
759,8,BODY,743,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
760,7,BODY,744,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
761,5,BODY,745,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
762,6,BODY,746,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
763,5,BODY,747,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
764,5,BODY,748,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
765,7,BODY,749,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
766,6,BODY,750,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
767,8,BODY,751,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
768,5,BODY,752,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
769,5,BODY,753,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
770,7,BODY,754,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
771,8,BODY,755,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
772,7,BODY,756,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
773,2,BODY,757,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
775,3,BODY,759,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
776,2,BODY,"17.1Synchronization The Java programming language provides multiple mechanisms for communicating between threads. The most basic of these methods is synchronization, which is implemented using monitors. Each object in Java is associated with a monitor, which a thread can lock or unlock. Only one thread at a time may hold a lock on a monitor. Any other threads attempting to lock that monitor are blocked until they can obtain a lock on that monitor. A thread t may lock a particular monitor multiple times; each unlock reverses the effect of one lock operation. The synchronized statement (§14.19) computes a reference to an object; it then attempts to perform a lock action on that object's monitor and does not proceed further until the lock action has successfully completed. After the lock action has been performed, the body of the synchronized statement is executed. If execution of the body is ever completed, either normally or abruptly, an unlock action is automatically performed on that same monitor. A synchronized method (§8.4.3.6) automatically performs a lock action when it is invoked; its body is not executed until the lock action has successfully completed. If the method is an instance method, it locks the monitor associated with the instance for which it was invoked (that is, the object that will be known as this during execution of the body of the method). If the method is static, it locks the monitor associated with the Class object that represents the class in which the method is defined. If execution of the method's body is ever completed, either normally or abruptly, an unlock action is automatically performed on that same monitor. The Java programming language neither prevents nor requires detection of deadlock conditions. Programs where threads hold (directly or indirectly) locks on multiple objects should use conventional techniques for deadlock avoidance, creating higher-level locking primitives that do not deadlock, if necessary. Other mechanisms, such as reads and writes of volatile variables and the use of classes in the java.util.concurrent package, provide alternative ways of synchronization.",11,424.64,360.01,2147,72,77.56,432.01,502.2,FALSE,FALSE
776,4,BODY,760,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
777,6,BODY,761,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
778,2,BODY,"•Otherwise, the following sequence occurs: 1.Thread t is added to the wait set of object m, and performs n unlock actions",11,25.14,360,121,72,76.06,432,101.2,FALSE,FALSE
778,3,BODY,on m.,11,6.14,24.44,5,100,108.06,124.44,114.2,FALSE,FALSE
778,8,BODY,762,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
779,4,BODY,763,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
780,6,BODY,764,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
781,11,BODY,765,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
782,8,BODY,766,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
783,7,BODY,767,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
784,3,BODY,"17.4.2Actions An inter-thread action is an action performed by one thread that can be detected or directly influenced by another thread. There are several kinds of inter-thread action that a program may perform: •Read (normal, or non-volatile). Reading a variable. •Write (normal, or non-volatile). Writing a variable. •Synchronization actions, which are: –Volatile read. A volatile read of a variable. –Volatile write. A volatile write of a variable. –Lock. Locking a monitor –Unlock. Unlocking a monitor. –The (synthetic) first and last action of a thread. –Actions that start a thread or detect that a thread has terminated (§17.4.4). •External Actions. An external action is an action that may be observable outside of an execution, and has a result based on an environment external to the execution. •Thread divergence actions (§17.4.9). A thread divergence action is only performed by a thread that is in an infinite loop in which no memory, synchronization, or external actions are performed. If a thread performs a thread",11,314.11,360.01,1029,72,251.09,432.01,565.2,FALSE,FALSE
784,4,BODY,768,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
785,2,BODY,"divergence action, it will be followed by an infinite number of thread divergence actions.",11,19.14,350.01,90,82,76.06,432.01,95.2,FALSE,FALSE
785,4,BODY,"This specification is only concerned with inter-thread actions. We do not need to concern ourselves with intra-thread actions (e.g., adding two local variables and storing the result in a third local variable). As previously mentioned, all threads need to obey the correct intra-thread semantics for Java programs. We will usually refer to inter-thread actions more succinctly as simply actions. An action a is described by a tuple < t, k, v, u >, comprising: •t - the thread performing the action •k - the kind of action •v - the variable or monitor involved in the action. For lock actions, v is the monitor being locked; for unlock actions, v is the monitor being unlocked. If the action is a (volatile or non-volatile) read, v is the variable being read. If the action is a (volatile or non-volatile) write, v is the variable being written. •u - an arbitrary unique identifier for the action An external action tuple contains an additional component, which contains the results of the external action as perceived by the thread performing the action. This may be information as to the success or failure of the action, and any values read by the action. Parameters to the external action (e.g., which bytes are written to which socket) are not part of the external action tuple. These parameters are set up by other actions within the thread and can be determined by examining the intra-thread semantics. They are not explicitly discussed in the memory model. In non-terminating executions, not all external actions are observable. Non- terminating executions and observable actions are discussed in §17.4.9.",11,371.14,360.01,1612,72,140.06,432.01,511.2,FALSE,FALSE
785,5,BODY,"17.4.3Programs and Program Order Among all the inter-thread actions performed by each thread t, the program order of t is a total order that reflects the order in which these actions would be performed according to the intra-thread semantics of t.",11,53.11,360.01,247,72,537.09,432.01,590.2,FALSE,FALSE
785,6,BODY,769,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
786,3,BODY,"17.4.4Synchronization Order Every execution has a synchronization order. A synchronization order is a total order over all of the synchronization actions of an execution. For each thread t, the synchronization order of the synchronization actions (§17.4.2) in t is consistent with the program order (§17.4.3) of t. Synchronization actions induce the synchronized-with relation on actions, defined as follows: •An unlock action on monitor m synchronizes-with all subsequent lock actions on m (where 'subsequent' is defined according to the synchronization order). •A write to a volatile variable v (§8.3.1.4) synchronizes-with all subsequent reads of v by any thread (where 'subsequent' is defined according to the synchronization order). •An action that starts a thread synchronizes-with the first action in the thread it starts.",11,207.11,360.01,829,72,372.09,432.01,579.2,FALSE,FALSE
786,4,BODY,770,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
787,8,BODY,771,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
788,5,BODY,"A program is correctly synchronized if and only if all sequentially consistent executions are free of data races. If a program is correctly synchronized, then all executions of the program will appear to be sequentially consistent (§17.4.3).",11,51.14,360,241,72,521.06,432,572.2,FALSE,FALSE
788,6,BODY,772,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
789,3,BODY,"We say that a read r of a variable v is allowed to observe a write w to v if, in the happens-before partial order of the execution trace: •r is not ordered before w (i.e., it is not the case that hb(r, w)), and •there is no intervening write w' to v (i.e. no write w' to v such that hb(w, w') and hb(w', r)). Informally, a read r is allowed to see the result of a write w if there is no happens- before ordering to prevent that read. A set of actions A is happens-before consistent if for all reads r in A, where W(r) is the write action seen by r, it is not the case that either hb(r, W(r)) or that there exists a write w in A such that w.v = r.v and hb(W(r), w) and hb(w, r). In a happens-before consistent set of actions, each read sees a write that it is allowed to see by the happens-before ordering.",11,179.14,360.01,805,72,220.06,432.01,399.2,FALSE,FALSE
789,9,BODY,773,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
790,6,BODY,"17.4.6Executions An execution E is described by a tuple < P, A, po, so, W, V, sw, hb >, comprising: •P - a program •A - a set of actions •po - program order, which for each thread t, is a total order over all actions performed by t in A •so - synchronization order, which is a total order over all synchronization actions in A •W - a write-seen function, which for each read r in A, gives W(r), the write action seen by r in E. •V - a value-written function, which for each write w in A, gives V(w), the value written by w in E. •sw - synchronizes-with, a partial order over synchronization actions •hb - happens-before, a partial order over actions Note that the synchronizes-with and happens-before elements are uniquely determined by the other components of an execution and the rules for well-formed executions (§17.4.7). An execution is happens-before consistent if its set of actions is happens-before consistent (§17.4.5).",11,308.11,360.01,929,72,251.09,432.01,559.2,FALSE,FALSE
790,7,BODY,774,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
791,2,BODY,"17.4.7Well-Formed Executions We only consider well-formed executions. An execution E = < P, A, po, so, W, V, sw, hb > is well formed if the following are true: 1.Each read sees a write to the same variable in the execution.",11,59.11,360,223,72,76.09,432,135.2,FALSE,FALSE
791,3,BODY,"All reads and writes of volatile variables are volatile actions. For all reads r in A, we have W(r) in A and W(r).v = r.v. The variable r.v is volatile if and only if r is a volatile read, and the variable w.v is volatile if and only if w is a volatile write.",11,45.14,342,259,90,148.06,432,193.2,FALSE,FALSE
791,4,BODY,2.The happens-before order is a partial order.,11,6.14,208.91,46,72,206.06,280.91,212.2,FALSE,FALSE
791,5,BODY,"The happens-before order is given by the transitive closure of synchronizes- with edges and program order. It must be a valid partial order: reflexive, transitive and antisymmetric.",11,32.14,342,181,90,225.06,432,257.2,FALSE,FALSE
791,6,BODY,3.The execution obeys intra-thread consistency.,11,6.14,219.93,47,72,270.06,291.93,276.2,FALSE,FALSE
791,7,BODY,"For each thread t, the actions performed by t in A are the same as would be generated by that thread in program-order in isolation, with each write w writing the value V(w), given that each read r sees the value V(W(r)). Values seen by each read are determined by the memory model. The program order given must reflect the program order in which the actions would be performed according to the intra-thread semantics of P.",11,71.14,342,422,90,289.06,432,360.2,FALSE,FALSE
791,8,BODY,4.The execution is happens-before consistent (§17.4.6). 5.The execution obeys synchronization-order consistency.,11,25.14,265.75,112,72,373.06,337.75,398.2,FALSE,FALSE
791,9,BODY,"For all volatile reads r in A, it is not the case that either so(r, W(r)) or that there exists a write w in A such that w.v = r.v and so(W(r), w) and so(w, r).",11,19.14,342,159,90,411.06,432,430.2,FALSE,FALSE
791,10,BODY,17.4.8Executions and Causality Requirements,11,6.34,225.42,43,72,456.09,297.42,462.43,TRUE,FALSE
791,12,BODY,"A well-formed execution E = < P, A, po, so, W, V, sw, hb > is validated by committing actions from A. If all of the actions in A can be committed, then the execution satisfies the causality requirements of the Java programming language memory model.",11,45.14,360,249,72,548.85,432,593.99,FALSE,FALSE
791,13,BODY,775,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
792,7,BODY,776,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
793,11,BODY,777,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
794,3,BODY,"17.4.9Observable Behavior and Nonterminating Executions For programs that always terminate in some bounded finite period of time, their behavior can be understood (informally) simply in terms of their allowable executions. For programs that can fail to terminate in a bounded amount of time, more subtle issues arise. The observable behavior of a program is defined by the finite sets of external actions that the program may perform. A program that, for example, simply prints 'Hello' forever is described by a set of behaviors that for any non-negative integer i, includes the behavior of printing 'Hello' i times. Termination is not explicitly modeled as a behavior, but a program can easily be extended to generate an additional external action executionTermination that occurs when all threads have terminated.",11,169.11,360.01,815,72,413.09,432.01,582.2,FALSE,FALSE
794,4,BODY,778,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
795,2,BODY,"We also define a special hang action. If behavior is described by a set of external actions including a hang action, it indicates a behavior where after the external actions are observed, the program can run for an unbounded amount of time without performing any additional external actions or terminating. Programs can hang if all threads are blocked or if the program can perform an unbounded number of actions without performing any external actions. A thread can be blocked in a variety of circumstances, such as when it is attempting to acquire a lock or perform an external action (such as a read) that depends on external data. An execution may result in a thread being blocked indefinitely and the execution's not terminating. In such cases, the actions generated by the blocked thread must consist of all actions generated by that thread up to and including the action that caused the thread to be blocked, and no actions that would be generated by the thread after that action. To reason about observable behaviors, we need to talk about sets of observable actions. If O is a set of observable actions for an execution E, then set O must be a subset of E's actions, A, and must contain only a finite number of actions, even if A contains an infinite number of actions. Furthermore, if an action y is in O, and either hb(x, y) or so(x, y), then x is in O. Note that a set of observable actions are not restricted to external actions. Rather, only external actions that are in a set of observable actions are deemed to be observable external actions. A behavior B is an allowable behavior of a program P if and only if B is a finite set of external actions and either: •There exists an execution E of P, and a set O of observable actions for E, and B is the set of external actions in O (If any threads in E end in a blocked state and O contains all actions in E, then B may also contain a hang action); or",11,399.14,360.01,1914,72,76.06,432.01,475.2,FALSE,FALSE
795,3,BODY,779,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
796,3,BODY,"17.5final Field Semantics Fields declared final are initialized once, but never changed under normal circumstances. The detailed semantics of final fields are somewhat different from those of normal fields. In particular, compilers have a great deal of freedom to move reads of final fields across synchronization barriers and calls to arbitrary or unknown methods. Correspondingly, compilers are allowed to keep the value of a final field cached in a register and not reload it from memory in situations where a non-final field would have to be reloaded. final fields also allow programmers to implement thread-safe immutable objects without synchronization. A thread-safe immutable object is seen as immutable by all threads, even if a data race is used to pass references to the immutable object between threads. This can provide safety guarantees against misuse of an immutable class by incorrect or malicious code. final fields must be used correctly to provide a guarantee of immutability. An object is considered to be completely initialized when its constructor finishes. A thread that can only see a reference to an object after that object has been completely initialized is guaranteed to see the correctly initialized values for that object's final fields. The usage model for final fields is a simple one: Set the final fields for an object in that object's constructor; and do not write a reference to the object being constructed in a place where another thread can see it before the object's constructor is finished. If this is followed, then when the object is seen by another thread, that thread will always see the correctly constructed version of that object's final fields.",11,327.64,360.01,1693,72,275.56,432.01,603.2,FALSE,FALSE
796,4,BODY,780,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
797,12,BODY,781,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
798,5,BODY,782,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
799,7,BODY,783,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
800,7,BODY,784,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
801,6,BODY,785,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
802,6,BODY,786,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
803,3,BODY,787,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
804,2,BODY,•§18.4 describes resolution in detail. •§18.5 defines how these inference tools are used to solve certain compile-time analysis problems.,11,38.14,360,137,72,76.06,432,114.2,FALSE,FALSE
804,5,BODY,"18.1.1Inference Variables Inference variables are meta-variables for types - that is, they are special names that allow abstract reasoning about types. To distinguish them from type variables, inference variables are represented with Greek letters, principally α. The term 'type' is used loosely in this chapter to include type-like syntax that contains inference variables. The term proper type excludes such 'types'",11,85.11,360,417,72,512.09,432,597.2,FALSE,FALSE
804,6,BODY,788,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
805,2,BODY,that mention inference variables. Assertions that involve inference variables are assertions about every proper type that can be produced by replacing each inference variable with a proper type.,11,32.14,360.01,194,72,76.06,432.01,108.2,FALSE,FALSE
805,5,BODY,789,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
806,4,BODY,790,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
807,5,BODY,791,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
808,6,BODY,792,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
809,4,BODY,793,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
810,5,BODY,794,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
811,6,BODY,795,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
812,11,BODY,796,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
813,2,BODY,"compile-time unchecked warnings, and may influence a method's invocation type (§15.12.2.6).",11,19.14,360,91,72,76.06,432,95.2,FALSE,FALSE
813,5,BODY,797,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
814,5,BODY,798,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
815,5,BODY,"•Otherwise, the constraint reduces to false.",11,6.14,194.22,44,72,568.06,266.22,574.2,FALSE,FALSE
815,6,BODY,799,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
816,8,BODY,800,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
817,4,BODY,801,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
818,4,BODY,802,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
819,4,BODY,803,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
820,4,BODY,804,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
821,3,BODY,805,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
822,3,BODY,806,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
823,5,BODY,807,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
824,8,BODY,808,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
825,4,BODY,"18.5.2Invocation Type Inference Given a method invocation expression that provides no explicit type arguments, and a corresponding most specific applicable generic method m, the process to infer the invocation type (§15.12.2.6) of the chosen method may require resolving additional constraints, both to assert compatibility with a target type and to assert validity of the method invocation's argument expressions.",11,79.11,360.01,414,72,218.34,432.01,297.46,FALSE,FALSE
825,7,BODY,809,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
826,6,BODY,810,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
827,8,BODY,"18.5.2.2Additional Argument Constraints The invocation type for the chosen method is determined after considering additional constraints that may be implied by the argument expressions of the method invocation expression, as follows:",11,52.2,360,233,72,527.52,432,579.72,FALSE,FALSE
827,9,BODY,811,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
828,3,BODY,812,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
829,5,BODY,813,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
830,5,BODY,5.The constraint(s) resulting from substitution are reduced and incorporated,11,6.14,349.99,76,82,281.06,431.99,287.2,FALSE,FALSE
830,6,BODY,with the current bound set.,11,6.14,117.62,27,100,294.06,217.62,300.2,FALSE,FALSE
830,8,BODY,814,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
831,3,BODY,815,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
832,5,BODY,816,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
833,7,BODY,817,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
834,3,BODY,818,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
835,5,BODY,819,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
836,4,BODY,820,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
837,6,BODY,821,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
838,10,BODY,822,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
839,3,BODY,823,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
841,3,BODY,Productions from §3 (Lexical Structure),11,6.34,185.77,39,72,281.39,257.77,287.73,TRUE,FALSE
841,5,BODY,825,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
842,1,BODY,Literal: IntegerLiteral FloatingPointLiteral BooleanLiteral CharacterLiteral StringLiteral TextBlock NullLiteral,11,97.05,101.68,112,90,76.13,191.68,173.18,FALSE,TRUE
842,2,BODY,"Productions from §4 (Types, Values, and Variables)",11,6.34,238.33,50,72,191.09,310.33,197.43,TRUE,TRUE
842,4,BODY,826,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
843,2,BODY,827,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
844,3,BODY,828,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
845,1,BODY,Productions from §7 (Packages and Modules),11,6.34,211.12,42,72,76.09,283.12,82.43,TRUE,FALSE
845,2,BODY,CompilationUnit: OrdinaryCompilationUnit ModularCompilationUnit OrdinaryCompilationUnit: [PackageDeclaration] {ImportDeclaration} {TopLevelClassOrInterfaceDeclaration},11,82.05,204.25,167,90,100.13,294.25,182.18,FALSE,TRUE
845,4,BODY,829,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
846,3,BODY,830,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
847,1,BODY,Productions from §8 (Classes),11,6.34,140.24,29,72,76.09,212.24,82.43,TRUE,FALSE
847,4,BODY,831,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
848,2,BODY,832,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
849,2,BODY,833,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
850,2,BODY,834,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
851,3,BODY,835,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
852,2,BODY,836,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
853,3,BODY,837,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
854,1,BODY,Productions from §9 (Interfaces),11,6.34,152.45,32,72,76.09,224.45,82.43,TRUE,FALSE
854,4,BODY,838,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
855,3,BODY,839,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
856,2,BODY,Productions from §10 (Arrays),11,6.34,142.68,29,72,461.09,214.68,467.43,TRUE,FALSE
856,4,BODY,840,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
857,1,BODY,"Productions from §14 (Blocks, Statements, and Patterns)",11,6.34,260.95,55,72,76.09,332.95,82.43,TRUE,TRUE
857,3,BODY,841,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
858,2,BODY,842,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
859,2,BODY,843,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
860,3,BODY,844,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
861,2,BODY,845,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
862,2,BODY,846,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
863,1,BODY,Productions from §15 (Expressions),11,6.34,167.13,34,72,76.09,239.13,82.43,TRUE,FALSE
863,5,BODY,847,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
864,2,BODY,848,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
865,2,BODY,849,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
866,2,BODY,850,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
867,2,BODY,851,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
868,2,BODY,852,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
869,2,BODY,853,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
871,1,BODY,"ORACLE AMERICA, INC. IS WILLING TO LICENSE THIS SPECIFICATION TO YOU ONLY UPON THE CONDITION THAT YOU ACCEPT ALL OF THE TERMS CONTAINED IN THIS AGREEMENT ('AGREEMENT'). PLEASE READ THE TERMS AND CONDITIONS OF THIS AGREEMENT CAREFULLY. Specification: JSR-398 Java SE 23 Version: 23 Status: Final Release Release: September 2024 Copyright © 1997, 2024, Oracle America, Inc. All rights reserved. LIMITED LICENSE GRANTS 1. License for Evaluation Purposes. Specification Lead hereby grants you a fully- paid, non-exclusive, non-transferable, worldwide, limited license (without the right to sublicense), under Specification Lead's applicable intellectual property rights to view, download, use and reproduce the Specification only for the purpose of internal evaluation. This includes (i) developing applications intended to run on an implementation of the Specification, provided that such applications do not themselves implement any portion(s) of the Specification, and (ii) discussing the Specification with any third party; and (iii) excerpting brief portions of the Specification in oral or written communications which discuss the Specification provided that such excerpts do not in the aggregate constitute a significant portion of the Specification. 2. License for the Distribution of Compliant Implementations. Specification Lead also grants you a perpetual, non-exclusive, non-transferable, worldwide, fully paid-up, royalty free, limited license (without the right to sublicense) under any applicable copyrights or, subject to the provisions of subsection 4 below, patent rights it may have covering the Specification to create and/or distribute an Independent Implementation of the Specification that: (a) fully implements the Specification including all its required interfaces and functionality; (b) does not modify, subset, superset or otherwise extend the Licensor Name Space, or include any public or protected packages, classes, Java interfaces, fields or methods within",11,453.14,360.01,1984,72,150.06,432.01,603.2,FALSE,FALSE
871,2,BODY,855,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
872,1,BODY,"the Licensor Name Space other than those required/authorized by the Specification or Specifications being implemented; and (c) passes the Technology Compatibility Kit (including satisfying the requirements of the applicable TCK Users Guide) for such Specification ('Compliant Implementation'). In addition, the foregoing license is expressly conditioned on your not acting outside its scope. No license is granted hereunder for any other purpose (including, for example, modifying the Specification, other than to the extent of your fair use rights, or distributing the Specification to third parties). Also, no right, title, or interest in or to any trademarks, service marks, or trade names of Specification Lead or Specification Lead's licensors is granted hereunder. Java, and Java-related logos, marks and names are trademarks or registered trademarks of Oracle America, Inc. in the U.S. and other countries. 3. Pass-through Conditions. You need not include limitations (a)-(c) from the previous paragraph or any other particular 'pass through' requirements in any license You grant concerning the use of your Independent Implementation or products derived from it. However, except with respect to Independent Implementations (and products derived from them) that satisfy limitations (a)-(c) from the previous paragraph, You may neither: (a) grant or otherwise pass through to your licensees any licenses under Specification Lead's applicable intellectual property rights; nor (b) authorize your licensees to make any claims concerning their implementation's compliance with the Specification in question. 4. Reciprocity Concerning Patent Licenses. a. With respect to any patent claims covered by the license granted under subparagraph 2 above that would be infringed by all technically feasible implementations of the Specification, such license is conditioned upon your offering on fair, reasonable and non-discriminatory terms, to any party seeking it from You, a perpetual, non-exclusive, non-transferable, worldwide license under Your patent rights which are or would be infringed by all technically feasible implementations of the Specification to develop, distribute and use a Compliant Implementation. b. With respect to any patent claims owned by Specification Lead and covered by the license granted under subparagraph 2, whether or not their infringement can be avoided in a technically feasible manner when implementing the Specification, such license shall terminate with respect to such claims if You initiate a claim against Specification Lead that it has, in the course of performing its responsibilities as the Specification Lead, induced any other entity to infringe Your patent rights. c. Also with respect to any patent claims owned by Specification Lead and covered by the license granted under subparagraph 2 above, where the infringement of",11,517.14,360.01,2868,72,76.06,432.01,593.2,FALSE,FALSE
872,2,BODY,856,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
873,1,BODY,"such claims can be avoided in a technically feasible manner when implementing the Specification such license, with respect to such claims, shall terminate if You initiate a claim against Specification Lead that its making, having made, using, offering to sell, selling or importing a Compliant Implementation infringes Your patent rights. 5. Definitions. For the purposes of this Agreement: 'Independent Implementation' shall mean an implementation of the Specification that neither derives from any of Specification Lead's source code or binary code materials nor, except with an appropriate and separate license from Specification Lead, includes any of Specification Lead's source code or binary code materials; 'Licensor Name Space' shall mean the public class or interface declarations whose names begin with 'java', 'javax', 'com.oracle', 'com.sun' or their equivalents in any subsequent naming convention adopted by Oracle America, Inc. through the Java Community Process, or any recognized successors or replacements thereof; and 'Technology Compatibility Kit' or 'TCK' shall mean the test suite and accompanying TCK User's Guide provided by Specification Lead which corresponds to the Specification and that was available either (i) from Specification Lead 120 days before the first release of Your Independent Implementation that allows its use for commercial purposes, or (ii) more recently than 120 days from such release but against which You elect to test Your implementation of the Specification. This Agreement will terminate immediately without notice from Specification Lead if you breach the Agreement or act outside the scope of the licenses granted above. DISCLAIMER OF WARRANTIES THE SPECIFICATION IS PROVIDED 'AS IS'. SPECIFICATION LEAD MAKES NO REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT (INCLUDING AS A CONSEQUENCE OF ANY PRACTICE OR IMPLEMENTATION OF THE SPECIFICATION), OR THAT THE CONTENTS OF THE SPECIFICATION ARE SUITABLE FOR ANY PURPOSE. This document does not represent any commitment to release or implement any portion of the Specification in any product. In addition, the Specification could include technical inaccuracies or typographical errors. LIMITATION OF LIABILITY TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL SPECIFICATION LEAD OR ITS LICENSORS BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION, LOST REVENUE,",11,523.14,360.01,2493,72,76.06,432.01,599.2,FALSE,FALSE
873,2,BODY,857,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
874,1,BODY,"PROFITS OR DATA, OR FOR SPECIAL, INDIRECT, CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF OR RELATED IN ANY WAY TO YOUR HAVING, IMPLEMENTING OR OTHERWISE USING THE SPECIFICATION, EVEN IF SPECIFICATION LEAD AND/OR ITS LICENSORS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. You will indemnify, hold harmless, and defend Specification Lead and its licensors from any claims arising or resulting from: (i) your use of the Specification; (ii) the use or distribution of your Java application, applet and/or implementation; and/or (iii) any claims that later versions or releases of any Specification furnished to you are incompatible with the Specification provided to you under this license. RESTRICTED RIGHTS LEGEND U.S. Government: If this Specification is being acquired by or on behalf of the U.S. Government or by a U.S. Government prime contractor or subcontractor (at any tier), then the Government's rights in the Software and accompanying documentation shall be only as set forth in this license; this is in accordance with 48 C.F.R. 227.7201 through 227.7202-4 (for Department of Defense (DoD) acquisitions) and with 48 C.F.R. 2.101 and 12.212 (for non-DoD acquisitions). REPORT If you provide Specification Lead with any comments or suggestions concerning the Specification ('Feedback'), you hereby: (i) agree that such Feedback is provided on a non-proprietary and non-confidential basis, and (ii) grant Specification Lead a perpetual, non-exclusive, worldwide, fully paid-up, irrevocable license, with the right to sublicense through multiple levels of sublicensees, to incorporate, disclose, and use without limitation the Feedback for any purpose. GENERAL TERMS Any action related to this Agreement will be governed by California law and controlling U.S. federal law. The U.N. Convention for the International Sale of Goods and the choice of law rules of any jurisdiction will not apply. The Specification is subject to U.S. export control laws and may be subject to export or import regulations in other countries. Licensee agrees to comply strictly with all such laws and regulations and acknowledges that it has the responsibility to obtain such licenses to export, re-export or import as may be required after delivery to Licensee.",11,509.14,360.01,2328,72,76.06,432.01,585.2,FALSE,FALSE
874,2,BODY,858,11,6.34,16.5,3,36,625.59,52.5,631.93,TRUE,FALSE
875,1,BODY,"This Agreement is the parties' entire agreement relating to its subject matter. It supersedes all prior or contemporaneous oral or written communications, proposals, conditions, representations and warranties and prevails over any conflicting or additional terms of any quote, order, acknowledgment, or other communication between the parties relating to its subject matter during the term of this Agreement. No modification to this Agreement will be binding, unless in writing and signed by an authorized representative of each party.",11,84.14,360,535,72,76.06,432,160.2,FALSE,FALSE
875,2,BODY,859,11,6.34,16.5,3,451.5,625.59,468,631.93,TRUE,FALSE
35,2,BODY,"THIS chapter specifies the lexical structure of the Java programming language. Programs are written in Unicode (§3.1), but lexical translations are provided (§3.2) so that Unicode escapes (§3.3) can be used to include any Unicode character using only ASCII characters. Line terminators are defined (§3.4) to support the different conventions of existing host systems while maintaining consistent line numbers. The Unicode characters resulting from the lexical translations are reduced to a sequence of input elements (§3.5), which are white space (§3.6), comments (§3.7), and tokens. The tokens are the identifiers (§3.8), keywords (§3.9), literals (§3.10), separators (§3.11), and operators (§3.12) of the syntactic grammar.",10.99,122.14,360.01,725,72,220.36,432.01,342.5,FALSE,FALSE
38,4,BODY,"The UnicodeInputCharacter production is ambiguous because an ASCII \ character in the compiler's raw input could be reduced to either a RawInputCharacter or the \ of a UnicodeEscape (to be followed by an ASCII u). To avoid ambiguity, for each ASCII \ character in the compiler's raw input, input processing must consider the most recent raw input characters that resulted from this translation step: •If the most recent raw input character in the result was itself translated from a Unicode escape in the compiler's raw input, then the ASCII \ character is eligible to begin a Unicode escape.",10.99,116.14,360,592,72,136.2,432,252.33,FALSE,FALSE
41,5,BODY,"As a special concession for compatibility with certain operating systems, the ASCII SUB character (\u001a, or control-Z) is ignored if it is the last character in the escaped input stream. The Input production is ambiguous, meaning that for some sequences of input characters, there is more than one way to reduce the input characters to input elements (that is, to tokenize the input characters). Ambiguities are resolved as follows: •A sequence of input characters that could be reduced to either an identifier token or a literal token is always reduced to a literal token. •A sequence of input characters that could be reduced to either an identifier token or a reserved keyword token (§3.9) is always reduced to a reserved keyword token. •A sequence of input characters that could be reduced to either a contextual keyword token or to other (non-keyword) tokens is reduced according to context, as specified in §3.9. •If the input character > appears in a type context (§4.11), that is, as part of a Type or an UnannType in the syntactic grammar (§4.1, §8.3), it is always reduced to",10.99,244.14,360.01,1087,72,334.2,432.01,578.33,FALSE,FALSE
57,2,BODY,"For decimal floating-point literals, at least one digit (in either the whole number or the fraction part) and either a decimal point, an exponent, or a float type suffix are required. All other parts are optional. The exponent, if present, is indicated by the ASCII letter e or E followed by an optionally signed integer. For hexadecimal floating-point literals, at least one digit is required (in either the whole number or the fraction part), and the exponent is mandatory, and the float type suffix is optional. The exponent is indicated by the ASCII letter p or P followed by an optionally signed integer. Underscores are allowed as separators between digits that denote the whole-number part, and between digits that denote the fraction part, and between digits that denote the exponent.",10.99,148.14,360.01,792,72,76.06,432.01,224.2,FALSE,FALSE
72,2,BODY,"There is also a special null type, the type of the expression null (§3.10.8, §15.8.1), which has no name. Because the null type has no name, it is impossible to declare a variable of the null type or to cast to the null type. The null reference is the only possible value of an expression of null type. The null reference can always be assigned or cast to any reference type (§5.2, §5.3, §5.5).",10.99,102.14,360.01,394,72,76.06,432.01,178.2,FALSE,FALSE
81,4,BODY,"A class or interface type consists of an identifier or a dotted sequence of identifiers, where each identifier is optionally followed by type arguments (§4.5.1). If type arguments appear anywhere in a class or interface type, it is a parameterized type (§4.5). Each identifier in a class or interface type is classified as a package name or a type name (§6.5.1). Identifiers which are classified as type names may be annotated. If a class or interface type has the form T.id (optionally followed by type arguments),",10.99,90.14,360.01,515,72,513.06,432.01,603.2,FALSE,FALSE
89,5,BODY,"Wildcards may be given explicit bounds, just like regular type variable declarations. An upper bound is signified by the following syntax, where B is the bound:",10.99,32.14,360,160,72,512.06,432,544.2,FALSE,FALSE
90,2,BODY,"Unlike ordinary type variables declared in a method signature, no type inference is required when using a wildcard. Consequently, it is permissible to declare lower bounds on a wildcard, using the following syntax, where B is a lower bound:",10.99,32.14,360.01,240,72,76.06,432.01,108.2,FALSE,FALSE
94,2,BODY,"•It is a parameterized type in which all type arguments are unbounded wildcards (§4.5.1). •It is a raw type (§4.8). •It is a primitive type (§4.2). •It is an array type (§10.1) whose element type is reifiable. •It is a nested type where, for each type T separated by a '.', T itself is reifiable.",10.99,95.14,360,296,72,76.06,432,171.2,FALSE,FALSE
105,4,BODY,"4.10.5Type Projections A synthetic type variable is a type variable introduced by the compiler during capture conversion (§5.1.10) or inference variable resolution (§18.4). It is sometimes necessary to find a close supertype of a type, where that supertype does not mention certain synthetic type variables. This is achieved with an upward projection applied to the type. Similarly, a downward projection may be applied to find a close subtype of a type, where that subtype does not mention certain synthetic type variables. Because such a type does not always exist, downward projection is a partial function. These operations take as input a set of type variables that should no longer be referenced, referred to as the restricted type variables. When the operations recur, the set of restricted type variables is implicitly passed on to the recursive application. The upward projection of a type T with respect to a set of restricted type variables is defined as follows: •If T does not mention any restricted type variable, then the result is T. •If T is a restricted type variable, then the result is the upward projection of the upper bound of T.",10.99,271.11,360.01,1152,72,198.09,432.01,469.2,FALSE,FALSE
125,2,BODY,"EVERY expression written in the Java programming language either produces no result (§15.1) or has a type that can be deduced at compile time (§15.3). When an expression appears in most contexts, it must be compatible with a type expected in that context; this type is called the target type. For convenience, compatibility of an expression with its surrounding context is facilitated in two ways: •First, for some expressions, termed poly expressions (§15.2), the deduced type can be influenced by the target type. The same expression can have different types in different contexts. •Second, after the type of the expression has been deduced, an implicit conversion from the type of the expression to the target type can sometimes be performed. If neither strategy is able to produce the appropriate type, a compile-time error occurs. The rules determining whether an expression is a poly expression, and if so, its type and compatibility in a particular context, vary depending on the kind of context and the form of the expression. In addition to influencing the type of the expression, the target type may in some cases influence the run time behavior of the expression in order to produce a value of the appropriate type. Similarly, the rules determining whether a target type allows an implicit conversion vary depending on the kind of context, the type of the expression, and, in one special case, the value of a constant expression (§15.29). A conversion from type S to type T allows an expression of type S to be treated at compile time as if it had type T instead. In some cases this will require a corresponding action at run time to check the validity of the conversion or to translate the run-time value of the expression into a form appropriate for the new type T.",10.99,335.14,360.01,1778,72,220.36,432.01,555.5,FALSE,FALSE
177,2,BODY,"unit in which the import declaration appears, as well as any annotations on the module declaration or package declaration of the compilation unit. The scope of a member imported by a single-static-import declaration (§7.5.3) or a static-import-on-demand declaration (§7.5.4) is the module declaration and all the class and interface declarations of the compilation unit in which the import declaration appears, as well as any annotations on the module declaration or package declaration of the compilation unit. The scope of a top level class or interface (§7.6) is all class and interface declarations in the package in which the top level class or interface is declared. The scope of a declaration of a member m declared in or inherited by a class or interface C (§8.2, §9.2) is the entire body of C, including any nested class or interface declarations. If C is a record class, then the scope of m additionally includes the header of the record declaration of C. The scope of a formal parameter of a method (§8.4.1), constructor (§8.8.1), or lambda expression (§15.27) is the entire body of the method, constructor, or lambda expression. The scope of a class's type parameter (§8.1.2) is the type parameter section of the class declaration, and the type parameter section of any superclass type or superinterface type of the class declaration, and the class body. If the class is a record class (§8.10), then the scope of the type parameter additionally includes the header of the record declaration (§8.10.1). The scope of an interface's type parameter (§9.1.2) is the type parameter section of the interface declaration, and the type parameter section of any superinterface type of the interface declaration, and the interface body. The scope of a method's type parameter (§8.4.4) is the entire declaration of the method, including the type parameter section, but excluding the method modifiers. The scope of a constructor's type parameter (§8.8.4) is the entire declaration of the constructor, including the type parameter section, but excluding the constructor modifiers. The scope of a local class or interface declaration immediately enclosed by a block (§14.2) is the rest of the immediately enclosing block, including the local class or interface declaration itself. The scope of a local class or interface declaration immediately enclosed by a switch block statement group (§14.11) is the rest of the immediately enclosing switch block statement group, including the local class or interface declaration itself.",10.99,508.14,360.01,2523,72,76.06,432.01,584.2,FALSE,FALSE
202,6,BODY,"6.5.4Meaning of PackageOrTypeNames 6.5.4.1Simple PackageOrTypeNames If the PackageOrTypeName, Q, is a valid TypeIdentifier and occurs in the scope of a class, interface, or type parameter named Q, then the PackageOrTypeName is reclassified as a TypeName.",10.99,79.24,360,254,72,521.61,432,600.85,FALSE,FALSE
206,6,BODY,"If the declaration declares a final variable which is definitely assigned before the simple expression, the meaning of the name is the value of that variable. Otherwise, the meaning of the expression name is the variable declared by the declaration. If the expression name appears in an assignment context, invocation context, or casting context, then the type of the expression name is the declared type of the field, local variable, or parameter after capture conversion (§5.1.10). Otherwise, the type of the expression name is the declared type of the field, local variable or parameter.",10.99,109.14,360.01,590,72,481.06,432.01,590.2,FALSE,FALSE
240,2,BODY,"The TypeName must be the canonical name (§6.7) of a class or interface. The class or interface must be either a member of a named package, or a member of a class or interface whose outermost lexically enclosing class or interface declaration (§8.1.3) is a member of a named package, or a compile-time error occurs. It is a compile-time error if the named class or interface is not accessible (§6.6). Two or more static-import-on-demand declarations in the same compilation unit may name the same class or interface; the effect is as if there was exactly one such declaration. Two or more static-import-on-demand declarations in the same compilation unit may name the same member; the effect is as if the member was imported exactly once. It is permissible for one static-import-on-demand declaration to import several fields, classes, or interfaces with the same name, or several methods with the same name and signature. This occurs when the named class or interface inherits multiple fields, member classes, member interfaces, or methods, all with the same name, from its own supertypes. If a compilation unit contains both a static-import-on-demand declaration and a type-import-on-demand declaration (§7.5.2) that name the same class or interface, the effect is as if the static member classes and interfaces of that class or interface (§8.5, §9.5) are imported only once.",10.99,302.14,360.01,1376,72,113.06,432.01,415.2,FALSE,FALSE
243,5,BODY,"A module declaration introduces a module name that can be used in other module declarations to express relationships between modules. A module name consists of one or more Java identifiers (§3.8) separated by '.' tokens. There are two kinds of modules: normal modules and open modules. The kind of a module determines the nature of access to the module's types, and the members of those types, for code outside the module.",10.99,77.14,360.01,422,72,519.06,432.01,596.2,FALSE,FALSE
295,4,BODY,"The FormalParameterList clause is described in §8.4.1, the MethodModifier clause in §8.4.3, the TypeParameters clause in §8.4.4, the Result clause in §8.4.5, the Throws clause in §8.4.6, and the MethodBody in §8.4.7. The Identifier in a MethodDeclarator may be used in a name to refer to the method (§6.5.7.1, §15.12). The scope and shadowing of a method declaration is specified in §6.3 and §6.4.1. The receiver parameter is an optional syntactic device for an instance method or an inner class's constructor. For an instance method, the receiver parameter represents the object for which the method is invoked. For an inner class's constructor, the receiver parameter represents the immediately enclosing instance of the newly constructed object. In both cases, the receiver parameter exists solely to allow the type of the represented object to be denoted in source code, so that the type may be annotated (§9.7.4). The receiver parameter is not a formal parameter; more precisely, it is not a declaration of any kind of variable (§4.12.3), it is never bound to any value passed as an argument in a method invocation expression or class instance creation expression, and it has no effect whatsoever at run time. A receiver parameter may appear either in the MethodDeclarator of an instance method or in the ConstructorDeclarator of a constructor of an inner class where the inner class is not declared in a static context (§8.1.3). If a receiver parameter appears in any other kind of method or constructor, then a compile-time error occurs. The type and name of a receiver parameter are constrained as follows: •In an instance method, the type of the receiver parameter must be the class or interface in which the method is declared, and the name of the receiver parameter must be this; otherwise, a compile-time error occurs. •In an inner class's constructor, the type of the receiver parameter must be the class or interface which is the immediately enclosing type declaration of the inner class, and the name of the receiver parameter must be Identifier . this where Identifier is the simple name of the class or interface which is the immediately enclosing type declaration of the inner class; otherwise, a compile-time error occurs.",10.99,438.14,360.01,2241,72,165.06,432.01,603.2,FALSE,FALSE
296,3,BODY,"8.4.1Formal Parameters The formal parameters of a method or constructor, if any, are specified by a list of comma-separated parameter specifiers. Each parameter specifier consists of a type (optionally preceded by the final modifier and/or one or more annotations) and an identifier (optionally followed by brackets) that specifies the name of the parameter. If a method or constructor has no formal parameters, and no receiver parameter, then an empty pair of parentheses appears in the declaration of the method or constructor.",10.99,124.11,360,529,72,179.09,432,303.2,FALSE,FALSE
297,4,BODY,"If the last formal parameter of a method is a variable arity parameter, the method is a variable arity method. Otherwise, it is a fixed arity method. The rules concerning annotation modifiers for a formal parameter declaration and for a receiver parameter are specified in §9.7.4 and §9.7.5. It is a compile-time error if final appears more than once as a modifier for a formal parameter declaration. The scope and shadowing of a formal parameter is specified in §6.3 and §6.4. References to a formal parameter from a nested class or interface, or a lambda expression, are restricted, as specified in §6.5.6.1. Every declaration of a formal parameter of a method or constructor must include an Identifier, otherwise a compile-time error occurs. It is a compile-time error for a method or constructor to declare two formal parameters with the same name. (That is, their declarations mention the same Identifier.) It is a compile-time error if a formal parameter that is declared final is assigned to within the body of the method or constructor. The declared type of a formal parameter depends on whether it is a variable arity parameter: •If the formal parameter is not a variable arity parameter, then the declared type is denoted by UnannType if no bracket pairs appear in UnannType and VariableDeclaratorId, and specified by §10.2 otherwise. •If the formal parameter is a variable arity parameter, then the declared type is an array type specified by §10.2. If the declared type of a variable arity parameter has a non-reifiable element type (§4.7), then a compile-time unchecked warning occurs for the declaration",10.99,384.14,360.01,1617,72,195.06,432.01,579.2,FALSE,FALSE
321,2,BODY,"8.4.9Overloading If two methods of a class (whether both declared in the same class, or both inherited by a class, or one declared and one inherited) have the same name but signatures that are not override-equivalent, then the method name is said to be overloaded. This fact causes no difficulty and never of itself results in a compile-time error. There is no required relationship between the return types or between the throws clauses of two methods with the same name, unless their signatures are override- equivalent. When a method is invoked (§15.12), the number of actual arguments (and any explicit type arguments) and the compile-time types of the arguments are used, at compile time, to determine the signature of the method that will be invoked (§15.12.2). If the method that is to be invoked is an instance method, the actual method to be invoked will be determined at run time, using dynamic method lookup (§15.12.4).",10.99,195.11,360.01,930,72,76.09,432.01,271.2,FALSE,FALSE
333,6,BODY,"2.After determining the immediately enclosing instance of i with respect to S (if any), evaluation of the superclass constructor invocation statement proceeds by evaluating the arguments to the constructor, left-to-right, as in an ordinary method invocation; and then invoking the constructor.",10.99,45.14,360,293,72,451.06,432,496.2,FALSE,FALSE
339,6,BODY,"The rules concerning annotation modifiers for an enum constant declaration are specified in §9.7.4 and §9.7.5. The Identifier in an EnumConstant provides the name of an implicit field of the enum class (§8.9.3) that can be used to refer to the enum constant. An enum constant may be followed by arguments, which are passed to the constructor of the enum when the constant is created during class initialization as described later in this section. The constructor to be invoked is chosen using the normal rules of overload resolution (§15.12.2). If the arguments are omitted, an empty argument list is assumed. The optional class body of an enum constant implicitly declares an anonymous class (§15.9.5) that (i) is a direct subclass of the immediately enclosing enum class (§8.1.4), and (ii) is final (§8.1.1.2). The class body is governed by the usual rules of anonymous classes; in particular it cannot contain any constructors. Instance",10.99,180.14,360.01,939,72,405.06,432.01,585.2,FALSE,FALSE
357,5,BODY,"It is a compile-time error for a record declaration to have more than one compact constructor declaration. The formal parameters of a compact constructor of a record class are implicitly declared. They are given by the derived formal parameter list of the record class (§8.10.4). The compact constructor of a record class is a variable arity constructor (§8.8.1) if the record class has a variable arity record component. The signature of a compact constructor declaration is equal to the derived constructor signature of the record class (§8.10.4.1). The body of a compact constructor declaration must satisfy all of the following conditions, or a compile-time error occurs: •The body must not contain a return statement (§14.17). •The body must not contain an explicit constructor invocation statement (§8.8.7.1). •The body must not contain an assignment to a component field of the record class. •All the other rules for a constructor in a normal class declaration must be satisfied (§8.8), except for the requirement that the component fields of the record class",10.99,275.14,360.01,1066,72,316.2,432.01,591.33,FALSE,FALSE
400,5,BODY,"An annotation on an annotation interface declaration is known as a meta- annotation. An annotation of interface A may appear as a meta-annotation on the declaration of the interface A itself. More generally, circularities in the transitive closure of the 'annotates' relation are permitted.",10.99,64.14,360,290,72,253.06,432,317.2,FALSE,FALSE
404,2,BODY,"•If the annotation's interface is applicable in the declaration context corresponding to the declaration, and not in type contexts, then the annotation is deemed to apply only to the declaration. •If the annotation's interface is applicable in type contexts, and not in the declaration context corresponding to the declaration, then the annotation is deemed to apply only to the type which is closest to the annotation. •If the annotation's interface is applicable in the declaration context corresponding to the declaration and in type contexts, then the annotation is deemed to apply to both the declaration and the type which is closest to the annotation. In the second and third cases above, the type which is closest to the annotation is determined as follows: •If the annotation appears before a void method declaration or a variable declaration that uses var (§14.4, §15.27.1), then there is no closest type. If the annotation's interface is deemed to apply only to the type which is closest to the annotation, a compile-time error occurs. •If the annotation appears before a constructor declaration, then the closest type is the type of the newly constructed object. The type of the newly constructed object is the fully qualified name of the type immediately enclosing the constructor declaration. Within that fully qualified name, the annotation applies to the simple type name indicated by the constructor declaration. •In all other cases, the closest type is the type written in source code for the declared entity; if that type is an array type, then the element type is deemed to be closest to the annotation.",10.99,328.14,360.01,1623,72,76.06,432.01,404.2,FALSE,FALSE
456,3,BODY,"12.5Creation of New Class Instances A new class instance is explicitly created when evaluation of a class instance creation expression (§15.9) causes a class to be instantiated. A new class instance may be implicitly created in the following situations: •Loading of a class or interface that contains a string literal (§3.10.5) or a text block (§3.10.6) may create a new String object to denote the string represented by the string literal or text block. (This object creation will not occur if an instance of String denoting the same sequence of Unicode code points as the string represented by the string literal or text block has previously been interned.) •Execution of an operation that causes boxing conversion (§5.1.7). Boxing conversion may create a new object of a wrapper class (Boolean, Byte, Short, Character, Integer, Long, Float, Double) associated with one of the primitive types. •Execution of a string concatenation operator + (§15.18.1) that is not part of a constant expression (§15.29) always creates a new String object to represent the result. String concatenation operators may also create temporary wrapper objects for a value of a primitive type. •Evaluation of a method reference expression (§15.13.3) or a lambda expression (§15.27.4) may require that a new instance be created of a class that implements a functional interface type (§9.8). Each of these situations identifies a particular constructor (§8.8) to be called with specified arguments (possibly none) as part of the class instance creation process. Whenever a new class instance is created, memory space is allocated for it with room for all the instance variables declared in the class and all the instance variables declared in each superclass of the class, including all the instance variables that may be hidden (§8.3). If there is not sufficient space available to allocate memory for the object, then creation of the class instance completes abruptly with an OutOfMemoryError.",10.99,422.64,360.01,1971,72,177.56,432.01,600.2,FALSE,FALSE
461,3,BODY,"12.6.1Implementing Finalization Every object can be characterized by two attributes: it may be reachable, finalizer- reachable, or unreachable, and it may also be unfinalized, finalizable, or finalized. A reachable object is any object that can be accessed in any potential continuing computation from any live thread. A finalizer-reachable object can be reached from some finalizable object through some chain of references, but not from any live thread. An unreachable object cannot be reached by either means. An unfinalized object has never had its finalizer automatically invoked. A finalized object has had its finalizer automatically invoked. A finalizable object has never had its finalizer automatically invoked, but the Java Virtual Machine may eventually automatically invoke its finalizer. An object o is not finalizable until its constructor has invoked the constructor for Object on o and that invocation has completed successfully (that is, without throwing an exception). Every pre-finalization write to a field of an object must be visible to the finalization of that object. Furthermore, none of the pre-finalization reads of fields of that object may see writes that occur after finalization of that object is initiated. Optimizing transformations of a program can be designed that reduce the number of objects that are reachable to be less than those which would naively be considered reachable. For example, a Java compiler or code generator may choose to set a variable or parameter that will no longer be used to null to cause the storage for such an object to be potentially reclaimable sooner. Another example of this occurs if the values in an object's fields are stored in registers. The program may then access the registers instead of the object, and never access the object again. This would imply that the object is garbage. Note that this sort of optimization is only allowed if references are on the stack, not stored in the heap.",10.99,419.11,360.01,1963,72,173.09,432.01,592.2,FALSE,FALSE
469,3,BODY,"following constraints: •The binary name of a top level class or interface (§7.6) is its canonical name (§6.7). •The binary name of a member class or interface (§8.5, §9.5) consists of the binary name of its immediately enclosing class or interface, followed by $, followed by the simple name of the member. •The binary name of a local class or interface (§14.3) consists of the binary name of its immediately enclosing class or interface, followed by $, followed by a non-empty sequence of digits, followed by the simple name of the local class. •The binary name of an anonymous class (§15.9.5) consists of the binary name of its immediately enclosing class or interface, followed by $, followed by a non-empty sequence of digits. •The binary name of a type variable declared by a generic class or interface (§8.1.2, §9.1.2) is the binary name of its immediately enclosing class or interface, followed by $, followed by the simple name of the type variable. •The binary name of a type variable declared by a generic method (§8.4.4) is the binary name of the class or interface declaring the method, followed by $, followed by the descriptor of the method (JVMS §4.3.3), followed by $, followed by the simple name of the type variable. •The binary name of a type variable declared by a generic constructor (§8.8.4) is the binary name of the class declaring the constructor, followed by $, followed by the descriptor of the constructor (JVMS §4.3.3), followed by $, followed by the simple name of the type variable.",10.99,347.14,342.01,1513,90,89.06,432.01,436.2,FALSE,FALSE
470,2,BODY,The class should have code to set the field's value to V during instance creation (§12.5).,10.99,19.14,342,90,90,76.06,432,95.2,FALSE,FALSE
492,5,BODY,"13.4.22Method and Constructor Body Changes to the body of a method or constructor do not break compatibility with pre-existing binaries. The keyword final on a method does not mean that the method can be safely inlined; it means only that the method cannot be overridden. It is still possible that a new version of that method will be provided at link-time. Furthermore, the structure of the original program must be preserved for purposes of reflection. Therefore, we note that a Java compiler cannot expand a method inline at compile time. In general we suggest that implementations use late-bound (run-time) code generation and optimization.",10.99,143.11,360.01,644,72,326.09,432.01,469.2,FALSE,FALSE
499,2,BODY,"THE sequence of execution of a program is controlled by statements, which are executed for their effect and do not have values. Some statements contain other statements as part of their structure; such other statements are substatements of the statement. We say that statement S immediately contains statement U if there is no statement T different from S and U such that S contains T and T contains U. In the same manner, some statements contain expressions (§15 (Expressions)) as part of their structure. The first section of this chapter discusses the distinction between normal and abrupt completion of statements (§14.1). Most of the remaining sections explain the various kinds of statements, describing in detail both their normal behavior and any special treatment of abrupt completion. Blocks are explained first (§14.2), both because they can appear in certain places where statements are not allowed and because one kind of statement, a local variable declaration statement (§14.4.2), must be immediately contained by a block. Local class and interface declarations (§14.3) are not statements, but must also be immediately contained by a block. Next, a grammatical maneuver that sidesteps the familiar 'dangling else' problem (§14.5) is explained. Every statement must be reachable in a certain technical sense (§14.22). Sections 14.23-14.29 are unused to allow for the introduction of new kinds of statements in future. The last section of this chapter (§14.30) describes patterns, which are used within statements and expressions to conditionally declare and initialize local variables. A pattern gives a concise description of how one value, such as an object, could",10.99,347.14,360,1680,72,254.36,432,601.5,FALSE,FALSE
511,5,BODY,ExpressionStatement: StatementExpression ; StatementExpression: Assignment PreIncrementExpression PreDecrementExpression PostIncrementExpression PostDecrementExpression MethodInvocation ClassInstanceCreationExpression,10.99,134.05,159.72,217,90,215.13,249.72,349.18,FALSE,TRUE
551,4,BODY,"14.18The throw Statement A throw statement causes an exception (§11 (Exceptions)) to be thrown. The result is an immediate transfer of control (§11.3) that may exit multiple statements and multiple constructor, instance initializer, static initializer and field initializer evaluations, and method invocations until a try statement (§14.20) is found that catches the thrown value. If no such try statement is found, then execution of the thread (§17 (Threads and Locks)) that executed the throw is terminated (§11.3) after invocation of the uncaughtException method for the thread group to which the thread belongs. ThrowStatement: throw Expression ;",10.99,164.62,360,650,72,373.56,432,538.18,FALSE,FALSE
562,4,BODY,"The resource specification denotes the resources of the try-with-resources statement, either by declaring local variables with initializer expressions or by referring to existing variables. An existing variable is referred to by an expression name (§6.5.6) or a field access expression (§15.11). The rules for a local variable declared in a resource specification are specified in §14.4. In addition, all of the following must be true, or a compile-time error occurs: •The VariableDeclaratorList consists of a single VariableDeclarator.",10.99,96.14,360.01,536,72,506.06,432.01,602.2,FALSE,FALSE
577,4,BODY,"A pattern is nested in a record pattern if (1) it appears directly in the component pattern list of the record pattern, or (2) it is nested in a record pattern that appears directly in the component pattern list of the record pattern. A pattern is top level if it is not nested in a record pattern. A type pattern declares one local variable, known as a pattern variable. If the declaration includes an identifier then this specifies the name of the pattern variable, otherwise the pattern variable is called an unnamed pattern variable. The rules for a local variable declared in a type pattern are specified in §14.4. In addition, all of the following must be true, or a compile-time error occurs: •The LocalVariableType in a top level type pattern denotes a reference type (and furthermore is not var). •The VariableDeclaratorList consists of a single VariableDeclarator. •The VariableDeclarator has no initializer. •The VariableDeclaratorId has no bracket pairs. The type of a pattern variable declared in a top level type pattern is the reference type denoted by LocalVariableType. The type of a pattern variable declared in a nested type pattern is determined as follows: •If the LocalVariableType is UnannType then the type of the pattern variable is denoted by UnannType.",10.99,307.14,360.01,1279,72,266.06,432.01,573.2,FALSE,FALSE
583,2,BODY,"MUCH of the work in a program is done by evaluating expressions, either for their side effects, such as assignments to variables, or for their values, which can be used as arguments or operands in larger expressions, or to affect the execution sequence in statements, or both. This chapter specifies the meanings of expressions and the rules for their evaluation.",10.99,77.14,360.01,363,72,220.36,432.01,297.5,FALSE,FALSE
604,3,BODY,ClassOrInterfaceTypeToInstantiate: {Annotation} Identifier {. {Annotation} Identifier} [TypeArgumentsOrDiamond],10.99,32.05,232.47,111,90,126.13,322.47,158.18,FALSE,TRUE
605,3,BODY,"15.9.1Determining the Class being Instantiated If ClassOrInterfaceTypeToInstantiate ends with TypeArguments (rather than <>), then ClassOrInterfaceTypeToInstantiate must denote a well-formed parameterized type (§4.5), or a compile-time error occurs. If ClassOrInterfaceTypeToInstantiate ends with <>, but the class or interface denoted by the Identifier in ClassOrInterfaceTypeToInstantiate is not generic, then a compile-time error occurs. If the class instance creation expression ends in a class body, then the class being instantiated is an anonymous class. Then: •If the class instance creation expression is unqualified, then: The Identifier in ClassOrInterfaceTypeToInstantiate must denote either a class that is accessible, freely extensible (§8.1.1.2), and not an enum class, or an",10.99,181.11,360,790,72,391.09,432,572.2,FALSE,FALSE
608,3,BODY,"–If the class instance creation expression is qualified, then the immediately enclosing instance of i is the object that is the value of the Primary expression or the ExpressionName.",10.99,32.14,350,182,82,319.06,432,351.2,FALSE,FALSE
613,4,BODY,"If C is an anonymous class, then its direct superclass type or direct superinterface type is the return type determined for mj (§15.12.2.6). It is a compile-time error if the direct superclass type or direct superinterface type, or any subexpression therein ('subexpression' includes type arguments of parameterized types, bounds of wildcard type arguments, and element types of array types, but excludes bounds of type variables), has one of the following forms: –A type variable that was not declared as a type parameter (such as a type variable produced by capture conversion). –An intersection type. –A class or interface type, where the class or interface declaration is not accessible from the class or interface in which the class instance creation expression appears.",10.99,186.14,350.01,775,82,381.06,432.01,567.2,FALSE,FALSE
616,6,BODY,"15.9.5.1Anonymous Constructors An anonymous class cannot have an explicitly declared constructor. Instead, an anonymous constructor is implicitly declared for an anonymous class. The form of the anonymous constructor for an anonymous class C with direct superclass S is as follows:",10.99,65.2,360,281,72,535.13,432,600.33,FALSE,FALSE
650,6,BODY,"•Otherwise, the method invocation is ambiguous, and a compile-time error occurs. 15.12.2.6Method Invocation Type The invocation type of a most specific accessible and applicable method is a method type (§8.2) which expresses the target types of the invocation arguments, the result (return type or void) of the invocation, and the exception types of the invocation. It is determined as follows: •If the chosen method is generic and the method invocation does not provide explicit type arguments, the invocation type is inferred as specified in §18.5.2. In this case, if the method invocation expression is a poly expression, then its compatibility with a target type is as determined by §18.5.2.1.",10.99,156.27,360.01,697,72,389.06,432.01,545.33,FALSE,FALSE
675,4,BODY,"15.13.3Run-Time Evaluation of Method References At run time, evaluation of a method reference expression is similar to evaluation of a class instance creation expression, insofar as normal completion produces a reference to an object. Evaluation of a method reference expression is distinct from invocation of the method itself. First, if the method reference expression begins with an ExpressionName or a Primary, this subexpression is evaluated. If the subexpression evaluates to null, a",10.99,98.11,360,489,72,494.09,432,592.2,FALSE,FALSE
682,3,BODY,"15.15.1Prefix Increment Operator ++ A unary expression preceded by a ++ operator is a prefix increment expression. The result of the unary expression must be a variable of a type that is convertible (§5.1.8) to a numeric type, or a compile-time error occurs. The type of the prefix increment expression is the type of the variable. The result of the prefix increment expression is not a variable, but a value. At run time, if evaluation of the operand expression completes abruptly, then the prefix increment expression completes abruptly for the same reason and no incrementation occurs. Otherwise, the value 1 is added to the value of the variable and the sum is stored back into the variable. Before the addition, binary numeric promotion (§5.6) is performed on the value 1 and the value of the variable. If necessary, the sum is narrowed by a narrowing primitive conversion (§5.1.3) and/ or subjected to boxing conversion (§5.1.7) to the type of the variable before it is stored. The value of the prefix increment expression is the value of the variable after the new value is stored.",10.99,214.11,360.01,1088,72,165.09,432.01,379.2,FALSE,FALSE
683,2,BODY,"At run time, if evaluation of the operand expression completes abruptly, then the prefix decrement expression completes abruptly for the same reason and no decrementation occurs. Otherwise, the value 1 is subtracted from the value of the variable and the difference is stored back into the variable. Before the subtraction, binary numeric promotion (§5.6) is performed on the value 1 and the value of the variable. If necessary, the difference is narrowed by a narrowing primitive conversion (§5.1.3) and/or subjected to boxing conversion (§5.1.7) to the type of the variable before it is stored. The value of the prefix decrement expression is the value of the variable after the new value is stored.",10.99,110.14,360.01,701,72,76.06,432.01,186.2,FALSE,FALSE
683,5,BODY,"15.15.3Unary Plus Operator + The type of the operand expression of the unary + operator must be a type that is convertible (§5.1.8) to a primitive numeric type, or a compile-time error occurs. Unary numeric promotion (§5.6) is performed on the operand. The type of the unary plus expression is the promoted type of the operand. The result of the unary plus expression is not a variable, but a value, even if the result of the operand expression is a variable. At run time, the value of the unary plus expression is the promoted value of the operand.",10.99,130.11,360.01,549,72,295.09,432.01,425.2,FALSE,FALSE
683,6,BODY,"15.15.4Unary Minus Operator - The type of the operand expression of the unary - operator must be a type that is convertible (§5.1.8) to a primitive numeric type, or a compile-time error occurs. Unary numeric promotion (§5.6) is performed on the operand. The type of the unary minus expression is the promoted type of the operand. At run time, the value of the unary minus expression is the arithmetic negation of the promoted value of the operand. For integer values, negation is the same as subtraction from zero. The Java programming language uses two's-complement representation for integers, and the",10.99,142.11,360,603,72,451.09,432,593.2,FALSE,FALSE
704,2,BODY,InclusiveOrExpression: ExclusiveOrExpression InclusiveOrExpression | ExclusiveOrExpression,10.99,32.05,224.97,90,90,76.13,314.97,108.18,FALSE,TRUE
752,1,BODY,"•V is not definitely assigned and is not definitely unassigned. (The rules cannot prove whether or not an assignment to V has occurred.) •V is definitely assigned and is definitely unassigned. (It is impossible for the statement or expression to complete normally.) To shorten the rules, the customary abbreviation 'iff' is used to mean 'if and only if'. We also use an abbreviation convention: if a rule contains one or more occurrences of '[un]assigned' then it stands for two rules, one with every occurrence of '[un]assigned' replaced by 'definitely assigned' and one with every occurrence of '[un]assigned' replaced by 'definitely unassigned'.",10.99,134.14,360,648,72,76.06,432,210.2,FALSE,FALSE
760,5,BODY,16.2.1Empty Statements •V is [un]assigned after an empty statement (§14.6) iff it is [un]assigned before the empty statement.,10.99,40.11,360,125,72,485.09,432,525.2,FALSE,FALSE
784,2,BODY,"17.4.1Shared Variables Memory that can be shared between threads is called shared memory or heap memory. All instance fields, static fields, and array elements are stored in heap memory. In this chapter, we use the term variable to refer to both fields and array elements. Local variables (§14.4), formal method parameters (§8.4.1), and exception handler parameters (§14.20) are never shared between threads and are unaffected by the memory model. Two accesses to (reads of or writes to) the same variable are said to be conflicting if at least one of the accesses is a write.",10.99,149.11,360.01,576,72,76.09,432.01,225.2,FALSE,FALSE
830,2,BODY,"constraints outside of the cycle (or cycles) are considered. A single constraint is selected from these considered constraints, as follows: –If any of the considered constraints have the form ‹Expression → T›, then the selected constraint is the considered constraint of this form that contains the expression to the left (§3.5) of the expression of every other considered constraint of this form. –If no considered constraint has the form ‹Expression → T›, then the selected constraint is the considered constraint that contains the expression to the left of the expression of every other considered constraint.",10.99,122.14,332,612,100,76.06,432,198.2,FALSE,FALSE
863,3,BODY,ClassOrInterfaceTypeToInstantiate: {Annotation} Identifier {. {Annotation} Identifier} [TypeArgumentsOrDiamond],10.99,32.05,232.47,111,90,493.13,322.47,525.18,FALSE,TRUE
19,2,BODY,"loopholes in the language; casts on reference types are checked at run time to ensure type safety. Chapter 6 describes declarations and names, and how to determine what names mean (that is, which declaration a name denotes). The Java programming language does not require classes and interfaces, or their members, to be declared before they are used. Declaration order is significant only for local variables, local classes, local interfaces, and the order of field initializers in a class or interface. Recommended naming conventions that make for more readable programs are described here. Chapter 7 describes the structure of a program, which is organized into packages. The members of a package are classes, interfaces, and subpackages. Packages, and consequently their members, have names in a hierarchical name space; the Internet domain name system can usually be used to form unique package names. Compilation units contain declarations of the classes and interfaces that are members of a given package, and may import classes and interfaces from other packages to give them short names. Packages may be grouped into modules that serve as building blocks in the construction of very large programs. The declaration of a module specifies which other modules (and thus packages, and thus classes and interfaces) are required in order to compile and run code in its own packages. The Java programming language supports limitations on external access to the members of packages, classes, and interfaces. The members of a package may be accessible solely by other members in the same package, or by members in other packages of the same module, or by members of packages in different modules. Similar constraints apply to the members of classes and interfaces. Chapter 8 describes classes. The members of classes are classes, interfaces, fields (variables) and methods. Class variables exist once per class. Class methods operate without reference to a specific object. Instance variables are dynamically created in objects that are instances of classes. Instance methods are invoked on instances of classes; such instances become the current object this during their execution, supporting the object-oriented programming style. Classes support single inheritance, in which each class has a single superclass. Each class inherits members from its superclass, and ultimately from the class Object. Variables of a class type can reference an instance of the named class or any subclass of that class, allowing new classes to be used with existing methods, polymorphically. Classes support concurrent programming with synchronized methods. Methods declare the checked exceptions that can arise from their execution, which allows",10.98,516.14,360.01,2728,72,76.06,432.01,592.2,FALSE,FALSE
23,5,BODY,"1.4Relationship to Predefined Classes and Interfaces As noted above, this specification often refers to classes and interfaces of the Java SE Platform API. In particular, some classes and interfaces have a special relationship with the Java programming language. Examples include classes such as Object, Class, ClassLoader, String, and Thread, and the classes and interfaces in the package java.lang.reflect, among others. This specification constrains the behavior of such classes and interfaces, but does not provide a complete specification for them. The reader is referred to the Java SE Platform API documentation. Consequently, this specification does not describe reflection in any detail. Many linguistic constructs have analogs in the Core Reflection API (java.lang.reflect) and the Language Model API (javax.lang.model), but these are generally not discussed here. For example, when we list the ways in which an object can be created, we generally do not include the ways in which the Core Reflection API can accomplish this. Readers should be aware of these additional mechanisms even though they are not mentioned in the text.",10.98,224.64,360.01,1138,72,294.56,432.01,519.2,FALSE,FALSE
37,2,BODY,"are two exceptions to account for situations that need more granular translation: in step 1, for the processing of contiguous \ characters (§3.3), and in step 3, for the processing of contextual keywords and adjacent > characters (§3.5).",10.98,32.14,360,237,72,76.06,432,108.2,FALSE,FALSE
38,8,BODY,"If an eligible \ is not followed by u, then it is treated as a RawInputCharacter and remains part of the escaped Unicode stream. If an eligible \ is followed by u, or more than one u, and the last u is not followed by four hexadecimal digits, then a compile-time error occurs. The character produced by a Unicode escape does not participate in further Unicode escapes.",10.98,83.14,360,368,72,456.2,432,539.33,FALSE,FALSE
100,5,BODY,"4.10.2Subtyping among Class and Interface Types Given a non-generic class or interface C, the direct supertypes of the type of C are all of the following:",10.98,40.11,360,154,72,557.09,432,597.2,FALSE,FALSE
109,2,BODY,"•The element type of an array type in any of the above contexts; and •A non-wildcard type argument, or a bound of a wildcard type argument, of a parameterized type in any of the above contexts. Finally, there are three special terms in the Java programming language which denote the use of a type: •An unbounded wildcard (§4.5.1) •The ... in the type of a variable arity parameter (§8.4.1), to indicate an array type •The simple name of a type in a constructor declaration (§8.8), to indicate the class of the constructed object The meaning of types in type contexts is given by: •§4.2, for primitive types •§4.4, for type parameters •§4.5, for class and interface types that are parameterized, or appear either as type arguments in a parameterized type or as bounds of wildcard type arguments in a parameterized type •§4.8, for class and interface types that are raw •§4.9, for intersection types in the bounds of type parameters •§6.5, for types of non-generic classes, interfaces, and type variables •§10.1, for array types Some type contexts restrict how a reference type may be parameterized: •The following type contexts require that if a type is a parameterized reference type, it has no wildcard type arguments: –In an extends or implements clause of a class declaration (§8.1.4, §8.1.5) –In an extends clause of an interface declaration (§9.1.3) –In an unqualified class instance creation expression, as the class type to be instantiated (§15.9) or as the direct superclass type or direct superinterface type of an anonymous class to be instantiated (§15.9.5) –In a method reference expression (§15.13), as the reference type to search for a member method or as the class type or array type to construct. In addition, no wildcard type arguments are permitted in the explicit type argument list to an explicit constructor invocation statement or class instance",10.98,516.14,360.01,1868,72,76.06,432.01,592.2,FALSE,FALSE
113,2,BODY,4.12.2Variables of Reference Type A variable of a class type T can hold a null reference or a reference to an instance of class T or of any class that is a subclass of T. A variable of an interface type can hold a null reference or a reference to any instance of any class that implements the interface.,10.98,72.11,359.99,303,72,76.09,431.99,148.2,FALSE,FALSE
127,1,BODY,"•Strict invocation contexts (§5.3, §15.9, §15.12), in which an argument is bound to a formal parameter of a constructor or method. Widening primitive, widening reference, and unchecked conversions may occur. •Loose invocation contexts (§5.3, §15.9, §15.12), in which, like strict invocation contexts, an argument is bound to a formal parameter. Method or constructor invocations may provide this context if no applicable declaration can be found using only strict invocation contexts. In addition to widening and unchecked conversions, this context allows boxing and unboxing conversions to occur. •String contexts (§5.4, §15.18.1), in which a value of any type is converted to an object of type String. •Casting contexts (§5.5), in which an expression's value is converted to a type explicitly specified by a cast operator (§15.16). Casting contexts are more inclusive than assignment or loose invocation contexts, allowing any specific conversion other than a string conversion, but certain casts to a reference type are checked for correctness at run time. •Numeric contexts (§5.6), in which the operands of a numeric operator or some other expressions that operate on numbers may be widened to a common type. •Testing contexts (§5.7), in which an expression's value is converted to a type explicitly specified by a pattern (§14.30). Testing contexts are more inclusive than assignment or loose invocation contexts, but not as inclusive as casting contexts. The term 'conversion' is also used to describe, without being specific, any conversions allowed in a particular context. For example, we say that an expression that is the initializer of a local variable is subject to 'assignment conversion', meaning that a specific conversion will be implicitly chosen for that expression according to the rules for the assignment context. As another example, we say that an expression undergoes 'casting conversion' to mean that the expression's type will be converted as permitted in a casting context.",10.98,393.14,360.01,2000,72,76.06,432.01,469.2,FALSE,FALSE
133,6,BODY,"5.1.5Widening Reference Conversion A widening reference conversion exists from any reference type S to any reference type T, provided S is a subtype of T (§4.10). Widening reference conversions never require a special action at run time and therefore never throw an exception at run time. They consist simply in regarding a reference as having some other type in a manner that can be proved correct at compile time.",10.98,98.11,360,415,72,399.09,432,497.2,FALSE,FALSE
168,2,BODY,"•A local class or interface (§14.3), one of the following: –A local class declared by a normal class declaration –A local class declared by an enum declaration –A local class declared by an record declaration –A local interface declared by a normal interface declaration Constructors (§8.8, §8.10.4) are also introduced by declarations, but use the name of the class in which they are declared rather than introducing a new name. A declaration commonly includes an identifier (§3.8) that can be used in a name to refer to the declared entity. The identifier is constrained to avoid certain contextual keywords when the entity being introduced is a class, interface, or type parameter. If a declaration does not include an identifier, but instead includes the keyword _ (underscore), then the entity cannot be referred to by name. The following kinds of entity may be declared using an underscore: •A local variable, one of the following: –A local variable declared by a local variable declaration statement (§14.4.2) –A local variable declared by a for statement or a try-with-resources statement (§14.14, §14.20.3) –A local variable declared by a pattern (§14.30.1) •An exception parameter of an exception handler declared in a catch clause of a try statement (§14.20) •A formal parameter of a lambda expression (§15.27.1) A local variable, exception parameter, or lambda parameter that is declared using an underscore is called an unnamed local variable, unnamed exception parameter, or unnamed lambda parameter, respectively.",10.98,389.14,360.01,1528,72,76.06,432.01,465.2,FALSE,FALSE
199,3,BODY,A name is syntactically classified as an ExpressionName in these contexts: •As the qualifying expression in a qualified superclass constructor invocation (§8.8.7.1) •As the qualifying expression in a qualified class instance creation expression (§15.9) •As the array reference expression in an array access expression (§15.10.3) •As a PostfixExpression (§15.14) •As the left-hand operand of an assignment operator (§15.26) •As a VariableAccess in a try-with-resources statement (§14.20.3) A name is syntactically classified as a MethodName in this context: •Before the '(' in a method invocation expression (§15.12) A name is syntactically classified as a PackageOrTypeName in these contexts: •To the left of the '.' in a qualified TypeName •In a type-import-on-demand declaration (§7.5.2) A name is syntactically classified as an AmbiguousName in these contexts: •To the left of the '.' in a qualified ExpressionName •To the left of the rightmost . that occurs before the '(' in a method invocation expression •To the left of the '.' in a qualified AmbiguousName •In the default value clause of an annotation element declaration (§9.6.2) •To the right of an '=' in an element-value pair (§9.7.1) •To the left of :: in a method reference expression (§15.13),10.98,387.14,360,1257,72,190.06,432,577.2,FALSE,FALSE
205,8,BODY,"6.5.6Meaning of Expression Names The meaning of a name classified as an ExpressionName is determined as follows. 6.5.6.1Simple Expression Names If an expression name consists of a single Identifier, then: •If the expression name appears as a CaseConstant in a switch label (§14.11.1), and the type of the selector expression of the enclosing switch statement or switch expression is an enum class type (§8.9), and the enum class declares an enum constant with name Identifier, then the expression name refers to the corresponding implicit field of the enum class. •Otherwise, if there is exactly one declaration denoting either a local variable, formal parameter, exception parameter, or field in scope at the point at which the identifier occurs, then the expression name refers to the in-scope variable. •Otherwise, a compile-time error occurs. If the declaration denotes an instance variable of a class C (§8.3.1.1), then both of the following must be true, or a compile-time error occurs: •The expression name does not occur in a static context (§8.1.3).",10.98,260.24,360.01,1058,72,342.96,432.01,603.2,FALSE,FALSE
214,3,BODY,"6.6.1Determining Accessibility •If a top level class or interface (§7.6) is declared public and is a member of a package that is exported by a module, then the class or interface may be accessed by any code in the same module, and by any code in another module to which the package is exported, provided that the compilation unit in which the class or interface is declared is visible to that other module (§7.3). •If a top level class or interface is declared public and is a member of a package that is not exported by a module, then the class or interface may be accessed by any code in the same module. •If a top level class or interface is declared with package access, then it may be accessed only from within the package in which it is declared. A top level class or interface declared without an access modifier implicitly has package access. •A member (class, interface, field, or method) of a class, interface, type parameter, or reference type, or a constructor of a class, is accessible only if (i) the class,",10.98,220.11,360.01,1021,72,299.09,432.01,519.2,FALSE,FALSE
222,2,BODY,"•An array type has a fully qualified name if and only if its element type has a fully qualified name. In that case, the fully qualified name of an array type consists of the fully qualified name of the component type of the array type followed by '[]'. A local class, local interface, or anonymous class does not have a fully qualified name. Every primitive type, named package, top level class, and top level interface has a canonical name: •For every primitive type, named package, top level class, and top level interface, the canonical name is the same as the fully qualified name. Each member class, member interface, and array type may have a canonical name: •A member class or member interface M declared in another class or interface C has a canonical name if and only if C has a canonical name. In that case, the canonical name of M consists of the canonical name of C, followed by '.', followed by the simple name of M. •An array type has a canonical name if and only if its component type has a canonical name. In that case, the canonical name of the array type consists of the canonical name of the component type of the array type followed by '[]'. A local class, local interface, or anonymous class does not have a canonical name.",10.98,313.14,360.01,1244,72,76.06,432.01,389.2,FALSE,FALSE
226,2,BODY,"is declared public but is not a member of an exported package is accessible only to code inside the module. For small programs and casual development, a package can be unnamed (§7.4.2) or have a simple name, but if code is to be widely distributed, unique package names should be chosen using qualified names. This can prevent the conflicts that would otherwise occur if two development groups happened to pick the same package name and these packages were later to be used in a single program.",10.98,90.14,360,494,72,76.06,432,166.2,FALSE,FALSE
238,2,BODY,"The PackageOrTypeName must be the canonical name (§6.7) of a package, a class, or an interface. If the PackageOrTypeName denotes a class or interface (§6.5.4), then the class or interface must be either a member of a named package, or a member of a class or interface whose outermost lexically enclosing class or interface declaration (§8.1.3) is a member of a named package, or a compile-time error occurs. It is a compile-time error if the named package is not uniquely visible to the current module (§7.4.3), or if the named class or interface is not accessible (§6.6). It is not a compile-time error to name either java.lang or the named package of the current compilation unit in a type-import-on-demand declaration. The type-import- on-demand declaration is ignored in such cases. Two or more type-import-on-demand declarations in the same compilation unit may name the same package, class, or interface. All but one of these declarations are considered redundant; the effect is as if that type was imported only once. If a compilation unit contains both a type-import-on-demand declaration and a static-import-on-demand declaration (§7.5.4) that name the same class or interface, the effect is as if the static member classes and interfaces of that class or interface (§8.5, §9.5) are imported only once.",10.98,257.14,360.01,1311,72,76.06,432.01,333.2,FALSE,FALSE
239,4,BODY,"The TypeName must be the canonical name (§6.7) of a class or interface. The class or interface must be either a member of a named package, or a member of a class or interface whose outermost lexically enclosing class or interface declaration (§8.1.3) is a member of a named package, or a compile-time error occurs. It is a compile-time error if the named class or interface is not accessible (§6.6). The Identifier must name at least one static member of the named class or interface. It is a compile-time error if there is no static member of that name, or if all of the named members are not accessible. It is permissible for one single-static-import declaration to import several fields, classes, or interfaces with the same name, or several methods with the same name and signature. This occurs when the named class or interface inherits multiple fields, member classes, member interfaces, or methods, all with the same name, from its own supertypes. If two single-static-import declarations in the same compilation unit attempt to import classes or interface with the same simple name, then a compile-time error occurs, unless the two classes or interfaces are the same, in which case the duplicate declaration is ignored. If a single-static-import declaration imports a class or interface whose simple name is x, and the compilation unit also declares a top level class or interface (§7.6) whose simple name is x, a compile-time error occurs. If a compilation unit contains both a single-static-import declaration that imports a class or interface whose simple name is x, and a single-type-import declaration (§7.5.1) that imports a class or interface whose simple name is x, a compile-time error occurs, unless the two classes or interfaces are the same, in which case the duplicate declaration is ignored.",10.98,373.14,360.01,1813,72,150.06,432.01,523.2,FALSE,FALSE
260,4,BODY,"The rules concerning annotation modifiers for a type parameter declaration are specified in §9.7.4 and §9.7.5. In a class's type parameter section, a type variable T directly depends on a type variable S if S is the bound of T, while T depends on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively). It is a compile-time error if a type variable in a class's type parameter section depends on itself. The scope and shadowing of a class's type parameter is specified in §6.3 and §6.4.1. References to a class's type parameter from a static context or a nested class or interface are restricted, as specified in §6.5.5.1. A generic class declaration defines a set of parameterized types (§4.5), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same class at run time.",10.98,205.14,360.01,928,72,262.06,432.01,467.2,FALSE,FALSE
291,10,BODY,"8.3.3Restrictions on Field References in Initializers References to a field are sometimes restricted, even through the field is in scope. The following rules constrain forward references to a field (where the use textually precedes the field declaration) as well as self-reference (where the field is used in its own initializer). For a reference by simple name to a class variable f declared in class or interface C, it is a compile-time error if: •The reference appears either in a class variable initializer of C or in a static initializer of C (§8.7); and •The reference appears either in the initializer of f's own declarator or at a point to the left of f's declarator; and •The reference is not on the left hand side of an assignment expression (§15.26); and •The innermost class or interface enclosing the reference is C.",10.98,213.11,360,829,72,377.09,432,590.2,FALSE,FALSE
306,3,BODY,"8.4.5Method Result The result of a method declaration either declares the type of value that the method returns (the return type), or uses the keyword void to indicate that the method does not return a value.",10.98,53.11,360,208,72,437.09,432,490.2,FALSE,FALSE
326,5,BODY,"ConstructorDeclaration: {ConstructorModifier} ConstructorDeclarator [Throws] ConstructorBody ConstructorDeclarator: [TypeParameters] SimpleTypeName ( [ReceiverParameter ,] [FormalParameterList] )",10.98,69.05,338.13,195,90,377.13,428.13,446.18,FALSE,TRUE
327,5,BODY,"8.8.1Formal Parameters The formal parameters of a constructor are identical in syntax and semantics to those of a method (§8.4.1). If the last formal parameter of a constructor is a variable arity parameter, the constructor is a variable arity constructor. Otherwise, it is a fixed arity constructor. The constructor of a non-private inner member class implicitly declares, as the first formal parameter, a variable representing the immediately enclosing instance of the class (§15.9.2, §15.9.3).",10.98,117.11,360,496,72,326.09,432,443.2,FALSE,FALSE
363,2,BODY,"The rules concerning annotation modifiers for a type parameter declaration are specified in §9.7.4 and §9.7.5. In an interface's type parameter section, a type variable T directly depends on a type variable S if S is the bound of T, while T depends on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively). It is a compile-time error if a type variable in a interface's type parameter section depends on itself. The scope and shadowing of an interface's type parameter is specified in §6.3 and §6.4.1. References to an interface's type parameter from a static context or a nested class or interface are restricted, as specified in §6.5.5.1. A generic interface declaration defines a set of parameterized types (§4.5), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same interface at run time.",10.98,199.14,360,955,72,76.06,432,275.2,FALSE,FALSE
368,5,BODY,"The declared type of a field is denoted by UnannType if no bracket pairs appear in UnannType and VariableDeclaratorId, and is specified by §10.2 otherwise. Every declaration of an interface field must include an Identifier, or a compile-time error occurs. The scope and shadowing of an interface field declaration is specified in §6.3 and §6.4.1. Because an interface field is static, its declaration introduces a static context (§8.1.3), which limits the use of constructs that refer to the current object. Notably, the keywords this and super are prohibited in a static context (§15.8.3, §15.11.2), as are unqualified references to instance variables, instance methods, and type parameters of lexically enclosing declarations (§6.5.5.1, §6.5.6.1, §15.12.3). It is a compile-time error for the body of an interface declaration to declare two fields with the same name. If the interface declares a field with a certain name, then the declaration of that field is said to hide any and all accessible declarations of fields with the same name in superinterfaces of the interface. It is possible for an interface to inherit more than one field with the same name. Such a situation does not in itself cause a compile-time error. However, any attempt within the body of the interface declaration to refer to any such field by its simple name will result in a compile-time error, because the reference is ambiguous.",10.98,289.14,360.01,1409,72,301.06,432.01,590.2,FALSE,FALSE
376,3,BODY,"9.4.2Overloading If two methods of an interface (whether both declared in the same interface, or both inherited by an interface, or one declared and one inherited) have the same name but different signatures that are not override-equivalent (§8.4.2), then the method name is said to be overloaded. This fact causes no difficulty and never of itself results in a compile-time error. There is no required relationship between the return types or between the throws clauses of two methods with the same name but different signatures that are not override-equivalent.",10.98,124.11,360,563,72,115.09,432,239.2,FALSE,FALSE
381,7,BODY,"An annotation interface with no elements is called a marker annotation interface. An annotation interface with one element is called a single-element annotation interface. By convention, the name of the sole element in a single-element annotation interface is value. Linguistic support for this convention is provided by single- element annotations (§9.7.3).",10.98,83.14,360,358,72,508.06,432,591.2,FALSE,FALSE
404,4,BODY,"It is a compile-time error if an annotation of interface A is syntactically a modifier for: •a module declaration, but A is not applicable to module declarations. •a package declaration, but A is not applicable to package declarations.",10.98,57.14,360,235,72,531.06,432,588.2,FALSE,FALSE
406,4,BODY,"It is a compile-time error if an annotation of interface A applies to the outermost level of a type in a type context, and A is not applicable in type contexts or the declaration context (if any) which occupies the same syntactic location. It is a compile-time error if an annotation of interface A applies to a part of a type (that is, not the outermost level) in a type context, and A is not applicable in type contexts. It is a compile-time error if an annotation of interface A applies to a type (or any part of a type) in a type context, and A is applicable in type contexts, but the annotation is not admissible.",10.98,122.14,360.01,618,72,414.06,432.01,536.2,FALSE,FALSE
407,3,BODY,"9.7.5Multiple Annotations of the Same Interface It is a compile-time error if multiple annotations of the same interface A appear in a declaration context or type context, unless A is repeatable (§9.6.3) and both A and the containing annotation interface of A are applicable in the declaration context or type context (§9.6.4.1).",10.98,66.11,360,329,72,217.09,432,283.2,FALSE,FALSE
424,2,BODY,"Each variable initializer must be assignment-compatible (§5.2) with the array's component type, or a compile-time error occurs. It is a compile-time error if the component type of the array being initialized is not reifiable (§4.7). The length of the array to be constructed is equal to the number of variable initializers immediately enclosed by the braces of the array initializer. Space is allocated for a new array of that length. If there is insufficient space to allocate the array, evaluation of the array initializer completes abruptly by throwing an OutOfMemoryError. Otherwise, a one-dimensional array is created of the specified length, and each component of the array is initialized to its default value (§4.12.5). The variable initializers immediately enclosed by the braces of the array initializer are then executed from left to right in the textual order they occur in the source code. The n'th variable initializer specifies the value of the n-1'th array component. If execution of a variable initializer completes abruptly, then execution of the array initializer completes abruptly for the same reason. If all the variable initializer expressions complete normally, the array initializer completes normally, with the value of the newly initialized array. If the component type is an array type, then the variable initializer specifying a component may itself be an array initializer; that is, array initializers may be nested. In this case, execution of the nested array initializer constructs and initializes an array object by recursive application of the algorithm above, and assigns it to the component.",10.98,303.14,360.01,1626,72,76.06,432.01,379.2,FALSE,FALSE
443,2,BODY,"THIS chapter specifies activities that occur during execution of a program. It is organized around the life cycle of the Java Virtual Machine and of the classes, interfaces, and objects that form a program. The Java Virtual Machine starts up by loading a specified class or interface, then invoking the method main in this specified class or interface. Section §12.1 outlines the loading, linking, and initialization steps involved in executing main, as an introduction to the concepts in this chapter. Further sections specify the details of loading (§12.2), linking (§12.3), and initialization (§12.4). The chapter continues with a specification of the procedures for creation of new class instances (§12.5); and finalization of class instances (§12.6). It concludes by describing the unloading of classes (§12.7) and the procedure followed when a program exits (§12.8).",10.98,161.14,360,872,72,220.36,432,381.5,FALSE,FALSE
443,4,BODY,"The Java Virtual Machine starts execution by invoking the method main of some specified class or interface, passing it a single argument which is an array of strings. In the examples in this specification, this first class is typically called Test. The precise semantics of Java Virtual Machine startup are given in Chapter 5 of The Java Virtual Machine Specification, Java SE 23 Edition. Here we present an overview of the process from the viewpoint of the Java programming language. The manner in which the initial class or interface is specified to the Java Virtual Machine is beyond the scope of this specification, but it is typical, in host environments that use command lines, for the fully qualified name of the class or interface to be specified as a command line argument and for following command",10.98,135.14,360.01,807,72,448.36,432.01,583.5,FALSE,FALSE
457,4,BODY,"2.If this constructor begins with an explicit constructor invocation (§8.8.7.1) of another constructor in the same class (using this), then evaluate the arguments and process that constructor invocation recursively using these same five steps. If that constructor invocation completes abruptly, then this procedure completes abruptly for the same reason; otherwise, continue with step 5.",10.98,58.14,360,387,72,185.06,432,243.2,FALSE,FALSE
465,4,BODY,"A thread terminates if either (i) its run method completes normally, or (ii) its run method completes abruptly and the relevant uncaught exception handler (§11.3) completes normally or abruptly. With no code left to run, the thread has completed execution and therefore has no current method (JVMS §2.5.1). A program exits when one of the following situations has occurred: 1.All of its non-daemon threads have terminated, and all of the shutdown hooks which consequently were started by the Java Virtual Machine, if any, have terminated.",10.98,109.14,360.01,538,72,178.06,432.01,287.2,FALSE,FALSE
467,2,BODY,"DEVELOPMENT tools for the Java programming language should support automatic recompilation as necessary whenever source code is available. Particular implementations may also store the source and binary representations of classes and interfaces in a versioning database and implement a ClassLoader that uses integrity mechanisms of the database to prevent linkage errors by providing binary- compatible versions of classes and interfaces to clients. Developers of packages, classes, and interfaces that are to be widely distributed face a different set of problems. In the Internet, which is our favorite example of a widely distributed system, it is often impractical or impossible to automatically recompile the pre-existing binaries that directly or indirectly depend on a class or interface that is to be changed. Instead, this specification defines a set of changes that developers are permitted to make to a package or to a class or interface while preserving (not breaking) compatibility with pre-existing binaries. Within the framework of Release-to-Release Binary Compatibility in SOM (Forman, Conner, Danforth, and Raper, Proceedings of OOPSLA '95), Java programming language binaries are binary compatible under all relevant transformations that the authors identify (with some caveats with respect to the addition of instance variables). Using their scheme, here is a list of some important binary compatible changes that the Java programming language supports: •Reimplementing existing methods, constructors, and initializers to improve performance. •Changing methods or constructors to return values on inputs for which they previously either threw exceptions that normally should not occur or failed by going into an infinite loop or causing a deadlock. •Adding new fields, methods, or constructors to an existing class or interface. •Deleting private fields, methods, or constructors of a class.",10.98,367.14,360.01,1911,72,220.36,432.01,587.5,FALSE,FALSE
472,2,BODY,the erasure of the declared signature (§8.4.2) of the method. The signature of a method must include all of the following as determined by §15.12.3: •The simple name of the method •The number of parameters to the method •A symbolic reference to the type of each parameter A reference to a method must also include either a symbolic reference to the erasure of the return type of the denoted method or an indication that the denoted method is declared void and does not return a value.,10.98,121.14,342,484,90,76.06,432,197.2,FALSE,FALSE
489,3,BODY,"13.4.14Method and Constructor Formal Parameters Changing the name of a formal parameter of a method or constructor does not impact pre-existing binaries. Changing the name of a method, or the type of a formal parameter to a method or constructor, or adding a parameter to or deleting a parameter from a method or constructor declaration creates a method or constructor with a new signature, and has the combined effect of deleting the method or constructor with the old signature and adding a method or constructor with the new signature (§13.4.12). Changing the type of the last formal parameter of a method from T[] to a variable arity parameter of type T, that is, to T... (§8.4.1), and vice versa, does not impact pre-existing binaries. For purposes of binary compatibility, adding or deleting a method or constructor m whose signature involves type variables (§4.4) or parameterized types (§4.5) is equivalent to the addition (respectively, deletion) of an otherwise equivalent method whose signature is the erasure (§4.6) of the signature of m.",10.98,214.11,360.01,1050,72,366.09,432.01,580.2,FALSE,FALSE
501,4,BODY,Block: { [BlockStatements] } BlockStatements: BlockStatement {BlockStatement} BlockStatement: LocalClassOrInterfaceDeclaration LocalVariableDeclarationStatement Statement,10.98,119.05,170.11,170,90,379.13,260.11,498.18,FALSE,TRUE
506,1,BODY,"If the optional keyword final appears at the start of the declaration, the variable being declared is a final variable (§4.12.4). The declared type of a local variable is determined as follows: •If the LocalVariableType is UnannType, and no bracket pairs appear in UnannType or VariableDeclaratorId, then the type of the local variable is denoted by UnannType. •If the LocalVariableType is UnannType, and bracket pairs appear in UnannType or VariableDeclaratorId, then the type of the local variable is specified by §10.2. •If the LocalVariableType is var, then let T be the type of the initializer expression when treated as if it did not appear in an assignment context, and were thus a standalone expression (§15.2). The type of the local variable is the upward projection of T with respect to all synthetic type variables mentioned by T (§4.10.5). It is a compile-time error if T is the null type.",10.98,205.14,360.01,901,72,76.06,432.01,281.2,FALSE,FALSE
522,6,BODY,"It is a compile-time error if, in a switch block that consists of switch labeled statement groups, a statement is labeled with a case label that declares one or more pattern variables (§6.3.3), and either: •An immediately preceding statement in the switch block can complete normally (§14.22), or •The statement is labeled with more than one switch label.",10.98,83.14,360.01,355,72,400.06,432.01,483.2,FALSE,FALSE
540,3,BODY,"•If the Expression is not present, or it is present and the value resulting from its evaluation (including any possible unboxing) is true, then the contained Statement is executed. Then there is a choice: –If execution of the Statement completes normally, then the following two steps are performed in sequence: 1.First, if the ForUpdate part is present, the expressions are evaluated in sequence from left to right; their values, if any, are discarded. If evaluation of any expression completes abruptly for some reason, the for statement completes abruptly for the same reason; any ForUpdate statement expressions to the right of the one that completed abruptly are not evaluated. If the ForUpdate part is not present, no action is taken.",10.98,167.14,360.01,740,72,379.2,432.01,546.33,FALSE,FALSE
584,2,BODY,"Evaluation of an expression can produce side effects, because expressions may contain embedded assignments, increment operators, decrement operators, method invocations, and, in switch expressions, arbitrary statements. An expression occurs in either: •The declaration of some class or interface that is being declared: in a field initializer, in a static initializer, in an instance initializer, in a constructor declaration, in a method declaration, or in an annotation. •An annotation on the declaration of a module, a package, or a top level class or interface.",10.98,128.14,360,565,72,76.06,432,204.2,FALSE,FALSE
588,3,BODY,"There are no circumstances where the evaluation of a floating-point expression may use intermediate results that have more precision or more exponent range than indicated by the expression's type. A floating-point operation that overflows produces a signed infinity. A floating-point operation that underflows produces a subnormal value or a signed zero. A floating-point operation that has no unique mathematically defined result produces NaN. All numeric operations with NaN as an operand produce NaN as a result. Since NaN is unordered, any numerical comparison operation involving one or two NaNs returns false, any == comparison involving NaN returns false, and any ! = comparison involving NaN returns true. Floating-point arithmetic is an approximation to real arithmetic. While there are an infinite number of real numbers, a particular floating-point format only has a finite number of values. In the Java programming language, a rounding policy is a function used to map from a real number to a floating-point value in a given format. For real numbers in the representable range of a floating-point format, a continuous segment of the real number line is mapped to a single floating-point value. The real number whose value is numerically equal to a floating-point value is mapped to that floating-point value; for example, the real number 1.5 is mapped to the floating-point value 1.5 in a given format. The Java programming language defines two rounding policies, as follows: •The round to nearest rounding policy applies to all floating-point operators except for (i) conversion to an integer value, and (ii) floating-point remainder. Under the round to nearest rounding policy, inexact results must be rounded to the representable value nearest to the infinitely precise result; if the two nearest representable values are equally near, then the value whose least significant bit is zero is chosen. The round to nearest rounding policy corresponds to the default rounding- direction attribute for binary arithmetic in IEEE 754, roundTiesToEven.",10.98,431.14,360.01,2058,72,108.06,432.01,539.2,FALSE,FALSE
603,7,BODY,ClassInstanceCreationExpression: UnqualifiedClassInstanceCreationExpression ExpressionName . UnqualifiedClassInstanceCreationExpression Primary . UnqualifiedClassInstanceCreationExpression,10.98,45.05,297.73,188,90,554.13,387.73,599.18,FALSE,TRUE
604,7,BODY,"A class instance creation expression specifies a class to be instantiated, possibly followed by type arguments (§4.5.1) or a diamond (<>) if the class being instantiated is generic (§8.1.2), followed by (a possibly empty) list of actual value arguments to the constructor. If the type argument list to the class is empty — the diamond form <> — the type arguments of the class are inferred. It is legal, though strongly discouraged as a matter of style, to have white space between the '<' and '>' of a diamond. If the constructor is generic (§8.8.4), the type arguments to the constructor may similarly either be inferred or passed explicitly. If passed explicitly, the type arguments to the constructor immediately follow the keyword new. It is a compile-time error if a class instance creation expression provides type arguments to a constructor but uses the diamond form for type arguments to the class.",10.98,180.14,360,907,72,278.06,432,458.2,FALSE,FALSE
604,9,BODY,"If TypeArguments is present immediately after new, or immediately before (, then it is a compile-time error if any of the type arguments are wildcards (§4.5.1). The exception types that a class instance creation expression can throw are specified in §11.2.1. Class instance creation expressions have two forms:",10.98,70.14,360,310,72,509.06,432,579.2,FALSE,FALSE
609,3,BODY,"15.9.3Choosing the Constructor and its Arguments Let C be the class being instantiated. To create an instance of C, i, a constructor of C is chosen at compile time by the following rules. First, the actual arguments to the constructor invocation are determined: •If C is an anonymous class with direct superclass S, then: –If S is not an inner class, or if S is a local class that occurs in a static context, then the arguments to the constructor are the arguments in the argument list of the class instance creation expression, if any, in the order they appear in the expression. –Otherwise, the first argument to the constructor is the immediately enclosing instance of i with respect to S (§15.9.2), and the subsequent arguments to the constructor are the arguments in the argument list of the class instance creation expression, if any, in the order they appear in the class instance creation expression.",10.98,207.11,360.01,908,72,383.09,432.01,590.2,FALSE,FALSE
632,2,BODY,"15.12.1Compile-Time Step 1: Determine Type to Search The first step in processing a method invocation at compile time is to figure out the name of the method to be invoked and which type to search for definitions of methods of that name. The name of the method is specified by the MethodName or Identifier which immediately precedes the left parenthesis of the MethodInvocation. For the type to search, there are six cases to consider, depending on the form that precedes the left parenthesis of the MethodInvocation: •If the form is MethodName, that is, just an Identifier, then: If the Identifier appears in the scope of a method declaration with that name (§6.3, §6.4.1), then: –If there is an enclosing class or interface declaration of which that method is a member, let E be the innermost such class or interface declaration. The type to search is the type of E.this (§15.8.4).",10.98,213.11,360.01,883,72,76.09,432.01,289.2,FALSE,FALSE
641,4,BODY,"•If the member is a fixed arity method with arity n, the arity of the method invocation is equal to n, and for all i (1 ≤ i ≤ n), the i'th argument of the method invocation is potentially compatible, as defined below, with the type of the i'th parameter of the method. •If the member is a variable arity method with arity n, then for all i (1 ≤ i ≤ n-1), the i'th argument of the method invocation is potentially compatible with the type of the i'th parameter of the method; and, where the nth parameter of the method has type T[], one of the following is true: –The arity of the method invocation is equal to n-1. –The arity of the method invocation is equal to n, and the nth argument of the method invocation is potentially compatible with either T or T[]. –The arity of the method invocation is m, where m > n, and for all i (n ≤ i ≤ m), the i'th argument of the method invocation is potentially compatible with T. •If the method invocation includes explicit type arguments, and the member is a generic method, then the number of type arguments is equal to the number of type parameters of the method.",10.98,231.14,360.01,1105,72,224.06,432.01,455.2,FALSE,FALSE
651,5,BODY,"15.12.3Compile-Time Step 3: Is the Chosen Method Appropriate? If there is a most specific method declaration for a method invocation, it is called the compile-time declaration for the method invocation. It is a compile-time error if an argument to a method invocation is not compatible with its target type, as derived from the invocation type of the compile-time declaration. If the compile-time declaration is applicable by variable arity invocation, then where the last formal parameter type of the invocation type of the method is Fn[], it is a compile-time error if the type which is the erasure of Fn is not accessible (§6.6) at the point of invocation.",10.98,143.11,360,659,72,430.09,432,573.2,FALSE,FALSE
652,2,BODY,"If the compile-time declaration is void, then the method invocation must be a top level expression (that is, the Expression in an expression statement or in the ForInit or ForUpdate part of a for statement), or a compile-time error occurs. Such a method invocation produces no value and so must be used only in a situation where a value is not needed. In addition, whether the compile-time declaration is appropriate may depend on the form of the method invocation expression before the left parenthesis, as follows: •If the form is MethodName - that is, just an Identifier - and the compile-time declaration is an instance method, then: –It is a compile-time error if the method invocation occurs in a static context (§8.1.3). –Otherwise, let T be the class or interface to search (§15.12.1). It is a compile- time error if the innermost enclosing class or interface declaration of the method invocation is neither T nor an inner class of T.",10.98,199.14,360.01,942,72,76.06,432.01,275.2,FALSE,FALSE
660,2,BODY,"2.Otherwise, if S has a superclass, then steps 1 and 2 of this lookup procedure are performed recursively using the direct superclass of S in place of S; the method to be invoked, if any, is the result of the recursive invocation of this lookup procedure.",10.98,45.14,360,255,72,76.06,432,121.2,FALSE,FALSE
666,2,BODY,"•If ClassType denotes a parameterized type (§4.5), then it is a compile-time error if any of its type arguments are wildcards. •If ClassType denotes a raw type (§4.8), then it is a compile-time error if TypeArguments is present after the ::. If a method reference expression has the form ArrayType :: new, then ArrayType must denote a type that is reifiable (§4.7), or a compile-time error occurs. The target reference of an instance method (§15.12.4.1) may be provided by the method reference expression using an ExpressionName, a Primary, or super, or it may be provided later when the method is invoked. The immediately enclosing instance of a new inner class instance (§15.9.2) is provided by a lexically enclosing instance of this (§8.1.3). When more than one member method of a type has the same name, or when a class has more than one constructor, the appropriate method or constructor is selected based on the functional interface type targeted by the method reference expression, as specified in §15.13.1. If a method or constructor is generic, the appropriate type arguments may either be inferred or provided explicitly. Similarly, the type arguments of a generic type mentioned by the method reference expression may be provided explicitly or inferred. Method reference expressions are always poly expressions (§15.2). It is a compile-time error if a method reference expression occurs in a program in someplace other than an assignment context (§5.2), an invocation context (§5.3), or a casting context (§5.5). Evaluation of a method reference expression produces an instance of a functional interface type (§9.8). This does not cause the execution of the corresponding method; instead, the execution may occur at a later time when an appropriate method of the functional interface is invoked.",10.98,392.14,360.01,1806,72,76.06,432.01,468.2,FALSE,FALSE
673,4,BODY,"For some method reference expressions, there is only one possible compile-time declaration with only one possible invocation type (§15.12.2.6), regardless of the targeted function type. Such method reference expressions are said to be exact. A method reference expression that is not exact is said to be inexact. A method reference expression ending with Identifier is exact if it satisfies all of the following: •If the method reference expression has the form ReferenceType :: [TypeArguments] Identifier, then ReferenceType does not denote a raw type. •The type to search has exactly one member method with the name Identifier that is accessible to the class or interface in which the method reference expression appears. •This method is not variable arity (§8.4.1). •If this method is generic (§8.4.4), then the method reference expression provides TypeArguments. A method reference expression of the form ClassType :: [TypeArguments] new is exact if it satisfies all of the following: •The type denoted by ClassType is not raw, or is a non-static member type of a raw type. •The type denoted by ClassType has exactly one constructor that is accessible to the class or interface in which the method reference expression appears. •This constructor is not variable arity. •If this constructor is generic, then the method reference expression provides TypeArguments. A method reference expression of the form ArrayType :: new is always exact.",10.98,371.14,360.01,1442,72,230.06,432.01,601.2,FALSE,FALSE
688,2,BODY,"Integer division rounds toward 0. That is, the quotient produced for operands n and d that are integers after binary numeric promotion (§5.6) is an integer value q whose magnitude is as large as possible while satisfying |d ⋅ q| ≤ |n|. Moreover, q is positive when |n| ≥ |d| and n and d have the same sign, but q is negative when |n| ≥ |d| and n and d have opposite signs. There is one special case that does not satisfy this rule: if the dividend is the negative integer of largest possible magnitude for its type, and the divisor is -1, then integer overflow occurs and the result is equal to the dividend. Despite the overflow, no exception is thrown in this case. On the other hand, if the value of the divisor in an integer division is 0, then an ArithmeticException is thrown. The result of a floating-point division is determined by the rules of IEEE 754 arithmetic: •If either operand is NaN, the result is NaN. •If the result is not NaN, the sign of the result is positive if both operands have the same sign, and negative if the operands have different signs. •Division of an infinity by an infinity results in NaN. •Division of an infinity by a finite value results in a signed infinity. The sign is determined by the rule stated above. •Division of a finite value by an infinity results in a signed zero. The sign is determined by the rule stated above. •Division of a zero by a zero results in NaN; division of zero by any other finite value results in a signed zero. The sign is determined by the rule stated above. •Division of a nonzero finite value by a zero results in a signed infinity. The sign is determined by the rule stated above. •In the remaining cases, where neither an infinity nor NaN is involved, the exact mathematical quotient is computed. If the magnitude of the quotient is too large to represent, we say the operation overflows; the result is then an infinity of appropriate sign. Otherwise, the quotient is rounded to the nearest representable value using the round to nearest rounding policy (§15.4). The Java programming language requires support of gradual underflow as defined by IEEE 754. Despite the fact that overflow, underflow, division by zero, or loss of information may occur, evaluation of a floating-point division operator / never throws a run- time exception.",10.98,513.14,360.01,2311,72,76.06,432.01,589.2,FALSE,FALSE
691,6,BODY,AdditiveExpression: MultiplicativeExpression AdditiveExpression + MultiplicativeExpression AdditiveExpression - MultiplicativeExpression,10.98,45.05,217.05,136,90,354.13,307.05,399.18,FALSE,TRUE
691,7,BODY,"The additive operators have the same precedence and are syntactically left- associative (they group left-to-right). If the type of either operand of a + operator is String, then the operation is string concatenation. Otherwise, the type of each of the operands of the + operator must be a type that is convertible (§5.1.8) to a primitive numeric type, or a compile-time error occurs. In every case, the type of each of the operands of the binary - operator must be a type that is convertible (§5.1.8) to a primitive numeric type, or a compile-time error occurs.",10.98,128.14,360,561,72,417.06,432,545.2,FALSE,FALSE
694,6,BODY,"15.18.2Additive Operators (+ and -) for Numeric Types The binary + operator performs addition when applied to two operands of numeric type, producing the sum of the operands. The binary - operator performs subtraction, producing the difference of two numeric operands. Binary numeric promotion is performed on the operands (§5.6).",10.98,91.11,360.01,330,72,321.09,432.01,412.2,FALSE,FALSE
703,7,BODY,AndExpression: EqualityExpression AndExpression & EqualityExpression ExclusiveOrExpression: AndExpression ExclusiveOrExpression ^ AndExpression,10.98,82.05,190.76,143,90,512.13,280.76,594.18,FALSE,TRUE
717,2,BODY,"The result of the first operand of an assignment operator must be a variable, or a compile-time error occurs. This operand may be a named variable, such as a local variable or a field of the current object or class, or it may be a computed variable, as can result from a field access (§15.11) or an array access (§15.10.3). The type of the assignment expression is the type of the variable after capture conversion (§5.1.10). At run time, the result of the assignment expression is the value of the variable after the assignment has occurred. The result of an assignment expression is not itself a variable. A variable that is declared final cannot be assigned to (unless it is definitely unassigned (§16 (Definite Assignment))), because when an access of such a final variable is used as an expression, the result is a value, not a variable, and so it cannot be used as the first operand of an assignment operator.",10.98,199.14,360.01,915,72,76.06,432.01,275.2,FALSE,FALSE
732,2,BODY,"A normal parameter specifier consists of optional modifiers, a type (or var), and either an identifier or the keyword _ (underscore). If an identifier is present, it specifies the name of the formal parameter. If the keyword _ is present, the formal parameter cannot be referred to by name. A concise parameter specifier consists of an identifier or the keyword _. If an identifier is present, it specifies the name of the formal parameter. If the keyword _ is present, the formal parameter cannot be referred to by name. A formal parameter of a lambda expression that cannot be referred to by name is called an unnamed lambda parameter. If a lambda expression has no formal parameters, then an empty pair of parentheses appears before the -> and the lambda body.",10.98,154.14,360.01,763,72,76.06,432.01,230.2,FALSE,FALSE
734,7,BODY,"It is a compile-time error if a formal parameter that is declared final is assigned to within the body of the lambda expression. When the lambda expression is invoked (via a method invocation expression (§15.12)), the values of the actual argument expressions initialize newly created parameter variables, each of the declared or inferred type, before execution of the lambda body. An Identifier that appears in the NormalLambdaParameter or",10.98,77.14,360,440,72,522.06,432,599.2,FALSE,FALSE
736,6,BODY,"Any local variable, formal parameter, or exception parameter used but not declared in a lambda expression must either be final or effectively final (§4.12.4), as specified in §6.5.6.1. Any local variable used but not declared in a lambda body must be definitely assigned (§16 (Definite Assignment)) before the lambda body, or a compile-time error occurs.",10.98,77.14,360.01,354,72,332.06,432.01,409.2,FALSE,FALSE
739,2,BODY,"(ii) the lambda body is a value-compatible block, and each result expression (§15.27.2) is compatible with R in an assignment context.",10.98,19.14,340,134,92,76.06,432,95.2,FALSE,FALSE
751,8,BODY,"In all, there are four possibilities for a variable V after a statement or expression has been executed: •V is definitely assigned and is not definitely unassigned. (The flow analysis rules prove that an assignment to V has occurred.) •V is definitely unassigned and is not definitely assigned. (The flow analysis rules prove that an assignment to V has not occurred.)",10.98,95.14,360,368,72,482.06,432,577.2,FALSE,FALSE
759,5,BODY,"•If the expression has subexpressions, V is [un]assigned after the expression iff V is [un]assigned after its rightmost immediate subexpression.",10.98,19.14,360,144,72,336.06,432,355.2,FALSE,FALSE
762,3,BODY,16.2.3Local Class and Interface Declarations •V is [un]assigned after a local class or interface declaration (§14.3) iff V is [un]assigned before the local class or interface declaration.,10.98,40.11,360,187,72,115.09,432,155.2,FALSE,FALSE
764,4,BODY,•V is [un]assigned before a block statement that is not the first of a switch labeled statement group in the switch block iff V is [un]assigned after the preceding block statement.,10.98,32.14,360.01,180,72,501.06,432.01,533.2,FALSE,FALSE
770,6,BODY,"•V is definitely assigned before the declaration of a class body of an enum constant with no arguments that is declared within the scope of V iff V is definitely assigned before the enum constant. •V is definitely assigned before the declaration of a class body of an enum constant with arguments that is declared within the scope of V iff V is definitely assigned after the last argument expression of the enum constant The definite assignment/unassignment status of any construct within the class body of an enum constant is governed by the usual rules for classes. •V is [un]assigned before the first argument to an enum constant iff it is [un]assigned before the enum constant. •V is [un]assigned before y (an argument of an enum constant, but not the first) iff V is [un]assigned after the argument to the left of y.",10.98,173.14,360,821,72,360.06,432,533.2,FALSE,FALSE
787,7,BODY,"17.4.5Happens-before Order Two actions can be ordered by a happens-before relationship. If one action happens-before another, then the first is visible to and ordered before the second. If we have two actions x and y, we write hb(x, y) to indicate that x happens-before y. •If x and y are actions of the same thread and x comes before y in program order, then hb(x, y). •There is a happens-before edge from the end of a constructor of an object to the start of a finalizer (§12.6) for that object. •If an action x synchronizes-with a following action y, then we also have hb(x, y). •If hb(x, y) and hb(y, z), then hb(x, z). The wait methods of class Object (§17.2.1) have lock and unlock actions associated with them; their happens-before relationships are defined by these associated actions. It should be noted that the presence of a happens-before relationship between two actions does not necessarily imply that they have to take place in that order in an implementation. If the reordering produces results consistent with a legal execution, it is not illegal.",10.98,264.11,360.01,1064,72,307.09,432.01,571.2,FALSE,FALSE
829,2,BODY,"set C generated by §18.5.2 when inferring the poly expression's invocation type. »For a parenthesized expression, the search is applied recursively to the contained expression. »For a conditional expression, the search is applied recursively to the second and third operands. »For a lambda expression, the search is applied recursively to the lambda body. »For a switch expression, the search is applied recursively to each of its result expressions.",10.98,147.14,330,450,102,76.06,432,223.2,FALSE,FALSE
844,2,BODY,ModuleName: Identifier ModuleName . Identifier PackageName: Identifier PackageName . Identifier TypeName: TypeIdentifier PackageOrTypeName . TypeIdentifier ExpressionName: Identifier AmbiguousName . Identifier MethodName: UnqualifiedMethodIdentifier PackageOrTypeName: Identifier PackageOrTypeName . Identifier AmbiguousName: Identifier AmbiguousName . Identifier,10.98,319.05,180.37,363,90,187.13,270.37,506.18,FALSE,TRUE
29,2,BODY,THIS chapter describes the context-free grammars used in this specification to define the lexical and syntactic structure of a program.,10.97,19.14,360,135,72,220.36,432,239.5,FALSE,FALSE
38,6,BODY,"•Otherwise, consider how many backslashes appeared contiguously as raw input characters in the result, back to a non-backslash character or the start of the result. (It is immaterial whether any such backslash arose from an ASCII \ character in the compiler's raw input or from a Unicode escape \u005c in the compiler's raw input.) If this number is even, then the ASCII \ character is eligible to begin a Unicode escape; if the number is odd, then the ASCII \ character is not eligible to begin a Unicode escape.",10.97,84.14,360.01,513,72,307.2,432.01,391.33,FALSE,FALSE
42,2,BODY,"the numerical comparison operator >, even when it could be combined with an adjacent > character to form a different operator.",10.97,19.14,350,126,82,76.06,432,95.2,FALSE,FALSE
50,2,BODY,"Underscores are allowed as separators between digits that denote the integer. In a hexadecimal or binary literal, the integer is only denoted by the digits after the 0x or 0b characters and before any type suffix. Therefore, underscores may not appear immediately after 0x or 0b, or after the last digit in the numeral. In a decimal or octal literal, the integer is denoted by all the digits in the literal before any type suffix. Therefore, underscores may not appear before the first digit or after the last digit in the numeral. Underscores may appear after the initial 0 in an octal numeral (since 0 is a digit that denotes part of the integer) and after the initial non-zero digit in a non-zero decimal literal.",10.97,122.14,360.01,716,72,76.06,432.01,198.2,FALSE,FALSE
52,2,BODY,"A hexadecimal numeral consists of the leading ASCII characters 0x or 0X followed by one or more ASCII hexadecimal digits interspersed with underscores, and can represent a positive, zero, or negative integer. Hexadecimal digits with values 10 through 15 are represented by the ASCII letters a through f or A through F, respectively; each letter used as a hexadecimal digit may be uppercase or lowercase.",10.97,77.14,360.01,403,72,76.06,432.01,153.2,FALSE,FALSE
64,3,BODY,"A text block is always of type String (§4.3.3). The opening delimiter is a sequence that starts with three double quote characters ('''), continues with zero or more space, tab, and form feed characters, and concludes with a line terminator. The closing delimiter is a sequence of three double quote characters. The content of a text block is the sequence of characters that begins immediately after the line terminator of the opening delimiter, and ends immediately before the first double quote of the closing delimiter. Unlike in a string literal (§3.10.5), it is not a compile-time error for a line terminator to appear in the content of a text block.",10.97,147.14,360.01,655,72,310.93,432.01,458.07,FALSE,FALSE
70,3,BODY,"3.10.8The Null Literal The null type has one value, the null reference, represented by the null literal null, which is formed from ASCII characters.",10.97,40.11,360,148,72,166.09,432,206.2,FALSE,FALSE
82,2,BODY,"then id must be the simple name of an accessible member type of T (§6.6, §8.5, §9.5), or a compile-time error occurs. The class or interface type denotes that member type.",10.97,32.14,360,171,72,76.06,432,108.2,FALSE,FALSE
121,2,BODY,"types are introduced by type declarations, which include class declarations (§8.1) and interface declarations (§9.1). We often use the term type to refer to either a class or an interface. In the Java Virtual Machine, every object belongs to some particular class: the class that was mentioned in the creation expression that produced the object (§15.9), or the class whose Class object was used to invoke a reflective method to produce the object, or the String class for objects implicitly created by the string concatenation operator + (§15.18.1). This class is called the class of the object. An object is said to be an instance of its class and of all superclasses of its class. Every array also has a class. The method getClass, when invoked for an array object, will return a class object (of class Class) that represents the class of the array (§10.8). The compile-time type of a variable is always declared, and the compile-time type of an expression can be deduced at compile time. The compile-time type limits the possible values that the variable can hold at run time or the expression can produce at run time. If a run-time value is a reference that is not null, it refers to an object or array that has a class, and that class will necessarily be compatible with the compile-time type. Even though a variable or expression may have a compile-time type that is an interface type, there are no instances of interfaces. A variable or expression whose type is an interface type can reference any object whose class implements (§8.1.5) that interface. Sometimes a variable or expression is said to have a 'run-time type'. This refers to the class of the object referred to by the value of the variable or expression at run time, assuming that the value is not null. The correspondence between compile-time types and run-time types is incomplete for two reasons: 1.At run time, classes and interfaces are loaded by the Java Virtual Machine using class loaders. Each class loader defines its own set of classes and interfaces. As a result, it is possible for two loaders to load an identical class or interface definition but produce distinct classes or interfaces at run time. Consequently, code that compiled correctly may fail at link time if the class loaders that load it are inconsistent.",10.97,464.14,360.01,2301,72,76.06,432.01,540.2,FALSE,FALSE
135,2,BODY,"•One of the following cases applies: 1.S is a class or interface type, and T is a class or interface type, and S names a class or interface that is not disjoint from the class or interface named by T. ('disjoint' is defined below.)",10.97,51.14,360,231,72,76.06,432,127.2,FALSE,FALSE
135,5,BODY,"4.S is a type variable, and a narrowing reference conversion exists from the",10.97,6.14,350,76,82,230.06,432,236.2,FALSE,FALSE
135,7,BODY,"5.T is a type variable, and either a widening reference conversion or a",10.97,6.14,350,71,82,262.06,432,268.2,FALSE,FALSE
160,2,BODY,"•An operand of a numerical comparison operator <, <=, >, or >= (§15.20.1) •An operand of a numerical equality operator == or != (§15.21.1) •An operand of an integer bitwise operator &, ^, or | (§15.22.1) An expression appears in a numeric array context if the expression is one of the following: •A dimension expression in an array creation expression (§15.10.1) •The index expression in an array access expression (§15.10.3) An expression appears in a numeric choice context if the expression is one of the following: •The second or third operand of a numeric conditional expression (§15.25.2) •A result expression of a standalone switch expression (§15.28.1) where all the result expressions are convertible to a numeric type Numeric promotion determines the promoted type of all the expressions in a numeric context. The promoted type is chosen such that each expression can be converted to the promoted type, and, in the case of an arithmetic operation, the operation is defined for values of the promoted type. The order of expressions in a numeric context is not significant for numeric promotion. The rules are as follows: 1.If any expression is of a reference type, it is subjected to unboxing conversion",10.97,287.14,360.01,1212,72,76.06,432.01,363.2,FALSE,FALSE
178,2,BODY,"The scope of a local variable declared in a block by a local variable declaration statement (§14.4.2) is the rest of the block, starting with the declaration's own initializer and including any further declarators to the right in the local variable declaration statement. The scope of a local variable declared in the ForInit part of a basic for statement (§14.14.1) includes all of the following: •Its own initializer •Any further declarators to the right in the ForInit part of the for statement •The Expression and ForUpdate parts of the for statement •The contained Statement The scope of a local variable declared in the header of an enhanced for statement (§14.14.2) is the contained Statement. The scope of a local variable declared in the resource specification of a try-with- resources statement (§14.20.3) is from the declaration rightward over the remainder of the resource specification and the entire try block associated with the try-with- resources statement.",10.97,243.14,360,974,72,76.06,432,319.2,FALSE,FALSE
203,2,BODY,"Otherwise, the PackageOrTypeName is reclassified as a PackageName. The meaning of the PackageOrTypeName is the meaning of the reclassified name. 6.5.4.2Qualified PackageOrTypeNames Given a qualified PackageOrTypeName of the form Q.Id, if Id is a valid TypeIdentifier and the class, interface, type parameter, or package denoted by Q has a member class or interface named Id, then the qualified PackageOrTypeName name is reclassified as a TypeName. Otherwise, it is reclassified as a PackageName. The meaning of the qualified PackageOrTypeName is the meaning of the reclassified name.",10.97,137.27,360,583,72,76.06,432,213.33,FALSE,FALSE
203,4,BODY,"If the declaration denotes a type parameter of a generic method or constructor m (§8.4.4, §8.8.4), and the type name appears directly or indirectly in the body of a local class, local interface, or anonymous class D declared directly in the body of m, then both of the following must be true, or a compile-time error occurs: •The type name does not occur in a static context. •D is an inner class, and the immediately enclosing class or interface declaration of the type name is D or an inner class of D.",10.97,96.14,360,504,72,486.33,432,582.47,FALSE,FALSE
204,7,BODY,"6.5.5.2Qualified Type Names If a type name is of the form Q.Id, then Q must be either the name of a class, interface, or type parameter in a package uniquely visible to the current module, or the name of a package uniquely visible to the current module (§7.4.3). If Id names exactly one accessible class or interface (§6.6) that is a member of the class, interface, type parameter, or package denoted by Q, then the qualified type name denotes that class or interface.",10.97,97.2,360.01,468,72,502.13,432.01,599.33,FALSE,FALSE
225,2,BODY,"PROGRAMS are organized as sets of packages. The members of a package (§7.1) are classes and interfaces, which are declared in compilation units of the package, and subpackages, which may contain compilation units and subpackages of their own. Each package has its own set of names for classes and interfaces, which helps to prevent name conflicts. The naming structure for packages is hierarchical. If a set of packages is sufficiently cohesive, then the packages may be grouped into a module. A module categorizes some or all of its packages as exported, which means their classes and interfaces may be accessed from code outside the module. If a package is not exported by a module, then only code inside the module may access its classes and interfaces. Furthermore, if code in a module wishes to access the packages exported by another module, then the first module must explicitly depend on the second module. Thus, a module controls how its packages use other modules (by specifying dependences) and controls how other modules use its packages (by specifying which of its packages are exported). Modules and packages may be stored in a file system or in a database (§7.2). Modules and packages that are stored in a file system may have certain constraints on the organization of their compilation units to allow a simple implementation to find module, class, and interface declarations easily. Code in a compilation unit automatically has access to all classes and interfaces declared in its package and also automatically imports all of the public classes and interfaces declared in the predefined package java.lang. A top level class or interface is accessible (§6.6) outside the package that declares it only if the class or interface is declared public. A top level class or interface is accessible outside the module that declares it only if the class or interface is declared public and is a member of an exported package. A class or interface that",10.97,361.14,360.01,1960,72,220.36,432.01,581.5,FALSE,FALSE
226,5,BODY,"If the fully qualified name (§6.7) of a package is P, and Q is a subpackage of P, then P.Q is the fully qualified name of the subpackage, and furthermore denotes a package. A package may not contain two members of the same name, or a compile-time error results.",10.97,64.14,360,261,72,364.06,432,428.2,FALSE,FALSE
233,2,BODY,"7.4.2Unnamed Packages An ordinary compilation unit that has no package declaration, but has at least one other kind of declaration, is part of an unnamed package. Unnamed packages are provided by the Java SE Platform principally for convenience when developing small or temporary applications or when just beginning development. An unnamed package cannot have subpackages, since the syntax of a package declaration always includes a reference to a named top level package. An implementation of the Java SE Platform must support at least one unnamed package. An implementation may support more than one unnamed package, but is not required to do so. Which ordinary compilation units are in each unnamed package is determined by the host system. The host system must associate ordinary compilation units in an unnamed package with an unnamed module (§7.7.5), not a named module.",10.97,207.11,360.01,876,72,76.09,432.01,283.2,FALSE,FALSE
234,3,BODY,A package is visible to a module M if and only if an ordinary compilation unit containing a declaration of the package is visible to M.,10.97,19.14,360,135,72,148.06,432,167.2,FALSE,FALSE
235,2,BODY,"•A type-import-on-demand declaration (§7.5.2) imports all the accessible classes and interfaces of a named package, class, or interface as needed, by mentioning the canonical name of the package, class, or interface. •A single-static-import declaration (§7.5.3) imports all accessible static members with a given name from a class or interface, by giving its canonical name. •A static-import-on-demand declaration (§7.5.4) imports all accessible static members of a named class or interface as needed, by mentioning the canonical name of the class or interface. The scope and shadowing of a class, interface, or member imported by these declarations is specified in §6.3 and §6.4.",10.97,154.14,360,680,72,76.06,432,230.2,FALSE,FALSE
255,4,BODY,ClassDeclaration: NormalClassDeclaration EnumDeclaration RecordDeclaration NormalClassDeclaration: {ClassModifier} class TypeIdentifier [TypeParameters] [ClassExtends] [ClassImplements] [ClassPermits] ClassBody,10.97,95.05,296.85,210,90,263.13,386.85,358.18,FALSE,TRUE
265,2,BODY,"An instance i of a direct inner class C of a class or interface O is associated with an instance of O, known as the immediately enclosing instance of i. The immediately enclosing instance of an object, if any, is determined when the object is created (§15.9.2). An object o is the zeroth lexically enclosing instance of itself. An object o is the n'th lexically enclosing instance of an instance i if it is the immediately enclosing instance of the n-1'th lexically enclosing instance of i. An instance of an inner local class or an anonymous class whose declaration occurs in a static context has no immediately enclosing instance. Also, an instance of a static nested class (§8.1.1.4) has no immediately enclosing instance. For every superclass S of C which is itself a direct inner class of a class or interface SO, there is an instance of SO associated with i, known as the immediately enclosing instance of i with respect to S. The immediately enclosing instance of an object with respect to its class' direct superclass, if any, is determined when the superclass constructor is invoked via an explicit constructor invocation statement (§8.8.7.1). When an inner class (whose declaration does not occur in a static context) refers to an instance variable that is a member of a lexically enclosing class or interface declaration, the variable of the corresponding lexically enclosing instance is used. Any local variable, formal parameter, or exception parameter used but not declared in an inner class must either be final or effectively final (§4.12.4), as specified in §6.5.6.1. Any local variable used but not declared in an inner class must be definitely assigned (§16 (Definite Assignment)) before the body of the inner class, or a compile-time error occurs.",10.97,347.14,360.01,1767,72,76.06,432.01,423.2,FALSE,FALSE
270,2,BODY,"A class whose declaration lacks an implements clause has no direct superinterface types, with one exception: an anonymous class may have a superinterface type (§15.9.5). An interface is a direct superinterface of a class if the interface is named by one of the direct superinterface types of the class. An interface I is a superinterface of class C if any of the following is true: •I is a direct superinterface of C. •C has some direct superinterface J for which I is a superinterface, using the definition of 'superinterface of an interface' given in §9.1.3. •I is a superinterface of the direct superclass of C. A class can have a superinterface in more than one way. A class is said to directly implement its direct superinterfaces, and to implement all of its superinterfaces. A class is said to be a direct subclass of its direct superinterfaces, and a subclass of all of its superinterfaces. A class may not declare a direct superclass type and a direct superinterface type, or two direct superinterface types, which are, or which have supertypes (§4.10.2) which are, different parameterizations of the same generic interface (§9.1.2), or a parameterization of a generic interface and a raw type naming that same generic interface. In the case of such a conflict, a compile-time error occurs.",10.97,307.14,360.01,1299,72,76.06,432.01,383.2,FALSE,FALSE
274,2,BODY,"•If C is not an enum class, then its permitted direct subclasses are those classes declared in the same compilation unit as C (§7.3) which have a canonical name (§6.7) and whose direct superclass is C.",10.97,32.14,360,201,72,76.06,432,108.2,FALSE,FALSE
274,7,BODY,The scope and shadowing of a declaration of a member m declared in or inherited by a class C is specified in §6.3 and §6.4.1.,10.97,19.14,360,125,72,538.06,432,557.2,FALSE,FALSE
282,2,BODY,"If a field declaration hides the declaration of another field, the two fields need not have the same type. A class inherits from its direct superclass and direct superinterfaces all the non- private fields of the superclass and superinterfaces that are both accessible (§6.6) to code in the class and not hidden by a declaration in the class. A private field of a superclass might be accessible to a subclass - for example, if both classes are members of the same class. Nevertheless, a private field is never inherited by a subclass. It is possible for a class to inherit more than one field with the same name, either from its superclass and superinterfaces or from its superinterfaces alone. Such a situation does not in itself cause a compile-time error. However, any attempt within the body of the class to refer to any such field by its simple name will result in a compile-time error, because the reference is ambiguous. There might be several paths by which the same field declaration is inherited from an interface. In such a situation, the field is considered to be inherited only once, and it may be referred to by its simple name without ambiguity.",10.97,225.14,360.01,1160,72,76.06,432.01,301.2,FALSE,FALSE
290,5,BODY,"If the declarator is for an instance variable (that is, a field that is not static), then the following rules apply to its initializer: •The initializer may refer to the current object using the keyword this or the keyword super, and may refer by simple name to any class variable declared in or inherited by the class, even one whose declaration occurs to the right of the initializer (§3.5). •At run time, the initializer is evaluated and the assignment performed each time an instance of the class is created (§12.5). References from variable initializers to fields that may not yet be initialized are restricted, as specified in §8.3.3 and §16 (Definite Assignment). Exception checking for a variable initializer in a field declaration is specified in §11.2.3.",10.97,173.14,360.01,764,72,351.06,432.01,524.2,FALSE,FALSE
292,2,BODY,"For a reference by simple name to an instance variable f declared in class C, it is a compile-time error if: •The reference appears either in an instance variable initializer of C or in an instance initializer of C (§8.6); and •The reference appears in the initializer of f's own declarator or at a point to the left of f's declarator; and •The reference is not on the left hand side of an assignment expression (§15.26); and •The innermost class enclosing the reference is C.",10.97,134.14,360,476,72,76.06,432,210.2,FALSE,FALSE
306,5,BODY,"If the result is not void, then the return type of a method is denoted by UnannType if no bracket pairs appear after the formal parameter list, and is specified by §10.2 otherwise.",10.97,32.14,360,180,72,558.06,432,590.2,FALSE,FALSE
326,3,BODY,"It is a compile-time error if a static initializer cannot complete normally (§14.22). It is a compile-time error if a return statement (§14.17) appears anywhere within a static initializer. A static initializer introduces a static context (§8.1.3, which limits the use of constructs that refer to the current object. Notably, the keywords this and super are prohibited in a static context (§15.8.3, §15.11.2), as are unqualified references to instance variables, instance methods, and type parameters of lexically enclosing declarations (§6.5.5.1, §6.5.6.1, §15.12.3). Restrictions on how a static initializer may refer to class variables, even when the class variables are in scope, are specified in §8.3.3. Exception checking for a static initializer is specified in §11.2.3.",10.97,160.14,360,777,72,113.06,432,273.2,FALSE,FALSE
331,7,BODY,Explicit constructor invocation statements are divided into two kinds: •Alternate constructor invocations begin with the keyword this (possibly prefaced with explicit type arguments). They are used to invoke an alternate constructor of the same class. •Superclass constructor invocations begin with either the keyword super (possibly prefaced with explicit type arguments) or a Primary expression or an ExpressionName. They are used to invoke a constructor of the direct superclass. They are further divided: –Unqualified superclass constructor invocations begin with the keyword super (possibly prefaced with explicit type arguments). –Qualified superclass constructor invocations begin with a Primary expression or an ExpressionName. They allow a subclass constructor to explicitly specify,10.97,173.14,360.01,791,72,423.2,432.01,596.33,FALSE,FALSE
333,7,BODY,"3.Finally, if the superclass constructor invocation statement completes normally, then all instance variable initializers of C and all instance initializers of C are executed. If an instance initializer or instance variable initializer I textually precedes another instance initializer or instance variable initializer J, then I is executed before J. Execution of instance variable initializers and instance initializers is performed regardless of whether the superclass constructor invocation actually appears",10.97,90.14,360.01,510,72,509.06,432.01,599.2,FALSE,FALSE
348,3,BODY,"RecordHeader: ( [RecordComponentList] ) RecordComponentList: RecordComponent {, RecordComponent} RecordComponent: {RecordComponentModifier} UnannType Identifier VariableArityRecordComponent VariableArityRecordComponent: {RecordComponentModifier} UnannType {Annotation} ... Identifier RecordComponentModifier: Annotation",10.97,180.05,316.95,319,90,145.13,406.95,325.18,FALSE,TRUE
356,2,BODY,"8.10.4.1Normal Canonical Constructors A (non-compact) constructor in the declaration of record class R is the canonical constructor of R if its signature is override-equivalent (§8.4.2) to the derived constructor signature of R. The derived constructor signature of a record class R is a signature that consists of the name R, no type parameters, and the formal parameter types derived from the record header of R by taking the declared type of each record component in order.",10.97,97.2,360,476,72,76.13,432,173.33,FALSE,FALSE
370,2,BODY,"The initializer need not be a constant expression (§15.29). It is a compile-time error if the initializer of an interface field uses the simple name of the same field or another field whose declaration occurs to the right of the initializer (§3.5) in the same interface. The initializer of an interface field may not refer to the current object using the keyword this or the keyword super, as specified in §15.8.3, §15.11.2, and §15.12.3. At run time, the initializer is evaluated and the field assignment performed exactly once, when the interface is initialized (§12.4.2). Note that interface fields that are constant variables (§4.12.4) are initialized before other interface fields. This also applies to static fields that are constant variables in classes (§8.3.2). Such fields will never be observed to have their default initial values (§4.12.5), even by devious programs.",10.97,186.14,360.01,879,72,76.06,432.01,262.2,FALSE,FALSE
387,3,BODY,"An annotation interface AC may be the containing annotation interface of some annotation interface A while also having its own containing annotation interface SC. That is, a containing annotation interface may itself be a repeatable annotation interface.",10.97,45.14,360.01,254,72,108.06,432.01,153.2,FALSE,FALSE
407,5,BODY,"If a declaration context or type context has multiple annotations of a repeatable annotation interface A, then it is as if the context has no explicitly declared annotations of interface A and one implicitly declared annotation of the containing annotation interface of A. The implicitly declared annotation is called the container annotation, and the multiple annotations of interface A which appeared in the context are called the base annotations. The elements of the (array-typed) value element of the container annotation are all the base annotations in the left-to-right order in which they appeared in the context. It is a compile-time error if, in a declaration context or type context, there are multiple annotations of a repeatable annotation interface A and any annotations of the containing annotation interface of A.",10.97,161.14,360.01,829,72,334.06,432.01,495.2,FALSE,FALSE
408,3,BODY,"It is a compile-time error if, in a declaration context or type context, there is one annotation of a repeatable annotation interface A and multiple annotations of the containing annotation interface of A.",10.97,32.14,360,205,72,148.06,432,180.2,FALSE,FALSE
425,2,BODY,"10.7Array Members The members of an array type are all of the following: •The public final field length, which contains the number of components of the array. length may be positive or zero. •The public method clone, which overrides the method of the same name in class Object and throws no checked exceptions. The return type of the clone method of an array type T[] is T[]. A clone of a multidimensional array is shallow, which is to say that it creates only a single new array. Subarrays are shared. •All the members inherited from class Object; the only method of Object that is not inherited is its clone method.",10.97,177.64,360,617,72,77.56,432,255.2,FALSE,FALSE
429,2,BODY,"WHEN a program violates the semantic constraints of the Java programming language, the Java Virtual Machine signals this error to the program as an exception. An example of such a violation is an attempt to index outside the bounds of an array. Some programming languages and their implementations react to such errors by peremptorily terminating the program; other programming languages allow an implementation to react in an arbitrary or unpredictable way. Neither of these approaches is compatible with the design goals of the Java SE Platform: to provide portability and robustness. Instead, the Java programming language specifies that an exception will be thrown when semantic constraints are violated and will cause a non-local transfer of control from the point where the exception occurred to a point that can be specified by the programmer. An exception is said to be thrown from the point where it occurred and is said to be caught at the point to which control is transferred. Programs can also throw exceptions explicitly, using throw statements (§14.18). Explicit use of throw statements provides an alternative to the old-fashioned style of handling error conditions by returning funny values, such as the integer value -1 where a negative value would not normally be expected. Experience shows that too often such funny values are ignored or not checked for by callers, leading to programs that are not robust, exhibit undesirable behavior, or both. Every exception is represented by an instance of the class Throwable or one of its subclasses (§11.1). Such an object can be used to carry information from the point at which an exception occurs to the handler that catches it. Handlers are established by catch clauses of try statements (§14.20).",10.97,354.14,360.01,1762,72,220.36,432.01,574.5,FALSE,FALSE
434,2,BODY,"11.2.1Exception Analysis of Expressions A class instance creation expression (§15.9) can throw an exception class E iff either: •The expression is a qualified class instance creation expression and the qualifying expression can throw E; or •Some expression of the argument list can throw E; or •E is one of the exception types of the invocation type of the chosen constructor (§15.12.2.6); or •The class instance creation expression includes a ClassBody, and some instance initializer or instance variable initializer in the ClassBody can throw E. A method invocation expression (§15.12) can throw an exception class E iff either: •The method invocation expression is of the form Primary . [TypeArguments] Identifier and the Primary expression can throw E; or •Some expression of the argument list can throw E; or •E is one of the exception types of the invocation type of the chosen method (§15.12.2.6). A lambda expression (§15.27) can throw no exception classes. A switch expression (§15.28) can throw an exception class E iff either: •The selector expression can throw E; or •Some switch rule expression, switch rule block, switch rule throw statement, or switch labeled statement group in the switch block can throw E. For every other kind of expression, the expression can throw an exception class E iff one of its immediate subexpressions can throw E.",10.97,378.11,360,1358,72,76.09,432,454.2,FALSE,FALSE
444,5,BODY,"We now outline the steps the Java Virtual Machine may take to execute Test, as an example of the loading, linking, and initialization processes that are described further in later sections.",10.97,32.14,360,189,72,200.06,432,232.2,FALSE,FALSE
449,3,BODY,"12.3.2Preparation of a Class or Interface Preparation involves creating the static fields (class variables and constants) for a class or interface and initializing such fields to the default values (§4.12.5). This does not require the execution of any source code; explicit initializers for static fields are executed as part of initialization (§12.4), not preparation.",10.97,66.11,360,369,72,224.09,432,290.2,FALSE,FALSE
455,3,BODY,"8.Next, determine whether assertions are enabled (§14.10) for C by querying its",10.97,6.14,360,79,72,237.06,432,243.2,FALSE,FALSE
468,4,BODY,"Programs must be compiled either into the class file format specified by The Java Virtual Machine Specification, Java SE 23 Edition, or into a representation that can be mapped into that format by a class loader written in the Java programming language. A class file corresponding to a class or interface declaration must have certain properties. A number of these properties are specifically chosen to support source code transformations that preserve binary compatibility. The required properties are:",10.97,103.14,360,503,72,464.06,432,567.2,FALSE,FALSE
470,5,BODY,"5.Given a method invocation expression or a method reference expression in a class or interface C, referencing a method named m declared (or implicitly",10.97,19.14,360,151,72,519.06,432,538.2,FALSE,FALSE
475,2,BODY,"reference to the name of the class or interface indicated as the service by the directive. The following sections discuss changes that may be made to class and interface declarations without breaking compatibility with pre-existing binaries. Under the translation requirements given above, the Java Virtual Machine and its class file format support these changes. Any other valid binary format, such as a compressed or encrypted representation that is mapped back into class files by a class loader under the above requirements, will necessarily support these changes as well.",10.97,103.14,360.01,576,72,76.06,432.01,179.2,FALSE,FALSE
476,2,BODY,"13.3Evolution of Packages and Modules A new top level class or interface may be added to a package without breaking compatibility with pre-existing binaries, provided the new class or interface does not reuse a name previously given to an unrelated class or interface. If a new class or interface reuses a name previously given to an unrelated class or interface, then a conflict may result, since binaries for both classes or interfaces could not be loaded by the same class loader. Changes in top level classes and interfaces that are not public and that are not a superclass or superinterface, respectively, of a public class or interface, affect only classes and interfaces within the package in which they are declared. Such classes and interfaces may be deleted or otherwise changed, even if incompatibilities are otherwise described here, provided that the affected binaries of that package are updated together. If a module that was declared to export or open a package is changed to not export or open the package, or to export or open the package to a different set of friends, then an IllegalAccessError is thrown if a pre-existing binary is linked that needs but no longer has access to the public and protected classes and interfaces of the package. Such a change is not recommended for modules that have been widely distributed. If a module was not declared to export or open a given package, then changing the module to export or open the package does not break compatibility with pre-existing binaries. However, changing the module to export the package may prevent the program from starting, since any module that reads the module may also read some other module that exports a package with the same name. Adding a requires directive to a module declaration, or adding the transitive modifier to a requires directive, does not break compatibility with pre-existing binaries. However, it may prevent the program from starting, since the module may now read multiple modules that export packages with the same name. Deleting a requires directive in a module declaration, or deleting the transitive modifier from a requires directive, may break compatibility with any pre-existing binary that relied on the directive or modifier for readability of a given module in the course of referencing classes and interfaces exported by that module. An IllegalAccessError may be thrown when such a reference from a pre-existing binary is linked. Adding or deleting a uses or provides directive in a module declaration does not break compatibility with pre-existing binaries.",10.97,514.64,360.01,2578,72,77.56,432.01,592.2,FALSE,FALSE
494,5,BODY,"Deleting an enum constant from an enum class will delete the public field that corresponds to the enum constant (§8.9.3). The consequences are specified in §13.4.8. Such a change is not recommended for widely distributed enum classes. In all other respects, the binary compatibility rules for enum classes are identical to those for normal classes.",10.97,64.14,360,348,72,253.06,432,317.2,FALSE,FALSE
501,2,BODY,"•A yield with a given value The terms 'complete normally' and 'complete abruptly' also apply to the evaluation of expressions (§15.6). The only reason an expression can complete abruptly is that an exception is thrown, because of either a throw with a given value (§14.18) or a run-time exception or error (§11 (Exceptions), §15.6). If a statement evaluates an expression, abrupt completion of the expression always causes the immediate abrupt completion of the statement, with the same reason. All succeeding steps in the normal mode of execution are not performed. Unless otherwise specified in this chapter, abrupt completion of a substatement causes the immediate abrupt completion of the statement itself, with the same reason, and all succeeding steps in the normal mode of execution of the statement are not performed. Unless otherwise specified, a statement completes normally if all expressions it evaluates and all substatements it executes complete normally.",10.97,199.14,360.01,969,72,76.06,432.01,275.2,FALSE,FALSE
503,1,BODY,"A local interface may be a normal interface (§9.1), but not an annotation interface (§9.6). Every local interface is implicitly static (§9.1.1.3). Like an anonymous class (§15.9.5), a local class or interface is not a member of any package, class, or interface (§7.1, §8.5). Unlike an anonymous class, a local class or interface has a simple name (§6.2, §6.7). The scope and shadowing of a local class or interface declaration is specified in §6.3 and §6.4.",10.97,96.14,360,457,72,76.06,432,172.2,FALSE,FALSE
505,1,BODY,"•a pattern (§14.30.1) The rules concerning annotation modifiers for a local variable declaration are specified in §9.7.4 and §9.7.5. If the keyword final appears as a modifier for a local variable declaration, then the local variable is a final variable (§4.12.4). It is a compile-time error if final appears more than once as a modifier for a local variable declaration. It is a compile-time error if a local variable declaration that (i) does not include an Identifier and (ii) does not have an initializer, appears in any of the following locations: •a local variable declaration statement in a block (§14.4.2) •the header of a basic for statement (§14.14.1) It is a compile-time error if the LocalVariableType is var and any of the following are true: •More than one VariableDeclarator is listed. •The VariableDeclaratorId has one or more bracket pairs. •The VariableDeclarator lacks an initializer. •The initializer of the VariableDeclarator is an ArrayInitializer. •The initializer of the VariableDeclarator contains a reference to the variable.",10.97,312.14,360,1051,72,76.06,432,388.2,FALSE,FALSE
510,2,BODY,"The Identifier is declared to be the label of the immediately contained Statement. Unlike C and C++, the Java programming language has no goto statement; identifier statement labels are used with break or continue statements (§14.15, §14.16) appearing anywhere within the labeled statement. The scope of a label of a labeled statement is the immediately contained Statement. It is a compile-time error if the name of a label of a labeled statement is used within the scope of the label as a label of another labeled statement. There is no restriction against using the same identifier as a label and as the name of a package, class, interface, method, field, parameter, or local variable. Use of an identifier to label a statement does not obscure (§6.4.2) a package, class, interface, method, field, parameter, or local variable with the same name. Use of an identifier as a class, interface, method, field, local variable or as the parameter of an exception handler (§14.20) does not obscure a statement label with the same name. A labeled statement is executed by executing the immediately contained Statement. If the statement is labeled by an Identifier and the contained Statement completes abruptly because of a break with the same Identifier, then the labeled statement completes normally. In all other cases of abrupt completion of the Statement, the labeled statement completes abruptly for the same reason.",10.97,263.14,360.01,1417,72,76.06,432.01,339.2,FALSE,FALSE
514,2,BODY,"top level class or interface that lexically contains the assert statement enables assertions. Whether a top level class or interface enables assertions is determined no later than the earliest of (i) the initialization of the top level class or interface, and (ii) the initialization of any class or interface nested in the top level class or interface. Whether a top level class or interface enables assertions cannot be changed after it has been determined. An assert statement that is executed before its class or interface has completed initialization is enabled.",10.97,122.14,360,567,72,76.06,432,198.2,FALSE,FALSE
538,4,BODY,"•If execution of the Statement completes abruptly for any other reason, the do statement completes abruptly for the same reason.",10.97,19.14,360,128,72,236.06,432,255.2,FALSE,FALSE
571,5,BODY,•A switch rule block in a switch block is reachable iff the switch block is reachable. •A switch rule throw statement in a switch block is reachable iff the switch block is reachable.,10.97,51.14,360.01,183,72,472.06,432.01,523.2,FALSE,FALSE
578,5,BODY,"A type pattern is said to be null matching if it is appears directly in the component pattern list of a record pattern with type R, where the corresponding record component of R has type U, and the type pattern is unconditional for the type U (§14.30.3).",10.97,45.14,360,254,72,229.06,432,274.2,FALSE,FALSE
585,2,BODY,"•Method invocation expressions (§15.12) •Method reference expressions (§15.13) •Conditional expressions (§15.25) •Lambda expressions (§15.27) •switch expressions (§15.28) The rules determining whether an expression of one of these forms is a poly expression are given in the individual sections that specify these forms of expressions. Expressions that are not poly expressions are standalone expressions. Standalone expressions are expressions of the forms above when determined not to be poly expressions, as well as all expressions of all other forms. Expressions of all other forms are said to have a standalone form. Some expressions have a value that can be determined at compile time. These are constant expressions (§15.29).",10.97,217.14,360,732,72,76.06,432,293.2,FALSE,FALSE
606,2,BODY,"interface that is accessible and freely extensible (§9.1.1.4). Otherwise, a compile- time error occurs. If the Identifier in ClassOrInterfaceTypeToInstantiate denotes a class, C, then an anonymous direct subclass of C is declared. If TypeArguments is present, then C has type arguments given by TypeArguments; if <> is present, then C will have its type arguments inferred in §15.9.3; otherwise, C has no type arguments. The body of the subclass is the ClassBody given in the class instance creation expression. The class being instantiated is the anonymous subclass. If the Identifier in ClassOrInterfaceTypeToInstantiate denotes an interface, I, then an anonymous direct subclass of Object that implements I is declared. If TypeArguments is present, then I has type arguments given by TypeArguments; if <> is present, then I will have its type arguments inferred in §15.9.3; otherwise, I has no type arguments. The body of the subclass is the ClassBody given in the class instance creation expression. The class being instantiated is the anonymous subclass. •If the class instance creation expression is qualified, then: The Identifier in ClassOrInterfaceTypeToInstantiate must unambiguously denote an inner class that is accessible, freely extensible, not an enum class, and a member of the compile-time type of the Primary expression or the ExpressionName. Otherwise, a compile-time error occurs. Let the Identifier in ClassOrInterfaceTypeToInstantiate denote a class, C. An anonymous direct subclass of C is declared. If TypeArguments is present, then C has type arguments given by TypeArguments; if <> is present, then C will have its type arguments inferred in §15.9.3; otherwise, C has no type arguments. The body of the subclass is the ClassBody given in the class instance creation expression. The class being instantiated is the anonymous subclass. If a class instance creation expression does not declare an anonymous class, then: •If the class instance creation expression is unqualified, then: The Identifier in ClassOrInterfaceTypeToInstantiate must denote a class that is accessible, non-abstract, and not an enum class. Otherwise, a compile-time error occurs. The class being instantiated is specified by the Identifier in ClassOrInterfaceTypeToInstantiate. If TypeArguments is present, then the class has type arguments given by TypeArguments; if <> is present, then the class will have its type arguments inferred in §15.9.3; otherwise, the class has no type arguments.",10.97,515.14,360.01,2488,72,76.06,432.01,591.2,FALSE,FALSE
607,2,BODY,"•If the class instance creation expression is qualified, then: The ClassOrInterfaceTypeToInstantiate must unambiguously denote an inner class that is accessible, non-abstract, not an enum class, and a member of the compile-time type of the Primary expression or the ExpressionName. The class being instantiated is specified by the Identifier in ClassOrInterfaceTypeToInstantiate. If TypeArguments is present, then the class has type arguments given by TypeArguments; if <> is present, then the class will have its type arguments inferred in §15.9.3; otherwise, the class has no type arguments.",10.97,122.14,360.01,593,72,76.06,432.01,198.2,FALSE,FALSE
614,2,BODY,"It is a compile-time error if an argument to a class instance creation expression is not compatible with its target type, as derived from the invocation type (§15.12.2.6). If the compile-time declaration is applicable by variable arity invocation (§15.12.2.4), then where the last formal parameter type of the invocation type of the constructor is Fn[], it is a compile-time error if the type which is the erasure of Fn is not accessible at the point of invocation. The type of the class instance creation expression is the return type corresponding to the chosen constructor, as defined above.",10.97,109.14,360.01,594,72,76.06,432.01,185.2,FALSE,FALSE
642,2,BODY,"An expression is potentially compatible with a target type according to the following rules: •A lambda expression (§15.27) is potentially compatible with a functional interface type T (§9.8) if all of the following are true: –The arity of the function type of T (§9.9) is the same as the arity of the lambda expression. –If the function type of T has a void return, then the lambda body is either a statement expression (§14.8) or a void-compatible block (§15.27.2). –If the function type of T has a (non-void) return type, then the lambda body is either an expression or a value-compatible block (§15.27.2).",10.97,147.14,360,608,72,76.06,432,223.2,FALSE,FALSE
650,4,BODY,"2.Then, the thrown exception types include every type E which satisfies the",10.97,6.14,350,75,82,287.06,432,293.2,FALSE,FALSE
656,10,BODY,"15.12.4.2Evaluate Arguments The process of evaluating the argument list differs, depending on whether the method being invoked is a fixed arity method or a variable arity method (§8.4.1). If the method being invoked is a variable arity method m, it necessarily has n > 0 formal parameters, and the n'th parameter type of the invocation type (§15.12.2.6) of m necessarily has type T[] for some T. Let k be the number of actual argument expressions in the method invocation: if k ≠ n, or if k = n and the type of the k'th argument expression is not assignment compatible with T[], then m was found applicable by variable arity invocation (§15.12.2.4). In this case, the argument list",10.97,123.2,360.01,681,72,479.13,432.01,602.33,FALSE,FALSE
658,6,BODY,15.12.4.4Locate Method to Invoke As in the previous section (§15.12.4.3): •Let Q be the qualifying class or interface of the method invocation (§13.1). •Let m be the method found in Q or a superclass or superinterface of Q. (Note that m was merely the name of the method in the previous section; here it is the actual declaration.) •Let C be the class or interface that declares m. The strategy for locating a method to invoke depends on the invocation mode:,10.97,128.2,360.01,458,72,474.13,432.01,602.33,FALSE,FALSE
660,3,BODY,"3.If no method is found by the previous two steps, the superinterfaces of S are",10.97,6.14,360,79,72,134.06,432,140.2,FALSE,FALSE
668,2,BODY,"type targeted by the expression, just as the compile-time declaration of a method invocation depends on the invocation's arguments (§15.12.3). The search for a compile-time declaration mirrors the process for method invocations in §15.12.1 and §15.12.2, as follows: •First, a type to search is determined: –If the method reference expression has the form ExpressionName :: [TypeArguments] Identifier or Primary :: [TypeArguments] Identifier, the type to search is the type of the expression preceding the :: token. –If the method reference expression has the form ReferenceType :: [TypeArguments] Identifier, the type to search is the result of capture conversion (§5.1.10) applied to ReferenceType. –If the method reference expression has the form super :: [TypeArguments] Identifier, the type to search is the superclass type of the immediately enclosing class or interface declaration of the method reference expression. Let T be the class or interface declaration immediately enclosing the method reference expression. It is a compile-time error if T is the class Object or an interface. –If the method reference expression has the form TypeName . super :: [TypeArguments] Identifier, then if TypeName denotes a class, the type to search is the superclass type of the named class; otherwise, TypeName denotes an interface to search. It is a compile-time error if TypeName is neither a lexically enclosing class or interface declaration of the method reference expression, nor a direct superinterface of the immediately enclosing class or interface declaration of the method reference expression. It is a compile-time error if TypeName is the class Object. It is a compile-time error if TypeName is an interface, and there exists some other direct superclass or direct superinterface of the immediately enclosing class or interface declaration of the method reference expression, J, such that J is a subclass or subinterface of TypeName. –For the two other forms (involving :: new), the referenced method is notional and there is no type to search.",10.97,475.14,360.01,2051,72,76.06,432.01,551.2,FALSE,FALSE
669,3,BODY,"–If the method reference expression has the form ClassType :: [TypeArguments] new, then the potentially applicable methods are a set of notional methods corresponding to the constructors of ClassType. If ClassType is a raw type, but is not a non-static member type of a raw type, the candidate notional member methods are those specified in §15.9.3 for a class instance creation expression that uses <> to elide the type arguments to a class. Otherwise, the candidate notional member methods are the constructors of ClassType, treated as if they were methods with return type ClassType. Among these candidates, the potentially applicable methods are the notional methods that would be potentially applicable for a method invocation which has arity n, has type arguments TypeArguments, and appears in the same class as the method reference expression. –If the method reference expression has the form ArrayType :: new, a single notional method is considered. The method has a single parameter of type int, returns the ArrayType, and has no throws clause. If n = 1, this is the only potentially applicable method; otherwise, there are no potentially applicable methods. –For all other forms, the potentially applicable methods are the member methods of the type to search that would be potentially applicable for a method invocation which names Identifier, has arity n, has type argument TypeArguments, and appears in the same class as the method reference expression.",10.97,303.14,350.01,1466,82,288.06,432.01,591.2,FALSE,FALSE
682,6,BODY,"15.15.2Prefix Decrement Operator -- A unary expression preceded by a -- operator is a prefix decrement expression. The result of the unary expression must be a variable of a type that is convertible (§5.1.8) to a numeric type, or a compile-time error occurs. The type of the prefix decrement expression is the type of the variable. The result of the prefix decrement expression is not a variable, but a value.",10.97,91.11,360,409,72,488.09,432,579.2,FALSE,FALSE
686,6,BODY,MultiplicativeExpression: UnaryExpression MultiplicativeExpression * UnaryExpression MultiplicativeExpression / UnaryExpression MultiplicativeExpression % UnaryExpression,10.97,58.05,208.49,170,90,344.13,298.49,402.18,FALSE,TRUE
687,3,BODY,"15.17.2Division Operator / The binary / operator performs division, producing the quotient of its operands. The left-hand operand is the dividend and the right-hand operand is the divisor.",10.97,40.11,360,188,72,545.09,432,585.2,FALSE,FALSE
695,2,BODY,"If an integer addition overflows, then the result is the low-order bits of the mathematical sum as represented in some sufficiently large two's-complement format. If overflow occurs, then the sign of the result is not the same as the sign of the mathematical sum of the two operand values. The result of a floating-point addition is determined by the rules of IEEE 754 arithmetic: •If either operand is NaN, the result is NaN. •The sum of two infinities of opposite sign is NaN. •The sum of two infinities of the same sign is the infinity of that sign. •The sum of an infinity and a finite value is equal to the infinite operand. •The sum of two zeros of opposite sign is positive zero. •The sum of two zeros of the same sign is the zero of that sign. •The sum of a zero and a nonzero finite value is equal to the nonzero operand. •The sum of two nonzero finite values of the same magnitude and opposite sign is positive zero. •In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved, and the operands have the same sign or have different magnitudes, the exact mathematical sum is computed. If the magnitude of the sum is too large to represent, we say the operation overflows; the result is then an infinity of appropriate sign. Otherwise, the sum is rounded to the nearest representable value using the round to nearest rounding policy (§15.4). The Java programming language requires support of gradual underflow. The binary - operator performs subtraction when applied to two operands of numeric type, producing the difference of its operands; the left-hand operand is the minuend and the right-hand operand is the subtrahend. For both integer and floating-point subtraction, it is always the case that a-b produces the same result as a+(-b). Note that, for integer values, subtraction from zero is the same as negation. However, for floating-point operands, subtraction from zero is not the same as negation, because if x is +0.0, then 0.0-x is +0.0, but -x is -0.0. Despite the fact that overflow, underflow, or loss of information may occur, evaluation of a numeric additive operator never throws a run-time exception.",10.97,518.14,360.01,2151,72,76.06,432.01,594.2,FALSE,FALSE
704,4,BODY,"15.22.1Integer Bitwise Operators &, ^, and | When both operands of an operator &, ̂, or | are of a type that is convertible (§5.1.8) to a primitive integral type, binary numeric promotion is first performed on the operands (§5.6). The type of the bitwise operator expression is the promoted type of the operands. For &, the result value is the bitwise AND of the operand values. For ^, the result value is the bitwise exclusive OR of the operand values. For |, the result value is the bitwise inclusive OR of the operand values.",10.97,129.11,360,528,72,260.09,432,389.2,FALSE,FALSE
705,6,BODY,ConditionalAndExpression: InclusiveOrExpression ConditionalAndExpression && InclusiveOrExpression,10.97,32.05,246.29,97,90,402.13,336.29,434.18,FALSE,TRUE
706,4,BODY,ConditionalOrExpression: ConditionalAndExpression ConditionalOrExpression || ConditionalAndExpression,10.97,32.05,259.15,101,90,308.13,349.15,340.18,FALSE,TRUE
707,4,BODY,ConditionalExpression: ConditionalOrExpression ConditionalOrExpression ? Expression : ConditionalExpression ConditionalOrExpression ? Expression : LambdaExpression,10.97,45.05,295.81,163,90,212.13,385.81,257.18,FALSE,TRUE
724,4,BODY,"•Otherwise, consider the array component selected in the previous step, whose value was saved. This component is a variable; call its type S. Also, let T be",10.97,19.14,360,156,72,437.06,432,456.2,FALSE,FALSE
762,4,BODY,16.2.4Local Variable Declaration Statements •V is [un]assigned after a local variable declaration statement (§14.4.2) that contains no variable initializers iff V is [un]assigned before the local variable declaration statement. •V is definitely assigned after a local variable declaration statement that contains at least one variable initializer iff either V is definitely assigned after the last variable initializer in the local variable declaration statement or the last variable initializer in the declaration is in the declarator that declares V. •V is definitely unassigned after a local variable declaration statement that contains at least one variable initializer iff V is definitely unassigned after the last variable initializer in the local variable declaration statement and the last variable initializer in the declaration is not in the declarator that declares V. •V is [un]assigned before the first variable initializer in a local variable declaration statement iff V is [un]assigned before the local variable declaration statement. •V is definitely assigned before any variable initializer e other than the first one in the local variable declaration statement iff either V is definitely assigned after the variable initializer to the left of e or the initializer expression to the left of e is in the declarator that declares V. •V is definitely unassigned before any variable initializer e other than the first one in the local variable declaration statement iff V is definitely unassigned after the variable initializer to the left of e and the initializer expression to the left of e is not in the declarator that declares V.,10.97,317.11,360.01,1647,72,181.09,432.01,498.2,FALSE,FALSE
767,2,BODY,"•Otherwise, three rules apply: –V is [un]assigned after the initialization part iff V is [un]assigned after the last expression statement in the initialization part. –V is [un]assigned before the first expression statement in the initialization part iff V is [un]assigned before the initialization part. –V is [un]assigned before an expression statement S other than the first in the initialization part iff V is [un]assigned after the expression statement immediately preceding S.",10.97,115.14,360.01,481,72,76.06,432.01,191.2,FALSE,FALSE
770,3,BODY,•V is [un]assigned after an empty array initializer (§10.6) iff V is [un]assigned before the empty array initializer. •V is [un]assigned after a non-empty array initializer iff V is [un]assigned after the last variable initializer in the array initializer. •V is [un]assigned before the first variable initializer of the array initializer iff V is [un]assigned before the array initializer. •V is [un]assigned before any other variable initializer e of the array initializer iff V is [un]assigned after the variable initializer to the left of e in the array initializer.,10.97,115.14,360,570,72,108.06,432,223.2,FALSE,FALSE
775,2,BODY,"WHILE most of the discussion in the preceding chapters is concerned only with the behavior of code as executed a single statement or expression at a time, that is, by a single thread, the Java Virtual Machine can support many threads of execution at once. These threads independently execute code that operates on values and objects residing in a shared main memory. Threads may be supported by having many hardware processors, by time-slicing a single hardware processor, or by time- slicing many hardware processors. Threads are represented by the Thread class. The only way for a user to create a thread is to create an object of this class; each thread is associated with such an object. A thread will start when the start() method is invoked on the corresponding Thread object. The behavior of threads, particularly when not correctly synchronized, can be confusing and counterintuitive. This chapter describes the semantics of multithreaded programs; it includes rules for which values may be seen by a read of shared memory that is updated by multiple threads. As the specification is similar to the memory models for different hardware architectures, these semantics are known as the Java programming language memory model. When no confusion can arise, we will simply refer to these rules as 'the memory model'. These semantics do not prescribe how a multithreaded program should be executed. Rather, they describe the behaviors that multithreaded programs are allowed to exhibit. Any execution strategy that generates only allowed behaviors is an acceptable execution strategy.",10.97,297.14,360.01,1586,72,220.36,432.01,517.5,FALSE,FALSE
808,5,BODY,"A constraint formula of the form ‹LambdaExpression → T›, where T mentions at least one inference variable, is reduced as follows:",10.97,19.14,360,129,72,579.57,432,598.71,FALSE,FALSE
810,4,BODY,"A constraint formula of the form ‹MethodReference → T›, where T mentions at least one inference variable, is reduced as follows: •If T is not a functional interface type, or if T is a functional interface type that does not have a function type (§9.9), the constraint reduces to false.",10.97,51.14,360,285,72,537.59,432,588.73,FALSE,FALSE
811,4,BODY,"–Otherwise, a search for a compile-time declaration is performed, as specified in §15.13.1. If there is no compile-time declaration for the method reference, the constraint reduces to false. Otherwise, there is a compile-time declaration, and: (let R be the result of the function type) ›If R is void, the constraint reduces to true. ›Otherwise, if the method reference expression elides TypeArguments, and the compile-time declaration is a generic method, and the return type of the compile-time declaration mentions at least one of the method's type parameters, then: »If R mentions one of the type parameters of the function type, the constraint reduces to false.",10.97,154.14,350,666,82,410.06,432,564.2,FALSE,FALSE
816,3,BODY,"18.2.5Checked Exception Constraints A constraint formula of the form ‹LambdaExpression →throws T› is reduced as follows: •If T is not a functional interface type (§9.8), the constraint reduces to false. •Otherwise, let the target function type for the lambda expression be determined as specified in §15.27.3. If no valid function type can be found, the constraint reduces to false. •Otherwise, if the lambda expression is implicitly typed, and one or more of the function type's parameter types is not a proper type, the constraint reduces to false.",10.97,149.11,360,550,72,306.09,432,455.2,FALSE,FALSE
838,3,BODY,"5.Otherwise, the inference variables α1, ..., αn are resolved in B2 (§18.4). Unlike normal resolution, in this case resolution skips the step that attempts to produce an instantiation for an inference variable from its proper lower bounds or proper upper bounds; instead, any new instantiations are created by skipping directly to the step that introduces fresh type variables. If resolution fails, then inference fails.",10.97,77.14,360.01,420,72,146.06,432.01,223.2,FALSE,FALSE
847,2,BODY,ClassDeclaration: NormalClassDeclaration EnumDeclaration RecordDeclaration NormalClassDeclaration: {ClassModifier} class TypeIdentifier [TypeParameters] [ClassExtends] [ClassImplements] [ClassPermits] ClassBody,10.97,95.05,296.85,210,90,100.13,386.85,195.18,FALSE,TRUE
853,2,BODY,"RecordHeader: ( [RecordComponentList] ) RecordComponentList: RecordComponent {, RecordComponent} RecordComponent: {RecordComponentModifier} UnannType Identifier VariableArityRecordComponent VariableArityRecordComponent: {RecordComponentModifier} UnannType {Annotation} ... Identifier RecordComponentModifier: Annotation RecordBody: { {RecordBodyDeclaration} } RecordBodyDeclaration: ClassBodyDeclaration CompactConstructorDeclaration CompactConstructorDeclaration: {ConstructorModifier} SimpleTypeName ConstructorBody",10.97,304.05,316.95,517,90,126.13,406.95,430.18,FALSE,TRUE
20,2,BODY,"compile-time checking to ensure that exceptional conditions are handled. Objects can declare a finalize method that will be invoked before the objects are discarded by the garbage collector, allowing the objects to clean up their state. For simplicity, the language has neither declaration 'headers' separate from the implementation of a class nor separate type and class hierarchies. A restricted kind of class, enum classes, supports the definition of small sets of values and their manipulation in a type safe manner. Unlike enumerations in other languages, enum constants are objects and may have their own methods. Another restricted kind of class, record classes, supports the compact expression of simple objects that serve as aggregates of values. Chapter 9 describes interfaces. The members of interfaces are classes, interfaces, constant fields, and methods. Classes that are otherwise unrelated can implement the same interface. A variable of an interface type can contain a reference to any object that implements the interface. Classes and interfaces support multiple inheritance from interfaces. A class that implements one or more interfaces may inherit instance methods from both its superclass and its superinterfaces. Annotations are metadata that may be applied to declarations in a program, as well as to the uses of types in declarations and expressions. The form of an annotation is defined by an annotation interface, a specialized kind of interface. Annotations are not permitted to affect the semantics of programs in the Java programming language in any way. However, they provide useful input to various tools. Chapter 10 describes arrays. Array accesses include bounds checking. Arrays are dynamically created objects and may be assigned to variables of type Object. The language supports arrays of arrays, rather than multidimensional arrays. Chapter 11 describes exceptions, which are nonresuming and fully integrated with the language semantics and concurrency mechanisms. There are three kinds of exceptions: checked exceptions, run-time exceptions, and errors. The compiler ensures that checked exceptions are properly handled by requiring that a method or constructor can result in a checked exception only if the method or constructor declares it. This provides compile-time checking that exception handlers exist, and aids programming in the large. Most user-defined exceptions should be checked exceptions. Invalid operations in the program detected by the Java Virtual Machine result in run-time exceptions, such as NullPointerException. Errors result from failures detected by the Java Virtual Machine, such as OutOfMemoryError. Most simple programs do not try to handle errors.",10.96,509.14,360.01,2717,72,76.06,432.01,585.2,FALSE,FALSE
30,5,BODY,"Terminal symbols are shown in fixed width font in the productions of the lexical and syntactic grammars, and throughout this specification whenever the text is directly referring to such a terminal symbol. These are to appear in a program exactly as written. Nonterminal symbols are shown in italic type. The definition of a nonterminal is introduced by the name of the nonterminal being defined, followed by a colon. One or more alternative definitions for the nonterminal then follow on succeeding lines.",10.96,90.14,360.01,506,72,306.06,432.01,396.2,FALSE,FALSE
39,3,BODY,"The Java programming language specifies a standard way of transforming a program written in Unicode into ASCII that changes a program into a form that can be processed by ASCII-based tools. The transformation involves converting any Unicode escapes in the source text of the program to ASCII by adding an extra u - for example, \uxxxx becomes \uuxxxx - while simultaneously converting non- ASCII characters in the source text to Unicode escapes containing a single u each. This transformed version is equally acceptable to a Java compiler and represents the exact same program. The exact Unicode source can later be restored from this ASCII form by converting each escape sequence where multiple u's are present to a sequence of Unicode characters with one fewer u, while simultaneously converting each escape sequence with a single u to the corresponding single Unicode character.",10.96,142.14,360,881,72,362.06,432,504.2,FALSE,FALSE
47,5,BODY,"•For var, when recognized as a terminal in a LocalVariableType (§14.4) or a LambdaParameterType (§15.27.1).",10.96,19.14,342,107,90,418.06,432,437.2,FALSE,FALSE
51,2,BODY,"A decimal numeral is either the single ASCII digit 0, representing the integer zero, or consists of an ASCII digit from 1 to 9 optionally followed by one or more ASCII digits from 0 to 9 interspersed with underscores, representing a positive integer.",10.96,32.14,360,250,72,76.06,432,108.2,FALSE,FALSE
65,5,BODY,"Using the escape sequences \n and \' to represent a newline character and a double quote character, respectively, is permitted in a text block, though not usually necessary. The exception is where three consecutive double quote characters appear that are not intended to be the closing delimiter ''' - in this case, it is",10.96,45.14,360.01,321,72,558.06,432.01,603.2,FALSE,FALSE
107,3,BODY,"•If T is an array type, S[], then if the downward projection of S is S', the result is S'[]; if the downward projection of S is undefined, then the result is undefined. •If T is an intersection type, then if the downward projection is defined for each element of T, the result is an intersection type whose elements are the downward projections of the elements of T; if the downward projection is undefined for any element of T, then the result is undefined. Like lub (§4.10.4), upward projection and downward projection may produce infinite types, due to the recursion on type variable bounds.",10.96,109.14,360.01,594,72,262.06,432.01,371.2,FALSE,FALSE
113,4,BODY,"If T is a primitive type, then a variable of type 'array of T' can hold a null reference or a reference to any array of type 'array of T'. If T is a reference type, then a variable of type 'array of T' can hold a null reference or a reference to any array of type 'array of S' such that type S is a subclass or subinterface of type T. A variable of type Object[] can hold a reference to an array of any reference type. A variable of type Object can hold a null reference or a reference to any object, whether it is an instance of a class or an array. It is possible that a variable of a parameterized type will refer to an object that is not of that parameterized type. This situation is known as heap pollution. Heap pollution can only occur if the program performed some operation involving a raw type that would give rise to a compile-time unchecked warning (§4.8, §5.1.6, §5.1.9, §8.4.1, §8.4.8.3, §8.4.8.4, §9.4.1.2, §15.12.4.2), or if the program aliases an array variable of non-reifiable element type through an array variable of a supertype which is either raw or non-generic.",10.96,218.14,360.01,1085,72,209.06,432.01,427.2,FALSE,FALSE
115,3,BODY,"4.12.3Kinds of Variables There are eight kinds of variables: 1.A class variable is a field declared using the keyword static within a class declaration (§8.3.1.1), or with or without the keyword static within an interface declaration (§9.3). A class variable is created when its class or interface is prepared (§12.3.2) and is initialized to a default value (§4.12.5). The class variable effectively ceases to exist when its class or interface is unloaded (§12.7).",10.96,117.11,360,464,72,187.09,432,304.2,FALSE,FALSE
116,6,BODY,"clause of a try statement (§14.20). The new variable is initialized with the actual object associated with the exception (§11.3, §14.18). The exception parameter effectively ceases to exist when execution of the block associated with the catch clause is complete. 8.Local variables (§14.4) are declared by statements (§14.4.2, §14.14.1, §14.14.2, §14.20.3) and by patterns (§14.30). A local variable declared by a pattern is called a pattern variable. A local variable declared by a statement is created when the flow of control enters the nearest enclosing block (§14.2), for statement, or try-with- resources statement. A local variable declared by a statement is initialized as part of the execution of the statement, provided the variable's declarator has an initializer. The rules of definite assignment (§16 (Definite Assignment)) prevent the value of a local",10.96,186.14,360.01,865,72,308.06,432.01,494.2,FALSE,FALSE
119,2,BODY,"•A local variable declared by a statement and whose declarator lacks an initializer is effectively final if all of the following are true: –It is not declared final. –Whenever it occurs as the left hand side in an assignment expression, it is definitely unassigned and not definitely assigned before the assignment; that is, it is definitely unassigned and not definitely assigned after the right hand side of the assignment expression (§16 (Definite Assignment)). –It never occurs as the operand of a prefix or postfix increment or decrement operator.",10.96,128.14,360,552,72,76.06,432,204.2,FALSE,FALSE
131,2,BODY,"A narrowing conversion of a char to an integral type T likewise simply discards all but the n lowest order bits, where n is the number of bits used to represent type T. In addition to a possible loss of information about the magnitude of the numeric value, this may cause the resulting value to be a negative number, even though chars represent 16-bit unsigned integer values. A narrowing conversion of a floating-point number to an integral type T takes two steps: 1.In the first step, the floating-point number is converted either to a long, if T is",10.96,109.14,360.01,551,72,76.06,432.01,185.2,FALSE,FALSE
137,2,BODY,"reference conversion is not unchecked, then it is checked; the Java Virtual Machine will be able to fully validate its type correctness, so no warning is given at compile time. The unchecked narrowing reference conversions are as follows: •A narrowing reference conversion from a type S to a parameterized class or interface type T is unchecked, unless at least one of the following is true: –All of the type arguments of T are unbounded wildcards. –T <: S, and S has no subtype X other than T where the type arguments of X are not contained in the type arguments of T.",10.96,134.14,360.01,569,72,76.06,432.01,210.2,FALSE,FALSE
167,2,BODY,"•A member of a reference type (§8.2, §9.2, §8.9.3, §9.6, §10.7), one of the following: –A member class (§8.5, §9.5) –A member interface (§8.5, §9.5) –A field, one of the following: ›A field declared in a class (§8.3) ›A field declared in an interface (§9.3) ›An implicitly declared field of a class corresponding to an enum constant or a record component ›The field length, which is implicitly a member of every array type (§10.7) –A method, one of the following: ›A method (abstract or otherwise) declared in a class (§8.4) ›A method (abstract or otherwise) declared in an interface (§9.4) ›An implicitly declared accessor method corresponding to a record component",10.96,254.14,360,666,72,76.06,432,330.2,FALSE,FALSE
167,3,BODY,"•An enum constant (§8.9.1) •A record component (§8.10.3) •A formal parameter, one of the following: –A formal parameter of a method of a class or interface (§8.4.1) –A formal parameter of a constructor of a class (§8.8.1) –A formal parameter of a lambda expression (§15.27.1) •An exception parameter of an exception handler declared in a catch clause of a try statement (§14.20) •A local variable, one of the following: –A local variable declared by a local variable declaration statement in a block (§14.4.2) –A local variable declared by a for statement or a try-with-resources statement (§14.14, §14.20.3) –A local variable declared by a pattern (§14.30.1)",10.96,235.14,360,659,72,343.06,432,578.2,FALSE,FALSE
187,2,BODY,"The following rules apply to a switch statement with a switch block consisting of switch labeled statement groups (§14.11.1): •A pattern variable introduced by a switch label is definitely matched in all the statements of the associated switch labeled statement group. •A pattern variable introduced by a statement S contained in a switch block statement group is definitely matched at all the statements following S, if any, in the switch block statement group. 6.3.2.7Labeled Statements The following rule applies to a labeled statement (§14.7): •A pattern variable is introduced by a labeled statement L: S (where L is a label) iff (i) it is introduced by the statement S, and (ii) S does not contain a reachable break statement for which the labeled statement is the break target (§14.15).",10.96,188.27,360,793,72,76.06,432,264.33,FALSE,FALSE
188,4,BODY,"It is a compile-time error if the name of a formal parameter is used to declare a new variable within the body of the method, constructor, or lambda expression, unless the new variable is declared within a class or interface declaration contained by the method, constructor, or lambda expression. It is a compile-time error if the name of a local variable v is used to declare a new variable within the scope of v, unless the new variable is declared within a class or interface declaration appearing within the scope of v. It is a compile-time error if the name of an exception parameter is used to declare a new variable within the Block of the catch clause, unless the new variable is declared within a class or interface declaration contained by the Block of the catch clause. It is a compile-time error if the name of a local class or interface C is used to declare a new local class or interface within the scope of C, unless the new local class or interface is declared within a class or interface declaration appearing within the scope of C.",10.96,206.14,360.01,1049,72,166.06,432.01,372.2,FALSE,FALSE
191,3,BODY,"6.4.1Shadowing Some declarations may be shadowed in part of their scope by another declaration of the same name, in which case a simple name cannot be used to refer to the declared entity. Shadowing is distinct from hiding (§8.3, §8.4.8.2, §8.5, §9.3, §9.5), which applies only to members which would otherwise be inherited but are not because of a declaration in a subclass. Shadowing is also distinct from obscuring (§6.4.2). A declaration d of a type named n shadows the declarations of any other types named n that are in scope at the point where d occurs throughout the scope of d. A declaration d of a field or formal parameter named n shadows, throughout the scope of d, the declarations of any other variables named n that are in scope at the point where d occurs. A declaration d of a local variable or exception parameter named n shadows, throughout the scope of d, (a) the declarations of any other fields named n that are in scope at the point where d occurs, and (b) the declarations of any other variables named n that are in scope at the point where d occurs but are not declared in the innermost class in which d is declared. A declaration d of a method named n shadows the declarations of any other methods named n that are in an enclosing scope at the point where d occurs throughout the scope of d. A package declaration never shadows any other declaration. A type-import-on-demand declaration never causes any other declaration to be shadowed. A static-import-on-demand declaration never causes any other declaration to be shadowed. A single-type-import declaration d in a compilation unit c of package p that imports a type named n shadows, throughout c, the declarations of: •any top level type named n declared in another compilation unit of p",10.96,425.11,360.01,1766,72,165.09,432.01,590.2,FALSE,FALSE
202,5,BODY,"The meaning of a name classified as a PackageName is determined as follows. 6.5.3.1Simple Package Names If a package name consists of a single Identifier, then the identifier must occur in the scope of exactly one declaration of a top level package with this name (§6.3), and that package must be uniquely visible to the current module (§7.4.3), or a compile- time error occurs. The meaning of the package name is that package. 6.5.3.2Qualified Package Names If a package name is of the form Q.Id, then Q must also be a package name. The package name Q.Id names a package that is the member named Id within the package named by Q. If Q.Id does not name a package that is uniquely visible to the current module (§7.4.3), then a compile-time error occurs.",10.96,197.4,360,753,72,298.06,432,495.46,FALSE,FALSE
234,5,BODY,"A package is uniquely visible to a module M if and only if one of the following holds: •An ordinary compilation unit associated with M contains a declaration of the package, and M does not read any other module that exports the package to M. •No ordinary compilation unit associated with M contains a declaration of the package, and M reads exactly one other module that exports the package to M.",10.96,70.14,360.01,396,72,258.06,432.01,328.2,FALSE,FALSE
253,2,BODY,"A class declaration defines a new class and describes how it is implemented (§8.1). A top level class (§7.6) is a class declared directly in a compilation unit. A nested class is any class whose declaration occurs within the body of another class or interface declaration. A nested class may be a member class (§8.5, §9.5), a local class (§14.3), or an anonymous class (§15.9.5). Some kinds of nested class are an inner class (§8.1.3), which is a class that can refer to enclosing class instances, local variables, and type variables. An enum class (§8.9) is a class declared with abbreviated syntax that defines a small set of named class instances. A record class (§8.10) is a class declared with abbreviated syntax that defines a simple aggregate of values. This chapter discusses the common semantics of all classes. Details that are specific to particular kinds of classes are discussed in the sections dedicated to these constructs. A class may be declared public (§8.1.1) so it can be referred to from code in any package of its module and potentially from code in other modules. A class may be declared abstract (§8.1.1.1), and must be declared abstract if it is incompletely implemented; such a class cannot be instantiated, but can be extended by subclasses. The degree to which a class can be extended can be controlled explicitly (§8.1.1.2): it may be declared sealed to limit its subclasses, or it may be declared final to ensure no subclasses. Each class except Object is an extension of (that is, a subclass of) a single existing class (§8.1.4) and may implement interfaces (§8.1.5). A class may be generic (§8.1.2), that is, its declaration may introduce type variables whose bindings differ among different instances of the class.",10.96,372.14,360.01,1747,72,220.36,432.01,592.5,FALSE,FALSE
263,4,BODY,"A construct (statement, local variable declaration statement, local class declaration, local interface declaration, or expression) occurs in a static context if the innermost: •method declaration, •field declaration, •constructor declaration, •instance initializer, •static initializer, or •explicit constructor invocation statement which encloses the construct is one of the following: •a static method declaration (§8.4.3.2, §9.4) •a static field declaration (§8.3.1.1, §9.3) •a static initializer (§8.7) •an explicit constructor invocation statement (§8.8.7.1)",10.96,228.14,360.01,563,72,340.06,432.01,568.2,FALSE,FALSE
264,3,BODY,An inner class C is a direct inner class of a class or interface O if O is the immediately enclosing class or interface declaration of C and the declaration of C does not occur in a static context.,10.96,32.14,360,197,72,362.06,432,394.2,FALSE,FALSE
264,7,BODY,A class or interface O is the zeroth lexically enclosing class or interface declaration of itself. A class O is the n'th lexically enclosing class declaration of a class C if it is the immediately enclosing class declaration of the n-1'th lexically enclosing class declaration of C.,10.96,64.14,360.01,282,72,525.06,432.01,589.2,FALSE,TRUE
269,8,BODY,"Each InterfaceType must name an accessible interface (§6.6), or a compile-time error occurs. It is a compile-time error if any InterfaceType names a interface that is sealed (§9.1.1.4) and the class being declared is not a permitted direct subclass of the named interface (§9.1.4). If an InterfaceType has type arguments, it must denote a well-formed parameterized type (§4.5), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. It is a compile-time error if the same interface is named by a direct superinterface type more than once in a single implements clause. This is true even if the interface is named in different ways.",10.96,154.14,360.01,671,72,350.56,432.01,504.7,FALSE,FALSE
273,2,BODY,"Every TypeName must name an accessible class (§6.6), or a compile-time error occurs. It is a compile-time error if the same class is specified more than once in a permits clause. This is true even if the class is named in different ways.",10.96,51.14,360,237,72,76.06,432,127.2,FALSE,FALSE
290,3,BODY,"8.3.2Field Initialization If a declarator in a field declaration has a variable initializer, then the declarator has the semantics of an assignment (§15.26) to the declared variable. If the declarator is for a class variable (that is, a static field) (§8.3.1.1), then the following rules apply to its initializer: •The initializer may not refer to the current object using the keyword this or the keyword super, as specified in §15.8.3 and §15.11.2, nor refer by simple name to any instance variable or instance method, as specified in §6.5.6.1 and §15.12.3. •At run time, the initializer is evaluated and the assignment performed exactly once, when the class is initialized (§12.4.2).",10.96,149.11,360.01,685,72,137.09,432.01,286.2,FALSE,FALSE
312,4,BODY,An overridden method can be accessed by using a method invocation expression (§15.12) that contains the keyword super. A qualified name or a cast to a superclass type is not effective in attempting to access an overridden method.,10.96,32.14,360,229,72,353.06,432,385.2,FALSE,FALSE
315,2,BODY,A hidden method can be accessed by using a qualified name or by using a method invocation expression (§15.12) that contains the keyword super or a cast to a superclass type.,10.96,32.14,360.01,173,72,76.06,432.01,108.2,FALSE,FALSE
325,5,BODY,"It is a compile-time error if an instance initializer cannot complete normally (§14.22). It is a compile-time error if a return statement (§14.17) appears anywhere within an instance initializer. An instance initializer is permitted to refer to the current object using the keyword this (§15.8.3) or the keyword super (§15.11.2, §15.12), and to use any type variables in scope. Restrictions on how an instance initializer may refer to instance variables, even when the instance variables are in scope, are specified in §8.3.3. Exception checking for an instance initializer is specified in §11.2.3.",10.96,147.14,360.01,598,72,346.06,432.01,493.2,FALSE,FALSE
330,6,BODY,ConstructorBody: { [ExplicitConstructorInvocation] [BlockStatements] },10.96,19.05,253.32,70,90,324.13,343.32,343.18,FALSE,TRUE
350,4,BODY,"8.10.3Record Members For each record component, a record class has a field with the same name as the record component and the same type as the declared type of the record component. This field, which is declared implicitly, is known as a component field. A component field is private, final, and non-static. A component field is annotated with the annotations, if any, that appear on the corresponding record component and whose annotation interfaces are applicable in the field declaration context, or in type contexts, or both (§9.7.4). Furthermore, for each record component, a record class has a method with the same name as the record component and an empty formal parameter list. This method, which is declared explicitly or implicitly, is known as an accessor method. If an accessor method for a record component is declared explicitly, then all of the following must be true, or a compile-time error occurs: •The return type of the accessor method (§8.4.5) must be the same as the declared type of the record component. •The accessor method must not be generic (§8.4.4).",10.96,245.11,360.01,1078,72,332.09,432.01,577.2,FALSE,FALSE
355,2,BODY,"•If the record class has package access, then the canonical constructor must not be private; otherwise, a compile-time error occurs. •If the record class is private, then the canonical constructor may be declared with any accessibility. An explicitly declared canonical constructor may be a fixed arity constructor or a variable arity constructor (§8.8.1). If a canonical constructor is not explicitly declared in the declaration of a record class R, then a canonical constructor r is implicitly declared in R with the following properties: •The signature of r has no type parameters, and has formal parameters given by the derived formal parameter list of R, defined below. •r has the same access modifier as R, unless R lacks an access modifier, in which case r has package access. •r has no throws clause. •The body of r initializes each component field of the record class with the corresponding formal parameter of r, in the order that record components (corresponding to the component fields) appear in the record header. The derived formal parameter list of a record class is formed by deriving a formal parameter from each record component in the record header, in order, as follows: •If the record component is not a variable arity record component, then the derived formal parameter has the same name and declared type as the record component. If the record component is a variable arity record component, then the derived formal parameter is a variable arity parameter (§8.4.1) with the same name and declared type as the record component. •The derived formal parameter is annotated with the annotations, if any, that appear on the record component and whose annotation interfaces are applicable in the formal parameter context, or in type contexts, or both (§9.7.4). A record declaration may contain declarations of constructors that are not canonical constructors. The body of every non-canonical constructor in a record declaration must start with an alternate constructor invocation (§8.8.7.1), or a compile-time error occurs.",10.96,468.14,360.01,2041,72,76.06,432.01,544.2,FALSE,FALSE
364,3,BODY,9.1.4Permitted Direct Subclasses and Subinterfaces The optional permits clause in a normal interface declaration specifies all the classes and interfaces intended as direct subclasses and direct subinterfaces of the interface being declared (§9.1.1.4).,10.96,53.11,360,252,72,511.09,432,564.2,FALSE,FALSE
366,2,BODY,in the same compilation unit as I (§7.3) which have a canonical name (§6.7) and whose direct superinterfaces include I.,10.96,19.14,360,119,72,76.06,432,95.2,FALSE,FALSE
399,2,BODY,"The TypeName specifies the annotation interface corresponding to the annotation. The annotation is said to be 'of' that interface. The TypeName must name an accessible annotation interface (§6.6), or a compile- time error occurs. The Identifier in an element-value pair must be the simple name of one of the elements (that is, methods) of the annotation interface, or a compile-time error occurs. The return type of this method defines the element type of the element-value pair. If the element type is an array type, then it is not required to use curly braces to specify the element value of the element-value pair. If the element value is not an ElementValueArrayInitializer, then an array value whose sole element is the element value is associated with the element. If the element value is an ElementValueArrayInitializer, then the array value represented by the ElementValueArrayInitializer is associated with the element. It is a compile-time error if the element type is not commensurate with the element value. An element type T is commensurate with an element value v if and only if one of the following is true: •T is an array type E[], and either: –If v is a ConditionalExpression or an Annotation, then v is commensurate with E; or –If v is an ElementValueArrayInitializer, then each element value that v contains is commensurate with E.",10.96,327.14,360,1350,72,76.06,432,403.2,FALSE,FALSE
401,10,BODY,9.7.3Single-Element Annotations A single-element annotation is a shorthand designed for use with single-element annotation interfaces (§9.6.1). SingleElementAnnotation: @ TypeName ( ElementValue ),10.96,77.09,359.99,196,72,330.09,431.99,407.18,FALSE,FALSE
401,12,BODY,"It is legal to use single-element annotations for annotation interfaces with multiple elements, so long as one element is named value and all other elements have default values (§9.6.2).",10.96,32.14,360.01,186,72,467.06,432.01,499.2,FALSE,FALSE
412,6,BODY,"If no such method exists, then let m be a method in M with: 1.a signature that is a subsignature of every method's signature in M; and 2.a return type such that m is return-type-substitutable (§8.4.5) for every",10.96,44.14,350,210,82,502.06,432,546.2,FALSE,FALSE
414,3,BODY,•The function type of the raw type of a generic functional interface I<...> is the erasure of the function type of the generic functional interface I<...>. •The function type of an intersection type that induces a notional functional interface is the function type of the notional functional interface.,10.96,51.14,360,302,72,280.06,432,331.2,FALSE,FALSE
420,16,BODY,"Once an array object is created, its length never changes. To make an array variable refer to an array of different length, a reference to a different array must be assigned to the variable. A single variable of array type may contain references to arrays of different lengths, because an array's length is not part of its type. If an array variable v has type A[], where A is a reference type, then v can hold a reference to an instance of any array type B[], provided B can be assigned to A",10.96,96.14,360.01,492,72,507.06,432.01,603.2,FALSE,FALSE
434,4,BODY,11.2.2Exception Analysis of Statements A throw statement (§14.18) whose thrown expression has static type E and is not a final or effectively final exception parameter can throw E or any exception class that the thrown expression can throw.,10.96,53.11,360,240,72,542.09,432,595.2,FALSE,FALSE
445,2,BODY,"The resolution step is optional at the time of initial linkage. An implementation may resolve symbolic references from a class or interface that is being linked very early, even to the point of resolving all symbolic references from the classes and interfaces that are further referenced, recursively. (This resolution may result in errors from these further loading and linking steps.) This implementation choice represents one extreme and is similar to the kind of 'static' linkage that has been done for many years in simple implementations of the C language. (In these implementations, a compiled program is typically represented as an 'a.out' file that contains a fully-linked version of the program, including completely resolved links to library routines used by the program. Copies of these library routines are included in the 'a.out' file.) An implementation may instead choose to resolve a symbolic reference only when it is actively used; consistent use of this strategy for all symbolic references would represent the 'laziest' form of resolution. In this case, if Test had several symbolic references to another class, then the references might be resolved one at a time, as they are used, or perhaps not at all, if these references were never used during execution of the program. The only requirement on when resolution is performed is that any errors detected during resolution must be thrown at a point in the program where some action is taken by the program that might, directly or indirectly, require linkage to the class or interface involved in the error. Using the 'static' example implementation choice described above, loading and linkage errors could occur before the program is executed if they involved a class or interface mentioned in the class Test or any of the further, recursively referenced, classes and interfaces. In a system that implemented the 'laziest' resolution, these errors would be thrown only when an incorrect symbolic reference is actively used. The resolution process is described further in §12.3.3.",10.96,362.14,360.01,2051,72,76.06,432.01,438.2,FALSE,FALSE
483,2,BODY,"package, or private access. Changing a member or constructor to permit less access is therefore not recommended for widely distributed classes. Perhaps surprisingly, the binary format is defined so that changing a member or constructor to be more accessible does not cause a linkage error when a subclass (already) defines a method to have less access.",10.96,64.14,360,352,72,76.06,432,140.2,FALSE,FALSE
484,2,BODY,"13.4.8Field Declarations Widely distributed programs should not expose any fields to their clients. Apart from the binary compatibility issues discussed below, this is generally good software engineering practice. Adding a field to a class may break compatibility with pre-existing binaries that are not recompiled. Assume a reference to a field f with qualifying class C. Assume further that f is in fact an instance (respectively static) field declared in a superclass of C, S, and that the type of f is X. If a new field of type X with the same name as f is added to a subclass of S that is a superclass of C or C itself, then a linkage error may occur. Such a linkage error will occur only if, in addition to the above, either one of the following is true: •The new field is less accessible than the old one. •The new field is a static (respectively instance) field. In particular, no linkage error will occur in the case where a class could no longer be recompiled because a field access previously referenced a field of a superclass with an incompatible type. The previously compiled class with such a reference will continue to reference the field declared in a superclass.",10.96,252.11,360.01,1180,72,76.09,432.01,328.2,FALSE,FALSE
486,2,BODY,"reference from a pre-existing binary is linked. Only private fields may be safely deleted from a widely distributed class. For purposes of binary compatibility, adding or deleting a field f whose type involves type variables (§4.4) or parameterized types (§4.5) is equivalent to the addition (respectively, deletion) of a field of the same name whose type is the erasure (§4.6) of the type of f.",10.96,77.14,360,395,72,76.06,432,153.2,FALSE,FALSE
486,11,BODY,"Deleting the keyword final or changing the value to which a field is initialized does not break compatibility with existing binaries. If a field is a constant variable (§4.12.4), and moreover is static, then deleting the keyword final or changing its value will not break compatibility with pre- existing binaries by causing them not to run, but they will not see any new value for a usage of the field unless they are recompiled. This result is a side-effect of the decision to support conditional compilation (§14.22). (One might suppose that the new value is not seen if the usage occurs in a constant expression (§15.29) but is seen otherwise. This is not so; pre-existing binaries do not see the new value at all.)",10.96,116.14,360,719,72,487.06,432,603.2,FALSE,FALSE
490,2,BODY,"13.4.15Method Result Type Changing the result type of a method, or replacing a result type with void, or replacing void with a result type, has the combined effect of deleting the old method and adding a new method with the new result type or newly void result (see §13.4.12). For purposes of binary compatibility, adding or deleting a method or constructor m whose return type involves type variables (§4.4) or parameterized types (§4.5) is equivalent to the addition (respectively, deletion) of the an otherwise equivalent method whose return type is the erasure (§4.6) of the return type of m.",10.96,124.11,360.01,596,72,76.09,432.01,200.2,FALSE,FALSE
507,4,BODY,LocalVariableDeclarationStatement: LocalVariableDeclaration ;,10.96,19.05,163.77,61,90,180.13,253.77,199.18,FALSE,TRUE
509,9,BODY,LabeledStatement: Identifier : Statement LabeledStatementNoShortIf: Identifier : StatementNoShortIf,10.96,56.05,148.62,99,90,545.13,238.62,601.18,FALSE,TRUE
532,6,BODY,"•If a switch label applies, then one of the following holds: –If it is the switch label for a switch rule expression, then the switch rule expression is necessarily a statement expression (§14.11.2). The statement expression is evaluated. If the evaluation completes normally, then the switch",10.96,51.14,360,292,72,515.06,432,566.2,FALSE,FALSE
541,8,BODY,"•If execution of the Statement completes abruptly for any other reason, the for statement completes abruptly for the same reason.",10.96,19.14,360,129,72,532.2,432,551.33,FALSE,FALSE
563,2,BODY,"•The VariableDeclarator has an initializer. •The VariableDeclaratorId has no bracket pairs. The scope and shadowing of a local variable declared in a resource specification is specified in §6.3 and §6.4. References to the local variable from a nested class or interface, or a lambda expression, are restricted, as specified in §6.5.6.1. The type of a local variable declared in a resource specification is specified in §14.4.1. The type of a local variable declared in a resource specification, or the type of an existing variable referred to in a resource specification, must be a subtype of AutoCloseable, or a compile-time error occurs. It is a compile-time error for a resource specification to declare two local variables with the same name.",10.96,198.14,360.01,746,72,76.06,432.01,274.2,FALSE,FALSE
578,2,BODY,"•If the LocalVariableType is var then the type pattern must appear directly in the component pattern list of a record pattern, or a compile-time error occurs. Let R be the type of the record pattern, and let T be the type of the corresponding component field in R (§8.10.3). The type of the pattern variable is the upward projection of T with respect to all synthetic type variables mentioned by T.",10.96,64.14,360,398,72,76.06,432,140.2,FALSE,FALSE
579,2,BODY,"The match-all pattern is a special pattern that declares no pattern variables and can only appear directly in the component pattern list of a record pattern r. Let R be the type of the record pattern r, and let T be the type of the corresponding component field in R (§8.10.3). The type of the match-all pattern is the upward projection of T with respect to all synthetic type variables mentioned by T.",10.96,64.14,360.01,402,72,76.06,432.01,140.2,FALSE,FALSE
581,2,BODY,•A type pattern that declares a pattern variable of a primitive type P is unconditional for the type P. •A match-all pattern is unconditional for every type T.,10.96,38.14,360,159,72,76.06,432,114.2,FALSE,FALSE
603,2,BODY,It is a compile-time error if the class or interface whose declaration immediately encloses a qualified this expression is not an inner class of TypeName or TypeName itself.,10.96,32.14,360,173,72,76.06,432,108.2,FALSE,FALSE
609,2,BODY,"•If S is an inner member class, then: –If the class instance creation expression is unqualified, then: ›If the class instance creation expression occurs in a static context, then a compile-time error occurs. ›Otherwise, if S is not a member of any class whose declaration encloses the class instance creation expression, then a compile-time error occurs. ›Otherwise, let O be the innermost enclosing class declaration of which S is a member, and let U be the immediately enclosing class or interface declaration of the class instance creation expression. If U is not an inner class of O or O itself, then a compile-time error occurs. Let n be an integer such that O is the n'th lexically enclosing class or interface declaration of U. The immediately enclosing instance of i with respect to S is the n'th lexically enclosing instance of this. ›Otherwise, a compile-time error occurs. –If the class instance creation expression is qualified, then the immediately enclosing instance of i with respect to S is the object that is the value of the Primary expression or the ExpressionName.",10.96,281.14,360,1084,72,76.06,432,357.2,FALSE,FALSE
610,2,BODY,"•If C is a local class or a private inner member class, then the arguments to the constructor are the arguments in the argument list of the class instance creation expression, if any, in the order they appear in the class instance creation expression. •If C is a non-private inner member class, then the first argument to the constructor is the immediately enclosing instance of i (§8.8.1, §15.9.2), and the subsequent arguments to its constructor are the arguments in the argument list of the class instance creation expression, if any, in the order they appear in the class instance creation expression. •Otherwise, the arguments to the constructor are the arguments in the argument list of the class instance creation expression, if any, in the order they appear in the expression. Second, a constructor of C and corresponding throws clause and return type are determined: •If the class instance creation expression does not use <>, then: –If C is not an anonymous class, then: Let T be the type denoted by C followed by any class type arguments in the expression. The process specified in §15.12.2, modified to handle",10.96,263.14,360.01,1121,72,76.06,432.01,339.2,FALSE,FALSE
617,2,BODY,"•If S is not an inner class, or if S is a local class that occurs in a static context, then the anonymous constructor has one formal parameter for each actual argument to the class instance creation expression or enum constant that declares C. The actual arguments to the class instance creation expression or enum constant are used to determine a constructor x of S, as specified in §15.9.3. The type of each formal parameter of the anonymous constructor is made identical to the corresponding formal parameter of x. The anonymous constructor body consists of an explicit constructor invocation (§8.8.7.1) of the form super(...), where the actual arguments are the formal parameters of the anonymous constructor, in the order they were declared. The superclass constructor to be invoked is x. •Otherwise, the first formal parameter of the anonymous constructor represents the value of the immediately enclosing instance of i with respect to S (§15.9.2). The type of this parameter is the class type that immediately encloses the declaration of S. The anonymous constructor has an additional formal parameter for each actual argument to the class instance creation expression that declared the anonymous class. The n'th formal parameter corresponds to the n-1'th actual argument. The actual arguments to the class instance creation expression are used to determine a constructor x of S, as specified in §15.9.3. The type of each formal parameter of the anonymous constructor is made identical to the corresponding formal parameter of x. The anonymous constructor body consists of an explicit constructor invocation of the form o.super(...), where o is the first formal parameter of the anonymous constructor, and the actual arguments are the subsequent formal parameters of the constructor, in the order they were declared. The superclass constructor to be invoked is x. In all cases, the throws clause of an anonymous constructor lists all the checked exceptions thrown by the explicit constructor invocation statement contained in the anonymous constructor, as specified in §15.9.3, and all checked exceptions thrown by any instance initializers or instance variable initializers of the anonymous class. Note that it is possible for the signature of the anonymous constructor to refer to an inaccessible type (for example, if such a type occurred in the signature of the superclass constructor x). This does not, in itself, cause any errors at either compile- time or run-time.",10.96,496.14,360.01,2479,72,76.06,432.01,572.2,FALSE,FALSE
619,2,BODY,"Each dimension expression undergoes unary numeric promotion (§5.6). The promoted type must be int, or a compile-time error occurs. The type of the array creation expression is an array type that can denoted by a copy of the array creation expression from which the new keyword and every DimExpr expression and array initializer have been deleted.",10.96,64.14,360.01,346,72,76.06,432.01,140.2,FALSE,FALSE
644,2,BODY,"•If m is not a generic method, then m is applicable by strict invocation if, for 1 ≤ i ≤ n, either ei is compatible in a strict invocation context with Fi (§5.3) or ei is not pertinent to applicability. If no method applicable by strict invocation is found, the search for applicable methods continues with phase 2 (§15.12.2.3). Otherwise, the most specific method (§15.12.2.5) is chosen among the methods that are applicable by strict invocation.",10.96,96.14,360,447,72,76.06,432,172.2,FALSE,FALSE
648,4,BODY,"–e is a parenthesized expression, and one of these conditions applies recursively to the contained expression. –e is a conditional expression, and, for each of the second and third operands, one of these conditions applies recursively. –e is a switch expression, and, for each of its result expressions, one of these conditions applies recursively.",10.96,83.14,350.01,348,82,479.06,432.01,562.2,FALSE,FALSE
650,2,BODY,"every maximally specific method's return type (after adapting for any type parameters (§8.4.4) if the two methods have the same signature). If no preferred method exists according to the above rules, then a maximally specific method is preferred if it: –has a signature that is a subsignature of every maximally specific method's signature; and –is return-type-substitutable (§8.4.5) for every maximally specific method. The thrown exception types of the most specific method are derived from the throws clauses of the maximally specific methods, as follows: 1.If the most specific method is generic, the throws clauses are first adapted",10.96,153.14,350,637,82,76.06,432,229.2,FALSE,FALSE
653,2,BODY,overrides (§9.4.1) the compile-time declaration from a direct superclass or direct superinterface of E.,10.96,19.14,340,103,92,76.06,432,95.2,FALSE,FALSE
659,4,BODY,"The procedure for dynamic method lookup is as follows. Let S be the class to search, beginning with R. Then: 1.If class S contains a declaration for a method that overrides method m of class or interface C from R (§8.4.8.1), then that overriding method is the method to be invoked, and the procedure terminates.",10.96,64.14,360,311,72,537.06,432,601.2,FALSE,FALSE
671,2,BODY,"method that is non-static, then the compile-time declaration is the most specific method of the second search. Otherwise, there is no compile-time declaration. –For all other forms of method reference expression, one search for a most specific applicable method is performed. The search is as specified in §15.12.2.2 through §15.12.2.5, with the clarifications below. The method reference is treated as if it were an invocation with argument expressions of types P1, ..., Pn; the type arguments, if any, are given by the method reference expression. If the search results in an error as specified in §15.12.2.2 through §15.12.2.5, or if the most specific applicable method is static, there is no compile-time declaration. Otherwise, the compile-time declaration is the most specific applicable method.",10.96,205.14,350,801,82,76.06,432,281.2,FALSE,FALSE
674,2,BODY,"15.13.2Type of a Method Reference A method reference expression is compatible in an assignment context, invocation context, or casting context with a target type T if T is a functional interface type (§9.8) and the expression is congruent with the function type of the ground target type derived from T. The ground target type is derived from T as follows: •If T is a wildcard-parameterized functional interface type, then the ground target type is the non-wildcard parameterization (§9.9) of T. •Otherwise, the ground target type is T. A method reference expression is congruent with a function type if both of the following are true: •The function type identifies a single compile-time declaration corresponding to the reference. •One of the following is true: –The result of the function type is void. –The result of the function type is R, and the result of applying capture conversion (§5.1.10) to the return type of the invocation type (§15.12.2.6) of the chosen compile-time declaration is R' (where R is the target type that may be used to infer R'), and neither R nor R' is void, and R' is compatible with R in an assignment context.",10.96,309.11,360.01,1142,72,76.09,432.01,385.2,FALSE,FALSE
680,9,BODY,UnaryExpression: PreIncrementExpression PreDecrementExpression + UnaryExpression - UnaryExpression UnaryExpressionNotPlusMinus,10.96,71.05,149.94,126,90,532.13,239.94,603.18,FALSE,TRUE
684,5,BODY,"15.15.5Bitwise Complement Operator ~ The type of the operand expression of the unary ~ operator must be a type that is convertible (§5.1.8) to a primitive integral type, or a compile-time error occurs. Unary numeric promotion (§5.6) is performed on the operand. The type of the unary bitwise complement expression is the promoted type of the operand. At run time, the value of the unary bitwise complement expression is the bitwise complement of the promoted value of the operand. In all cases, ~x equals (-x)-1.",10.96,104.11,360.01,512,72,291.09,432.01,395.2,FALSE,FALSE
697,5,BODY,RelationalExpression: ShiftExpression RelationalExpression < ShiftExpression RelationalExpression > ShiftExpression RelationalExpression <= ShiftExpression RelationalExpression >= ShiftExpression InstanceofExpression,10.96,84.05,190.08,216,90,333.13,280.08,417.18,FALSE,TRUE
701,9,BODY,"15.21.1Numerical Equality Operators == and != If the operands of an equality operator are both of numeric type, or one is of numeric type and the other is convertible (§5.1.8) to numeric type, binary numeric promotion is performed on the operands (§5.6).",10.96,53.11,360,254,72,506.09,432,559.2,FALSE,FALSE
704,3,BODY,"These operators have different precedence, with & having the highest precedence and | the lowest precedence. Each of these operators is syntactically left-associative (each groups left-to-right). Each operator is commutative if the operand expressions have no side effects. Each operator is associative. The bitwise and logical operators may be used to compare two operands of numeric type or two operands of type boolean. All other cases result in a compile-time error.",10.96,108.14,360.01,470,72,126.06,432.01,234.2,FALSE,FALSE
738,3,BODY,"15.27.3Type of a Lambda Expression A lambda expression is compatible in an assignment context, invocation context, or casting context with a target type T if T is a functional interface type (§9.8) and the expression is congruent with the function type of the ground target type derived from T. The ground target type is derived from T as follows: •If T is a wildcard-parameterized functional interface type and the lambda expression is explicitly typed, then the ground target type is inferred as described in §18.5.3. •If T is a wildcard-parameterized functional interface type and the lambda expression is implicitly typed, then the ground target type is the non-wildcard parameterization (§9.9) of T. •Otherwise, the ground target type is T. A lambda expression is congruent with a function type if all of the following are true: •The function type has no type parameters. •The number of lambda parameters is the same as the number of parameter types of the function type. •If the lambda expression is explicitly typed, its formal parameter types are the same as the parameter types of the function type. •If the lambda parameters are assumed to have the same types as the function type's parameter types, then: –If the function type's result is void, the lambda body is either a statement expression (§14.8) or a void-compatible block. –If the function type's result is a (non-void) type R, then either (i) the lambda body is an expression that is compatible with R in an assignment context, or",10.96,405.11,360.01,1499,72,175.09,432.01,580.2,FALSE,FALSE
739,3,BODY,"If a lambda expression is compatible with a target type T, then the type of the expression, U, is the ground target type derived from T. It is a compile-time error if any class or interface mentioned by either U or the function type of U is not accessible (§6.6) from the class or interface in which the lambda expression appears. For each non-static member method m of U, if the function type of U has a subsignature of the signature of m, then a notional method whose method type is the function type of U is deemed to override m, and any compile-time error or unchecked warning specified in §8.4.8.3 may occur. A checked exception that can be thrown in the body of the lambda expression may cause a compile-time error, as specified in §11.2.3.",10.96,154.14,360.01,746,72,108.06,432.01,262.2,FALSE,FALSE
747,2,BODY,"EVERY local variable declared by a statement (§14.4.2, §14.14.1, §14.14.2, §14.20.3) and every blank final field (§4.12.4, §8.3.1.2) must have a definitely assigned value when any access of its value occurs. An access to its value consists of the simple name of the variable (or, for a field, the simple name of the field qualified by this) occurring anywhere in an expression except as the left-hand operand of the simple assignment operator = (§15.26.1). For every access of a local variable declared by a statement x, or blank final field x, x must be definitely assigned before the access, or a compile-time error occurs. Similarly, every blank final variable must be assigned at most once; it must be definitely unassigned when an assignment to it occurs. Such an assignment is defined to occur if and only if either the simple name of the variable (or, for a field, its simple name qualified by this) occurs on the left hand side of an assignment operator. For every assignment to a blank final variable, the variable must be definitely unassigned before the assignment, or a compile-time error occurs. Note that local variables declared by a pattern (§14.30) are not subject to the rules of definite assignment. Every local variable declared by a pattern is initialized by the process of pattern matching and so always has a value when accessed. The remainder of this chapter is devoted to a precise explanation of the words 'definitely assigned before' and 'definitely unassigned before'. The idea behind definite assignment is that an assignment to the local variable declared by a statement or blank final field must occur on every possible execution path to the access. Similarly, the idea behind definite unassignment is that no other assignment to the blank final variable is permitted to occur on any possible execution path to an assignment.",10.96,366.14,360.01,1856,72,220.36,432.01,586.5,FALSE,FALSE
788,3,BODY,"More specifically, if two actions share a happens-before relationship, they do not necessarily have to appear to have happened in that order to any code with which they do not share a happens-before relationship. Writes in one thread that are in a data race with reads in another thread may, for example, appear to occur out of order to those reads. The happens-before relation defines when data races take place. A set of synchronization edges, S, is sufficient if it is the minimal set such that the transitive closure of S with the program order determines all of the happens-before edges in the execution. This set is unique. It follows from the above definitions that: •An unlock on a monitor happens-before every subsequent lock on that monitor. •A write to a volatile field (§8.3.1.4) happens-before every subsequent read of that field. •A call to start() on a thread happens-before any actions in the started thread. •All actions in a thread happen-before any other thread successfully returns from a join() on that thread. •The default initialization of any object happens-before any other actions (other than default-writes) of a program. When a program contains two conflicting accesses (§17.4.1) that are not ordered by a happens-before relationship, it is said to contain a data race. The semantics of operations other than inter-thread actions, such as reads of array lengths (§10.7), executions of checked casts (§5.5, §15.16), and invocations of virtual methods (§15.12), are not directly affected by data races.",10.96,352.14,360.01,1528,72,118.06,432.01,470.2,FALSE,FALSE
798,3,BODY,"17.5.1Semantics of final Fields Let o be an object, and c be a constructor for o in which a final field f is written. A freeze action on final field f of o takes place when c exits, either normally or abruptly. Note that if one constructor invokes another constructor, and the invoked constructor sets a final field, the freeze for the final field takes place at the end of the invoked constructor. For each execution, the behavior of reads is influenced by two additional partial orders, the dereference chain dereferences() and the memory chain mc(), which are considered to be part of the execution (and thus, fixed for any particular execution). These partial orders must satisfy the following constraints (which need not have a unique solution): •Dereference Chain: If an action a is a read or write of a field or element of an object o by a thread t that did not initialize o, then there must exist some read r by thread t that sees the address of o such that r dereferences(r, a). •Memory Chain: There are several constraints on the memory chain ordering: –If r is a read that sees a write w, then it must be the case that mc(w, r). –If r and a are actions such that dereferences(r, a), then it must be the case that mc(r, a). –If w is a write of the address of an object o by a thread t that did not initialize o, then there must exist some read r by thread t that sees the address of o such that mc(r, w).",10.96,329.11,360.01,1414,72,205.09,432.01,534.2,FALSE,FALSE
805,4,BODY,"18.1.3Bounds During the inference process, a set of bounds on inference variables is maintained. A bound has one of the following forms: •S = T, where at least one of S or T is an inference variable: S is the same as T.",10.96,59.11,360,219,72,534.09,432,593.2,FALSE,FALSE
807,4,BODY,"18.2.1Expression Compatibility Constraints A constraint formula of the form ‹Expression → T› is reduced as follows: •If T is a proper type, the constraint reduces to true if the expression is compatible in a loose invocation context with T (§5.3), and false otherwise. •Otherwise, if the expression is a standalone expression (§15.2) of type S, the constraint reduces to ‹S → T›.",10.96,92.14,360,379,72,478.09,432,570.23,FALSE,FALSE
825,6,BODY,"18.5.2.1Poly Method Invocation Compatibility If the method invocation expression is a poly expression (§15.12), its compatibility with a target type T is determined as follows. If the method invocation expression appears in a strict invocation context and T is a primitive type, the expression is not compatible with T. Otherwise: •Let B2 be the bound set produced by reduction in order to demonstrate that m is applicable in §18.5.1. (While it was necessary in §18.5.1 to demonstrate that the inference variables in B2 could be resolved, in order to establish applicability, the instantiations produced by this resolution step are not considered part of B2.)",10.96,167.2,360,659,72,390.38,432,557.59,FALSE,FALSE
829,4,BODY,"•While C is not empty, the following process is repeated, starting with the bound set B3 and accumulating new bounds into a 'current' bound set, ultimately producing a new bound set, B4: 1.A subset of constraints is selected in C, satisfying the property that, for each constraint, no input variable can influence an output variable of another constraint in C. The terms input variable and output variable are defined below. An inference variable α can influence an inference variable β if α depends on the resolution of β (§18.4), or vice versa; or if there exists a third inference variable γ such that α can influence γ and γ can influence β. If this subset is empty, then there is a cycle (or cycles) in the graph of dependencies between constraints. In this case, the constraints in C that participate in a dependency cycle (or cycles) and do not depend on any",10.96,161.14,360.01,865,72,396.06,432.01,557.2,FALSE,FALSE
852,1,BODY,"EnumDeclaration: {ClassModifier} enum TypeIdentifier [ClassImplements] EnumBody EnumBody: { [EnumConstantList] [,] [EnumBodyDeclarations] } EnumConstantList: EnumConstant {, EnumConstant} EnumConstant: {EnumConstantModifier} Identifier [( [ArgumentList] )] [ClassBody] EnumConstantModifier: Annotation EnumBodyDeclarations: ; {ClassBodyDeclaration}",10.96,204.05,320.81,348,90,76.13,410.81,280.18,FALSE,TRUE
21,2,BODY,"Chapter 12 describes activities that occur during execution of a program. A program is normally stored as binary files representing compiled classes and interfaces. These binary files can be loaded into a Java Virtual Machine, linked to other classes and interfaces, and initialized. After initialization, class methods and class variables may be used. Some classes may be instantiated to create new objects of the class type. Objects that are class instances also contain an instance of each superclass of the class, and object creation involves recursive creation of these superclass instances. When an object is no longer referenced, it may be reclaimed by the garbage collector. If an object declares a finalizer, the finalizer is executed before the object is reclaimed to give the object a last chance to clean up resources that would not otherwise be released. When a class is no longer needed, it may be unloaded. Chapter 13 describes binary compatibility, specifying the impact of changes to classes and interfaces on other classes and interfaces that use the changed classes and interfaces but have not been recompiled. These considerations are of interest to developers of classes and interfaces that are to be widely distributed, in a continuing series of versions, often through the Internet. Good program development environments automatically recompile dependent code whenever a class or interface is changed, so most programmers need not be concerned about these details. Chapter 14 describes blocks and statements, which are based on C and C++. The language has no goto statement, but includes labeled break and continue statements. Unlike C, the Java programming language requires boolean (or Boolean) expressions in control-flow statements, and does not convert types to boolean implicitly (except through unboxing), in the hope of catching more errors at compile time. A synchronized statement provides basic object-level monitor locking. A try statement can include catch and finally clauses to protect against non-local control transfers. Chapter 14 also describes patterns, which are used within statements (and expressions) to conditionally declare and initialize local variables. Chapter 15 describes expressions. This document fully specifies the (apparent) order of evaluation of expressions, for increased determinism and portability. Overloaded methods and constructors are resolved at compile time by picking the most specific method or constructor from those which are applicable. Chapter 16 describes the precise way in which the language ensures that local variables are definitely set before use. While all other variables are automatically initialized to a default value, the Java programming language does",10.95,510.14,360.01,2741,72,76.06,432.01,586.2,FALSE,FALSE
54,2,BODY,"A binary numeral consists of the leading ASCII characters 0b or 0B followed by one or more of the ASCII digits 0 or 1 interspersed with underscores, and can represent a positive, zero, or negative integer.",10.95,32.14,360.01,205,72,76.06,432.01,108.2,FALSE,FALSE
87,2,BODY,"The erasures (§4.6) of all constituent types of a bound must be pairwise different, or a compile-time error occurs. A type variable must not at the same time be a subtype of two interface types which are different parameterizations of the same generic interface, or a compile-time error occurs. The order of types in a bound is only significant in that the erasure of a type variable is determined by the first type in its bound, and that a class type or type variable may only appear in the first position. The members of a type variable X with bound T & I1 & ... & In are the members of the intersection type (§4.9) T & I1 & ... & In appearing at the point where the type variable is declared.",10.95,154.14,360.01,695,72,76.06,432.01,230.2,FALSE,FALSE
93,2,BODY,"A static member that is declared in a generic class or interface must be referred to using the name of the generic class or interface (§6.1, §6.5.5.2, §6.5.6.2), or a compile-time error occurs.",10.95,32.14,360,193,72,76.06,432,108.2,FALSE,FALSE
105,2,BODY,"of T and T is a subtype of lub(U1, ..., Uk). However, a compiler for the Java programming language must implement lub() as specified above. It is possible that the lub() function yields an infinite type. This is permissible, and a compiler for the Java programming language must recognize such situations and represent them appropriately using cyclic data structures.",10.95,64.14,360.01,367,72,76.06,432.01,140.2,FALSE,FALSE
106,4,BODY,"•If T is an array type, S[], then the result is an array type whose component type is the upward projection of S. •If T is an intersection type, then the result is an intersection type. For each element, S, of T, the result has as an element the upward projection of S. The downward projection of a type T with respect to a set of restricted type variables is a partial function, defined as follows: •If T does not mention any restricted type variable, then the result is T. •If T is a restricted type variable, then if T has a lower bound, and if the downward projection of that bound is L, the result is L; if T has no lower bound, or if the downward projection of that bound is undefined, then the result is undefined.",10.95,147.14,360.01,721,72,384.06,432.01,531.2,FALSE,FALSE
118,7,BODY,"Certain variables that are not declared final are instead considered effectively final: •A local variable declared by a statement and whose declarator has an initializer (§14.4), or a local variable declared by a pattern (§14.30.1), is effectively final if all of the following are true: –It is not declared final. –It never occurs as the left hand side in an assignment expression (§15.26). (Note that the local variable declarator containing the initializer is not an assignment expression.) –It never occurs as the operand of a prefix or postfix increment or decrement operator (§15.14, §15.15).",10.95,160.14,360,598,72,443.06,432,603.2,FALSE,FALSE
119,3,BODY,"•A method, constructor, lambda, or exception parameter (§8.4.1, §8.8.1, §9.4, §15.27.1, §14.20) is treated, for the purpose of determining whether it is effectively final, as a local variable whose declarator has an initializer. If a variable is effectively final, adding the final modifier to its declaration will not introduce any compile-time errors. Conversely, a local variable or parameter that is declared final in a valid program becomes effectively final if the final modifier is removed.",10.95,90.14,360,497,72,217.06,432,307.2,FALSE,FALSE
134,2,BODY,"5.1.6Narrowing Reference Conversion A narrowing reference conversion treats expressions of a reference type S as expressions of a different reference type T, where S is not a subtype of T. The supported pairs of types are defined in §5.1.6.1. Unlike widening reference conversion, the types need not be directly related. However, there are restrictions that prohibit conversion between certain pairs of types when it can be statically proven that no value can be of both types. A narrowing reference conversion may require a test at run time to validate that a value of type S is a legitimate value of type T. However, due to the lack of parameterized type information at run time, some conversions cannot be fully validated by a run time test; they are flagged at compile time (§5.1.6.2). For conversions that can be fully validated by a run time test, and for certain conversions that involve parameterized type information but can still be partially validated at run time, a ClassCastException is thrown if the test fails (§5.1.6.3). 5.1.6.1Allowed Narrowing Reference Conversion A narrowing reference conversion exists from reference type S to reference type T if all of the following are true: •S is not a subtype of T (§4.10) •If there exists a parameterized type X that is a supertype of T, and a parameterized type Y that is a supertype of S, such that the erasures of X and Y are the same, then X and Y are not provably distinct (§4.5).",10.95,313.24,360,1445,72,76.09,432,389.33,FALSE,FALSE
136,6,BODY,"5.1.6.2Checked and Unchecked Narrowing Reference Conversions A narrowing reference conversion is either checked or unchecked. These terms refer to the ability of the Java Virtual Machine to validate, or not, the type correctness of the conversion. If a narrowing reference conversion is unchecked, then the Java Virtual Machine will not be able to fully validate its type correctness, possibly leading to heap pollution (§4.12.2). To flag this to the programmer, an unchecked narrowing reference conversion causes a compile-time unchecked warning, unless suppressed by @SuppressWarnings (§9.6.4.5). Conversely, if a narrowing",10.95,123.2,360,625,72,471.13,432,594.33,FALSE,FALSE
137,3,BODY,"•A narrowing reference conversion from a type S to a type variable T is unchecked. •A narrowing reference conversion from a type S to an intersection type T1 & ... & Tn is unchecked if there exists a Ti (1 ≤ i ≤ n) such that S is not a subtype of Ti and a narrowing reference conversion from S to Ti is unchecked. 5.1.6.3Narrowing Reference Conversions at Run Time All checked narrowing reference conversions require a validity check at run time. Primarily, these conversions are to class and interface types that are not parameterized. Some unchecked narrowing reference conversions require a validity check at run time. This depends on whether the unchecked narrowing reference conversion is completely unchecked or partially unchecked. A partially unchecked narrowing reference conversion requires a validity check at run time, while a completely unchecked narrowing reference conversion does not.",10.95,195.27,360,900,72,223.06,432,418.33,FALSE,FALSE
165,2,BODY,"NAMES are used to refer to entities declared in a program. A declared entity (§6.1) is a package, a class, an interface, a member (class, interface, field, or method) of a reference type, a type parameter, a formal parameter, an exception parameter, or a local variable. Names in programs are either simple, consisting of a single identifier, or qualified, consisting of a sequence of identifiers separated by '.' tokens (§6.2). Every declaration that introduces a name has a scope (§6.3), which is the part of the program text within which the declared entity can be referred to by a simple name. A qualified name N.x may be used to refer to a member of a package or reference type, where N is a simple or qualified name and x is an identifier. If N names a package, then x is a member of that package, which is either a class, an interface, or a subpackage. If N names a reference type or a variable of a reference type, then x names a member of that type, which is either a class, an interface, a field, or a method. In determining the meaning of a name (§6.5), the context of the occurrence is used to disambiguate among packages, types, variables, and methods with the same name. Access control (§6.6) can be specified in a class, interface, method, or field declaration to control when access to a member is allowed. Access is a different concept from scope. Access specifies the part of the program text within which the declared entity can be referred to by a qualified name. Access to a declared entity is also relevant in a field access expression (§15.11), a method invocation expression in which the method is not specified by a simple name (§15.12), a method reference expression (§15.13), or a qualified class instance creation expression (§15.9). In the absence of an access modifier, most declarations have package access, allowing access anywhere within the package that contains its declaration; other possibilities are public, protected, and private.",10.95,380.14,360.01,1969,72,220.36,432.01,600.5,FALSE,FALSE
206,4,BODY,"If the declaration denotes a local variable, formal parameter, or exception parameter that is neither final nor effectively final (§4.12.4), it is a compile-time error if the expression name appears either in an inner class enclosed directly or indirectly by X, or in a lambda expression contained by X (§15.27).",10.95,45.14,360.01,312,72,345.06,432.01,390.2,FALSE,FALSE
215,2,BODY,"interface, type parameter, or reference type is accessible, and (ii) the member or constructor is declared to permit access: –If the member or constructor is declared public, then access is permitted. All members of interfaces lacking access modifiers are implicitly public. –Otherwise, if the member or constructor is declared protected, then access is permitted only when one of the following is true: ›Access to the member or constructor occurs from within the package containing the class in which the protected member or constructor is declared. ›Access is correct as described in §6.6.2. –Otherwise, if the member or constructor is declared with package access, then access is permitted only when the access occurs from within the package in which the class, interface, type parameter, or reference type is declared. A class member or constructor declared without an access modifier implicitly has package access. –Otherwise, the member or constructor is declared private. Access is permitted only when one of the following is true: ›Access occurs from within the body of the top level class or interface that encloses the declaration of the member or constructor. ›Access occurs in the permits clause of the top level class or interface that encloses the declaration of the member. ›Access occurs in the record component list of the top level record class that encloses the declaration of the member.",10.95,358.14,350.01,1407,82,76.06,432.01,434.2,FALSE,FALSE
236,2,BODY,"If the class or interface imported by the single-type-import declaration is declared as a top level class or interface (§7.6) in the compilation unit that contains the import declaration, then the import declaration is ignored. If a single-type-import declaration imports a class or interface whose simple name is x, and the compilation unit also declares a top level class or interface whose simple name is x, a compile-time error occurs. If a compilation unit contains both a single-type-import declaration that imports a class or interface whose simple name is x, and a single-static-import declaration (§7.5.3) that imports a class or interface whose simple name is x, a compile-time error occurs, unless the two classes or interfaces are the same, in which case the duplicate declaration is ignored.",10.95,148.14,360.01,804,72,76.06,432.01,224.2,FALSE,FALSE
239,5,BODY,7.5.4Static-Import-on-Demand Declarations A static-import-on-demand declaration allows all accessible static members of a named class or interface to be imported as needed.,10.95,40.11,360,172,72,549.09,432,589.2,FALSE,FALSE
254,1,BODY,"Class declarations may be decorated with annotations (§9.7) just like any other kind of declaration. The body of a class declares members (fields, methods, classes, and interfaces), instance and static initializers, and constructors (§8.1.7). The scope (§6.3) of a member (§8.2) is the entire body of the declaration of the class to which the member belongs. Field, method, member class, member interface, and constructor declarations may include the access modifiers public, protected, or private (§6.6). The members of a class include both declared and inherited members (§8.2). Newly declared fields can hide fields declared in a superclass or superinterface. Newly declared member classes and member interfaces can hide member classes and member interfaces declared in a superclass or superinterface. Newly declared methods can hide, implement, or override methods declared in a superclass or superinterface. Field declarations (§8.3) describe class variables, which are incarnated once, and instance variables, which are freshly incarnated for each instance of the class. A field may be declared final (§8.3.1.2), in which case it can be assigned to only once. Any field declaration may include an initializer. Member class declarations (§8.5) describe nested classes that are members of the surrounding class. Member classes may be static, in which case they have no access to the instance variables of the surrounding class; or they may be inner classes. Member interface declarations (§8.5) describe nested interfaces that are members of the surrounding class. Method declarations (§8.4) describe code that may be invoked by method invocation expressions (§15.12). A class method is invoked relative to the class; an instance method is invoked with respect to some particular object that is an instance of a class. A method whose declaration does not indicate how it is implemented must be declared abstract. A method may be declared final (§8.4.3.3), in which case it cannot be hidden or overridden. A method may be implemented by platform-dependent native code (§8.4.3.4). A synchronized method (§8.4.3.6) automatically locks an object before executing its body and automatically unlocks the object on return, as if by use of a synchronized statement (§14.19), thus allowing its activities to be synchronized with those of other threads (§17 (Threads and Locks)). Method names may be overloaded (§8.4.9). Instance initializers (§8.6) are blocks of executable code that may be used to help initialize an instance when it is created (§15.9).",10.95,516.14,360.01,2549,72,76.06,432.01,592.2,FALSE,FALSE
306,2,BODY,"8.4.4Generic Methods A method is generic if it declares one or more type variables (§4.4). These type variables are known as the type parameters of the method. The form of the type parameter section of a generic method is identical to the type parameter section of a generic class (§8.1.2). A generic method declaration defines a set of methods, one for each possible invocation of the type parameter section by type arguments. Type arguments may not need to be provided explicitly when a generic method is invoked, as they can often be inferred (§18 (Type Inference)). The scope and shadowing of a method's type parameter is specified in §6.3 and §6.4.1. References to a method's type parameter from a nested class or interface are restricted, as specified in §6.5.5.1. Two methods or constructors M and N have the same type parameters if both of the following are true: •M and N have same number of type parameters (possibly zero). •Where A1, ..., An are the type parameters of M and B1, ..., Bn are the type parameters of N, let θ=[B1:=A1, ..., Bn:=An]. Then, for all i (1 ≤ i ≤ n), the bound of Ai is the same type as θ applied to the bound of Bi. Where two methods or constructors M and N have the same type parameters, a type mentioned in N can be adapted to the type parameters of M by applying θ, as defined above, to the type.",10.95,335.11,360.01,1335,72,76.09,432.01,411.2,FALSE,FALSE
307,3,BODY,8.4.6Method Throws A throws clause is used to denote any checked exception classes (§11.1.1) that the statements in a method or constructor body can throw (§11.2.2).,10.95,40.11,360,165,72,342.09,432,382.2,FALSE,FALSE
309,6,BODY,"The rules for return statements in a method body are specified in §14.17. If a method is declared to have a return type (§8.4.5), then a compile-time error occurs if the body of the method can complete normally (§14.1).",10.95,38.14,360,219,72,328.06,432,366.2,FALSE,FALSE
330,7,BODY,"It is a compile-time error for a constructor to directly or indirectly invoke itself through a series of one or more explicit constructor invocations involving this. If a constructor body does not begin with an explicit constructor invocation and the constructor being declared is not part of the primordial class Object, then the constructor body implicitly begins with a superclass constructor invocation 'super();', an invocation of the constructor of its direct superclass that takes no arguments. Except for the possibility of explicit constructor invocations, and the prohibition on explicitly returning a value (§14.17), the body of a constructor is like the body of a method (§8.4.7). A return statement (§14.17) may be used in the body of a constructor if it does not include an expression.",10.95,167.14,360,799,72,361.06,432,528.2,FALSE,FALSE
332,3,BODY,"An explicit constructor invocation statement introduces a static context (§8.1.3), which limits the use of constructs that refer to the current object. Notably, the keywords this and super are prohibited in a static context (§15.8.3, §15.11.2), as are unqualified references to instance variables, instance methods, and type parameters of lexically enclosing declarations (§6.5.5.1, §6.5.6.1, §15.12.3). If TypeArguments is present to the left of this or super, then it is a compile-time error if any of the type arguments are wildcards (§4.5.1). Let C be the class being instantiated, and let S be the direct superclass of C. If a superclass constructor invocation statement is unqualified, then: •If S is an inner member class, but S is not a member of a class enclosing C, then a compile-time error occurs. Otherwise, let O be the innermost enclosing class of C of which S is a member. C must be an inner class of O (§8.1.3), or a compile-time error occurs. •If S is an inner local class, and S does not occur in a static context, let O be the immediately enclosing class or interface declaration of S. C must be an inner class of O, or a compile-time error occurs. If a superclass constructor invocation statement is qualified, then: •If S is not an inner class, or if the declaration of S occurs in a static context, then a compile-time error occurs. •Otherwise, let p be the Primary expression or the ExpressionName immediately preceding '.super', and let O be the immediately enclosing class of S. It is a compile-time error if the type of p is not O or a subclass of O, or if the type of p is not accessible (§6.6). The exception types that an explicit constructor invocation statement can throw are specified in §11.2.2. Evaluation of an alternate constructor invocation statement proceeds by first evaluating the arguments to the constructor, left-to-right, as in an ordinary method invocation; and then invoking the constructor. Evaluation of a superclass constructor invocation statement proceeds as follows:",10.95,442.14,360.01,2020,72,121.06,432.01,563.2,FALSE,FALSE
333,2,BODY,1.Let i be the instance being created. The immediately enclosing instance of i,10.95,6.14,360,78,72,76.06,432,82.2,FALSE,FALSE
359,2,BODY,"AN interface declaration defines a new interface that can be implemented by one or more classes. Programs can use interfaces to provide a common supertype for otherwise unrelated classes, and to make it unnecessary for related classes to share a common abstract superclass. Interfaces have no instance variables, and typically declare one or more abstract methods; otherwise unrelated classes can implement an interface by providing implementations for its abstract methods. Interfaces may not be directly instantiated. A top level interface (§7.6) is an interface declared directly in a compilation unit. A nested interface is any interface whose declaration occurs within the body of another class or interface declaration. A nested interface may be a member interface (§8.5, §9.5) or a local interface (§14.3). An annotation interface (§9.6) is an interface declared with distinct syntax, intended to be implemented by reflective representations of annotations (§9.7). This chapter discusses the common semantics of all interfaces. Details that are specific to particular kinds of interfaces are discussed in the sections dedicated to these constructs. An interface may be declared to be a direct extension of one or more other interfaces, meaning that it inherits all the member classes and interfaces, instance methods, and static fields of the interfaces it extends, except for any members that it may override or hide. A class may be declared to directly implement one or more interfaces (§8.1.5), meaning that any instance of the class implements all the abstract methods specified by the interface or interfaces. A class necessarily implements all the interfaces that its direct superclasses and direct superinterfaces do. This (multiple)",10.95,360.14,360.01,1747,72,220.36,432.01,580.5,FALSE,FALSE
360,2,BODY,"interface inheritance allows objects to support (multiple) common behaviors without sharing a superclass. Unlike a class, an interface cannot be declared final. However, an interface may be declared sealed (§9.1.1.4) to limit its subclasses and subinterfaces. A variable whose declared type is an interface type may have as its value a reference to any instance of a class which implements the specified interface. It is not sufficient that the class happen to implement all the abstract methods of the interface; the class or one of its superclasses must actually be declared to implement the interface, or else the class is not considered to implement the interface.",10.95,122.14,360.01,668,72,76.06,432.01,198.2,FALSE,FALSE
360,4,BODY,InterfaceDeclaration: NormalInterfaceDeclaration AnnotationInterfaceDeclaration NormalInterfaceDeclaration: {InterfaceModifier} interface TypeIdentifier [TypeParameters] [InterfaceExtends] [InterfacePermits] InterfaceBody,10.95,82.05,297.45,221,90,321.13,387.45,403.18,FALSE,TRUE
374,4,BODY,"9.4.1.2Requirements in Overriding The relationship between the return type of an interface method and the return types of any overridden interface methods is specified in §8.4.8.3. The relationship between the throws clause of an interface method and the throws clauses of any overridden interface methods is specified in §8.4.8.3. The relationship between the signature of an interface method and the signatures of any overridden interface methods is specified in §8.4.8.3. The relationship between the accessibility of an interface method and the accessibility of any overridden interface methods is specified in §8.4.8.3. It is a compile-time error if a default method is override-equivalent (§8.4.2) with a non-private method of the class Object, because any class implementing the interface will inherit its own implementation of the method.",10.95,180.2,360.01,846,72,174.13,432.01,354.33,FALSE,FALSE
383,7,BODY,"9.6.2Defaults for Annotation Interface Elements An annotation interface element may have a default value, specified by attaching the keyword default and a value to the method declaration which defines the element.",10.95,53.11,360,213,72,443.09,432,496.2,FALSE,FALSE
430,2,BODY,"During the process of throwing an exception, the Java Virtual Machine abruptly completes, one by one, any expressions, statements, method and constructor invocations, initializers, and field initialization expressions that have begun but not completed execution in the current thread. This process continues until a handler is found that indicates that it handles that particular exception by naming the class of the exception or a superclass of the class of the exception (§11.2). If no such handler is found, then the exception may be handled by one of a hierarchy of uncaught exception handlers (§11.3) - thus every effort is made to avoid letting an exception go unhandled. The exception mechanism of the Java SE Platform is integrated with its synchronization model (§17.1), so that monitors are unlocked as synchronized statements (§14.19) and invocations of synchronized methods (§8.4.3.6, §15.12) complete abruptly.",10.95,168.14,360.01,923,72,76.06,432.01,244.2,FALSE,FALSE
433,2,BODY,"or constructor must mention the class of that exception or one of the superclasses of the class of that exception (§11.2.3). The checked exception classes (§11.1.1) named in the throws clause are part of the contract between the implementor and user of the method or constructor. The throws clause of an overriding method may not specify that this method will result in throwing any checked exception which the overridden method is not permitted, by its throws clause, to throw (§8.4.8.3). When interfaces are involved, more than one method declaration may be overridden by a single overriding declaration. In this case, the overriding declaration must have a throws clause that is compatible with all the overridden declarations (§9.4.1). The unchecked exception classes (§11.1.1) are exempted from compile-time checking.",10.95,161.14,360.01,822,72,76.06,432.01,237.2,FALSE,FALSE
436,2,BODY,"11.2.3Exception Checking It is a compile-time error if a method or constructor body can throw some exception class E when E is a checked exception class and E is not a subclass of some class declared in the throws clause of the method or constructor. It is a compile-time error if a lambda body can throw some exception class E when E is a checked exception class and E is not a subclass of some class declared in the throws clause of the function type targeted by the lambda expression. It is a compile-time error if a class variable initializer (§8.3.2) or static initializer (§8.7) of a named class or interface can throw a checked exception class. It is a compile-time error if an instance variable initializer (§8.3.2) or instance initializer (§8.6) of a named class can throw a checked exception class, unless the named class has at least one explicitly declared constructor and the exception class or one of its superclasses is explicitly declared in the throws clause of each constructor.",10.95,201.11,360.01,996,72,76.09,432.01,277.2,FALSE,FALSE
444,7,BODY,"12.1.2Link Test: Verify, Prepare, (Optionally) Resolve After Test is loaded, it must be initialized before main can be invoked. And Test, like all classes and interfaces, must be linked before it is initialized. Linking involves verification, preparation, and (optionally) resolution. Linking is described further in §12.3. Verification checks that the loaded representation of Test is well-formed, with a proper symbol table. Verification also checks that the code that implements Test obeys the semantic requirements of the Java programming language and the Java Virtual Machine. If a problem is detected during verification, then an error is thrown. Verification is described further in §12.3.1. Preparation involves allocation of static storage and any data structures that are used internally by the implementation of the Java Virtual Machine, such as method tables. Preparation is described further in §12.3.2. Resolution is the process of checking symbolic references from Test to other classes and interfaces, by loading the other classes and interfaces that are mentioned and checking that the references are correct.",10.95,227.11,360.01,1126,72,363.09,432.01,590.2,FALSE,FALSE
457,5,BODY,"3.This constructor does not begin with an explicit constructor invocation of another constructor in the same class (using this). If this constructor is for a class other than Object, then this constructor will begin with an explicit or implicit invocation of a superclass constructor (using super). Evaluate the arguments and process that superclass constructor invocation recursively using these same five steps. If that constructor invocation completes abruptly, then this procedure completes abruptly for the same reason. Otherwise, continue with step 4.",10.95,97.14,360,557,72,256.06,432,353.2,FALSE,FALSE
470,3,BODY,"4.Given a legal expression denoting a field access in a class C, referencing a field named f that is not a constant variable and is declared in a (possibly distinct) class or interface D, we define the qualifying class or interface of the field reference as follows: •If the expression is referenced by a simple name, then if f is a member of the current class or interface, C, then let Q be C. Otherwise, let Q be the innermost lexically enclosing class or interface declaration of which f is a member. In either case, Q is the qualifying class or interface of the reference. •If the reference is of the form TypeName.f, where TypeName denotes a class or interface, then the class or interface denoted by TypeName is the qualifying class or interface of the reference. •If the expression is of the form ExpressionName.f or Primary.f, then: –If the compile-time type of ExpressionName or Primary is an intersection type V1 & ... & Vn (§4.9), then the qualifying class or interface of the reference is the erasure (§4.6) of V1. –Otherwise, the erasure of the compile-time type of ExpressionName or Primary is the qualifying class or interface of the reference.",10.95,244.14,360.01,1159,72,108.06,432.01,352.2,FALSE,FALSE
470,4,BODY,"•If the expression is of the form super.f, then the superclass of C is the qualifying class or interface of the reference. •If the expression is of the form TypeName.super.f, then the superclass of the class denoted by TypeName is the qualifying class or interface of the reference. The reference to f must be compiled into a symbolic reference to the qualifying class or interface of the reference, plus the simple name of the field, f. The reference must also include a symbolic reference to the erasure of the declared type of the field, so that the verifier can check that the type is as expected.",10.95,141.14,342,601,90,365.06,432,506.2,FALSE,FALSE
472,4,BODY,"A binary representation for a class or interface must also contain all of the following: 1.If it is a class and is not Object, then a symbolic reference to the direct",10.95,38.14,360,166,72,544.06,432,582.2,FALSE,FALSE
488,2,BODY,"Assume a reference to a method m with qualifying class C. Assume further that m is in fact an instance (respectively static) method declared in a superclass of C, S. If a new method of type X with the same signature and return type as m is added to a subclass of S that is a superclass of C or C itself, then a linkage error may occur. Such a linkage error will occur only if, in addition to the above, either one of the following is true: •The new method is less accessible than the old one. •The new method is a static (respectively instance) method. Deleting a method or constructor from a class may break compatibility with any pre-existing binary that referenced this method or constructor; a NoSuchMethodError may be thrown when such a reference from a pre-existing binary is linked. Such an error will occur only if no method with a matching signature and return type is declared in a superclass. If the source code for a non-inner class contains no declared constructors, then a default constructor with no parameters is implicitly declared (§8.8.9). Adding one or more constructor declarations to the source code of such a class will prevent this default constructor from being implicitly declared, effectively deleting a constructor, unless one of the new constructors also has no parameters, thus replacing the default constructor. The default constructor with no parameters is given the same access modifier as the class of its declaration, so any replacement should have as much or more access if compatibility with pre-existing binaries is to be preserved.",10.95,309.14,360,1570,72,76.06,432,385.2,FALSE,FALSE
492,4,BODY,13.4.21Method and Constructor Throws Changes to the throws clause of methods or constructors do not break compatibility with pre-existing binaries; these clauses are checked only at compile time.,10.95,40.11,360,195,72,260.09,432,300.2,FALSE,FALSE
519,4,BODY,"The switch block of a switch statement or a switch expression must be switch compatible with the type of the selector expression, or a compile-time error occurs. A switch label in a switch block is said to be dominated if for every value that it applies to, it can be determined that one of the preceding switch labels would also apply. It is a compile-time error if any switch label in a switch block is dominated. The rules for determining whether a switch label is dominated are as follows:",10.95,77.14,360.01,493,72,450.06,432.01,527.2,FALSE,FALSE
564,6,BODY,T is the type of the variable denoted by VariableAccess and #r is an automatically generated identifier that is distinct from any other identifiers (automatically generated or otherwise) that are in scope at the point where the try-with-resources statement occurs. The try-with-resources statement is then translated according to the rest of this section. The meaning of a basic try-with-resources statement of the form:,10.95,77.14,360.01,420,72,295.2,432.01,372.33,FALSE,FALSE
579,4,BODY,"14.30.2Pattern Matching Pattern matching is the process of testing a value against a pattern at run time. Pattern matching is distinct from statement execution (§14.1) and expression evaluation (§15.1). If a value successfully matches a pattern, then the process of pattern matching will initialize all the pattern variables declared by the pattern, if any. The process of pattern matching may involve expression evaluation or statement execution. Accordingly, pattern matching is said to complete abruptly if evaluation of an expression or execution of a statement completes abruptly. An abrupt completion always has an associated reason, which is always a throw with a given value. Pattern matching is said to complete normally if it does not complete abruptly. The rules for determining whether a value matches a pattern, and for initializing pattern variables, are as follows: •The null reference matches a type pattern if the type pattern is null-matching (§14.30.1); and does not match otherwise. If the null reference matches, then the pattern variable declared by the type pattern is initialized to the null reference. If the null reference does not match, then the pattern variable declared by the type pattern is not initialized. •A value v that is not the null reference matches a type pattern of type T if v can be converted by testing conversion (§5.7) to the target type T without raising a ClassCastException; and does not match otherwise. If v matches, then the pattern variable declared by the type pattern is initialized to v. If v does not match, then the pattern variable declared by the type pattern is not initialized.",10.95,400.11,360,1640,72,198.09,432,598.2,FALSE,FALSE
618,6,BODY,"An array creation expression creates an object that is a new array whose elements are of the type specified by the PrimitiveType or ClassOrInterfaceType. It is a compile-time error if the ClassOrInterfaceType does not denote a reifiable type (§4.7). Otherwise, the ClassOrInterfaceType may name any named reference type, even an abstract class type (§8.1.1.1) or an interface type.",10.95,64.14,360,381,72,431.06,432,495.2,FALSE,FALSE
622,11,BODY,"The type of the array reference expression must be an array type (call it T[], an array whose components are of type T), or a compile-time error occurs.",10.95,19.14,360,152,72,572.06,432,591.2,FALSE,FALSE
626,3,BODY,"15.11.1Field Access Using a Primary The type of the Primary must be a reference type T, or a compile-time error occurs. The meaning of the field access expression is determined as follows: •If the identifier names several accessible (§6.6) member fields in type T, then the field access is ambiguous and a compile-time error occurs. •If the identifier does not name an accessible member field in type T, then the field access is undefined and a compile-time error occurs. •Otherwise, the identifier names a single accessible member field in type T, and the type of the field access expression is the type of the member field after capture conversion (§5.1.10). At run time, the result of the field access expression is computed as follows: (assuming that the program is correct with respect to definite assignment analysis, that is, every blank final variable is definitely assigned before access) •If the field is static: –The Primary expression is evaluated, and the result is discarded. If evaluation of the Primary expression completes abruptly, the field access expression completes abruptly for the same reason. –If the field is a non-blank final field, then the result is the value of the specified class variable in the class or interface that is the type of the Primary expression. –If the field is not final, or is a blank final and the field access occurs in a class variable initializer (§8.3.2) or static initializer (§8.7), then the result is a variable, namely, the specified class variable in the class that is the type of the Primary expression.",10.95,367.11,360.01,1562,72,166.09,432.01,533.2,FALSE,FALSE
632,5,BODY,"•If the form is TypeName . [TypeArguments] Identifier, then the type to search is the (possibly raw) type denoted by TypeName. •If the form is ExpressionName . [TypeArguments] Identifier, then the type to search is the declared type T of the variable denoted by ExpressionName if T is a class or interface type, or the upper bound of T if T is a type variable. •If the form is Primary . [TypeArguments] Identifier, then let T be the type of the Primary expression. The type to search is T if T is a class or interface type, or the upper bound of T if T is a type variable. It is a compile-time error if T is not a reference type. •If the form is super . [TypeArguments] Identifier, then the type to search is the direct superclass type of the class whose declaration contains the method invocation. Let E be the class or interface declaration immediately enclosing the method invocation. It is a compile-time error if E is the class Object or an interface.",10.95,205.14,360.01,956,72,389.06,432.01,594.2,FALSE,FALSE
649,2,BODY,"A method is said to be maximally specific for a method invocation if it is accessible and applicable and there is no other method that is accessible and applicable that is strictly more specific. If there is exactly one maximally specific method, then that method is in fact the most specific method; it is necessarily more specific than any other accessible method that is applicable. It is then subjected to some further compile-time checks as specified in §15.12.3. It is possible that no method is the most specific, because there are two or more methods that are maximally specific. In this case: •If all the maximally specific methods have override-equivalent signatures (§8.4.2), and exactly one of the maximally specific methods is concrete (that is, neither abstract nor default), then it is the most specific method. •Otherwise, if all the maximally specific methods have override-equivalent signatures, and all the maximally specific methods are abstract or default, and the declarations of these methods have the same erased parameter types, and at least one maximally specific method is preferred according to the rules below, then the most specific method is chosen arbitrarily among the subset of the maximally specific methods that are preferred. The most specific method is then considered to be abstract. A maximally specific method is preferred if it has: –a signature that is a subsignature of every maximally specific method's signature; and –a return type R (possibly void), where either R is the same as every maximally specific method's return type, or R is a reference type and is a subtype of",10.95,347.14,360.01,1618,72,76.06,432.01,423.2,FALSE,FALSE
655,2,BODY,"•If the form is MethodName - that is, just an Identifier - then: –If the invocation mode is static, then there is no target reference. –Otherwise, let T be the enclosing type declaration of which the method is a member, and let n be an integer such that T is the n'th lexically enclosing type declaration of the class whose declaration immediately contains the method invocation. The target reference is the n'th lexically enclosing instance of this. It is a compile-time error if the n'th lexically enclosing instance of this does not exist.",10.95,115.14,360,542,72,76.06,432,191.2,FALSE,FALSE
670,2,BODY,"•Finally, if there are no potentially applicable methods, then there is no compile- time declaration. Otherwise, given a targeted function type with parameter types P1, ..., Pn and a set of potentially applicable methods, the compile-time declaration is selected as follows: –If the method reference expression has the form ReferenceType :: [TypeArguments] Identifier, then two searches for a most specific applicable method are performed. Each search is as specified in §15.12.2.2 through §15.12.2.5, with the clarifications below. Each search produces a set of applicable methods and, possibly, designates a most specific method of the set. In the case of an error as specified in §15.12.2.4, the set of applicable methods is empty. In the case of an error as specified in §15.12.2.5, there is no most specific method. In the first search, the method reference is treated as if it were an invocation with argument expressions of types P1, ..., Pn. Type arguments, if any, are given by the method reference expression. In the second search, if P1, ..., Pn is not empty and P1 is a subtype of ReferenceType, then the method reference expression is treated as if it were a method invocation expression with argument expressions of types P2, ..., Pn. If ReferenceType is a raw type, and there exists a parameterization of this type, G<...>, that is a supertype of P1, the type to search is the result of capture conversion (§5.1.10) applied to G<...>; otherwise, the type to search is the same as the type of the first search. Type arguments, if any, are given by the method reference expression. If the first search produces a most specific method that is static, and the set of applicable methods produced by the second search contains no non-static methods, then the compile-time declaration is the most specific method of the first search. Otherwise, if the set of applicable methods produced by the first search contains no static methods, and the second search produces a most specific",10.95,419.14,360.01,1989,72,76.06,432.01,495.2,FALSE,FALSE
678,9,BODY,"Postfix expressions include uses of the postfix ++ and -- operators. Names are not considered to be primary expressions (§15.8), but are handled separately in the",10.95,19.14,360,162,72,578.06,432,597.2,FALSE,FALSE
686,2,BODY,"The result of a cast expression is not a variable, but a value, even if the result of evaluating the operand expression is a variable. If the compile-time type of the operand cannot be converted by casting conversion (§5.5) to the target type specified by the cast operator, then a compile-time error occurs. Otherwise, at run time, the operand value is converted (if necessary) by casting conversion to the target type specified by the cast operator. A ClassCastException is thrown if a cast is found at run time to be impermissible.",10.95,115.14,360.01,534,72,76.06,432.01,191.2,FALSE,FALSE
694,8,BODY,"The type of an additive expression on numeric operands is the promoted type of its operands. If this promoted type is int or long, then integer arithmetic is performed. If this promoted type is float or double, then floating-point arithmetic is performed. Addition is a commutative operation if the operand expressions have no side effects. Integer addition is associative when the operands are all of the same type. Floating-point addition is not associative.",10.95,140.14,360,460,72,453.06,432,593.2,FALSE,FALSE
696,3,BODY,"The operators << (left shift), >> (signed right shift), and >>> (unsigned right shift) are called the shift operators. The left-hand operand of a shift operator is the value to be shifted; the right-hand operand specifies the shift distance.",10.95,32.14,360.01,241,72,108.06,432.01,140.2,FALSE,FALSE
696,5,BODY,"The shift operators are syntactically left-associative (they group left-to-right). Unary numeric promotion (§5.6) is performed on each operand separately. (Binary numeric promotion is not performed on the operands.) It is a compile-time error if the type of each of the operands of a shift operator, after unary numeric promotion, is not a primitive integral type. The type of the shift expression is the promoted type of the left-hand operand. If the promoted type of the left-hand operand is int, then only the five lowest-order bits of the right-hand operand are used as the shift distance. It is as if the right-hand operand were subjected to a bitwise logical AND operator & (§15.22.1) with the mask value 0x1f (0b11111). The shift distance actually used is therefore always in the range 0 to 31, inclusive. If the promoted type of the left-hand operand is long, then only the six lowest- order bits of the right-hand operand are used as the shift distance. It is as if the right-hand operand were subjected to a bitwise logical AND operator & (§15.22.1) with the mask value 0x3f (0b111111). The shift distance actually used is therefore always in the range 0 to 63, inclusive. At run time, shift operations are performed on the two's-complement integer representation of the value of the left operand. The value of n << s is n left-shifted s bit positions; this is equivalent (even if overflow occurs) to multiplication by two to the power s. The value of n >> s is n right-shifted s bit positions with sign-extension. The resulting value is floor(n / 2). For non-negative values of n, this is equivalent to truncating integer division, as computed by the integer division operator /, by two to the power s.",10.95,353.14,360,1713,72,234.06,432,587.2,FALSE,FALSE
698,4,BODY,"If the promoted type of the operands is int or long, then signed integer comparison is performed. If the promoted type is float or double, then floating-point comparison is performed. The result of a floating-point comparison, as determined by the specification of the IEEE 754 standard, is: •If either operand is NaN, then the result is false. •All values other than NaN are ordered, with negative infinity less than all finite values, and positive infinity greater than all finite values. •Positive zero and negative zero are considered equal.",10.95,153.14,360,545,72,123.06,432,276.2,FALSE,FALSE
701,5,BODY,EqualityExpression: RelationalExpression EqualityExpression == RelationalExpression EqualityExpression != RelationalExpression,10.95,45.05,207.18,126,90,180.13,297.18,225.18,FALSE,TRUE
713,48,BODY,"At run time, the first operand expression of the conditional expression is evaluated first. If necessary, unboxing conversion is performed on the result. The resulting boolean value is then used to choose either the second or the third operand expression: •If the value of the first operand is true, then the second operand expression is chosen. •If the value of the first operand is false, then the third operand expression is chosen.",10.95,115.14,360,435,72,458.55,432,573.69,FALSE,FALSE
719,2,BODY,class RC is assignment compatible (§5.2) with the actual type SC of the array component.,10.95,19.14,340,88,92,76.06,432,95.2,FALSE,FALSE
751,4,BODY,"The phrase 'V is definitely assigned after X' (where V is a local variable and X is a statement or expression) means 'V is definitely assigned after X if X completes normally'. If X completes abruptly, the assignment need not have occurred, and the rules stated here take this into account.",10.95,45.14,360.01,290,72,263.06,432.01,308.2,FALSE,FALSE
760,6,BODY,16.2.2Blocks •A blank final member field V is definitely assigned (and moreover is not definitely unassigned) before the block (§14.2) that is the body of any method in,10.95,40.11,360,168,72,551.09,432,591.2,FALSE,FALSE
767,3,BODY,"16.2.12.2Incrementation Part of for Statement •If the incrementation part of the for statement is empty, then V is [un]assigned after the incrementation part iff V is [un]assigned before the incrementation part. •Otherwise, three rules apply: –V is [un]assigned after the incrementation part iff V is [un]assigned after the last expression statement in the incrementation part. –V is [un]assigned before the first expression statement in the incrementation part iff V is [un]assigned before the incrementation part. –V is [un]assigned before an expression statement S other than the first in the incrementation part iff V is [un]assigned after the expression statement immediately preceding S.",10.95,167.2,360.01,693,72,212.13,432.01,379.33,FALSE,FALSE
772,6,BODY,"Let C be a class, and let V be a blank final non-static member field of C, declared in C. Then: •V is definitely unassigned (and moreover is not definitely assigned) before the leftmost instance initializer (§8.6) or instance variable initializer of C. •V is [un]assigned before an instance initializer or instance variable initializer of C other than the leftmost iff V is [un]assigned after the preceding instance initializer or instance variable initializer of C. The following rules hold within the constructors (§8.8.7) of class C: •V is definitely assigned (and moreover is not definitely unassigned) after an alternate constructor invocation (§8.8.7.1). •V is definitely unassigned (and moreover is not definitely assigned) before an explicit or implicit superclass constructor invocation (§8.8.7.1). •If C has no instance initializers or instance variable initializers, then V is not definitely assigned (and moreover is definitely unassigned) after an explicit or implicit superclass constructor invocation.",10.95,224.14,360.01,1016,72,376.06,432.01,600.2,FALSE,FALSE
812,3,BODY,"»If R does not mention one of the type parameters of the function type, then the constraint reduces to the bound set B3 which would be used to determine the method reference's compatibility when targeting the return type of the function type, as defined in §18.5.2.1. B3 may contain new inference variables, as well as dependencies between these new variables and the inference variables in T.",10.95,71.14,330,393,102,112.06,432,183.2,FALSE,FALSE
816,5,BODY,"•Otherwise, if the function type's return type is neither void nor a proper type, the constraint reduces to false.",10.95,19.14,360,114,72,500.06,432,519.2,FALSE,FALSE
854,2,BODY,InterfaceDeclaration: NormalInterfaceDeclaration AnnotationInterfaceDeclaration NormalInterfaceDeclaration: {InterfaceModifier} interface TypeIdentifier [TypeParameters] [InterfaceExtends] [InterfacePermits] InterfaceBody,10.95,82.05,297.45,221,90,100.13,387.45,182.18,FALSE,TRUE
856,1,BODY,"Annotation: NormalAnnotation MarkerAnnotation SingleElementAnnotation NormalAnnotation: @ TypeName ( [ElementValuePairList] ) ElementValuePairList: ElementValuePair {, ElementValuePair} ElementValuePair: Identifier = ElementValue ElementValue: ConditionalExpression ElementValueArrayInitializer Annotation ElementValueArrayInitializer: { [ElementValueList] [,] } ElementValueList: ElementValue {, ElementValue} MarkerAnnotation: @ TypeName SingleElementAnnotation: @ TypeName ( ElementValue )",10.95,367.05,192.24,492,90,76.13,282.24,443.18,FALSE,TRUE
135,8,BODY,narrowing reference conversion exists from S to the upper bound of T.,10.94,6.14,308.34,69,100,275.06,408.34,281.2,FALSE,FALSE
148,2,BODY,"If the type of an expression can be converted to the type of a variable by assignment conversion, we say the expression (or its value) is assignable to the variable or, equivalently, that the type of the expression is assignment compatible with the type of the variable. The only exceptions that may arise from conversions in an assignment context are: •A ClassCastException if, after the conversions above have been applied, the resulting value is an object which is not an instance of a subclass or subinterface of the erasure (§4.6) of the type of the variable.",10.94,109.14,360.01,564,72,76.06,432.01,185.2,FALSE,FALSE
209,4,BODY,"6.5.6.2Qualified Expression Names If an expression name is of the form Q.Id, then Q has already been classified as a package name, a type name, or an expression name. If Q is a package name, then a compile-time error occurs. If Q is a type name that names a class type, then: •If there is not exactly one accessible member (§6.6) of the class type that is a field named Id, then a compile-time error occurs. •Otherwise, if the single accessible member field is not a class variable (that is, it is not declared static), then a compile-time error occurs. •Otherwise, if the class variable is declared final, then Q.Id denotes the value of the class variable. The type of the expression Q.Id is the declared type of the class variable after capture conversion (§5.1.10). If Q.Id appears in a context that requires a variable and not a value, then a compile-time error occurs.",10.94,237.2,360,873,72,298.13,432,535.33,FALSE,FALSE
234,7,BODY,"An import declaration allows a named class, interface, or static member to be referred to by a simple name (§6.2) that consists of a single identifier. Without the use of an appropriate import declaration, a reference to a class or interface declared in another package, or a reference to a static member of another class or interface, would typically need to use a fully qualified name (§6.7).",10.94,64.14,360,394,72,395.06,432,459.2,FALSE,FALSE
265,4,BODY,"A blank final field (§4.12.4) of a lexically enclosing class or interface declaration may not be assigned within an inner class, or a compile-time error occurs.",10.94,19.14,360.01,160,72,464.06,432.01,483.2,FALSE,FALSE
266,6,BODY,8.1.4Superclasses and Subclasses The optional extends clause in a normal class declaration specifies the direct superclass type of the class being declared.,10.94,40.11,360,156,72,483.09,432,523.2,FALSE,FALSE
272,8,BODY,8.1.6Permitted Direct Subclasses The optional permits clause in a normal class declaration specifies all the classes intended as direct subclasses of the class being declared (§8.1.1.2).,10.94,40.11,360,186,72,459.09,432,499.2,FALSE,FALSE
298,2,BODY,"of the variable arity method, unless the method is annotated with @SafeVarargs (§9.6.4.7) or the warning is suppressed by @SuppressWarnings (§9.6.4.5). When the method or constructor is invoked (§15.12), the values of the actual argument expressions initialize newly created parameter variables, each of the declared type, before execution of the body of the method or constructor. The Identifier that appears in the FormalParameter may be used as a simple name in the body of the method or constructor to refer to the formal parameter. Invocations of a variable arity method may contain more actual argument expressions than formal parameters. All the actual argument expressions that do not correspond to the formal parameters preceding the variable arity parameter will be evaluated and the results stored into an array that will be passed to the method invocation (§15.12.4.2).",10.94,161.14,360.01,881,72,76.06,432.01,237.2,FALSE,FALSE
320,2,BODY,"It is a compile-time error if a class C inherits a concrete method whose signature is override-equivalent with another method inherited by C. It is a compile-time error if a class C inherits a default method whose signature is override-equivalent with another method inherited by C, unless there exists an abstract method declared in a superclass of C and inherited by C that is override- equivalent with the two methods.",10.94,77.14,360,421,72,76.06,432,153.2,FALSE,FALSE
320,4,BODY,"Otherwise, the set of override-equivalent methods consists of at least one abstract method and zero or more default methods; then the class is necessarily an abstract class and is considered to inherit all the methods. One of the inherited methods must be return-type-substitutable for every other inherited method; otherwise, a compile-time error occurs. (The throws clauses do not cause errors in this case.) There might be several paths by which the same method declaration is inherited from an interface. This fact causes no difficulty and never, of itself, results in a compile-time error.",10.94,122.14,360,594,72,276.06,432,398.2,FALSE,FALSE
324,5,BODY,A class inherits from its direct superclass and direct superinterfaces all the non- private member classes and interfaces of the superclass and superinterfaces that are both accessible to code in the class and not hidden by a declaration in the class.,10.94,32.14,360.01,251,72,551.06,432.01,583.2,FALSE,FALSE
338,3,BODY,EnumDeclaration: {ClassModifier} enum TypeIdentifier [ClassImplements] EnumBody,10.94,19.05,308.67,79,90,145.13,398.67,164.18,FALSE,TRUE
347,3,BODY,RecordDeclaration: {ClassModifier} record TypeIdentifier [TypeParameters] RecordHeader [ClassImplements] RecordBody,10.94,32.05,333.5,115,90,145.13,423.5,177.18,FALSE,TRUE
366,7,BODY,The scope of a declaration of a member m declared in or inherited by an interface I is specified in §6.3.,10.94,19.14,360,105,72,395.06,432,414.2,FALSE,FALSE
368,3,BODY,"The rules concerning annotation modifiers for an interface field declaration are specified in §9.7.4 and §9.7.5. Every field declaration in the body of an interface declaration is implicitly public, static, and final. It is permitted to redundantly specify any or all of these modifiers for such fields. It is a compile-time error if the same keyword appears more than once as a modifier for a field declaration.",10.94,96.14,360.01,412,72,144.06,432.01,240.2,FALSE,FALSE
423,8,BODY,"An array initializer is written as a comma-separated list of expressions, enclosed by braces { and }. A trailing comma may appear after the last expression in an array initializer and is ignored.",10.94,51.14,360,195,72,542.06,432,593.2,FALSE,FALSE
433,4,BODY,"We say that a statement or expression can throw an exception class E if, according to the rules in §11.2.1 and §11.2.2, the execution of the statement or expression can result in an exception of class E being thrown. We say that a catch clause can catch its catchable exception class(es): •The catchable exception class of a uni-catch clause is the declared type of its exception parameter (§14.20). •The catchable exception classes of a multi-catch clause are the alternatives in the union that denotes the type of its exception parameter.",10.94,115.14,360,540,72,462.06,432,577.2,FALSE,FALSE
438,5,BODY,The control transfer that occurs when an exception is thrown causes abrupt completion of expressions (§15.6) and statements (§14.1) until a catch clause is encountered that can handle the exception; execution then continues by executing the block of that catch clause. The code that caused the exception is never resumed.,10.94,45.14,360.01,321,72,532.06,432.01,577.2,FALSE,FALSE
449,2,BODY,"provided with a structurally correct signature; and that every instruction obeys the type discipline of the Java Virtual Machine. If an error occurs during verification, then an instance of the following subclass of class LinkageError will be thrown at the point in the program that caused the class to be verified: •VerifyError: The binary definition for a class or interface failed to pass a set of required checks to verify that it obeys the semantics of the Java Virtual Machine language and that it cannot violate the integrity of the Java Virtual Machine. (See §13.4.2, §13.4.4, §13.4.9, and §13.4.17 for some examples.)",10.94,122.14,360.01,626,72,76.06,432.01,198.2,FALSE,FALSE
469,7,BODY,"compile time to the value V denoted by the constant variable's initializer. If such a field is static, then no reference to the field should be present in the code in a binary file, including the class or interface which declared the field. Such a field must always appear to have been initialized (§12.4.2); the default initial value for the field (if different than V) must never be observed. If such a field is non-static, then no reference to the field should be present in the code in a binary file, except in the class containing the field. (It will be a class rather than an interface, since an interface has only static fields.)",10.94,109.14,342.01,636,90,494.06,432.01,603.2,FALSE,FALSE
481,3,BODY,"13.4.6Class Body and Member Declarations No incompatibility with pre-existing binaries is caused by adding an instance (respectively static) member that has the same name and accessibility (for fields), or same name and accessibility and signature and return type (for methods), as an instance (respectively static) member of a superclass or subclass. No error occurs even if the set of classes being linked would encounter a compile-time error. Deleting a class member or constructor that is not declared private may cause a linkage error if the member or constructor is used by a pre-existing binary.",10.94,111.11,360,602,72,166.09,432,277.2,FALSE,FALSE
496,2,BODY,"13.5.3Superinterfaces Changes to the interface hierarchy cause errors in the same way that changes to the class hierarchy do, as described in §13.4.4. In particular, changes that result in any previous superinterface of a class no longer being a superinterface can break compatibility with pre-existing binaries, resulting in a VerifyError.",10.94,66.11,360.01,340,72,76.09,432.01,142.2,FALSE,FALSE
536,3,BODY,"•If execution of the Statement completes abruptly for any other reason, the while statement completes abruptly for the same reason.",10.94,19.14,360,131,72,276.06,432,295.2,FALSE,FALSE
537,2,BODY,"•If execution of the Statement completes normally, then the Expression is evaluated. If the result is of type Boolean, it is subjected to unboxing conversion (§5.1.8). If evaluation of the Expression or the subsequent unboxing conversion (if any) completes abruptly for some reason, the do statement completes abruptly for the same reason. Otherwise, there is a choice based on the resulting value: –If the value is true, then the entire do statement is executed again. –If the value is false, no further action is taken and the do statement completes normally.",10.94,147.14,360.01,561,72,76.06,432.01,223.2,FALSE,FALSE
540,4,BODY,"2.Second, another for iteration step is performed. –If execution of the Statement completes abruptly, see §14.14.1.3.",10.94,25.14,295.65,117,82,559.2,377.65,584.33,FALSE,FALSE
586,4,BODY,"A floating-point expression is an expression whose type is float or double (§4.2.3). Floating-point expressions of type float denote values that exactly correspond to the values representable in the 32-bit IEEE 754 binary32 format. Floating-point expressions of type double denote values that exactly correspond to the values representable in the 64-bit IEEE 754 binary64 format. Many of the comparison and numerical operators of the Java programming language that can be used to form floating-point expressions correspond to IEEE 754 operations, as do the conversions that act on floating-point values (Table 15.4- A).",10.94,116.14,360,619,72,265.06,432,381.2,FALSE,FALSE
603,5,BODY,"In particular, the presence or absence of parentheses around an expression does not affect whether a variable is definitely assigned, definitely assigned when true, definitely assigned when false, definitely unassigned, definitely unassigned when true, or definitely unassigned when false (§16 (Definite Assignment)). If a parenthesized expression appears in a context of a particular kind with target type T (§5 (Conversions and Contexts)), its contained expression similarly appears in a context of the same kind with target type T. If the contained expression is a poly expression (§15.2), the parenthesized expression is also a poly expression. Otherwise, it is a standalone expression. A poly parenthesized expression is compatible with a target type T if its contained expression is compatible with T.",10.94,154.14,360,807,72,296.06,432,450.2,FALSE,FALSE
608,2,BODY,"•If C is an inner member class, then: –If the class instance creation expression is unqualified, then: ›If the class instance creation expression occurs in a static context, then a compile-time error occurs. ›Otherwise, if C is not a member of any class whose declaration lexically encloses the class instance creation expression, then a compile-time error occurs. ›Otherwise, let O be the innermost enclosing class declaration of which C is a member, and let U be the immediately enclosing class or interface declaration of the class instance creation expression. If U is not an inner class of O or O itself, then a compile-time error occurs. Let n be an integer such that O is the n'th lexically enclosing class or interface declaration of U The immediately enclosing instance of i is the n'th lexically enclosing instance of this.",10.94,230.14,360,833,72,76.06,432,306.2,FALSE,FALSE
608,4,BODY,"If C is an anonymous class, and its direct superclass S is an inner class, then i may have an immediately enclosing instance with respect to S, determined as follows: •If S is an inner local class, then: –If S occurs in a static context, then i has no immediately enclosing instance with respect to S. –Otherwise, if the class instance creation expression occurs in a static context, then a compile-time error occurs. –Otherwise, let O be the immediately enclosing class or interface declaration of S, and let U be the immediately enclosing class or interface declaration of the class instance creation expression. If U is not an inner class of O or O itself, then a compile-time error occurs. Let n be an integer such that O is the n'th lexically enclosing class or interface declaration of U. The immediately enclosing instance of i with respect to S is the n'th lexically enclosing instance of this.",10.94,230.14,360.01,902,72,364.06,432.01,594.2,FALSE,FALSE
614,3,BODY,"15.9.4Run-Time Evaluation of Class Instance Creation Expressions At run time, evaluation of a class instance creation expression is as follows. First, if the class instance creation expression is a qualified class instance creation expression, the qualifying primary expression is evaluated. If the qualifying expression evaluates to null, a NullPointerException is raised, and the class instance creation expression completes abruptly. If the qualifying expression completes abruptly, the class instance creation expression completes abruptly for the same reason. Next, space is allocated for the new class instance. If there is insufficient space to allocate the object, evaluation of the class instance creation expression completes abruptly by throwing an OutOfMemoryError. The new object contains new instances of all the fields declared in the specified class and all its superclasses. As each new field instance is created, it is initialized to its default value (§4.12.5). Next, the actual arguments to the constructor are evaluated, left-to-right. If any of the argument evaluations completes abruptly, any argument expressions to its right are not evaluated, and the class instance creation expression completes abruptly for the same reason. Next, the selected constructor of the specified class is invoked. This results in invoking at least one constructor for each superclass of the class. This process can be directed by explicit constructor invocation statements (§8.8.7.1) and is specified in detail in §12.5. The value of a class instance creation expression is a reference to the newly created object of the specified class. Every time the expression is evaluated, a fresh object is created.",10.94,362.11,360.01,1708,72,211.09,432.01,573.2,FALSE,FALSE
692,2,BODY,"15.18.1String Concatenation Operator + If only one operand expression is of type String, then string conversion (§5.1.11) is performed on the other operand to produce a string at run time. The result of string concatenation is a reference to a String object that is the concatenation of the two operand strings. The characters of the left-hand operand precede the characters of the right-hand operand in the newly created string. The String object is newly created (§12.5) unless the expression is a constant expression (§15.29).",10.94,117.11,360,529,72,76.09,432,193.2,FALSE,FALSE
697,9,BODY,"15.20.1Numerical Comparison Operators <, <=, >, and >= The type of each of the operands of a numerical comparison operator must be a type that is convertible (§5.1.8) to a primitive numeric type, or a compile-time error occurs.",10.94,53.11,360.01,227,72,534.09,432.01,587.2,FALSE,FALSE
703,6,BODY,"The bitwise operators and logical operators include the AND operator &, exclusive OR operator ^, and inclusive OR operator |.",10.94,19.14,360,125,72,475.06,432,494.2,FALSE,FALSE
708,6,BODY,–A numeric conditional expression. –A switch expression (§15.28) whose result expressions are all numeric expressions.,10.94,38.14,350,118,82,523.06,432,561.2,FALSE,FALSE
735,5,BODY,"Unlike code appearing in anonymous class declarations, the meaning of names and the this and super keywords appearing in a lambda body, along with the accessibility of referenced declarations, are the same as in the surrounding context (except that lambda parameters may introduce new names).",10.94,45.14,360.01,292,72,229.06,432.01,274.2,FALSE,FALSE
748,1,BODY,"The analysis takes into account the structure of statements and expressions; it also provides a special treatment of the expression operators &&, ||, !, and ? :, and of boolean-valued constant expressions. Except for the special treatment of the conditional boolean operators &&, ||, and ? : and of boolean-valued constant expressions, the values of expressions are not taken into account in the flow analysis.",10.94,77.14,360,410,72,76.06,432,153.2,FALSE,FALSE
751,6,BODY,The statement 'V is definitely unassigned after X' (where V is a variable and X is a statement or expression) means 'V is definitely unassigned after X if X completes normally'.,10.94,32.14,360,177,72,369.06,432,401.2,FALSE,FALSE
760,3,BODY,"For any immediate subexpression y of an expression x, where x is not a lambda expression, V is [un]assigned before y iff one of the following is true: •y is the leftmost immediate subexpression of x and V is [un]assigned before x. •y is the right-hand operand of a binary operator and V is [un]assigned after the left-hand operand. •x is an array access, y is the subexpression within the brackets, and V is [un]assigned after the subexpression before the brackets. •x is a primary method invocation expression, y is the first argument expression in the method invocation expression, and V is [un]assigned after the primary expression that computes the target object. •x is a method invocation expression or a class instance creation expression; y is an argument expression, but not the first; and V is [un]assigned after the argument expression to the left of y. •x is a qualified class instance creation expression, y is the first argument expression in the class instance creation expression, and V is [un]assigned after the primary expression that computes the qualifying object. •x is an array creation expression; y is a dimension expression, but not the first; and V is [un]assigned after the dimension expression to the left of y. •x is an array creation expression initialized via an array initializer; y is the array initializer in x; and V is [un]assigned after the dimension expression to the left of y.",10.94,314.14,360.01,1415,72,102.06,432.01,416.2,FALSE,FALSE
766,4,BODY,•V is [un]assigned before the contained statement iff either of the following is true: –A condition expression is present and V is [un]assigned after the condition expression when true. –No condition expression is present and V is [un]assigned before the condition part of the for statement.,10.94,70.14,360,291,72,319.06,432,389.2,FALSE,FALSE
769,4,BODY,"•A formal parameter V of a method or constructor (§8.4.1, §8.8.1) is definitely assigned (and moreover is not definitely unassigned) before the body of the method or constructor. •An exception parameter V of a catch clause (§14.20) is definitely assigned (and moreover is not definitely unassigned) before the body of the catch clause.",10.94,64.14,360.01,335,72,507.06,432.01,571.2,FALSE,FALSE
772,4,BODY,Let C be a class declared within the scope of V. Then: •V is definitely assigned before an instance variable initializer (§8.3.2) of C iff V is definitely assigned before the declaration of C.,10.94,38.14,360,192,72,273.06,432,311.2,FALSE,FALSE
793,2,BODY,"Given a set of sufficient synchronizes-with edges for Ei, if there is a release-acquire pair that happens-before (§17.4.5) an action you are committing, then that pair must be present in all Ej, where j ≥ i. Formally: 8.Let sswi be the swi edges that are also in the transitive reduction of hbi but not in po. We call sswi the sufficient synchronizes-with edges for Ei. If sswi(x, y) and hbi(y, z) and z in Ci, then swj(x, y) for all j ≥ i. If an action y is committed, all external actions that happen-before y are also committed.",10.94,109.14,360.01,531,72,76.06,432.01,185.2,FALSE,FALSE
831,2,BODY,"•For ‹LambdaExpression → T›: –If T is an inference variable, it is the (only) input variable. –If T is a functional interface type, and a function type can be derived from T (§15.27.3), then the input variables include (i) if the lambda expression is implicitly typed, the inference variables mentioned by the function type's parameter types; and (ii) if the function type's return type, R, is not void, then for each result expression e in the lambda body (or for the body itself if it is an expression), the input variables of ‹e → R›. –Otherwise, there are no input variables. •For ‹LambdaExpression →throws T›: –If T is an inference variable, it is the (only) input variable. –If T is a functional interface type, and a function type can be derived, as described in §15.27.3, the input variables include (i) if the lambda expression is implicitly typed, the inference variables mentioned by the function type's parameter types; and (ii) the inference variables mentioned by the function type's return type. –Otherwise, there are no input variables. •For ‹MethodReference → T›: –If T is an inference variable, it is the (only) input variable. –If T is a functional interface type with a function type, and if the method reference is inexact (§15.13.1), the input variables are the inference variables mentioned by the function type's parameter types. –Otherwise, there are no input variables. •For ‹MethodReference →throws T›: –If T is an inference variable, it is the (only) input variable. –If T is a functional interface type with a function type, and if the method reference is inexact (§15.13.1), the input variables are the inference variables mentioned by the function type's parameter types and the function type's return type. –Otherwise, there are no input variables. •For ‹Expression → T›, if Expression is a parenthesized expression: Where the contained expression of Expression is Expression', the input variables are the input variables of ‹Expression' → T›.",10.94,525.17,360.01,1975,72,76.06,432.01,601.23,FALSE,FALSE
843,1,BODY,"ClassType: {Annotation} TypeIdentifier [TypeArguments] PackageName . {Annotation} TypeIdentifier [TypeArguments] ClassOrInterfaceType . {Annotation} TypeIdentifier [TypeArguments] InterfaceType: ClassType TypeVariable: {Annotation} TypeIdentifier ArrayType: PrimitiveType Dims ClassOrInterfaceType Dims TypeVariable Dims Dims: {Annotation} [ ] {{Annotation} [ ]} TypeParameter: {TypeParameterModifier} TypeIdentifier [TypeBound] TypeParameterModifier: Annotation TypeBound: extends TypeVariable extends ClassOrInterfaceType {AdditionalBound} AdditionalBound: & InterfaceType TypeArguments: < TypeArgumentList > TypeArgumentList: TypeArgument {, TypeArgument} TypeArgument: ReferenceType Wildcard",10.94,504.05,321.79,695,90,76.13,411.79,580.18,FALSE,TRUE
853,1,BODY,RecordDeclaration: {ClassModifier} record TypeIdentifier [TypeParameters] RecordHeader [ClassImplements] RecordBody,10.94,32.05,333.5,115,90,76.13,423.5,108.18,FALSE,TRUE
856,3,BODY,"ArrayInitializer: { [VariableInitializerList] [,] } VariableInitializerList: VariableInitializer {, VariableInitializer}",10.94,56.05,193.49,120,90,485.13,283.49,541.18,FALSE,TRUE
864,1,BODY,ArrayCreationExpression: ArrayCreationExpressionWithoutInitializer ArrayCreationExpressionWithInitializer ArrayCreationExpressionWithoutInitializer: new PrimitiveType DimExprs [Dims] new ClassOrInterfaceType DimExprs [Dims] ArrayCreationExpressionWithInitializer: new PrimitiveType Dims ArrayInitializer new ClassOrInterfaceType Dims ArrayInitializer DimExprs: DimExpr {DimExpr} DimExpr: {Annotation} [ Expression ] ArrayAccess: ExpressionName [ Expression ] PrimaryNoNewArray [ Expression ] ArrayCreationExpressionWithInitializer [ Expression ],10.94,269.05,255.77,545,90,76.13,345.77,345.18,FALSE,TRUE
25,4,BODY,"Some preview APIs are described as reflective by the Java SE Platform Specification, principally in the java.lang.reflect, java.lang.invoke, and javax.lang.model packages. The rule for use of reflective preview APIs is as follows: •Whether preview features are enabled or disabled, any source code reference to a reflective preview API element causes a preview warning, unless one of the following is true: –The declaration where the reference appears is within the same module as the declaration of the reflective preview API element. –The reference appears in a declaration that is annotated to suppress preview warnings. –The reference appears in an import declaration. All preview APIs not described as reflective in the Java SE Platform Specification are normal. The rules for use of normal preview APIs are as follows: •If preview features are disabled, then any source code reference to a normal preview API element causes a compile-time error, unless: –The declaration where the reference appears is within the same module as the declaration of the normal preview API element.",10.93,269.14,360,1084,72,234.06,432,503.2,FALSE,FALSE
26,3,BODY,"1.6Feedback Readers are invited to report technical errors and ambiguities in The Java Language Specification to jls-jvms-spec-comments@openjdk.org. Questions concerning the behavior of javac (the reference compiler for the Java programming language), and in particular its conformance to this specification, may be sent to compiler-dev@openjdk.org.",10.93,94.64,360,349,72,227.56,432,322.2,FALSE,FALSE
35,3,BODY,"3.1Unicode Programs are written using the Unicode character set (§1.7). Information about this character set and its associated character encodings may be found at https:// www.unicode.org/. The Java SE Platform tracks the Unicode Standard as it evolves. The precise version of Unicode used by a given release is specified in the documentation of the class Character. The Unicode standard was originally designed as a fixed-width 16-bit character encoding. It has since been changed to allow for characters whose representation requires more than 16 bits. The range of legal code points is now U+0000 to U +10FFFF, using the hexadecimal U+n notation. Characters whose code points are greater than U+FFFF are called supplementary characters. To represent the complete range of characters using only 16-bit units, the Unicode standard defines an encoding called UTF-16. In this encoding, supplementary characters are represented as pairs of 16-bit code units, the first from the high-surrogates range",10.93,217.64,360,998,72,378.86,432,596.5,FALSE,FALSE
60,5,BODY,A character literal is always of type char (§4.2.1). The content of a character literal is the SingleCharacter or the EscapeSequence which follows the opening '. It is a compile-time error for the character following the content to be other than a '. It is a compile-time error for a line terminator (§3.4) to appear after the opening ' and before the closing '.,10.93,89.14,360,362,72,266.2,432,355.33,FALSE,FALSE
61,4,BODY,StringLiteral: ' {StringCharacter} ' StringCharacter: InputCharacter but not ' or \ EscapeSequence,10.93,69.18,140.27,98,90,351.13,230.27,420.31,FALSE,TRUE
61,5,BODY,A string literal is always of type String (§4.3.3). The content of a string literal is the sequence of characters that begins immediately after the opening ' and ends immediately before the matching closing '. It is a compile-time error for a line terminator (§3.4) to appear after the opening ' and before the matching closing '.,10.93,70.14,360.01,330,72,438.2,432.01,508.33,FALSE,FALSE
75,6,BODY,"4.2.3Floating-Point Types and Values The floating-point types are float and double, which are conceptually associated with the 32-bit binary32 and 64-bit binary64 floating-point formats for IEEE 754 values and operations, as specified in the IEEE 754 Standard (§1.7).",10.93,53.11,360,267,72,261.09,432,314.2,FALSE,FALSE
96,4,BODY,"The superclass types (respectively, superinterface types) of a raw type are the erasures of the superclass types (superinterface types) of the named class or interface. The type of a constructor (§8.8), instance method (§8.4, §9.4), or non-static field (§8.3) of a raw type C that is not inherited from its superclasses or superinterfaces is the erasure of its type in the generic class or interface C. The type of an inherited instance method or non-static field of a raw type C, where the member was declared in a class or interface D, is the type of the member in the supertype of C that names D. The type of a static method or static field of a raw type C is the same as its type in the generic class or interface C. It is a compile-time error to pass type arguments to a non-static member class or interface of a raw type that is not inherited from its superclasses or superinterfaces. It is a compile-time error to attempt to use a member class or interface of a parameterized type as a raw type.",10.93,218.14,360.01,1002,72,162.06,432.01,380.2,FALSE,FALSE
108,14,BODY,"14.The element type in an array creation expression (§15.10.1) 15.The type in the cast operator of a cast expression (§15.16) 16.The type that follows the instanceof type comparison operator (§15.20.2) 17.In a method reference expression (§15.13), as the reference type to search",10.93,63.14,350,279,82,491.06,432,554.2,FALSE,FALSE
115,5,BODY,"the keyword static (§8.3.1.1). If a class T has a field a that is an instance variable, then a new instance variable a is created and initialized to a default value (§4.12.5) as part of each newly created object of class T or of any class that is a subclass of T (§8.1.4). The instance variable effectively ceases to exist when the object of which it is a field is no longer referenced, after any necessary finalization of the object (§12.6) has been completed.",10.93,90.14,342,461,90,330.06,432,420.2,FALSE,FALSE
130,2,BODY,"A widening conversion from float to double occurs as determined by the rules of IEEE 754 for converting between binary floating-point formats. Despite the fact that loss of precision may occur, a widening primitive conversion never results in a run-time exception (§11.1.1).",10.93,51.14,360.01,274,72,76.06,432.01,127.2,FALSE,FALSE
182,3,BODY,6.3.1.3Logical Complement Operator ! The following rules apply to a logical complement expression !a (§15.15.6): •A pattern variable is introduced by !a when true iff it is introduced by a when false. •A pattern variable is introduced by !a when false iff it is introduced by a when true. 6.3.1.4Conditional Operator ? : The following rules apply to a conditional expression a ? b : c (§15.25): •A pattern variable introduced by a when true is definitely matched at b. •A pattern variable introduced by a when false is definitely matched at c.,10.93,175.34,360,543,72,110.13,432,285.46,FALSE,FALSE
183,3,BODY,"6.3.1.6switch Expressions The following rule applies to a switch expression with a switch block consisting of switch rules (§14.11.1): •A pattern variable introduced by a switch label is definitely matched in the associated switch rule expression, switch rule block, or switch rule throw statement. The following rules apply to a switch expression with a switch block consisting of switch labeled statement groups (§14.11.1): •A pattern variable introduced by a switch label is definitely matched in all the statements of the associated switch labeled statement group. •A pattern variable introduced by a statement S contained in a switch labeled statement group is definitely matched at all the statements following S, if any, in the switch labeled statement group. 6.3.1.7Parenthesized Expressions The following rules apply to a parenthesized expression (a) (§15.8.5): •A pattern variable is introduced by (a) when true iff it is introduced by a when true. •A pattern variable is introduced by (a) when false iff it is introduced by a when false.",10.93,304.34,360,1048,72,222.26,432,526.6,FALSE,FALSE
184,6,BODY,"6.3.2.1Blocks The following rule applies to a block statement S contained in a block (§14.2) that is not a switch block (§14.11.1): •A pattern variable introduced by S is definitely matched at all the block statements following S, if any, in the block. 6.3.2.2if Statements The following rules apply to a statement if (e) S (§14.9.1): •A pattern variable introduced by e when true is definitely matched at S.",10.93,137.34,360,408,72,449.13,432,586.47,FALSE,FALSE
198,9,BODY,"14.The element type in an array creation expression (§15.10.1) 15.The type in the cast operator of a cast expression (§15.16) 16.The type that follows the instanceof relational operator (§15.20.2) 17.In a method reference expression (§15.13), as the reference type to search",10.93,63.14,350,274,82,459.06,432,522.2,FALSE,FALSE
205,2,BODY,"If Id does not name a member class or interface within Q (§8.5, §9.5), or the member class or interface named Id within Q is not accessible, or Id names more than one member class or interface within Q, then a compile-time error occurs.",10.93,32.14,360,236,72,76.06,432,108.2,FALSE,FALSE
211,2,BODY,"•Otherwise, Q.Id denotes a variable, the field Id of class T, which may be either a class variable or an instance variable. The type of the expression Q.Id is the type of the field member after capture conversion (§5.1.10).",10.93,51.14,360,223,72,76.06,432,127.2,FALSE,FALSE
241,2,BODY,"In the absence of an access modifier, a top level class or interface has package access: it is accessible only within ordinary compilation units of the package in which it is declared (§6.6.1). A class or interface may be declared public to grant access to the class or interface from code in other packages of the same module, and potentially from code in packages of other modules. It is a compile-time error if a top level class or interface declaration contains any one of the following access modifiers: protected, private, or static. It is a compile-time error if the name of a top level class or interface appears as the name of any other top level class or interface declared in the same package. The scope and shadowing of a top level class or interface is specified in §6.3 and §6.4. The fully qualified name of a top level class or interface is specified in §6.7.",10.93,173.14,360.01,874,72,108.06,432.01,281.2,FALSE,FALSE
257,2,BODY,situation can occur if the class would have as members two abstract methods that have the same method signature (§8.4.2) but return types for which no type is return-type-substitutable with both (§8.4.5).,10.93,32.14,360.01,204,72,76.06,432.01,108.2,FALSE,FALSE
262,3,BODY,"8.1.3Inner Classes and Enclosing Instances An inner class is a nested class that is not explicitly or implicitly static. An inner class is one of the following: •a member class that is not explicitly or implicitly static (§8.5) •a local class that is not implicitly static (§14.3) •an anonymous class (§15.9.5) The following nested classes are implicitly static, so are not inner classes: •a member enum class (§8.9) •a local enum class (§14.3) •a member record class (§8.10) •a local record class (§14.3) •a member class of an interface (§9.5) All of the rules that apply to nested classes apply to inner classes. In particular, an inner class may declare and inherit static members (§8.2), and declare static initializers (§8.7), even though the inner class itself is not static.",10.93,262.11,360,781,72,225.09,432,487.2,FALSE,FALSE
264,5,BODY,A class C is an inner class of class or interface O if it is either a direct inner class of O or an inner class of an inner class of O.,10.93,19.14,360,135,72,445.06,432,464.2,FALSE,FALSE
316,2,BODY,"A method that overrides or hides another method, including methods that implement abstract methods defined in interfaces, may not be declared to throw more checked exceptions than the overridden or hidden method.",10.93,32.14,360,212,72,76.06,432,108.2,FALSE,FALSE
333,3,BODY,"with respect to S (if any) must be determined: •If S is not an inner class, or if the declaration of S occurs in a static context, then no immediately enclosing instance of i with respect to S exists. •Otherwise, if the superclass constructor invocation is unqualified, then S is necessarily an inner local class or an inner member class. If S is an inner local class, let O be the immediately enclosing class or interface declaration of S. If S is an inner member class, let O be the innermost enclosing class of C of which S is a member. Let n be an integer (n ≥ 1) such that O is the n'th lexically enclosing class or interface declaration of C. The immediately enclosing instance of i with respect to S is the n'th lexically enclosing instance of this.",10.93,198.14,342.01,756,90,89.06,432.01,287.2,FALSE,FALSE
341,4,BODY,"It is a compile-time error if an enum declaration E has an abstract method m as a member, unless E has at least one enum constant and all of E's enum constants have class bodies that provide concrete implementations of m. It is a compile-time error for an enum declaration to declare a finalizer (§12.6). An instance of an enum class may never be finalized.",10.93,64.14,360,357,72,286.06,432,350.2,FALSE,FALSE
351,2,BODY,"•The accessor method must be a public instance method with no formal parameters and no throws clause. If a record class has a record component for which an accessor method is not declared explicitly, then an accessor method for that record component is declared implicitly, with the following properties: •Its name is the same as the name of the record component. •Its return type is the same as the declared type of the record component. •It is not generic. •It is a public instance method with no formal parameters and no throws clause. •It is annotated with the annotations, if any, that appear on the corresponding record component and whose annotation interfaces are applicable in the method declaration context, or in type contexts, or both (§9.7.4). •Its body returns the value of the corresponding component field.",10.93,204.14,360.01,822,72,76.06,432.01,280.2,FALSE,FALSE
363,6,BODY,"Each InterfaceType in the extends clause of an interface declaration must name an accessible interface (§6.6), or a compile-time error occurs. It is a compile-time error if any InterfaceType names a interface that is sealed (§9.1.1.4) and the interface being declared is not a permitted direct subinterface of the named interface (§9.1.4).",10.93,64.14,360.01,339,72,525.06,432.01,589.2,FALSE,FALSE
364,2,BODY,"If an InterfaceType has type arguments, it must denote a well-formed parameterized type (§4.5), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. One interface is a direct superinterface of another interface if the first interface is named by one of the direct superinterface types of the second interface. The superinterface relationship is the transitive closure of the direct superinterface relationship. An interface I is a superinterface of interface K if either of the following is true: •I is a direct superinterface of K. •Where J is a direct superinterface of K, I is a superinterface of J, applying this definition recursively. An interface is said to be a direct subinterface of its direct superinterface, and a subinterface of each of its superinterfaces. While every class is an extension of class Object, there is no single interface of which all interfaces are extensions. An interface I directly depends on a class or interface A if A is mentioned in the extends clause of I either as a superinterface or as a qualifier in the fully qualified form of a superinterface name. An interface I depends on a class or interface A if any of the following is true: •I directly depends on A. •I directly depends on a class C that depends on A (§8.1.5). •I directly depends on an interface J that depends on A, applying this definition recursively. It is a compile-time error if an interface depends on itself. If circularly declared interfaces are detected at run time, as interfaces are loaded, then a ClassCircularityError is thrown (§12.2.1).",10.93,409.14,360.01,1596,72,76.06,432.01,485.2,FALSE,FALSE
375,3,BODY,"9.4.1.3Inheriting Methods with Override-Equivalent Signatures It is possible for an interface to inherit several methods with override-equivalent signatures (§8.4.2). If an interface I inherits a default method whose signature is override-equivalent with another method inherited by I, then a compile-time error occurs. (This is the case whether the other method is abstract or default.) Otherwise, all the inherited methods are abstract, and the interface is considered to inherit all the methods. One of the inherited methods must be return-type-substitutable for every other inherited method, or else a compile-time error occurs. (The throws clauses do not cause errors in this case.) There might be several paths by which the same method declaration is inherited from an interface. This fact causes no difficulty and never, of itself, results in a compile-time error.",10.93,206.2,360,871,72,162.13,432,368.33,FALSE,FALSE
385,2,BODY,"3.AC is retained for at least as long as A, where retention is expressed explicitly",10.93,6.14,360,83,72,76.06,432,82.2,FALSE,FALSE
395,2,BODY,"•The use is within a declaration that is annotated to suppress deprecation warnings (§9.6.4.5); or •The declaration where the use appears and the declaration of the ordinarily deprecated program element are both within the same outermost class; or •The use is within an import declaration that imports the ordinarily deprecated class, interface, or member; or •The use is within an exports or opens directive (§7.7.2). A Java compiler must produce a removal warning when a terminally deprecated program element is used (overridden, invoked, or referenced by name) in the declaration of a program element (whether explicitly or implicitly declared), unless: •The use is within a declaration that is annotated to suppress removal warnings (§9.6.4.5); or •The declaration where the use appears and the declaration of the terminally deprecated program element are both within the same outermost class; or •The use is within an import declaration that imports the terminally deprecated class, interface, or member; or •The use is within an exports or opens directive.",10.93,275.14,360,1062,72,76.06,432,351.2,FALSE,FALSE
412,8,BODY,"The function type's type parameters, formal parameter types, and return type are as given by m.",10.93,19.14,350.01,95,82,572.06,432.01,591.2,FALSE,FALSE
417,2,BODY,"IN the Java programming language, arrays are objects (§4.3.1), are dynamically created, and may be assigned to variables of type Object (§4.3.2). All methods of class Object may be invoked on an array. An array object contains a number of variables. The number of variables may be zero, in which case the array is said to be empty. The variables contained in an array have no names; instead they are referenced by array access expressions that use non-negative integer index values. These variables are called the components of the array. If an array has n components, we say n is the length of the array; the components of the array are referenced using integer indices from 0 to n - 1, inclusive. All the components of an array have the same type, called the component type of the array. If the component type of an array is T, then the type of the array itself is written T[]. The component type of an array may itself be an array type. The components of such an array may contain references to subarrays. If, starting from any array type, one considers its component type, and then (if that is also an array type) the component type of that type, and so on, eventually one must reach a component type that is not an array type; this is called the element type of the original array, and the components at this level of the data structure are called the elements of the original array. There are some situations in which an element of an array can be an array: if the element type is Object or Cloneable or java.io.Serializable, then some or all of the elements may be arrays, because any array object can be assigned to any variable of these types.",10.93,329.14,360,1652,72,220.36,432,549.5,FALSE,FALSE
432,2,BODY,"11.1.3Asynchronous Exceptions Most exceptions occur synchronously as a result of an action by the thread in which they occur, and at a point in the program that is specified to possibly result in such an exception. An asynchronous exception is, by contrast, an exception that can potentially occur at any point in the execution of a program. Asynchronous exceptions occur only as a result of an internal error or resource limitation in the Java Virtual Machine that prevents it from implementing the semantics of the Java programming language. The asynchronous exception that is thrown is an instance of a subclass of VirtualMachineError.",10.93,124.11,360.01,638,72,76.09,432.01,200.2,FALSE,FALSE
454,6,BODY,further action is required. Release LC and complete normally.,10.93,6.14,269.25,61,90,448.06,359.25,454.2,FALSE,FALSE
459,8,BODY,"The class Object has a protected method called finalize; this method can be overridden by other classes. The particular definition of finalize that can be invoked for an object is called the finalizer of that object. Before the storage for an object is reclaimed by the garbage collector, the Java Virtual Machine will invoke the finalizer of that object. Finalizers provide a chance to free up resources that cannot be freed automatically by an automatic storage manager. In such situations, simply reclaiming the memory used by an object would not guarantee that the resources it held would be reclaimed. The Java programming language does not specify how soon a finalizer will be invoked, except to say that it will happen before the storage for the object is reused. The Java programming language does not specify which thread will invoke the finalizer for any given object.",10.93,167.14,360.01,878,72,434.06,432.01,601.2,FALSE,FALSE
479,3,BODY,"13.4.4Superclasses and Superinterfaces A ClassCircularityError is thrown at load time if a class would be a superclass of itself. Changes to the class hierarchy that could result in such a circularity when newly compiled binaries are loaded with pre-existing binaries are not recommended for widely distributed classes. Changing the direct superclass type or the set of direct superinterface types of a class will not break compatibility with pre-existing binaries, provided that the total set of superclasses or superinterfaces, respectively, of the class loses no members.",10.93,111.11,360.01,574,72,147.09,432.01,258.2,FALSE,FALSE
500,2,BODY,"14.1Normal and Abrupt Completion of Statements Every statement has a normal mode of execution in which certain computational steps are carried out. The following sections describe the normal mode of execution for each kind of statement. If all the steps are carried out as described, with no indication of abrupt completion, the statement is said to complete normally. However, certain events may prevent a statement from completing normally: •The break, yield, continue, and return statements (§14.15, §14.21, §14.16, §14.17) cause a transfer of control that may prevent normal completion of expressions, statements, and blocks that contain them. •Evaluation of certain expressions may throw exceptions from the Java Virtual Machine (§15.6). An explicit throw (§14.18) statement also results in an exception. An exception causes a transfer of control that may prevent normal completion of statements. If such an event occurs, then execution of one or more statements may be terminated before all steps of their normal mode of execution have completed; such statements are said to complete abruptly. An abrupt completion always has an associated reason, which is one of the following: •A break with no label •A break with a given label •A continue with no label •A continue with a given label •A return with no value •A return with a given value •A throw with a given value, including exceptions thrown by the Java Virtual Machine",10.93,433.64,360.01,1430,72,157.56,432.01,591.2,FALSE,FALSE
504,5,BODY,A local variable declaration can appear in the following locations: •a local variable declaration statement in a block (§14.4.2) •the header of a basic for statement (§14.14.1) •the header of an enhanced for statement (§14.14.2) •the resource specification of a try-with-resources statement (§14.20.3),10.93,82.14,322.82,301,72,517.06,394.82,599.2,FALSE,FALSE
518,6,BODY,"Switch labels and their case constants, null literals, and case patterns are said to be associated with the switch block. For a given switch block both of the following must be true, otherwise a compile- time error occurs: •No two of the case constants associated with a switch block may have the same value. •No more than one null literal may be associated with a switch block.",10.93,102.14,360,378,72,499.06,432,601.2,FALSE,FALSE
527,5,BODY,A switch statement or expression is exhaustive if its switch block is exhaustive for the selector expression.,10.93,19.14,360,109,72,526.06,432,545.2,FALSE,FALSE
533,2,BODY,"statement completes normally. If the result of evaluation is a value, it is discarded. –If it is the switch label for a switch rule block, then the block is executed. If this block completes normally, then the switch statement completes normally. –If it is the switch label for a switch rule throw statement, then the throw statement is executed. –If it is the switch label for a switch labeled statement group, then all the statements in the switch block that follow the switch label are executed in order. If these statements complete normally, then the switch statement completes normally. –Otherwise, there are no statements in the switch block that follow the switch label that applies, and the switch statement completes normally.",10.93,173.14,350.02,736,82,76.06,432.02,249.2,FALSE,FALSE
541,2,BODY,"•If the Expression is present and the value resulting from its evaluation (including any possible unboxing) is false, no further action is taken and the for statement completes normally.",10.93,32.14,360.01,186,72,76.06,432.01,108.2,FALSE,FALSE
545,2,BODY,"•Otherwise, the Expression necessarily has an array type, S[], and the basic for statement has this form:",10.93,19.14,360,105,72,76.06,432,95.2,FALSE,FALSE
580,5,BODY,"14.30.3Properties of Patterns A pattern p is said to be applicable at a type T if one of the following rules apply: •A type pattern that declares a pattern variable of a reference type U is applicable at a reference type T if there is a testing conversion (§5.7) from type T to type U. •A type pattern that declares a pattern variable of a primitive type P is applicable at the type P. •A record pattern with type R and pattern list L is applicable at type T if (i) there is a testing conversion (§5.7) from type T to type R, and (ii) for every component pattern p appearing in L, if any, p is applicable at the type of the corresponding component field in R. •A match-all pattern is applicable at every type T. A pattern p is said to be unconditional for a type T if it can be determined at compile time that every value of type T will match p, and so the run time, testing aspect of pattern matching could be elided. It is defined as follows: •A type pattern that declares a pattern variable of a reference type S is unconditional for a reference type T if the erasure of T is a subtype of the erasure of S.",10.93,258.11,360.01,1109,72,320.09,432.01,578.2,FALSE,FALSE
586,2,BODY,"•If C is final, then the expression is guaranteed to have a value that is either (i) the null reference, or (ii) an object whose class is C itself, because final classes have no subclasses. •If C is sealed, then the expression is guaranteed to have a value that is either (i) the null reference, (ii) an object whose class is C itself, or (iii) assignment compatible with one of the permitted direct subclasses of C (§8.1.6). •If C is freely extensible, then the expression is guaranteed to have a value that is either (i) the null reference, (ii) an object whose class is C itself, or (iii) assignment compatible with C.",10.93,122.14,360,621,72,76.06,432,198.2,FALSE,FALSE
619,5,BODY,"15.10.2Run-Time Evaluation of Array Creation Expressions At run time, evaluation of an array creation expression behaves as follows: •If there are no dimension expressions, then there must be an array initializer. A newly allocated array will be initialized with the values provided by the array initializer as described in §10.6. The value of the array initializer becomes the value of the array creation expression. •Otherwise, there is no array initializer, and: –First, the dimension expressions are evaluated, left-to-right. If any of the expression evaluations completes abruptly, the expressions to the right of it are not evaluated. –Next, the values of the dimension expressions are checked. If the value of any DimExpr expression is less than zero, then a NegativeArraySizeException is thrown. –Next, space is allocated for the new array. If there is insufficient space to allocate the array, evaluation of the array creation expression completes abruptly by throwing an OutOfMemoryError. –Then, if a single DimExpr appears, a one-dimensional array is created of the specified length, and each component of the array is initialized to its default value (§4.12.5). –Otherwise, if n DimExpr expressions appear, then array creation effectively executes a set of nested loops of depth n-1 to create the implied arrays of arrays. A multidimensional array need not have arrays of the same length at each level.",10.93,348.11,360,1414,72,254.09,432,602.2,FALSE,FALSE
623,2,BODY,"The index expression undergoes unary numeric promotion (§5.6). The promoted type must be int, or a compile-time error occurs. The type of the array access expression is the result of applying capture conversion (§5.1.10) to T. The result of an array access expression is a variable of type T, namely the variable within the array selected by the value of the index expression. This resulting variable, which is a component of the array, is never considered final, even if the array reference expression denoted a final variable.",10.93,115.14,360.01,528,72,76.06,432.01,191.2,FALSE,FALSE
642,3,BODY,"•A method reference expression (§15.13) is potentially compatible with a functional interface type T if, where the arity of the function type of T is n, there exists at least one potentially applicable method when the method reference expression targets the function type with arity n (§15.13.1), and one of the following is true: –The method reference expression has the form ReferenceType :: [TypeArguments] Identifier and at least one potentially applicable method is either (i) static and supports arity n, or (ii) not static and supports arity n-1. –The method reference expression has some other form and at least one potentially applicable method is not static.",10.93,135.14,360.01,668,72,236.06,432.01,371.2,FALSE,FALSE
650,3,BODY,"to the type parameters of the most specific method (§8.4.4). If the most specific method is not generic but at least one maximally specific method is generic, the throws clauses are first erased.",10.93,38.14,332.01,195,100,236.06,432.01,274.2,FALSE,FALSE
657,4,BODY,"The argument expressions (possibly rewritten as described above) are now evaluated to yield argument values. Each argument value corresponds to exactly one of the method's n formal parameters. The argument expressions, if any, are evaluated in order, from left to right. If the evaluation of any argument expression completes abruptly, then no part of any argument expression to its right appears to have been evaluated, and the method invocation completes abruptly for the same reason. The result of evaluating the j'th argument expression is the j'th argument value, for 1 ≤ j ≤ n. Evaluation then continues, using the argument values, as described below. 15.12.4.3Check Accessibility of Type and Method In this section: •Let D be the class containing the method invocation. •Let Q be the qualifying class or interface of the method invocation (§13.1). •Let m be the name of the method as determined at compile time (§15.12.3). An implementation of the Java programming language must ensure, as part of linkage, that the class or interface Q is accessible: •If Q is in the same package as D, then Q is accessible. •If Q is in a different package than D, and their packages are in the same module, and Q is public or protected, then Q is accessible. •If Q is in a different package than D, and their packages are in different modules, and Q's module exports Q's package to D's module, and Q is public or protected, then Q is accessible.",10.93,348.27,360.01,1437,72,246.06,432.01,594.33,FALSE,FALSE
660,4,BODY,"searched for a suitable method. A set of candidate methods is considered with the following properties: (i) each method is declared in a (direct or indirect) superinterface of R; (ii) each method has the name and descriptor required by the method invocation; (iii) each method is non-static and non-private; (iv) for each method, where the method's declaring interface is I, there is no other method satisfying (i) through (iii) that is declared in a subinterface of I. If this set contains a default method, one such method is the method to be invoked. Otherwise, an abstract method in the set is selected as the method to be invoked.",10.93,135.14,342.01,635,90,147.06,432.01,282.2,FALSE,FALSE
678,2,BODY,"•If the form is ClassType :: [TypeArguments] new, the body of the invocation method has the effect of a class instance creation expression of the form new [TypeArguments] ClassType(A1, ..., An), where the arguments A1, ..., An are the formal parameters of the invocation method, and where: –The enclosing instance for the new object, if any, is derived from the site of the method reference expression, as specified in §15.9.2. –The constructor to invoke is the constructor that corresponds to the compile- time declaration of the method reference (§15.13.1).",10.93,109.14,360,559,72,76.06,432,185.2,FALSE,FALSE
681,2,BODY,PreIncrementExpression: ++ UnaryExpression PreDecrementExpression: -- UnaryExpression UnaryExpressionNotPlusMinus: PostfixExpression ~ UnaryExpression ! UnaryExpression CastExpression SwitchExpression,10.93,145.05,143.6,200,90,76.13,233.6,221.18,FALSE,TRUE
691,5,BODY,The operators + and - are called the additive operators.,10.93,6.14,243.58,56,72,330.06,315.58,336.2,FALSE,FALSE
696,4,BODY,ShiftExpression: AdditiveExpression ShiftExpression << AdditiveExpression ShiftExpression >> AdditiveExpression ShiftExpression >>> AdditiveExpression,10.93,58.05,186.31,150,90,158.13,276.31,216.18,FALSE,TRUE
717,3,BODY,"15.26.1Simple Assignment Operator = If the type of the right-hand operand is not assignment compatible with the type of the variable (§5.2), then a compile-time error occurs. Otherwise, at run time, the expression is evaluated in one of three ways. If the left-hand operand expression is a field access expression e.f (§15.11), possibly enclosed in one or more pairs of parentheses, then: •First, the expression e is evaluated. If evaluation of e completes abruptly, the assignment expression completes abruptly for the same reason. •Next, the right hand operand is evaluated. If evaluation of the right hand expression completes abruptly, the assignment expression completes abruptly for the same reason. •Then, if the field denoted by e.f is not static and the result of the evaluation of e above is null, then a NullPointerException is thrown. •Otherwise, the variable denoted by e.f is assigned the value of the right hand operand as computed above. If the left-hand operand is an array access expression (§15.10.3), possibly enclosed in one or more pairs of parentheses, then: •First, the array reference subexpression of the left-hand operand array access expression is evaluated. If this evaluation completes abruptly, then the",10.93,296.11,360,1234,72,301.09,432,597.2,FALSE,FALSE
730,2,BODY,LambdaExpression: LambdaParameters -> LambdaBody,10.93,19.05,172.35,48,90,76.13,262.35,95.18,FALSE,TRUE
757,4,BODY,•V is [un]assigned before a block statement that is not the first of a switch labeled statement group in the switch block iff V is [un]assigned after the preceding block statement. The following rule applies to all switch expressions:,10.93,51.14,360.01,234,72,550.06,432.01,601.2,FALSE,FALSE
766,2,BODY,•V is [un]assigned after a for statement iff both of the following are true: –Either a condition expression is not present or V is [un]assigned after the condition expression when false. –V is [un]assigned before every break statement for which the for statement is the break target.,10.93,70.14,360,283,72,76.06,432,146.2,FALSE,FALSE
778,6,BODY,"Each thread must determine an order over the events that could cause it to be removed from a wait set. That order does not have to be consistent with other orderings, but the thread must behave as though those events occurred in that order. For example, if a thread t is in the wait set for m, and then both an interrupt of t and a notification of m occur, there must be an order over these events. If the interrupt is deemed to have occurred first, then t will eventually return from wait by throwing InterruptedException, and some other thread in the wait set for m (if any exist at the time of the notification) must receive the notification. If the notification is deemed to have occurred first, then t will eventually return normally from wait with an interrupt still pending.",10.93,142.14,332,781,100,387.06,432,529.2,FALSE,FALSE
812,5,BODY,"›Otherwise, let R' be the result of applying capture conversion (§5.1.10) to the return type of the invocation type (§15.12.2.6) of the compile-time declaration. If R' is void, the constraint reduces to false; otherwise, the constraint reduces to ‹R' → R›.",10.93,46.17,340,256,92,248.06,432,294.23,FALSE,FALSE
857,2,BODY,Block: { [BlockStatements] } BlockStatements: BlockStatement {BlockStatement} BlockStatement: LocalClassOrInterfaceDeclaration LocalVariableDeclarationStatement Statement LocalClassOrInterfaceDeclaration: ClassDeclaration NormalInterfaceDeclaration LocalVariableDeclarationStatement: LocalVariableDeclaration ; LocalVariableDeclaration: {VariableModifier} LocalVariableType VariableDeclaratorList LocalVariableType: UnannType var Statement: StatementWithoutTrailingSubstatement LabeledStatement IfThenStatement IfThenElseStatement WhileStatement ForStatement StatementNoShortIf: StatementWithoutTrailingSubstatement LabeledStatementNoShortIf IfThenElseStatementNoShortIf WhileStatementNoShortIf ForStatementNoShortIf,10.93,484.05,290.14,716,90,100.13,380.14,584.18,FALSE,TRUE
868,1,BODY,EqualityExpression: RelationalExpression EqualityExpression == RelationalExpression EqualityExpression != RelationalExpression RelationalExpression: ShiftExpression RelationalExpression < ShiftExpression RelationalExpression > ShiftExpression RelationalExpression <= ShiftExpression RelationalExpression >= ShiftExpression InstanceofExpression InstanceofExpression: RelationalExpression instanceof ReferenceType RelationalExpression instanceof Pattern ShiftExpression: AdditiveExpression ShiftExpression << AdditiveExpression ShiftExpression >> AdditiveExpression ShiftExpression >>> AdditiveExpression AdditiveExpression: MultiplicativeExpression AdditiveExpression + MultiplicativeExpression AdditiveExpression - MultiplicativeExpression MultiplicativeExpression: UnaryExpression MultiplicativeExpression * UnaryExpression MultiplicativeExpression / UnaryExpression MultiplicativeExpression % UnaryExpression UnaryExpression: PreIncrementExpression PreDecrementExpression + UnaryExpression - UnaryExpression UnaryExpressionNotPlusMinus,10.93,501.05,229.58,1037,90,76.13,319.58,577.18,FALSE,TRUE
869,1,BODY,PreIncrementExpression: ++ UnaryExpression PreDecrementExpression: -- UnaryExpression UnaryExpressionNotPlusMinus: PostfixExpression ~ UnaryExpression ! UnaryExpression CastExpression SwitchExpression PostfixExpression: Primary ExpressionName PostIncrementExpression PostDecrementExpression PostIncrementExpression: PostfixExpression ++ PostDecrementExpression: PostfixExpression -- CastExpression: ( PrimitiveType ) UnaryExpression ( ReferenceType {AdditionalBound} ) UnaryExpressionNotPlusMinus ( ReferenceType {AdditionalBound} ) LambdaExpression SwitchExpression: switch ( Expression ) SwitchBlock ConstantExpression: Expression,10.93,432.05,321.08,632,90,76.13,411.08,508.18,FALSE,TRUE
49,4,BODY,IntegerLiteral: DecimalIntegerLiteral HexIntegerLiteral OctalIntegerLiteral BinaryIntegerLiteral DecimalIntegerLiteral: DecimalNumeral [IntegerTypeSuffix] HexIntegerLiteral: HexNumeral [IntegerTypeSuffix] OctalIntegerLiteral: OctalNumeral [IntegerTypeSuffix] BinaryIntegerLiteral: BinaryNumeral [IntegerTypeSuffix] IntegerTypeSuffix: (one of) l L,10.92,256.05,175.29,346,90,257.13,265.29,513.18,FALSE,TRUE
71,2,BODY,"THE Java programming language is a statically typed language, which means that every variable and every expression has a type that is known at compile time. The Java programming language is also a strongly typed language, because types limit the values that a variable (§4.12) can hold or that an expression can produce, limit the operations supported on those values, and determine the meaning of the operations. Strong static typing helps detect errors at compile time. The types of the Java programming language are divided into two kinds: primitive types and reference types. The primitive types (§4.2) are the boolean type and the numeric types. The numeric types are the integral types byte, short, int, long, and char, and the floating-point types float and double. The reference types (§4.3) are class types, interface types, and array types. There is also a special null type. An object (§4.3.1) is a dynamically created instance of a class type or a dynamically created array. The values of a reference type are references to objects. All objects, including arrays, support the methods of class Object (§4.3.2). String literals are represented by String objects (§4.3.3).",10.92,200.14,360.01,1181,72,220.36,432.01,420.5,FALSE,FALSE
131,5,BODY,"b.Otherwise, if this integer value can be represented as an int, then the",10.92,6.14,332,73,100,320.06,432,326.2,FALSE,FALSE
180,6,BODY,"6.3.1Scope for Pattern Variables in Expressions Only certain kinds of boolean expressions are involved in introducing pattern variables and determining where those variables are definitely matched. If an expression is not a conditional-and expression, conditional-or expression, logical complement expression, conditional expression, instanceof expression, switch expression, or parenthesized expression, then no scope rules apply. 6.3.1.1Conditional-And Operator && The following rules apply to a conditional-and expression a && b (§15.23): •A pattern variable introduced by a when true is definitely matched at b. •A pattern variable is introduced by a && b when true iff either (i) it is introduced by a when true or (ii) it is introduced by b when true.",10.92,177.24,360,757,72,410.09,432,587.33,FALSE,FALSE
210,4,BODY,"If Q is a type name that names an interface type, then: •If there is not exactly one accessible member of the interface type that is a field named Id, then a compile-time error occurs. •Otherwise, Q.Id denotes the value of the field. The type of the expression Q.Id is the declared type of the field after capture conversion (§5.1.10). If Q.Id appears in a context that requires a variable and not a value, then a compile-time error occurs. If Q is an expression name, let T be the type of the expression Q: •If T is not a reference type, a compile-time error occurs. •If there is not exactly one accessible member of the type T that is a field named Id, then a compile-time error occurs. •Otherwise, if this field is any of the following: –A field of an interface type –A final field of a class type (which may be either a class variable or an instance variable) –The final field length of an array type (§10.7) then Q.Id denotes the value of the field, unless it appears in a context that requires a variable and the field is a definitely unassigned blank final field, in which case it yields a variable. The type of the expression Q.Id is the declared type of the field after capture conversion (§5.1.10). If Q.Id appears in a context that requires a variable and not a value, and the field denoted by Q.Id is definitely assigned, then a compile-time error occurs.",10.92,389.14,360.01,1367,72,159.06,432.01,548.2,FALSE,FALSE
232,5,BODY,PackageDeclaration: {PackageModifier} package Identifier {. Identifier} ; PackageModifier: Annotation,10.92,56.05,248.21,101,90,211.13,338.21,267.18,FALSE,TRUE
307,4,BODY,"Throws: throws ExceptionTypeList ExceptionTypeList: ExceptionType {, ExceptionType} ExceptionType: ClassType TypeVariable",10.92,106.05,160.45,121,90,400.13,250.45,506.18,FALSE,TRUE
348,2,BODY,"class: a private field declared implicitly, and a public accessor method declared explicitly or implicitly (§8.10.3). If a record class has no record components, then an empty pair of parentheses appears in the header of the record declaration.",10.92,51.14,360,244,72,76.06,432,127.2,FALSE,FALSE
447,3,BODY,"12.2.2Class Loader Consistency Well-behaved class loaders maintain these properties: •Given the same name, a class loader should always return the same Class object. •If a class loader L1 delegates loading of a class or interface C to another loader L2, then for any class or interface D that is named by the direct superclass type of C, or by a direct superinterface type of C, or by the type of a field in C, or by the type of a formal parameter of a method or constructor in C, or by the return type of a method in C, L1 and L2 should return the same Class object for D. A malicious class loader could violate these properties. However, it could not undermine the security of the type system, because the Java Virtual Machine guards against this.",10.92,162.11,360,749,72,438.09,432,600.2,FALSE,FALSE
454,2,BODY,"might invoke a method of an unrelated class B, which might in turn invoke a method of class A. The implementation of the Java Virtual Machine is responsible for taking care of synchronization and recursive initialization by using the following procedure. The procedure assumes that the Class object has already been verified and prepared, and that the Class object contains state that indicates one of four situations: •This Class object is verified and prepared but not initialized. •This Class object is being initialized by some particular thread T. •This Class object is fully initialized and ready for use. •This Class object is in an erroneous state, perhaps because initialization was attempted and failed. For each class or interface C, there is a unique initialization lock LC. The mapping from C to LC is left to the discretion of the Java Virtual Machine implementation. The procedure for initializing C is then as follows: 1.Synchronize on the initialization lock, LC, for C. This involves waiting until the",10.92,243.14,360.01,1019,72,76.06,432.01,319.2,FALSE,FALSE
455,6,BODY,"10.If the execution of the initializers completes normally, then acquire LC, label the Class object for C as fully initialized, notify all waiting threads, release LC, and complete this procedure normally.",10.92,32.14,360,205,72,314.06,432,346.2,FALSE,FALSE
487,2,BODY,"The best way to avoid problems with 'inconstant constants' in widely-distributed code is to use static constant variables only for values which truly are unlikely ever to change. Other than for true mathematical constants, we recommend that source code make very sparing use of static constant variables.",10.92,45.14,360,304,72,76.06,432,121.2,FALSE,FALSE
508,3,BODY,"The problem is that both the outer if statement and the inner if statement might conceivably own the else clause. In this example, one might surmise that the programmer intended the else clause to belong to the outer if statement. The Java programming language, like C and C++ and many programming languages before them, arbitrarily decrees that an else clause belongs to the innermost if to which it might possibly belong. This rule is captured by the following grammar:",10.92,90.14,360,471,72,126.06,432,216.2,FALSE,FALSE
526,2,BODY,"•The type T names a record class R, and P contains a record pattern p with a type that names R and for every record component of R of type U, if any, the singleton set containing the corresponding component pattern of p covers U.",10.92,32.14,360,229,72,76.06,432,108.2,FALSE,FALSE
537,5,BODY,"14.13.1Abrupt Completion of do Statement Abrupt completion of the contained Statement is handled in the following manner: •If execution of the Statement completes abruptly because of a break with no label, then no further action is taken and the do statement completes normally. •If execution of the Statement completes abruptly because of a continue with no label, then the Expression is evaluated. Then there is a choice based on the resulting value: –If the value is true, then the entire do statement is executed again. –If the value is false, no further action is taken and the do statement completes normally.",10.92,155.11,360.01,615,72,290.09,432.01,445.2,FALSE,FALSE
541,6,BODY,"2.Second, another for iteration step is performed. •If execution of the Statement completes abruptly because of a continue with label L, then there is a choice: –If the for statement has label L, then the following two steps are performed in sequence: 1.First, if the ForUpdate part is present, the expressions are evaluated in",10.92,89.14,360,327,72,347.2,432,436.33,FALSE,FALSE
563,4,BODY,"Resources are final, in that: •A local variable declared in a resource specification is implicitly declared final if it is not explicitly declared final (§4.12.4). •An existing variable referred to in a resource specification must be a final or effectively final variable that is definitely assigned before the try-with- resources statement (§16 (Definite Assignment)), or a compile-time error occurs. Resources are initialized in left-to-right order. If a resource fails to initialize (that is, its initializer expression throws an exception), then all resources initialized so far by the try-with-resources statement are closed. If all resources initialize successfully, the try block executes as normal and then all non-null resources of the try-with- resources statement are closed. Resources are closed in the reverse order from that in which they were initialized. A resource is closed only if it initialized to a non-null value. An exception from the closing of one resource does not prevent the closing of other resources. Such an exception is suppressed if an exception was thrown previously by an initializer, the try block, or the closing of a resource. A try-with-resources statement whose resource specification indicates multiple resources is treated as if it were multiple try-with-resources statements, each of which has a resource specification that indicates a single resource. When a try- with-resources statement with n resources (n > 1) is translated, the result is a try-",10.92,283.14,360.01,1493,72,315.06,432.01,598.2,FALSE,FALSE
581,4,BODY,"A pattern p is said to dominate another pattern q if every value that matches q also matches p, and is defined as follows: •A pattern p dominates a type pattern that declares a pattern variable of type T if p is unconditional for T. •A pattern p dominates a record pattern with type R if p is unconditional for R. •A record pattern with type R and component pattern list L dominates another record pattern with type S and component pattern list M if (i) R and S name the same record class, and (ii) every component pattern, if any, in L dominates the corresponding component pattern in M. •A pattern p dominates a match-all pattern with type T if p is unconditional for T.",10.92,147.14,360,672,72,165.06,432,312.2,FALSE,FALSE
615,8,BODY,"15.9.5Anonymous Class Declarations An anonymous class is implicitly declared by a class instance creation expression or by an enum constant that ends with a class body (§8.9.1). An anonymous class is never abstract (§8.1.1.1). An anonymous class is never sealed (§8.1.1.2), and thus has no permitted direct subclasses (§8.1.6).",10.92,91.11,360,327,72,492.09,432,583.2,FALSE,FALSE
622,8,BODY,ArrayAccess: ExpressionName [ Expression ] PrimaryNoNewArray [ Expression ] ArrayCreationExpressionWithInitializer [ Expression ],10.92,45.05,255.77,129,90,429.13,345.77,474.18,FALSE,TRUE
652,3,BODY,"•If the form is TypeName . [TypeArguments] Identifier, then the compile-time declaration must be static, or a compile-time error occurs. •If the form is ExpressionName . [TypeArguments] Identifier or Primary . [TypeArguments] Identifier, then the compile-time declaration must not be a static method declared in an interface, or a compile-time error occurs. •If the form is super . [TypeArguments] Identifier, then: –It is a compile-time error if the compile-time declaration is abstract. –It is a compile-time error if the method invocation occurs in a static context. •If the form is TypeName . super . [TypeArguments] Identifier, then: –It is a compile-time error if the compile-time declaration is abstract. –It is a compile-time error if the method invocation occurs in a static context. –If TypeName denotes a class C, then if the class or interface declaration immediately enclosing the method invocation is not C or an inner class of C, a compile-time error occurs. –If TypeName denotes an interface, let E be the class or interface declaration immediately enclosing the method invocation. A compile-time error occurs if there exists a method, distinct from the compile-time declaration, that",10.92,268.14,360,1200,72,288.06,432,556.2,FALSE,FALSE
655,3,BODY,"•If the form is TypeName . [TypeArguments] Identifier, then there is no target reference. •If form is ExpressionName . [TypeArguments] Identifier, then: –If the invocation mode is static, then there is no target reference. The ExpressionName is evaluated, but the result is then discarded. –Otherwise, the target reference is the value denoted by ExpressionName. •If the form is Primary . [TypeArguments] Identifier involved, then: –If the invocation mode is static, then there is no target reference. The Primary expression is evaluated, but the result is then discarded. –Otherwise, the Primary expression is evaluated and the result is used as the target reference. In either case, if the evaluation of the Primary expression completes abruptly, then no part of any argument expression appears to have been evaluated, and the method invocation completes abruptly for the same reason. •If the form is super . [TypeArguments] Identifier, then the target reference is the value of this. •If the form is TypeName . super . [TypeArguments] Identifier, then if TypeName denotes a class, the target reference is the value of TypeName.this; otherwise, the target reference is the value of this.",10.92,294.14,360.01,1189,72,204.06,432.01,498.2,FALSE,FALSE
665,3,BODY,"If TypeArguments is present to the right of ::, then it is a compile-time error if any of the type arguments are wildcards (§4.5.1). If a method reference expression has the form ExpressionName :: [TypeArguments] Identifier or Primary :: [TypeArguments] Identifier, it is a compile-time error if the type of the ExpressionName or Primary is not a reference type. If a method reference expression has the form super :: [TypeArguments] Identifier, let E be the class or interface declaration immediately enclosing the method reference expression. It is a compile-time error if E is the class Object or if E is an interface. If a method reference expression has the form TypeName . super :: [TypeArguments] Identifier, then: •If TypeName denotes a class, C, then it is a compile-time error if C is not a lexically enclosing class of the current class, or if C is the class Object. •If TypeName denotes an interface, I, then let E be the class or interface declaration immediately enclosing the method reference expression. It is a compile-time error if I is not a direct superinterface of E, or if there exists some other direct superclass or direct superinterface of E, J, such that J is a subclass or subinterface of I. •If TypeName denotes a type variable, then a compile-time error occurs. If a method reference expression has the form super :: [TypeArguments] Identifier or TypeName . super :: [TypeArguments] Identifier, it is a compile-time error if the expression occurs in a static context (§8.1.3). If a method reference expression has the form ClassType :: [TypeArguments] new, then: •ClassType must name a class that is accessible (§6.6), non-abstract, and not an enum class, or a compile-time error occurs.",10.92,398.14,360.01,1716,72,191.06,432.01,589.2,FALSE,FALSE
677,4,BODY,"•If the form is super :: [TypeArguments] Identifier or TypeName . super :: [TypeArguments] Identifier, the body of the invocation method has the effect of a method invocation expression for a compile-time declaration which is the compile-time declaration of the method reference expression. Run-time evaluation of the method invocation expression is as specified in §15.12.4.3, §15.12.4.4, and §15.12.4.5, where: –The invocation mode is super. –If the method reference expression begins with a TypeName that names a class, the target reference is the value of TypeName . this at the point at which the method reference is evaluated. Otherwise, the target reference is the value of this at the point at which the method reference is evaluated. –The arguments to the method invocation expression are the formal parameters of the invocation method.",10.92,180.14,360.01,845,72,423.06,432.01,603.2,FALSE,FALSE
678,4,BODY,"•If the form is Type[] :: new (k ≥ 1), then the body of the invocation method has the same effect as an array creation expression of the form new Type [ size ] [], where size is the invocation method's single parameter. (The notation [] indicates a sequence of k bracket pairs.) If the body of the invocation method has the effect of a method invocation expression, then the compile-time parameter types and the compile-time result of the method invocation are determined as specified in §15.12.3. For the purpose of determining the compile-time result, the method invocation expression is an expression statement if the invocation method's result is void, and the Expression of a return statement if the invocation method's result is non-void.",10.92,129.14,360,744,72,198.06,432,327.2,FALSE,FALSE
679,5,BODY,15.14.2Postfix Increment Operator ++ A postfix expression followed by a ++ operator is a postfix increment expression.,10.92,27.11,357.55,118,72,250.09,429.55,277.2,FALSE,FALSE
679,9,BODY,"A variable that is declared final cannot be incremented because when an access of such a final variable is used as an expression, the result is a value, not a variable. Thus, it cannot be used as the operand of a postfix increment operator.",10.92,32.14,360.01,240,72,557.06,432.01,589.2,FALSE,FALSE
680,2,BODY,15.14.3Postfix Decrement Operator -- A postfix expression followed by a -- operator is a postfix decrement expression.,10.92,27.11,359.38,118,72,76.09,431.38,103.2,FALSE,FALSE
680,6,BODY,"A variable that is declared final cannot be decremented because when an access of such a final variable is used as an expression, the result is a value, not a variable. Thus, it cannot be used as the operand of a postfix decrement operator.",10.92,32.14,360.01,240,72,383.06,432.01,415.2,FALSE,FALSE
682,5,BODY,"A variable that is declared final cannot be incremented because when an access of such a final variable is used as an expression, the result is a value, not a variable. Thus, it cannot be used as the operand of a prefix increment operator.",10.92,32.14,360.01,239,72,430.06,432.01,462.2,FALSE,FALSE
683,4,BODY,"A variable that is declared final cannot be decremented because when an access of such a final variable is used as an expression, the result is a value, not a variable. Thus, it cannot be used as the operand of a prefix decrement operator.",10.92,32.14,360.01,239,72,237.06,432.01,269.2,FALSE,FALSE
690,3,BODY,"The result of a floating-point remainder operation as computed by the % operator is not the same as that computed by the remainder operation in IEEE 754, due to the choice of rounding policy in the Java programming language (§15.4). The IEEE 754 remainder operation computes the remainder from a rounding division, not a truncating division, and so its behavior is not analogous to that of the usual integer remainder operator. Instead, the Java programming language defines % on floating-point operands to behave in a manner analogous to that of the integer remainder operator, with an implied division using the round toward zero rounding policy; this may be compared with the C library function fmod. The IEEE 754 remainder operation may be computed by the library routine Math.IEEEremainder or StrictMath.IEEEremainder. The result of a floating-point remainder operation is determined by the following rules, which match IEEE 754 arithmetic except for how the implied division is computed: •If either operand is NaN, the result is NaN. •If the result is not NaN, the sign of the result equals the sign of the dividend. •If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN. •If the dividend is finite and the divisor is an infinity, the result equals the dividend. •If the dividend is a zero and the divisor is finite, the result equals the dividend. •In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved, the floating-point remainder r from the division of a dividend n by a divisor d is defined by the mathematical relation r = n - (d ⋅ q) where q is an integer that is negative only if n/d is negative and positive only if n/d is positive, and whose magnitude is as large as possible without exceeding the magnitude of the true mathematical quotient of n and d. Evaluation of a floating-point remainder operator % never throws a run-time exception, even if the right-hand operand is zero. Overflow, underflow, or loss of precision cannot occur.",10.92,418.14,360.01,2013,72,125.06,432.01,543.2,FALSE,FALSE
725,2,BODY,"the type of the left-hand operand of the assignment operator as determined at compile time. –If T is a primitive type, then S is necessarily the same as T. The saved value of the array component and the value of the right-hand operand are used to perform the binary operation indicated by the compound assignment operator. If this operation completes abruptly (the only possibility is an integer division by zero - see §15.17.2), then the assignment expression completes abruptly for the same reason and no assignment occurs. Otherwise, the result of the binary operation is converted to the type of the selected array component, and the result of the conversion is stored into the array component. –If T is a reference type, then it must be String. Because class String is a final class, S must also be String.",10.92,205.14,350.01,811,82,76.06,432.01,281.2,FALSE,FALSE
744,3,BODY,"•If a switch label applies, then one of the following holds: –If it is the switch label for a switch rule expression, then the expression is evaluated. If the result of evaluation is a value, then the switch expression completes normally with the same value. –If it is the switch label for a switch rule block, then the block is executed. If this block completes normally, then the switch expression completes normally. –If it is the switch label for a switch rule throw statement, then the throw statement is executed. –Otherwise, all the statements in the switch block after the switch label that applies are executed in order. If these statements complete normally, then the switch expression completes normally.",10.92,160.14,360.02,715,72,204.06,432.02,364.2,FALSE,FALSE
753,4,BODY,16.1.1Boolean Constant Expressions •V is [un]assigned after any constant expression (§15.29) whose value is true when false. •V is [un]assigned after any constant expression whose value is false when true. •V is [un]assigned after any constant expression whose value is true when true iff V is [un]assigned before the constant expression. •V is [un]assigned after any constant expression whose value is false when false iff V is [un]assigned before the constant expression. •V is [un]assigned after a boolean-valued constant expression e iff V is [un]assigned after e when true and V is [un]assigned after e when false.,10.92,155.11,360,619,72,264.09,432,419.2,FALSE,FALSE
849,1,BODY,UnannType: UnannPrimitiveType UnannReferenceType UnannPrimitiveType: NumericType boolean UnannReferenceType: UnannClassOrInterfaceType UnannTypeVariable UnannArrayType UnannClassOrInterfaceType: UnannClassType UnannInterfaceType UnannClassType: TypeIdentifier [TypeArguments] PackageName . {Annotation} TypeIdentifier [TypeArguments] UnannClassOrInterfaceType . {Annotation} TypeIdentifier [TypeArguments] UnannInterfaceType: UnannClassType UnannTypeVariable: TypeIdentifier UnannArrayType: UnannPrimitiveType Dims UnannClassOrInterfaceType Dims UnannTypeVariable Dims,10.92,408.05,287.56,568,90,76.13,377.56,484.18,FALSE,TRUE
858,1,BODY,StatementWithoutTrailingSubstatement: Block EmptyStatement ExpressionStatement AssertStatement SwitchStatement DoStatement BreakStatement ContinueStatement ReturnStatement SynchronizedStatement ThrowStatement TryStatement YieldStatement EmptyStatement: ; LabeledStatement: Identifier : Statement LabeledStatementNoShortIf: Identifier : StatementNoShortIf ExpressionStatement: StatementExpression ; StatementExpression: Assignment PreIncrementExpression PreDecrementExpression PostIncrementExpression PostDecrementExpression MethodInvocation ClassInstanceCreationExpression,10.92,438.05,176.62,572,90,76.13,266.62,514.18,FALSE,TRUE
860,1,BODY,"WhileStatement: while ( Expression ) Statement WhileStatementNoShortIf: while ( Expression ) StatementNoShortIf DoStatement: do Statement while ( Expression ) ; ForStatement: BasicForStatement EnhancedForStatement ForStatementNoShortIf: BasicForStatementNoShortIf EnhancedForStatementNoShortIf BasicForStatement: for ( [ForInit] ; [Expression] ; [ForUpdate] ) Statement BasicForStatementNoShortIf: for ( [ForInit] ; [Expression] ; [ForUpdate] ) StatementNoShortIf ForInit: StatementExpressionList LocalVariableDeclaration ForUpdate: StatementExpressionList StatementExpressionList: StatementExpression {, StatementExpression} EnhancedForStatement: for ( LocalVariableDeclaration : Expression ) Statement",10.92,441.05,311.8,703,90,76.13,401.8,517.18,FALSE,TRUE
867,1,BODY,AssignmentExpression: ConditionalExpression Assignment Assignment: LeftHandSide AssignmentOperator Expression LeftHandSide: ExpressionName FieldAccess ArrayAccess AssignmentOperator: (one of) =  *=  /=  %=  +=  -=  <<=  >>=  >>>=  &=  ^=  |= ConditionalExpression: ConditionalOrExpression ConditionalOrExpression ? Expression : ConditionalExpression ConditionalOrExpression ? Expression : LambdaExpression ConditionalOrExpression: ConditionalAndExpression ConditionalOrExpression || ConditionalAndExpression ConditionalAndExpression: InclusiveOrExpression ConditionalAndExpression && InclusiveOrExpression InclusiveOrExpression: ExclusiveOrExpression InclusiveOrExpression | ExclusiveOrExpression ExclusiveOrExpression: AndExpression ExclusiveOrExpression ^ AndExpression AndExpression: EqualityExpression AndExpression & EqualityExpression,10.92,495.05,295.81,840,90,76.13,385.81,571.18,FALSE,TRUE
86,5,BODY,"The scope of a type variable declared as a type parameter is specified in §6.3. Every type variable declared as a type parameter has a bound. If no bound is declared for a type variable, Object is assumed. If a bound is declared, it consists of either: •a single type variable T, or •a class or interface type T possibly followed by interface types I1 & ... & In. It is a compile-time error if any of the types I1, ..., In is a class type or type variable.",10.91,108.14,360,456,72,488.06,432,596.2,FALSE,FALSE
88,3,BODY,"4.5Parameterized Types A class or interface that is generic (§8.1.2, §9.1.2) defines a set of parameterized types. A parameterized type is a class or interface type of the form C<T1,...,Tn>, where C is the name of a generic class or interface, and <T1,...,Tn> is a list of type arguments that denote a particular parameterization of the generic class or interface. A generic class or interface has type parameters F1,...,Fn with corresponding bounds B1,...,Bn. Each type argument Ti of a parameterized type ranges over all types that are subtypes of all types listed in the corresponding bound. That is, for each bound type S in Bi, Ti is a subtype of S[F1:=T1,...,Fn:=Tn] (§4.10). A parameterized type C<T1,...,Tn> is well-formed if all of the following are true: •C is the name of a generic class or interface. •The number of type arguments is the same as the number of type parameters in the generic declaration of C. •When subjected to capture conversion (§5.1.10) resulting in the type C<X1,...,Xn>, each type argument Xi is a subtype of S[F1:=X1,...,Fn:=Xn] for each bound type S in Bi. It is a compile-time error if a parameterized type is not well-formed. In this specification, whenever we speak of a class or interface type, we include parameterized types as well, unless explicitly excluded. Two parameterized types are provably distinct if either of the following is true: •They are parameterizations of distinct generic type declarations. •Any of their type arguments are provably distinct.",10.91,375.64,360.01,1503,72,135.56,432.01,511.2,FALSE,FALSE
131,7,BODY,"•Otherwise, one of the following two cases must be true: a.The value must be too small (a negative value of large magnitude or negative infinity), and the result of the first step is the smallest representable value of type int or long.",10.91,51.14,342,236,90,352.06,432,403.2,FALSE,FALSE
138,2,BODY,"•An unchecked narrowing reference conversion from S to a non-intersection type T is completely unchecked if |S| <: |T|. Otherwise, it is partially unchecked. •An unchecked narrowing reference conversion from S to an intersection type T1 & ... & Tn is completely unchecked if, for all i (1 ≤ i ≤ n), either S <: Ti or a narrowing reference conversion from S to Ti is completely unchecked. Otherwise, it is partially unchecked. The run time validity check for a checked or partially unchecked narrowing reference conversion is as follows: •If the value at run time is null, then the conversion is allowed.",10.91,153.14,360,603,72,76.06,432,229.2,FALSE,FALSE
210,2,BODY,"•Otherwise, Q.Id denotes the class variable. The type of the expression Q.Id is the declared type of the class variable after capture conversion (§5.1.10).",10.91,38.14,360,155,72,76.06,432,114.2,FALSE,FALSE
231,3,BODY,"When compiling the modular and ordinary compilation units associated with a module M, the host system must respect the dependences specified in M's declaration. Specifically, the host system must limit the ordinary compilation units that would otherwise be observable, to only those that are visible to M. The ordinary compilation units that are visible to M are the observable ordinary compilation units associated with the modules that are read by M. The modules read by M are given by the result of resolution, as described in the java.lang.module package specification, with M as the only root module. The host system must perform resolution to determine the modules read by M; it is a compile-time error if resolution fails for any of the reasons described in the java.lang.module package specification.",10.91,136.14,360,808,72,259.06,432,395.2,FALSE,FALSE
232,3,BODY,A package declaration appears within an ordinary compilation unit to indicate the package to which the compilation unit belongs.,10.91,19.14,360,128,72,108.06,432,127.2,FALSE,FALSE
267,2,BODY,"The extends clause must not appear in the definition of the class Object, or a compile-time error occurs, because it is the primordial class and has no direct superclass type. The ClassType must name an accessible class (§6.6), or a compile-time error occurs. It is a compile-time error if the ClassType names a class that is sealed (§8.1.1.2) and the class being declared is not a permitted direct subclass of the named class (§8.1.6). It is a compile-time error if the ClassType names a class that is final, because final classes are not allowed to have subclasses (§8.1.1.2). It is a compile-time error if the ClassType names the class Enum, which can only be extended by an enum class (§8.9), or names the class Record, which can only be extended by a record class (§8.10). If the ClassType has type arguments, it must denote a well-formed parameterized type (§4.5), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. The direct superclass type of a class whose declaration lacks an extends clause is as follows: •The class Object has no direct superclass type. •For a class other than Object with a normal class declaration, the direct superclass type is Object. •For an enum class E, the direct superclass type is Enum<E>. •For a record class R, the direct superclass type is Record. •For an anonymous class, the direct superclass type is defined in §15.9.5. The direct superclass of a class is the class named by its direct superclass type. The direct superclass is important because its implementation is used to derive the implementation of the class being declared. The superclass relationship is the transitive closure of the direct superclass relationship. A class A is a superclass of class C if either of the following is true: •A is the direct superclass of C. •Where a class B is the direct superclass of C, A is a superclass of B, applying this definition recursively.",10.91,499.14,360.01,1929,72,76.06,432.01,575.2,FALSE,FALSE
269,6,BODY,8.1.5Superinterfaces The optional implements clause in a class declaration specifies the direct superinterface types of the class being declared.,10.91,40.11,360,145,72,218.59,432,258.7,FALSE,FALSE
281,6,BODY,"A hidden field can be accessed by using a qualified name (§6.5.6.2) if it is static, or by using a field access expression that contains the keyword super (§15.11.2) or a cast to a superclass type.",10.91,32.14,360,197,72,513.06,432,545.2,FALSE,FALSE
284,7,BODY,"8.3.1.1static Fields If a field is declared static, there exists exactly one incarnation of the field, no matter how many instances (possibly zero) of the class may eventually be created. A static field, sometimes called a class variable, is incarnated when the class is initialized (§12.4). A field that is not declared static is called an instance variable, and sometimes called a non-static field. Whenever a new instance of a class is created (§12.5), a new variable associated with that instance is created for every instance variable declared in that class or any of its superclasses. The declaration of a class variable introduces a static context (§8.1.3), which limits the use of constructs that refer to the current object. Notably, the keywords this and super are prohibited in a static context (§15.8.3, §15.11.2), as are unqualified references to instance variables, instance methods, and type parameters of lexically enclosing declarations (§6.5.5.1, §6.5.6.1, §15.12.3). References to an instance variable from a static context or a nested class or interface are restricted, as specified in §6.5.6.1.",10.91,226.2,360.01,1115,72,349.13,432.01,575.33,FALSE,FALSE
336,2,BODY,"•The default constructor has the same access modifier as the class, unless the class lacks an access modifier, in which case the default constructor has package access (§6.6). •The default constructor has no formal parameters, except in a non-private inner member class, where the default constructor implicitly declares one formal parameter representing the immediately enclosing instance of the class (§8.8.1, §15.9.2, §15.9.3). •The default constructor has no throws clause. •If the class being declared is the primordial class Object, then the default constructor has an empty body. Otherwise, the default constructor simply invokes the superclass constructor with no arguments. The form of the default constructor for an anonymous class is specified in §15.9.5.1. It is a compile-time error if a default constructor is implicitly declared but the superclass does not have an accessible constructor that takes no arguments and has no throws clause.",10.91,218.14,360.01,952,72,76.06,432.01,294.2,FALSE,FALSE
412,5,BODY,"The function type of a functional interface I is a method type (§8.2) that can be used to override (§8.4.8) the abstract method(s) of I. Let M be the set of abstract methods defined for I. The function type of I consists of the following: •Type parameters, formal parameter types, and return type: Let m be a method in M with: 1.a signature that is a subsignature of every method's signature in M; and 2.a return type R (possibly void), where either R is the same as every method's return type in M, or R is a reference type and is a subtype of every method's return type in M (after adapting for any type parameters (§8.4.4) if the two methods have the same signature).",10.91,166.14,360.01,670,72,323.06,432.01,489.2,FALSE,FALSE
431,4,BODY,"11.1.2The Causes of Exceptions An exception is thrown for one of four reasons: •A throw statement (§14.18) was executed. •An enabled assert statement was executed, and evaluation of its boolean expression evaluated to false (§14.10). •An abnormal execution condition was synchronously detected by the Java Virtual Machine, namely: –evaluation of an expression violates the normal semantics of the Java programming language (§15.6), such as an integer divide by zero. –an error occurs while loading, linking, or initializing part of the program (§12.2, §12.3, §12.4); in this case, an instance of a subclass of LinkageError is thrown. –an internal error or resource limitation prevents the Java Virtual Machine from implementing the semantics of the Java programming language; in this case, an instance of a subclass of VirtualMachineError is thrown. These exceptions are not thrown at an arbitrary point in the program, but rather at a point where they are specified as a possible result of an expression evaluation or statement execution. •An asynchronous exception occurred (§11.1.3).",10.91,296.11,360.01,1086,72,283.09,432.01,579.2,FALSE,FALSE
445,3,BODY,"12.1.3Initialize Test: Execute Initializers In our continuing example, the Java Virtual Machine is still trying to execute the method main of class Test. This is permitted only if the class has been initialized (§12.4.1). Initialization consists of execution of any class variable initializers and static initializers of the class Test, in textual order. But before Test can be initialized, its direct superclass must be initialized, as well as the direct superclass of its direct superclass, and so on, recursively. In the simplest case, Test has Object as its implicit direct superclass; if class Object has not yet been initialized, then it must",10.91,124.11,360.01,648,72,464.09,432.01,588.2,FALSE,FALSE
454,4,BODY,"2.If the Class object for C indicates that initialization is in progress for C by some other thread, then release LC and block the current thread until informed that the in-progress initialization has completed, at which time repeat this step. 3.If the Class object for C indicates that initialization is in progress for C by the current thread, then this must be a recursive request for initialization. Release LC and complete normally.",10.91,77.14,360,437,72,345.06,432,422.2,FALSE,FALSE
454,10,BODY,"progress by the current thread, and release LC. Then, initialize the static fields of C which are constant variables (§4.12.4, §8.3.2, §9.3.1).",10.91,38.14,342,143,90,512.06,432,550.2,FALSE,FALSE
516,7,BODY,SwitchBlock: { SwitchRule {SwitchRule} } { {SwitchBlockStatementGroup} {SwitchLabel :} },10.91,32.05,235.68,88,90,526.13,325.68,558.18,FALSE,TRUE
533,4,BODY,"•If execution of a statement or expression completes abruptly for any other reason, then the switch statement completes abruptly for the same reason.",10.91,19.14,360.01,149,72,358.06,432.01,377.2,FALSE,FALSE
535,5,BODY,"The Expression must have type boolean or Boolean, or a compile-time error occurs. A while statement is executed by first evaluating the Expression. If the result is of type Boolean, it is subjected to unboxing conversion (§5.1.8). If evaluation of the Expression or the subsequent unboxing conversion (if any) completes abruptly for some reason, the while statement completes abruptly for the same reason. Otherwise, execution continues by making a choice based on the resulting value: •If the value is true, then the contained Statement is executed. Then there is a choice: –If execution of the Statement completes normally, then the entire while statement is executed again, beginning by re-evaluating the Expression. –If execution of the Statement completes abruptly, see §14.12.1. •If the (possibly unboxed) value of the Expression is false, no further action is taken and the while statement completes normally.",10.91,230.14,360,916,72,307.06,432,537.2,FALSE,FALSE
538,2,BODY,"•If execution of the Statement completes abruptly because of a continue with label L, then there is a choice: –If the do statement has label L, then the Expression is evaluated. Then there is a choice: ›If the value of the Expression is true, then the entire do statement is executed again. ›If the value of the Expression is false, no further action is taken and the do statement completes normally.",10.91,115.14,360,400,72,76.06,432,191.2,FALSE,FALSE
539,3,BODY,"14.14.1The basic for Statement The basic for statement executes some initialization code, then executes an Expression, a Statement, and some update code repeatedly until the value of the Expression is false. BasicForStatement: for ( [ForInit] ; [Expression] ; [ForUpdate] ) Statement BasicForStatementNoShortIf: for ( [ForInit] ; [Expression] ; [ForUpdate] ) StatementNoShortIf ForInit: StatementExpressionList LocalVariableDeclaration ForUpdate: StatementExpressionList StatementExpressionList: StatementExpression {, StatementExpression}",10.91,251.09,360,539,72,184.09,432,435.18,FALSE,TRUE
539,4,BODY,"The type of the Expression must be boolean or Boolean, or a compile-time error occurs. The scope and shadowing of a local variable declared in the ForInit part of a basic for statement is specified in §6.3 and §6.4. References to a local variable declared in the ForInit part of a basic for statement from a nested class or interface, or a lambda expression, are restricted, as specified in §6.5.6.1. 14.14.1.1Initialization of for Statement A for statement is executed by first executing the ForInit code:",10.91,143.27,360,506,72,453.06,432,596.33,FALSE,FALSE
542,3,BODY,EnhancedForStatement: for ( LocalVariableDeclaration : Expression ) Statement,10.91,32.05,221.76,77,90,121.13,311.76,153.18,FALSE,TRUE
542,4,BODY,EnhancedForStatementNoShortIf: for ( LocalVariableDeclaration : Expression ) StatementNoShortIf,10.91,32.05,221.76,95,90,171.13,311.76,203.18,FALSE,TRUE
543,2,BODY,"The rules for a local variable declared in the header of an enhanced for statement are specified in §14.4, disregarding any rules in that section which apply when the LocalVariableType is var. In addition, all of the following must be true, or a compile-time error occurs: •The VariableDeclaratorList consists of a single VariableDeclarator. •The VariableDeclarator has no initializer. •The VariableDeclaratorId has no bracket pairs if the LocalVariableType is var. The scope and shadowing of a local variable declared in the header of an enhanced for statement is specified in §6.3 and §6.4. References to the local variable from a nested class or interface, or a lambda expression, are restricted, as specified in §6.5.6.1. The type T of the local variable declared in the header of the enhanced for statement is determined as follows: •If the LocalVariableType is UnannType, and no bracket pairs appear in UnannType or VariableDeclaratorId, then T is the type denoted by UnannType. •If the LocalVariableType is UnannType, and bracket pairs appear in UnannType or VariableDeclaratorId, then T is specified by §10.2. •If the LocalVariableType is var, then let R be derived from the type of the Expression, as follows: –If the Expression has an array type, then R is the component type of the array type. –Otherwise, if the Expression has a type that is a subtype of Iterable<X>, for some type X, then R is X. –Otherwise, the Expression has a type that is a subtype of the raw type Iterable, and R is Object. T is the upward projection of R with respect to all synthetic type variables mentioned by R (§4.10.5). The precise meaning of the enhanced for statement is given by translation into a basic for statement, as follows:",10.91,454.14,360.01,1725,72,76.06,432.01,530.2,FALSE,FALSE
557,3,BODY,"The exception types that a try statement can throw are specified in §11.2.2. The relationship of the exceptions thrown by the try block of a try statement and caught by the catch clauses (if any) of the try statement is specified in §11.2.3. Exception handlers are considered in left-to-right order: the earliest possible catch clause accepts the exception, receiving as its argument the thrown exception object, as specified in §11.3.",10.91,83.14,360.01,435,72,178.06,432.01,261.2,FALSE,FALSE
558,5,BODY,"•If execution of the try block completes abruptly for any other reason, then the try statement completes abruptly for the same reason.",10.91,19.14,359.99,134,72,489.06,431.99,508.2,FALSE,FALSE
607,3,BODY,"15.9.2Determining Enclosing Instances Let C be the class being instantiated, and let i be the instance being created. If C is an inner class, then i may have an immediately enclosing instance (§8.1.3), determined as follows: •If C is an anonymous class, then: –If the class instance creation expression occurs in a static context, then i has no immediately enclosing instance. –Otherwise, the immediately enclosing instance of i is this. •If C is an inner local class, then: –If C occurs in a static context, then i has no immediately enclosing instance. –Otherwise, if the class instance creation expression occurs in a static context, then a compile-time error occurs. –Otherwise, let O be the immediately enclosing class or interface declaration of C, and let U be the immediately enclosing class or interface declaration of the class instance creation expression. If U is not an inner class of O or O itself, then a compile-time error occurs. Let n be an integer such that O is the n'th lexically enclosing class or interface declaration of U. The immediately enclosing instance of i is the n'th lexically enclosing instance of this.",10.91,321.11,360.01,1137,72,224.09,432.01,545.2,FALSE,FALSE
616,2,BODY,An anonymous class declared by a class instance creation expression is never final (§8.1.1.2). An anonymous class declared by an enum constant is always final.,10.91,38.14,360,159,72,76.06,432,114.2,FALSE,FALSE
633,2,BODY,"•If the form is TypeName . super . [TypeArguments] Identifier, then: –It is a compile-time error if TypeName denotes neither a class nor an interface. –If TypeName denote a class, C, then the type to search is the direct superclass type of C. It is a compile-time error if C is not a lexically enclosing class declaration of the method invocation, or if C is the class Object. Let E be the class or interface declaration immediately enclosing the method invocation. It is a compile-time error if E is the class Object. –Otherwise, TypeName denotes an interface, I. Let E be the class or interface declaration immediately enclosing the method invocation. It is a compile-time error if I is not a direct superinterface of E, or if there exists some other direct superclass or direct superinterface of E, J, such that J is a subclass or subinterface of I. The type to search is the type of I that is a direct superinterface type of E.",10.91,217.14,360,931,72,76.06,432,293.2,FALSE,FALSE
651,4,BODY,"•If the chosen method is not generic, then: –If unchecked conversion was necessary for the method to be applicable, the parameter types of the invocation type are the parameter types of the method's type, and the return type and thrown types are given by the erasures of the return type and thrown types of the method's type. –Otherwise, if the chosen method is the getClass method of the class Object (§4.3.2), the invocation type is the same as the method's type, except that the return type is Class<? extends |T|>, where T is the type that was searched, as determined by §15.12.1, and |T| denotes the erasure of T (§4.6). –Otherwise, the invocation type is the same as the method's type.",10.91,141.14,360.01,691,72,263.06,432.01,404.2,FALSE,FALSE
653,5,BODY,"•If the compile-time declaration for the method invocation is a signature polymorphic method, then: –The compile-time parameter types are the types of the actual argument expressions. An argument expression which is the null literal null (§3.10.8) is treated as having the type Void. –The compile-time result is determined as follows: ›If the signature polymorphic method is either void or has a return type other than Object, the compile-time result is the result of the invocation type of the compile-time declaration (§15.12.2.6). ›Otherwise, if the method invocation expression is an expression statement, the compile-time result is void. ›Otherwise, if the method invocation expression is the operand of a cast expression (§15.16), the compile-time result is the erasure of the type of the cast expression (§4.6). ›Otherwise, the compile-time result is the signature polymorphic method's return type, Object.",10.91,237.14,360.01,913,72,318.06,432.01,555.2,FALSE,FALSE
671,3,BODY,"It is a compile-time error if a method reference expression has the form ReferenceType :: [TypeArguments] Identifier, and the compile-time declaration is static, and ReferenceType is not a simple or qualified name (§6.2). It is a compile-time error if the method reference expression has the form super :: [TypeArguments] Identifier or TypeName . super :: [TypeArguments] Identifier, and the compile-time declaration is abstract. It is a compile-time error if the method reference expression has the form super :: [TypeArguments] Identifier or TypeName . super :: [TypeArguments] Identifier, and the method reference expression occurs in a static context (§8.1.3). It is a compile-time error if the method reference expression has the form TypeName . super :: [TypeArguments] Identifier, and TypeName denotes a class C, and the immediately enclosing class or interface declaration of the method reference expression is not C or an inner class of C. It is a compile-time error if the method reference expression has the form TypeName . super :: [TypeArguments] Identifier, and TypeName denotes an interface, and there exists a method, distinct from the compile-time declaration, that overrides the compile-time declaration from a direct superclass or direct superinterface of the class or interface whose declaration immediately encloses the method reference expression (§8.4.8, §9.4.1). It is a compile-time error if the method reference expression is of the form ClassType :: [TypeArguments] new and a compile-time error would occur when determining an enclosing instance for ClassType as specified in §15.9.2 (treating",10.91,309.14,360.01,1620,72,294.06,432.01,603.2,FALSE,FALSE
676,2,BODY,"NullPointerException is raised, and the method reference expression completes abruptly. If the subexpression completes abruptly, the method reference expression completes abruptly for the same reason. Next, either a new instance of a class with the properties below is allocated and initialized, or an existing instance of a class with the properties below is referenced. If a new instance is to be created, but there is insufficient space to allocate the object, evaluation of the method reference expression completes abruptly by throwing an OutOfMemoryError. The value of a method reference expression is a reference to an instance of a class with the following properties: •The class implements the targeted functional interface type and, if the target type is an intersection type, every other interface type mentioned in the intersection. •Where the method reference expression has type U, for each non-static member method m of U: If the function type of U has a subsignature of the signature of m, then the class declares an invocation method that overrides m. The invocation method's body invokes the referenced method, creates a class instance, or creates an array, as described below. If the invocation method's result is not void, then the body returns the result of the method invocation or object creation, after any necessary assignment conversions (§5.2). If the erasure of the type of a method being overridden differs in its signature from the erasure of the function type of U, then before the method invocation or object creation, an invocation method's body checks that each argument value is an instance of a subclass or subinterface of the erasure of the corresponding parameter type in the function type of U; if not, a ClassCastException is thrown. •The class overrides no other methods of the functional interface type or other interface types mentioned above, although it may override methods of the Object class. The body of an invocation method depends on the form of the method reference expression, as follows: •If the form is ExpressionName :: [TypeArguments] Identifier or Primary :: [TypeArguments] Identifier, then the body of the invocation method has the effect of a method invocation expression for a compile-time declaration which is the compile-time declaration of the method reference expression. Run-time",10.91,489.14,360.01,2346,72,76.06,432.01,565.2,FALSE,FALSE
686,5,BODY,"The operators *, /, and % are called the multiplicative operators.",10.91,6.14,282.29,66,72,320.06,354.29,326.2,FALSE,FALSE
759,3,BODY,"16.1.10Other Expressions If an expression is not a boolean constant expression, and is not a preincrement expression ++a, predecrement expression --a, postincrement expression a++, postdecrement expression a--, logical complement expression !a, conditional-and expression a && b, conditional-or expression a || b, conditional expression a ? b : c, assignment expression, or lambda expression, then the following rules apply: •If the expression has no subexpressions, V is [un]assigned after the expression iff V is [un]assigned before the expression.",10.91,111.11,360,550,72,140.09,432,251.2,FALSE,FALSE
766,3,BODY,"•V is [un]assigned before the initialization part of the for statement iff V is [un]assigned before the for statement. •V is definitely assigned before the condition part of the for statement iff V is definitely assigned after the initialization part of the for statement. •V is definitely unassigned before the condition part of the for statement iff both of the following are true: –V is definitely unassigned after the initialization part of the for statement. –Assuming V is definitely unassigned before the condition part of the for statement, V is definitely unassigned after the incrementation part of the for statement.",10.91,147.14,360,627,72,159.06,432,306.2,FALSE,FALSE
766,5,BODY,"•V is [un]assigned before the incrementation part of the for statement iff V is [un]assigned after the contained statement and V is [un]assigned before every continue statement for which the for statement is the continue target. 16.2.12.1Initialization Part of for Statement •If the initialization part of the for statement is a local variable declaration statement, the rules of §16.2.4 apply. •Otherwise, if the initialization part is empty, then V is [un]assigned after the initialization part iff V is [un]assigned before the initialization part.",10.91,124.27,360,550,72,402.06,432,526.33,FALSE,FALSE
771,4,BODY,"Let C be a class, and let V be a blank final field of C. Then: •V is definitely assigned (and moreover, not definitely unassigned) before the declaration of any member class or interface (§8.5, §9.5) of C. Let C be a class declared within the scope of V. Then: •V is definitely assigned before the declaration of a member class or interface of C iff V is definitely assigned before the declaration of C.",10.91,89.14,360,403,72,239.06,432,328.2,FALSE,FALSE
772,1,BODY,"Let C be a class, and let V be a blank static final member field of C, declared in a superclass of C. Then: •V is definitely assigned (and moreover is not definitely unassigned) before every enum constant of C. •V is definitely assigned (and moreover is not definitely unassigned) before the block that is the body of a static initializer of C. •V is definitely assigned (and moreover is not definitely unassigned) before every static variable initializer of C.",10.91,115.14,360.01,461,72,76.06,432.01,191.2,FALSE,FALSE
773,1,BODY,"•If C has at least one instance initializer or instance variable initializer then V is [un]assigned after an explicit or implicit superclass constructor invocation iff V is [un]assigned after the rightmost instance initializer or instance variable initializer of C. Let C be a class, and let V be a blank final member field of C, declared in a superclass of C. Then: •V is definitely assigned (and moreover is not definitely unassigned) before the block that is the body of a constructor or instance initializer of C. •V is definitely assigned (and moreover is not definitely unassigned) before every instance variable initializer of C.",10.91,141.14,360.01,636,72,76.06,432.01,217.2,FALSE,FALSE
779,2,BODY,"17.2.2Notification Notification actions occur upon invocation of methods notify and notifyAll. Let thread t be the thread executing either of these methods on object m, and let n be the number of lock actions by t on m that have not been matched by unlock actions. One of the following actions occurs: •If n is zero, then an IllegalMonitorStateException is thrown. This is the case where thread t does not already possess the lock for target m. •If n is greater than zero and this is a notify action, then if m's wait set is not empty, a thread u that is a member of m's current wait set is selected and removed from the wait set. There is no guarantee about which thread in the wait set is selected. This removal from the wait set enables u's resumption in a wait action. Notice, however, that u's lock actions upon resumption cannot succeed until some time after t fully unlocks the monitor for m. •If n is greater than zero and this is a notifyAll action, then all threads are removed from m's wait set, and thus resume. Notice, however, that only one of them at a time will lock the monitor required during the resumption of wait.",10.91,277.11,360.01,1134,72,76.09,432.01,353.2,FALSE,FALSE
799,3,BODY,"17.5.2Reading final Fields During Construction A read of a final field of an object within the thread that constructs that object is ordered with respect to the initialization of that field within the constructor by the usual happens-before rules. If the read occurs after the field is set in the constructor, it sees the value the final field is assigned, otherwise it sees the default value.",10.91,66.11,360,393,72,172.09,432,238.2,FALSE,FALSE
801,2,BODY,"The compiler needs to treat these fields differently from other final fields. For example, a read of an ordinary final field is 'immune' to synchronization: the barrier involved in a lock or volatile read does not have to affect what value is read from a final field. Since the value of write-protected fields may be seen to change, synchronization events should have an effect on them. Therefore, the semantics dictate that these fields be treated as normal fields that cannot be changed by user code, unless that user code is in the System class.",10.91,84.14,360.01,548,72,76.06,432.01,160.2,FALSE,FALSE
828,2,BODY,"•If the method invocation expression is a poly expression, let B3 be the bound set generated in §18.5.2.1 to demonstrate compatibility with the actual target type of the method invocation. If the method invocation expression is not a poly expression, let B3 be the same as the bound set produced by reduction in order to demonstrate that m is applicable in §18.5.1. (While it was necessary in §18.5.1 and §18.5.2.1 to demonstrate that the inference variables in the bound set could be resolved, the instantiations produced by these resolution steps are not considered part of B3.) •A set of constraint formulas, C, is generated as follows. Let e1, ..., ek be the actual argument expressions of the method invocation expression. If m is applicable by strict or loose invocation, let F1, ..., Fk be the formal parameter types of m; if m is applicable by variable arity invocation, let F1, ..., Fk the first k variable arity parameter types of m (§15.12.2.4). Let θ be the substitution [P1:=α1, ..., Pp:=αp] defined in §18.5.1 to replace the type parameters of m with inference variables. Then, for all i (1 ≤ i ≤ k): –If ei is not pertinent to applicability, C contains ‹ei → Fi θ›. –Additional constraints may be included, depending on the form of ei: ›If ei is a LambdaExpression, C contains ‹LambdaExpression →throws Fi θ›, and the lambda body is searched for additional constraints: »For a block lambda body, the search is applied recursively to each of its result expressions. »For a poly class instance creation expression or a poly method invocation expression , C contains all the constraint formulas that would appear in the",10.91,403.14,360,1631,72,76.06,432,479.2,FALSE,FALSE
860,2,BODY,EnhancedForStatementNoShortIf: for ( LocalVariableDeclaration : Expression ) StatementNoShortIf,10.91,32.05,221.76,95,90,535.13,311.76,567.18,FALSE,TRUE
24,2,BODY,"•a new feature of the Java programming language ('preview language feature'), or •a new module, package, class, interface, field, method, constructor, or enum constant in the java.* or javax.* namespace ('preview API') that is fully specified, fully implemented, and yet impermanent. It is available in implementations of a given release of the Java SE Platform to provoke developer feedback based on real world use; this may lead to it becoming permanent in a future release of the Java SE Platform. Implementations must disable, at both compile time and run time, the preview features defined by a given release of the Java SE Platform, unless the user indicates via the host system, at both compile time and run time, that preview features are to be enabled. The preview features defined by a given release of the Java SE Platform are enumerated in the Java SE Platform Specification for that release. The preview features are specified as follows: •Preview language features are specified in standalone documents that indicate changes ('diffs') to The Java Language Specification for that release. The specifications of preview language features are incorporated into The Java Language Specification by reference, and made a part thereof, if and only if preview features are enabled at compile time. Java SE 23 defines four preview language features: Flexible Constructor Bodies; Implicitly Declared Classes and Instance main Methods; Module Import Declarations; and Primitive Types in Patterns, instanceof, and switch. The standalone documents which specify these preview features are available at the Oracle web site which hosts The Java Language Specification: https:// docs.oracle.com/javase/specs/. •Preview APIs are specified within the Java SE API Specification for that release. The rules for use of preview language features are as follows: •If preview features are disabled, then any source code reference to a preview language feature, or to a class or interface declared using a preview language feature, causes a compile-time error.",10.9,437.14,360.01,2049,72,76.06,432.01,513.2,FALSE,FALSE
43,3,BODY,These productions imply all of the following properties: •Comments do not nest. •/* and */ have no special meaning in comments that begin with //. •// has no special meaning in comments that begin with /* or /**.,10.9,63.14,308.51,212,72,469.33,380.51,532.47,FALSE,FALSE
72,6,BODY,"Primitive values do not share state with other primitive values. The numeric types are the integral types and the floating-point types. The integral types are byte, short, int, and long, whose values are 8-bit, 16-bit, 32-bit and 64-bit signed two's-complement integers, respectively, and char, whose values are 16-bit unsigned integers representing UTF-16 code units (§3.1).",10.9,70.14,360,375,72,514.06,432,584.2,FALSE,FALSE
73,4,BODY,"4.2.2Integer Operations The Java programming language provides a number of operators that act on integral values: •The comparison operators, which result in a value of type boolean: –The numerical comparison operators <, <=, >, and >= (§15.20.1) –The numerical equality operators == and != (§15.21.1) •The numerical operators, which result in a value of type int or long: –The unary plus and minus operators + and - (§15.15.3, §15.15.4) –The multiplicative operators *, /, and % (§15.17) –The additive operators + and - (§15.18) –The increment operator ++, both prefix (§15.15.1) and postfix (§15.14.2) –The decrement operator --, both prefix (§15.15.2) and postfix (§15.14.3) –The signed and unsigned shift operators <<, >>, and >>> (§15.19) –The bitwise complement operator ~ (§15.15.5) –The integer bitwise operators &, ^, and | (§15.22.1) •The conditional operator ? : (§15.25)",10.9,287.11,360.01,881,72,301.09,432.01,588.2,FALSE,FALSE
83,5,BODY,"The operators on references to objects are: •Field access, using either a qualified name (§6.6) or a field access expression (§15.11) •Method invocation (§15.12) •The cast operator (§5.5, §15.16) •The string concatenation operator + (§15.18.1), which, when given a String operand and a reference, will convert the reference to a String by invoking the toString method of the referenced object (using 'null' if either the reference or the result of toString is a null reference), and then will produce a newly created String that is the concatenation of the two strings •The instanceof operator (§15.20.2) •The reference equality operators == and != (§15.21.3) •The conditional operator ? : (§15.25). There may be many references to the same object. Most objects have state, stored in the fields of objects that are instances of classes or in the variables that are the components of an array object. If two variables contain references to the same object, the state of the object can be modified using one variable's reference to the object, and then the altered state can be observed through the reference in the other variable.",10.9,288.14,360.01,1129,72,247.06,432.01,535.2,FALSE,FALSE
108,4,BODY,"2.A type in the extends clause of an interface declaration (§9.1.3) 3.The return type of a method (§8.4.5, §9.4), including the type of an element",10.9,25.14,350,146,82,127.06,432,152.2,FALSE,FALSE
118,2,BODY,"A blank final is a final variable whose declaration lacks an initializer. A constant variable is a final variable of primitive type or type String that is initialized with a constant expression (§15.29). Whether a variable is a constant variable or not may have implications with respect to class initialization (§12.4.1), binary compatibility (§13.1), reachability (§14.22), and definite assignment (§16.1.1). Three kinds of variable are implicitly declared final: a field of an interface (§9.3), a local variable declared as a resource of a try-with-resources statement (§14.20.3), and an exception parameter of a multi-catch clause (§14.20). An exception parameter of a uni-catch clause is never implicitly declared final, but may be effectively final.",10.9,148.14,360,755,72,76.06,432,224.2,FALSE,FALSE
145,5,BODY,5.1.11String Conversion Any type may be converted to type String by string conversion.,10.9,27.11,285.67,86,72,571.09,357.67,598.2,FALSE,FALSE
184,2,BODY,"Where an if, while, do, or for statement contains an expression that introduces pattern variables, the scope of those variables can, in certain circumstances, include substatements of the statement.",10.9,32.14,360.01,198,72,76.06,432.01,108.2,FALSE,FALSE
233,7,BODY,"7.4.3Package Observability and Visibility A package is observable if and only if at least one of the following is true: •An ordinary compilation unit containing a declaration of the package is observable (§7.3). •A subpackage of the package is observable. The packages java, java.lang, and java.io are always observable.",10.9,97.11,359.99,320,72,506.09,431.99,603.2,FALSE,FALSE
238,6,BODY,7.5.3Single-Static-Import Declarations A single-static-import declaration imports all accessible static members with a given simple name from a class or interface. This makes these static members,10.9,40.11,360,195,72,563.09,432,603.2,FALSE,FALSE
244,2,BODY,"A normal module, without the open modifier, grants access at compile time and run time to types in only those packages which are explicitly exported. An open module, with the open modifier, grants access at compile time to types in only those packages which are explicitly exported, but grants access at run time to types in all its packages, as if all packages had been exported. For code outside a module (whether the module is normal or open), the access granted at compile time or run time to types in the module's exported packages is specifically to the public and protected types in those packages, and the public and protected members of those types (§6.6). No access is granted at compile time or run time to types, or their members, in packages which are not exported. Code inside the module may access public and protected types, and the public and protected members of those types, in all packages in the module at both compile time and run time. Distinct from access at compile time and access at run time, the Java SE Platform provides reflective access via the Core Reflection API (§1.4). A normal module grants reflective access to types in only those packages which are explicitly exported or explicitly opened (or both). An open module grants reflective access to types in all its packages, as if all packages had been opened. For code outside a normal module, the reflective access granted to types in the module's exported (and not opened) packages is specifically to the public and protected types in those packages, and the public and protected members of those types. The reflective access granted to types in the module's opened packages (whether exported or not) is to all types in those packages, and all members of those types. No reflective access is granted to types, or their members, in packages which are not exported or opened. Code inside the module enjoys reflective access to all types, and all their members, in all packages in the module. For code outside an open module, the reflective access granted to types in the module's opened packages (that is, all packages in the module) is to all types in those packages, and all members of those types. Code inside the module enjoys reflective access to all types, and all their members, in all packages in the module. The directives of a module declaration specify the module's dependences on other modules (via requires, §7.7.1), the packages it makes available to other modules (via exports and opens, §7.7.2), the services it consumes (via uses, §7.7.3), and the services it provides (via provides, §7.7.4).",10.9,471.14,360.01,2594,72,76.06,432.01,547.2,FALSE,FALSE
259,7,BODY,TypeParameters: < TypeParameterList >,10.9,19.05,111.24,37,90,579.39,201.24,598.44,FALSE,TRUE
274,4,BODY,"It is a compile-time error if the declaration of a sealed class C lacks a permits clause and C has no permitted direct subclasses. •If C is an enum class, then its permitted direct subclasses, if any, are specified in §8.9.",10.9,51.14,360,223,72,169.06,432,220.2,FALSE,FALSE
392,7,BODY,"If a method declaration in class or interface Q is annotated with @Override, then one of the following three conditions must be true, or a compile-time error occurs: •the method overrides from Q a method declared in a supertype of Q (§8.4.8.1, §9.4.1.1) •the method is override-equivalent to a public method of Object (§4.3.2, §8.4.2) •Q is a record class (§8.10), and the method is an accessor method for a record component of Q (§8.10.3)",10.9,102.14,360,439,72,277.2,432,379.33,FALSE,FALSE
401,3,BODY,MarkerAnnotation: @ TypeName,10.9,19.05,85.55,28,90,134.13,175.55,153.18,FALSE,TRUE
444,6,BODY,"12.1.1Load the Class Test The initial attempt to execute the method main of class Test discovers that the class Test is not loaded - that is, that the Java Virtual Machine does not currently contain a binary representation for this class. The Java Virtual Machine then uses a class loader to attempt to find such a binary representation. If this process fails, then an error is thrown. This loading process is described further in §12.2.",10.9,79.11,360.01,437,72,258.09,432.01,337.2,FALSE,FALSE
451,3,BODY,"12.4.1When Initialization Occurs A class or interface T will be initialized immediately before the first occurrence of any one of the following: •T is a class and an instance of T is created. •A static method declared by T is invoked. •A static field declared by T is assigned. •A static field declared by T is used and the field is not a constant variable (§4.12.4). When a class is initialized, its superclasses are initialized (if they have not been previously initialized), as well as any superinterfaces (§8.1.5) that declare any default methods (§9.4.3) (if they have not been previously initialized). Initialization of an interface does not, of itself, cause initialization of any of its superinterfaces. A reference to a static field (§8.3.1.1) causes initialization of only the class or interface that actually declares it, even though it might be referred to through the name of a subclass, a subinterface, or a class that implements an interface. Invocation of certain reflective methods in class Class and in package java.lang.reflect also causes class or interface initialization. A class or interface will not be initialized under any other circumstance.",10.9,283.11,360.01,1168,72,121.09,432.01,404.2,FALSE,FALSE
466,2,BODY,"complete normally or abruptly. No finally clause of any method in the thread is executed, nor any uncaught exception handler. If program exit occurs because a thread invoked Runtime.halt while shutdown hooks were running, then, in addition to daemon and non-daemon threads, any shutdown hook that has not yet terminated will execute no further Java code.",10.9,64.14,360,354,72,76.06,432,140.2,FALSE,FALSE
482,2,BODY,"The super keyword can be used to access a method declared in a superclass, bypassing any methods declared in the current class. The expression super.Identifier is resolved, at compile time, to a method m in the superclass S. If the method m is an instance method, then the method which is invoked at run time is the method with the same signature as m that is a member of the direct superclass of the class containing the expression involving super.",10.9,71.14,360.01,449,72,76.06,432.01,147.2,FALSE,FALSE
497,2,BODY,"13.5.6Field Declarations The considerations for changing field declarations in interfaces are the same as those for static final fields in classes, as described in §13.4.8 and §13.4.9.",10.9,40.11,360,184,72,76.09,432,116.2,FALSE,FALSE
509,4,BODY,Statements are thus grammatically divided into two categories: those that might end in an if statement that has no else clause (a 'short if statement') and those that definitely do not. Only statements that definitely do not end in a short if statement may appear as an immediate substatement before the keyword else in an if statement that does have an else clause. This simple rule prevents the 'dangling else' problem. The execution behavior of a statement with the 'no short if' restriction is identical to the execution behavior of the same kind of statement without the 'no short if' restriction; the distinction is drawn purely to resolve the syntactic difficulty.,10.9,135.14,360,671,72,185.06,432,320.2,FALSE,FALSE
515,2,BODY,"A disabled assert statement does nothing. In particular, neither Expression1 nor Expression2 (if it is present) are evaluated. Execution of a disabled assert statement always completes normally. An enabled assert statement is executed by first evaluating Expression1. If the result is of type Boolean, it is subjected to unboxing conversion (§5.1.8). If evaluation of Expression1 or the subsequent unboxing conversion (if any) completes abruptly for some reason, the assert statement completes abruptly for the same reason. Otherwise, execution continues by making a choice based on the value of Expression1: •If the value is true, no further action is taken and the assert statement completes normally. •If the value is false, the execution behavior depends on whether Expression2 is present: –If Expression2 is present, it is evaluated. Then: ›If the evaluation completes abruptly for some reason, the assert statement completes abruptly for the same reason. ›If the evaluation completes normally, an AssertionError instance whose 'detail message' is the resulting value of Expression2 is created. Then: »If the instance creation completes abruptly for some reason, the assert statement completes abruptly for the same reason. »If the instance creation completes normally, the assert statement completes abruptly by throwing the newly created AssertionError object.",10.9,365.14,360,1367,72,76.06,432,441.2,FALSE,FALSE
528,2,BODY,"14.11.1.2Determining which Switch Label Applies at Run Time Both the execution of a switch statement (§14.11.3) and the evaluation of a switch expression (§15.28.2) need to determine if a switch label associated with the switch block applies to the value of the selector expression. This proceeds as follows: 1.If the value is the null reference, then a case label with a null literal applies.",10.9,71.2,360.01,393,72,76.13,432.01,147.33,FALSE,FALSE
529,2,BODY,"2.If the value is not the null reference, then we determine the first (if any) case",10.9,6.14,360,83,72,76.06,432,82.2,FALSE,FALSE
541,4,BODY,"If the Expression is not present, then the only way a for statement can complete normally is by use of a break statement. 14.14.1.3Abrupt Completion of for Statement Abrupt completion of the contained Statement is handled in the following manner: •If execution of the Statement completes abruptly because of a break with no label, no further action is taken and the for statement completes normally. •If execution of the Statement completes abruptly because of a continue with no label, then the following two steps are performed in sequence: 1.First, if the ForUpdate part is present, the expressions are evaluated in",10.9,149.27,360.01,618,72,153.06,432.01,302.33,FALSE,FALSE
542,7,BODY,"The type of the Expression must be an array type (§10.1) or a subtype of the raw type Iterable, or a compile-time error occurs. The header of the enhanced for statement either declares a local variable whose name is the identifier given by VariableDeclaratorId, or declares an unnamed local variable (§6.3). When the enhanced for statement is executed, the local variable is initialized, on each iteration of the loop, to successive elements of the Iterable or the array produced by the expression.",10.9,90.14,360,498,72,487.06,432,577.2,FALSE,FALSE
551,2,BODY,"It is a compile-time error if the return target of a return statement with value Expression is either a constructor, or a method that is declared void. It is a compile-time error if the return target of a return statement with value Expression is a method with declared return type T, and the type of Expression is not assignable compatible (§5.2) with T. Execution of a return statement with no value always completes abruptly, the reason being a return with no value. Execution of a return statement with value Expression first evaluates the Expression. If the evaluation of the Expression completes abruptly for some reason, then the return statement completes abruptly for that reason. If evaluation of the Expression completes normally, producing a value V, then the return statement completes abruptly, the reason being a return with value V.",10.9,167.14,360,848,72,76.06,432,243.2,FALSE,FALSE
553,4,BODY,"A synchronized statement acquires a mutual-exclusion lock (§17.1) on behalf of the executing thread, executes a block, then releases the lock. While the executing thread owns the lock, no other thread may acquire the lock.",10.9,32.14,360,222,72,388.06,432,420.2,FALSE,FALSE
567,7,BODY,"The effect of the translation is to put the resource specification 'inside' the try statement. This allows a catch clause of an extended try-with-resources statement to catch an exception due to the automatic initialization or closing of any resource. Furthermore, all resources will have been closed (or attempted to be closed) by the time the finally block is executed, in keeping with the intent of the finally keyword.",10.9,77.14,360,422,72,487.2,432,564.33,FALSE,FALSE
591,2,BODY,"T[] if S is a subtype of T, but this requires a run-time check for assignment to an array component, similar to the check performed for a cast. •Exception handling (§14.20). An exception is caught by a catch clause only if the class of the thrown exception object is an instanceof the type of the formal parameter of the catch clause. Situations where the class of an object is not statically known may lead to run-time type errors. In addition, there are situations where the statically known type may not be accurate at run time. Such situations can arise in a program that gives rise to compile-time unchecked warnings. Such warnings are given in response to operations that cannot be statically guaranteed to be safe, and cannot immediately be subjected to dynamic checking because they involve non-reifiable types (§4.7). As a result, dynamic checks later in the course of program execution may detect inconsistencies and result in run-time type errors. A run-time type error can occur only in these situations: •In a cast, when the actual class of the object referenced by the value of the operand expression is not compatible with the target type specified by the cast operator (§5.5, §15.16); in this case a ClassCastException is thrown. •In an automatically generated cast introduced to ensure the validity of an operation on a non-reifiable type (§4.7). •In an assignment to an array component of reference type, when the actual class of the object referenced by the value to be assigned is not compatible with the actual run-time component type of the array (§10.5, §15.13, §15.26.1); in this case an ArrayStoreException is thrown. •When an exception is not caught by any catch clause of a try statement (§14.20); in this case the thread of control that encountered the exception first attempts to invoke an uncaught exception handler (§11.3) and then terminates.",10.9,392.14,360.01,1874,72,76.06,432.01,468.2,FALSE,FALSE
600,6,BODY,The type of a literal is determined as follows: •The type of an integer literal (§3.10.1) that ends with L or l (ell) is long (§4.2.1). The type of any other integer literal is int (§4.2.1). •The type of a floating-point literal (§3.10.2) that ends with F or f is float (§4.2.3). The type of any other floating-point literal is double (§4.2.3). •The type of a boolean literal (§3.10.3) is boolean (§4.2.5). •The type of a character literal (§3.10.4) is char (§4.2.1). •The type of a string literal (§3.10.5) or a text block (§3.10.6) is String (§4.3.3). •The type of the null literal null (§3.10.8) is the null type (§4.1); its value is the null reference. Evaluation of a lexical literal always completes normally.,10.9,203.14,360,715,72,314.06,432,517.2,FALSE,FALSE
601,6,BODY,It is a compile-time error if a this expression occurs in a static context (§8.1.3).,10.9,6.14,353.06,84,72,582.06,425.06,588.2,FALSE,FALSE
621,12,BODY,"If evaluation of an array creation expression finds there is insufficient memory to perform the creation operation, then an OutOfMemoryError is thrown. If the array creation expression does not have an array initializer, then this check occurs only after evaluation of all dimension expressions has completed normally. If the array creation expression does have an array initializer, then an OutOfMemoryError can occur when an object of reference type is allocated during evaluation of a variable initializer expression, or when space is allocated for an array to hold the values of a (possibly nested) array initializer.",10.9,97.14,360.01,621,72,496.06,432.01,593.2,FALSE,FALSE
679,6,BODY,PostIncrementExpression: PostfixExpression ++,10.9,19.05,116.7,45,90,295.13,206.7,314.18,FALSE,TRUE
680,3,BODY,PostDecrementExpression: PostfixExpression --,10.9,19.05,120.36,45,90,121.13,210.36,140.18,FALSE,TRUE
701,4,BODY,The operators == (equal to) and != (not equal to) are called the equality operators.,10.9,6.14,360,84,72,156.06,432,162.2,FALSE,FALSE
718,2,BODY,"assignment expression completes abruptly for the same reason; the index subexpression (of the left-hand operand array access expression) and the right- hand operand are not evaluated and no assignment occurs. •Otherwise, the index subexpression of the left-hand operand array access expression is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and the right-hand operand is not evaluated and no assignment occurs. •Otherwise, the right-hand operand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs. •Otherwise, if the value of the array reference subexpression is null, then no assignment occurs and a NullPointerException is thrown. •Otherwise, the value of the array reference subexpression indeed refers to an array. If the value of the index subexpression is less than zero, or greater than or equal to the length of the array, then no assignment occurs and an ArrayIndexOutOfBoundsException is thrown. •Otherwise, the value of the index subexpression is used to select a component of the array referred to by the value of the array reference subexpression. This component is a variable; call its type SC. Also, let TC be the type of the left- hand operand of the assignment operator as determined at compile time. Then there are two possibilities: –If TC is a primitive type, then SC is necessarily the same as TC. The value of the right-hand operand is converted to the type of the selected array component, and the result of the conversion is stored into the array component. –If TC is a reference type, then SC may not be the same as TC, but rather a type that extends or implements TC. Let RC be the class of the object referred to by the value of the right-hand operand at run time. A Java compiler may be able to prove at compile time that the array component will be of type TC exactly (for example, TC might be final). But if a Java compiler cannot prove at compile time that the array component will be of type TC exactly, then a check must be performed at run time to ensure that the",10.9,488.14,360.01,2170,72,76.06,432.01,564.2,FALSE,FALSE
752,3,BODY,"Throughout the rest of this chapter, we will, unless explicitly stated otherwise, write V to represent a local variable declared by a statement or blank final field which is in scope (§6.3). Likewise, we will use a, b, c, and e to represent expressions, and S and T to represent statements. We will use the phrase 'a is V' to mean that a is either the simple name of the variable V, or V's simple name qualified by this (ignoring parentheses). We will use the phrase 'a is not V' to mean the negation of 'a is V'.",10.9,71.14,360,513,72,363.06,432,434.2,FALSE,FALSE
756,2,BODY,"•V is [un]assigned before the first statement of any switch labeled statement group other than the first iff V is [un]assigned after the selector expression and V is [un]assigned after the preceding statement. The following rules apply only if the switch block of the switch expression consists of switch rules (§14.11.1): •V is definitely assigned after a switch expression when true iff for every switch rule, one of the following is true: –It introduces a switch rule expression e and V is definitely assigned after e when true. –It introduces a switch rule block B and for every yield statement with expression e contained in B that may exit the switch expression, V is definitely assigned after e when true. –It introduces a switch rule throw statement. •V is definitely assigned after a switch expression when false iff for every switch rule, one of the following is true: –It introduces a switch rule expression e and V is definitely assigned after e when false. –It introduces a switch rule block B and for every yield statement with expression e contained in B that may exit the switch expression, V is definitely assigned after e when false. –It introduces a switch rule throw statement. •V is definitely unassigned after a switch expression when true iff for every switch rule, one of the following is true: –It introduces a switch rule expression e and V is definitely unassigned after e when true. –It introduces a switch rule block B and for every yield statement with expression e contained in B that may exit the switch expression, V is definitely unassigned before the yield statement and V is definitely unassigned after e when true. –It introduces a switch rule throw statement.",10.9,461.14,360.01,1697,72,76.06,432.01,537.2,FALSE,FALSE
757,3,BODY,"•V is [un]assigned before the selector expression of a switch expression iff V is [un]assigned before the switch expression. •V is [un]assigned before the switch rule expression, switch rule block, or switch rule throw statement introduced by a switch rule in the switch block iff V is [un]assigned after the selector expression of the switch expression. •V is [un]assigned before the first block statement of a switch labeled statement group in the switch block iff both of the following are true: –V is [un]assigned after the selector expression of the switch expression. –If the switch labeled statement group is not the first in the switch block, V is [un]assigned after the last block statement of the preceding switch labeled statement group.",10.9,160.14,360.01,748,72,377.06,432.01,537.2,FALSE,FALSE
758,2,BODY,•V is [un]assigned before any guard associated with the switch block of a switch expression iff V is [un]assigned after the selector expression.,10.9,19.14,360,144,72,76.06,432,95.2,FALSE,FALSE
764,3,BODY,"•V is [un]assigned before the selector expression of a switch statement iff V is [un]assigned before the switch statement. •V is [un]assigned before any guard associated with the switch block of a switch statement iff V is [un]assigned after the selector expression. •V is [un]assigned before the switch rule expression, switch rule block, or switch rule throw statement introduced by a switch rule in the switch block iff V is [un]assigned after the selector expression of the switch statement. •V is [un]assigned before the first block statement of a switch labeled statement group in the switch block iff both of the following are true: –V is [un]assigned after the selector expression of the switch statement. –If the switch labeled statement group is not the first in the switch block, V is [un]assigned after the last block statement of the preceding switch labeled statement group.",10.9,192.14,360.01,888,72,296.06,432.01,488.2,FALSE,FALSE
771,7,BODY,"Let C be a class, and let V be a blank static final member field of C, declared in C. Then: •V is definitely unassigned (and moreover is not definitely assigned) before the leftmost enum constant, static initializer (§8.7), or static variable initializer of C. •V is [un]assigned before an enum constant, static initializer, or static variable initializer of C other than the leftmost iff V is [un]assigned after the preceding enum constant, static initializer, or static variable initializer of C.",10.9,96.14,360,498,72,498.06,432,594.2,FALSE,FALSE
787,4,BODY,•The final action in a thread T1 synchronizes-with any action in another thread T2 that detects that T1 has terminated.,10.9,19.14,360,119,72,150.06,432,169.2,FALSE,FALSE
799,2,BODY,"we consider hb(w, r2). (This happens-before ordering does not transitively close with other happens-before orderings.) Note that the dereferences order is reflexive, and r1 can be the same as r2. For reads of final fields, the only writes that are deemed to come before the read of the final field are the ones derived through the final field semantics.",10.9,70.14,360,353,72,76.06,432,146.2,FALSE,FALSE
812,6,BODY,"18.2.2Type Compatibility Constraints A constraint formula of the form ‹S → T› is reduced as follows: •If S and T are proper types, the constraint reduces to true if S is compatible in a loose invocation context with T (§5.3), and false otherwise. •Otherwise, if S is a primitive type, let S' be the result of applying boxing conversion (§5.1.7) to S. Then the constraint reduces to ‹S' → T›. •Otherwise, if T is a primitive type, let T' be the result of applying boxing conversion (§5.1.7) to T. Then the constraint reduces to ‹S = T'›. •Otherwise, if T is a parameterized type of the form G<T1, ..., Tn>, and there exists no type of the form G<...> that is a supertype of S, but the raw type G is a supertype of S, then the constraint reduces to true. •Otherwise, if T is an array type of the form G<T1, ..., Tn>[], and there exists no type of the form G<...>[] that is a supertype of S, but the raw type G[] is a supertype of S, then the constraint reduces to true. (The notation [] indicates an array type of k dimensions.) •Otherwise, the constraint reduces to ‹S <: T›. The fourth and fifth cases are implicit uses of unchecked conversion (§5.1.9). These, along with any use of unchecked conversion in the first case, may result in",10.9,277.11,360,1236,72,319.09,432,596.2,FALSE,FALSE
814,2,BODY,"exists, the constraint reduces to false. Otherwise, the constraint reduces to the following new constraints: for all i (1 ≤ i ≤ n), ‹Bi <= Ai›. –If T is any other class or interface type, then the constraint reduces to true if T is among the supertypes of S, and false otherwise. –If T is an array type, T'[], then among the supertypes of S that are array types, a most specific type is identified, S'[] (this may be S itself). If no such array type exists, the constraint reduces to false. Otherwise: ›If neither S' nor T' is a primitive type, the constraint reduces to ‹S' <: T'›. ›Otherwise, the constraint reduces to true if S' and T' are the same primitive type, and false otherwise.",10.9,147.14,350.01,688,82,76.06,432.01,223.2,FALSE,FALSE
816,7,BODY,"•Otherwise, let E1, ..., En be the types in the function type's throws clause that are not proper types. If the lambda expression is implicitly typed, let its parameter types be the function type's parameter types. If the lambda body is a poly",10.9,32.14,360,243,72,564.06,432,596.2,FALSE,FALSE
829,3,BODY,"›If ei is a MethodReference, C contains ‹MethodReference →throws Fi θ›. ›If ei is a poly class instance creation expression or a poly method invocation expression, C contains all the constraint formulas that would appear in the set C generated by §18.5.2 when inferring the poly expression's invocation type. ›If ei is a parenthesized expression, these rules are applied recursively to the contained expression. ›If ei is a conditional expression, these rules are applied recursively to the second and third operands. ›If ei is a switch expression, these rules are applied recursively to each of its result expressions.",10.9,147.14,340.01,619,92,236.06,432.01,383.2,FALSE,FALSE
830,7,BODY,"•Finally, if B4 does not contain the bound false, the inference variables in B4 are resolved. If resolution succeeds with instantiations T1, ..., Tp for inference variables α1, ..., αp, let θ' be the substitution [P1:=T1, ..., Pp:=Tp]. Then: –If unchecked conversion was necessary for the method to be applicable during constraint set reduction in §18.5.1, then the parameter types of the invocation type of m are obtained by applying θ' to the parameter types of m's type, and the return type and thrown types of the invocation type of m are given by the erasure of the return type and thrown types of m's type. –If unchecked conversion was not necessary for the method to be applicable, then the invocation type of m is obtained by applying θ' to the type of m. If B4 contains the bound false, or if resolution fails, then a compile-time error occurs. The process of reducing additional argument constraints may require carefully ordering constraint formulas of the forms ‹Expression → T›, ‹LambdaExpression →throws T›, and ‹MethodReference →throws T›. To facilitate this ordering, the input variables of these constraints are defined as follows:",10.9,244.14,360.01,1148,72,313.06,432.01,557.2,FALSE,FALSE
837,2,BODY,"18.5.5Record Pattern Type Inference When a record pattern (§14.30.1) for a generic record class R appears in a context in which values of a type T will be matched against it, and the pattern does not provide type arguments for R, the type arguments are inferred, as described below. 1.If T is not checked cast convertible (§5.5) to the raw type R, inference fails. 2.Otherwise, where P1, ..., Pn (n ≥ 1) are the type parameters of R, let α1, ..., αn be inference variables. An initial bound set, B0, is generated from the declared bounds of P1, ..., Pn, as described in §18.1.3.",10.9,117.11,360.01,578,72,76.09,432.01,193.2,FALSE,FALSE
841,4,BODY,"Identifier: IdentifierChars but not a ReservedKeyword or BooleanLiteral or NullLiteral IdentifierChars: JavaLetter {JavaLetterOrDigit} JavaLetter: any Unicode character that is a 'Java letter' JavaLetterOrDigit: any Unicode character that is a 'Java letter-or-digit' TypeIdentifier: Identifier but not permits, record, sealed, var, or yield UnqualifiedMethodIdentifier: Identifier but not yield",10.9,217.8,283.15,394,90,305.43,373.15,523.23,FALSE,TRUE
22,4,BODY,"On a machine with the Oracle JDK installed, this class, stored in the file Test.java, can be compiled and executed by giving the commands:",10.89,19.14,360,138,72,386.06,432,405.2,FALSE,FALSE
42,4,BODY,"Consider two tokens x and y in the resulting input stream. If x precedes y, then we say that x is to the left of y and that y is to the right of x.",10.89,19.14,360,147,72,190.06,432,209.2,FALSE,FALSE
60,4,BODY,CharacterLiteral: ' SingleCharacter ' ' EscapeSequence ' SingleCharacter: InputCharacter but not ' or \,10.89,69.14,140.27,103,90,179.13,230.27,248.27,FALSE,TRUE
68,6,BODY,"At run time, a text block is a reference to an instance of class String that denotes the string represented by the text block. Moreover, a text block always refers to the same instance of class String. This is because the strings represented by text blocks - or, more generally, strings that are the values of constant expressions (§15.29) - are 'interned' so as to share unique instances, as if by execution of the method String.intern (§12.5).",10.89,77.14,360,445,72,290.56,432,367.7,FALSE,FALSE
139,5,BODY,"If the conversion is to an intersection type T1 & ... & Tn, then for all i (1 ≤ i ≤ n), any run-time check required for a conversion from S to Ti is also required for the conversion to the intersection type.",10.89,32.14,360,207,72,527.06,432,559.2,FALSE,FALSE
185,2,BODY,•A pattern variable is introduced by if (e) S iff (i) it is introduced by e when false and (ii) S cannot complete normally.,10.89,19.14,360,123,72,76.06,432,95.2,FALSE,FALSE
197,8,BODY,"12.To the left of .super:: in a method reference expression (§15.13) •As the Identifier or dotted Identifier sequence that constitutes any ReferenceType (including a ReferenceType to the left of the brackets in an array type, or to the left of the < in a parameterized type, or in a non-wildcard type argument of a parameterized type, or in an extends or super clause of a wildcard type",10.89,64.14,360,386,72,343.06,432,407.2,FALSE,FALSE
250,4,BODY,"If a service provider does not have a provider method, then that service provider must have a provider constructor and must be a subtype of the service specified in the provides directive, or a compile-time error occurs. It is a compile-time error if more than one provides directive in a module declaration specifies the same service. It is a compile-time error if the with clause of a given provides directive specifies the same service provider more than once.",10.89,96.14,360.01,463,72,463.06,432.01,559.2,FALSE,FALSE
268,9,BODY,"A class C directly depends on a class or interface A if A is mentioned in the extends or implements clause of C either as a superclass or superinterface, or as a qualifier in the fully qualified form of a superclass or superinterface name. A class C depends on a class or interface A if any of the following is true: •C directly depends on A. •C directly depends on an interface I that depends (§9.1.3) on A. •C directly depends on a class B that depends on A, applying this definition recursively.",10.89,121.14,360.01,498,72,482.06,432.01,603.2,FALSE,FALSE
271,7,BODY,"Unless the class being declared is abstract, all the abstract member methods of each direct superinterface must be implemented (§8.4.8.1) either by a declaration in this class or by an existing method declaration inherited from the direct superclass or a direct superinterface, because a class that is not abstract is not permitted to have abstract methods (§8.1.1.1). Each default method (§9.4.3) of a superinterface of the class may optionally be overridden by a method in the class; if not, the default method is typically inherited and its behavior is as specified by its default body. It is permitted for a single method declaration in a class to implement methods of more than one superinterface.",10.89,135.14,360.01,702,72,381.06,432.01,516.2,FALSE,FALSE
337,4,BODY,"8.8.10Preventing Instantiation of a Class A class can be designed to prevent code outside the class declaration from creating instances of the class by declaring at least one constructor, to prevent the creation of a default constructor, and by declaring all constructors to be private (§6.6.1). A public class can likewise prevent the creation of instances outside its package by declaring at least one constructor, to prevent creation of a default constructor with public access, and by declaring no constructor that is public or protected (§6.6.2).",10.89,111.11,360.01,551,72,217.09,432.01,328.2,FALSE,FALSE
342,5,BODY,"8.9.3Enum Members The members of an enum class E are all of the following: •Members declared in the body of the declaration of E. •Members inherited from Enum<E>. •For each enum constant c declared in the body of the declaration of E, E has an implicitly declared public static final field of type E that has the same name as c. The field has a variable initializer which instantiates E and passes any arguments of c to the constructor chosen for E. The field has the same annotations as c (if any). These fields are implicitly declared in the same order as the corresponding enum constants, before any static fields explicitly declared in the body of the declaration of E. An enum constant is said to be created when the corresponding implicitly declared field is initialized.",10.89,213.11,360,777,72,381.09,432,594.2,FALSE,FALSE
350,3,BODY,"The CompactConstructorDeclaration clause is described in §8.10.4.2. It is a compile-time error for the body of a record declaration to contain a non- static field declaration (§8.3.1.1). It is a compile-time error for the body of a record declaration to contain a method declaration that is abstract or native (§8.4.3.1, §8.4.3.4). It is a compile-time error for the body of a record declaration to contain an instance initializer (§8.6).",10.89,102.14,360.01,438,72,204.06,432.01,306.2,FALSE,FALSE
363,3,BODY,"9.1.3Superinterfaces and Subinterfaces If an extends clause is provided, then the interface being declared extends each of the specified interface types and therefore inherits the member classes, member interfaces, instance methods, and static fields of each of those interface types. The specified interface types are the direct superinterface types of the interface being declared. Any class that implements the declared interface is also considered to implement all the interfaces that this interface extends.",10.89,117.11,360.01,512,72,301.09,432.01,418.2,FALSE,FALSE
371,3,BODY,"The rules concerning annotation modifiers for an interface method declaration are specified in §9.7.4 and §9.7.5. A method in the body of an interface declaration may be declared public or private (§6.6). If no access modifier is given, the method is implicitly public. It is permitted, but discouraged as a matter of style, to redundantly specify the public modifier for a method declaration in an interface declaration. A default method is an instance method declared in an interface with the default modifier. Its body is always represented by a block, which provides a default implementation for any class that implements the interface without overriding the method. Default methods are distinct from concrete methods (§8.4.3.1), which are declared in classes, and from private interface methods, which are neither inherited nor overridden. An interface can declare static methods, which are invoked without reference to a particular object. static interface methods are distinct from default methods, abstract interface methods, and non-static private interface methods, all of which are instance methods. The declaration of a static interface method introduces a static context (§8.1.3), which limits the use of constructs that refer to the current object. Notably, the keywords this and super are prohibited in a static context (§15.8.3, §15.11.2), as are unqualified references to instance variables, instance methods, and type parameters of lexically enclosing declarations (§6.5.5.1, §6.5.6.1, §15.12.3). References to an instance method from a static context or a nested class or interface are restricted (§15.12.3). The strictfp modifier on an interface method declaration is obsolete and should not be used in new code. Its presence or absence has no effect at run time. An interface method lacking a private, default, or static modifier is implicitly abstract. Its body is represented by a semicolon, not a block. It is permitted, but discouraged as a matter of style, to redundantly specify the abstract modifier for such a method declaration.",10.89,412.14,360.01,2058,72,183.06,432.01,595.2,FALSE,FALSE
446,2,BODY,"be initialized before Test is initialized. Class Object has no superclass, so the recursion terminates here. If class Test has another class Super as its superclass, then Super must be initialized before Test. This requires loading, verifying, and preparing Super if this has not already been done and, depending on the implementation, may also involve resolving the symbolic references from Super and so on, recursively. Initialization may thus cause loading, linking, and initialization errors, including such errors involving other classes and interfaces. The initialization process is described further in §12.4.",10.89,128.14,360,616,72,76.06,432,204.2,FALSE,FALSE
454,11,BODY,"7.Next, if C is a class rather than an interface, then let SC be its superclass and let SI1, ..., SIn be all superinterfaces of C that declare at least one default method. The order of superinterfaces is given by a recursive enumeration over",10.89,32.14,360,241,72,563.06,432,595.2,FALSE,FALSE
460,3,BODY,"The Java programming language imposes no ordering on finalize method calls. Finalizers may be called in any order, or even concurrently.",10.89,19.14,360,136,72,128.06,432,147.2,FALSE,FALSE
460,5,BODY,"It is guaranteed that the thread that invokes the finalizer will not be holding any user-visible synchronization locks when the finalizer is invoked. If an uncaught exception is thrown during the finalization, the exception is ignored and finalization of that object terminates. The completion of an object's constructor happens-before (§17.4.5) the execution of its finalize method (in the formal sense of happens-before). The finalize method declared in class Object takes no action. The fact that class Object declares a finalize method means that the finalize method for any class can always invoke the finalize method for its superclass. This should always be done, unless it is the programmer's intent to nullify the actions of the finalizer in the superclass. (Unlike constructors, finalizers do not automatically invoke the finalizer for the superclass; such an invocation must be coded explicitly.)",10.89,167.14,360.01,907,72,270.06,432.01,437.2,FALSE,FALSE
463,2,BODY,"cleared according to the rules provided in the API documentation for the package java.lang.ref. The only objects that are considered definitely reachable at a point di are those that can be shown to be reachable by the application of these rules: •An object B is definitely reachable at di from static fields if there exists a write w1 to a static field v of a class C such that the value written by w1 is a reference to B, the class C is loaded by a reachable classloader, and there does not exist a write w2 to v such that hb(w2, w1) is not true and both w1 and w2 come-before di. •An object B is definitely reachable from A at di if there is a write w1 to an element v of A such that the value written by w1 is a reference to B and there does not exist a write w2 to v such that hb(w2, w1) is not true and both w1 and w2 come- before di. •If an object C is definitely reachable from an object B, and object B is definitely reachable from an object A, then C is definitely reachable from A. If an object X is marked as unreachable at di, then: •X must not be definitely reachable at di from static fields; and •All active uses of X in thread t that come-after di must occur in the finalizer invocation for X or as a result of thread t performing a read that comes-after di of a reference to X; and •All reads that come-after di that see a reference to X must see writes to elements of objects that were unreachable at di, or see writes that came-after di. An action a is an active use of X if and only if at least one of the following is true: •a reads or writes an element of X •a locks or unlocks X and there is a lock action on X that happens-after the invocation of the finalizer for X •a writes a reference to X •a is an active use of an object Y, and X is definitely reachable from Y If an object X is marked as finalizable at di, then: •X must be marked as unreachable at di; and •di must be the only place where X is marked as finalizable; and •actions that happen-after the finalizer invocation must come-after di.",10.89,498.14,360.01,2025,72,76.06,432.01,574.2,FALSE,FALSE
474,3,BODY,"A class file corresponding to a module declaration must have the properties of a class file for a class whose binary name is module-info and which has no superclass, no superinterfaces, no fields, and no methods. In addition, the binary representation of the module must contain all of the following: •A specification of the name of the module, given as a symbolic reference to the name indicated after module. Also, the specification must include whether the module is normal or open (§7.7). •A specification of each dependence denoted by a requires directive, given as a symbolic reference to the name of the module indicated by the directive (§7.7.1). Also, the specification must include whether the dependence is transitive and whether the dependence is static. •A specification of each package denoted by an exports or opens directive, given as a symbolic reference to the name of the package indicated by the directive (§7.7.2). Also, if the directive was qualified, the specification must give symbolic references to the names of the modules indicated by the directive's to clause. •A specification of each service denoted by a uses directive, given as a symbolic reference to the name of the class or interface indicated by the directive (§7.7.3). •A specification of the service providers denoted by a provides directive, given as symbolic references to the names of the classes and interfaces indicated by the directive's with clause (§7.7.4). Also, the specification must give a symbolic",10.89,283.14,360.01,1499,72,300.06,432.01,583.2,FALSE,FALSE
483,11,BODY,"Allowing superclasses to change protected methods to be public without breaking binaries of pre-existing subclasses helps make binaries less fragile. The alternative, where such a change would cause a linkage error, would create additional binary incompatibilities.",10.89,45.14,360,265,72,538.06,432,583.2,FALSE,FALSE
551,5,BODY,"The Expression in a throw statement must either denote a variable or value of a reference type which is assignable (§5.2) to the type Throwable, or denote the null reference, or a compile-time error occurs.",10.89,32.14,360,206,72,556.06,432,588.2,FALSE,FALSE
555,2,BODY,"block of code is executed, no matter whether the try block completes normally or abruptly, and no matter whether a catch clause is first given control.",10.89,19.14,360,151,72,76.06,432,95.2,FALSE,FALSE
561,6,BODY,"14.20.3try-with-resources A try-with-resources statement is parameterized with variables (known as resources) that are initialized before execution of the try block and closed automatically, in the reverse order from which they were initialized, after execution of the try block. catch clauses and a finally clause are often unnecessary when resources are closed automatically. TryWithResourcesStatement: try ResourceSpecification Block [Catches] [Finally] ResourceSpecification: ( ResourceList [;] ) ResourceList: Resource {; Resource}",10.89,190.09,360.01,536,72,413.09,432.01,603.18,FALSE,FALSE
565,3,BODY,"{VariableModifierNoFinal} is defined as {VariableModifier} without final, if present. If VariableDeclaratorId is an identifier then Identifier is defined to be that identifier, otherwise Identifier is defined to be an automatically generated identifier that is distinct from any other identifiers (automatically generated or otherwise) that are in scope at the point where the try-with-resources statement occurs. #t, #primaryExc, and #suppressedExc are automatically generated identifiers that are distinct from any other identifiers (automatically generated or otherwise) that are in scope at the point where the try-with-resources statement occurs. If the resource specification indicates one resource, then ResourceSpecification_tail is empty (and the try-catch-finally statement is not itself a try-with-resources statement). If the resource specification indicates n > 1 resources, then ResourceSpecification_tail consists of the 2nd, 3rd, ..., n'th resources indicated in the resource specification, in the same order (and the try-catch-finally statement is itself a try-with-resources statement). Reachability and definite assignment rules for the basic try-with-resources statement are implicitly specified by the translation above. In a basic try-with-resources statement that manages a single resource:",10.89,276.14,360,1313,72,316.06,432,592.2,FALSE,FALSE
568,4,BODY,"A yield statement attempts to transfer control to the innermost enclosing switch expression; this enclosing expression, which is called the yield target, then immediately completes normally and the value of the Expression becomes the value of the switch expression. It is a compile-time error if a yield statement has no yield target. It is a compile-time error if the yield target contains any method, constructor, instance initializer, static initializer, or lambda expression that encloses the yield statement. That is, there are no non-local jumps. It is a compile-time error if the Expression of a yield statement is void (§15.1). Execution of a yield statement first evaluates the Expression. If the evaluation of the Expression completes abruptly for some reason, then the yield statement completes abruptly for that reason. If evaluation of the Expression completes normally, producing a value V, then the yield statement completes abruptly, the reason being a yield with value V.",10.89,199.14,360,988,72,182.06,432,381.2,FALSE,FALSE
569,6,BODY,"The rules in this section define two technical terms: •whether a statement is reachable •whether a statement can complete normally The rules allow a statement to complete normally only if it is reachable. Two further technical terms are used: •A reachable break statement exits a statement if, within the break target, either there are no try statements whose try blocks contain the break statement, or there are try statements whose try blocks contain the break statement and all finally clauses of those try statements can complete normally.",10.89,140.14,360,543,72,382.06,432,522.2,FALSE,FALSE
570,3,BODY,"•An assert statement can complete normally iff it is reachable. •A switch statement whose switch block is empty, or contains only switch labels, can complete normally.",10.89,38.14,360,167,72,547.06,432,585.2,FALSE,FALSE
580,2,BODY,"•The null reference does not match a record pattern. In this case, any pattern variables appearing in declarations contained in the record pattern are not initialized. •A value v that is not the null reference matches a record pattern with type R and component pattern list L if (i) v can be converted by testing conversion (§5.7) to the target type R without raising a ClassCastException; and (ii) each record component of v matches the corresponding component pattern in L; and does not match otherwise. Each record component of v is determined by invoking the accessor method of v corresponding to that component. If execution of the invocation of the accessor method completes abruptly for reason S, then pattern matching completes abruptly by throwing a MatchException with cause S.",10.89,167.14,360,787,72,76.06,432,243.2,FALSE,FALSE
611,2,BODY,"constructors, is used to choose one of the constructors of T and determine its throws clause. If there is no unique most-specific constructor in T that is both applicable and accessible (§6.6), then a compile-time error occurs (as in method invocations). Otherwise, the return type corresponding to the chosen constructor is T. –If C is an anonymous class, then: The process specified in §15.12.2, modified to handle constructors, is used to choose one of the constructors of the direct superclass type of C and determine its throws clause. If there is no unique most-specific constructor in the direct superclass type of C that is both applicable and accessible, then a compile-time error occurs (as in method invocations). Otherwise, C's anonymous constructor is chosen as the constructor of C (§15.9.5.1). Its body consists of an explicit constructor invocation (§8.8.7.1) of the constructor chosen in the direct superclass type of C. The throws clause of the chosen constructor includes the exceptions in the throws clause of the constructor chosen in the direct superclass type of C. The return type corresponding to the chosen constructor is the anonymous class type.",10.89,288.14,350.01,1173,82,76.06,432.01,364.2,FALSE,FALSE
629,4,BODY,"15.11.2Accessing Superclass Members using super The form super.Identifier refers to the field named Identifier of the current object, but with the current object viewed as an instance of the superclass of the current class. The form T.super.Identifier refers to the field named Identifier of the lexically enclosing instance corresponding to T, but with that instance viewed as an instance of the superclass of T. The forms using the keyword super may be used in the locations within a class declaration that allow the keyword this as an expression (§15.8.3). It is a compile-time error if a field access expression using the keyword super appears in a static context (§8.1.3). For a field access expression of the form super.Identifier: •It is a compile-time error if the immediately enclosing class or interface declaration of the field access expression is the class Object or an interface. For a field access expression of the form T.super.Identifier: •It is a compile-time error if T is the class Object or an interface. •Let U be the immediately enclosing class or interface declaration of the field access expression. It is a compile-time error if U is not an inner class of T or T itself. Suppose that a field access expression super.f appears within class C, and the immediate superclass of C is class S. If f in S is accessible from class C (§6.6), then super.f is treated as if it had been the expression this.f in the body of class S. Otherwise, a compile-time error occurs.",10.89,354.11,360,1486,72,157.09,432,511.2,FALSE,FALSE
643,5,BODY,"An argument expression is considered pertinent to applicability for a potentially applicable method m unless it has one of the following forms: •An implicitly typed lambda expression (§15.27.1). •An inexact method reference expression (§15.13.1). •If m is a generic method and the method invocation does not provide explicit type arguments, an explicitly typed lambda expression or an exact method reference expression for which the corresponding target type (as derived from the signature of m) is a type parameter of m. •An explicitly typed lambda expression whose body is an expression that is not pertinent to applicability. •An explicitly typed lambda expression whose body is a block, where at least one result expression is not pertinent to applicability. •A parenthesized expression (§15.8.5) whose contained expression is not pertinent to applicability. •A conditional expression (§15.25) whose second or third operand is not pertinent to applicability. Let m be a potentially applicable method (§15.12.2.1) with arity n and formal parameter types F1, ..., Fn, and let e1, ..., en be the actual argument expressions of the method invocation. Then: •If m is a generic method and the method invocation does not provide explicit type arguments, then the applicability of the method is inferred as specified in §18.5.1. •If m is a generic method and the method invocation provides explicit type arguments, then let R1, ..., Rp (p ≥ 1) be the type parameters of m, let Bl be the declared bound of Rl (1 ≤ l ≤ p), and let U1, ..., Up be the explicit type arguments given in the method invocation. Then m is applicable by strict invocation if both of the following are true: –For 1 ≤ i ≤ n, if ei is pertinent to applicability then ei is compatible in a strict invocation context with Fi[R1:=U1, ..., Rp:=Up] (§5.3). –For 1 ≤ l ≤ p, Ul <: Bl[R1:=U1, ..., Rp:=Up].",10.89,443.17,360.01,1865,72,153.2,432.01,596.36,FALSE,FALSE
664,2,BODY,"automatically unlocked when execution of the body of the method has completed, whether normally or abruptly. The locking and unlocking behavior is exactly as if the body of the method were embedded in a synchronized statement (§14.19).",10.89,32.14,360.01,235,72,76.06,432.01,108.2,FALSE,FALSE
689,2,BODY,"15.17.3Remainder Operator % The binary % operator is said to yield the remainder of its operands from an implied division; the left-hand operand is the dividend and the right-hand operand is the divisor. In C and C++, the remainder operator accepts only integral operands, but in the Java programming language, it also accepts floating-point operands. The remainder operation for operands that are integers after binary numeric promotion (§5.6) produces a result value such that (a/b)*b+(a%b) is equal to a. This identity holds even in the special case that the dividend is the negative integer of largest possible magnitude for its type and the divisor is -1 (the remainder is 0). It follows from this rule that the result of the remainder operation can be negative only if the dividend is negative, and can be positive only if the dividend is positive. Moreover, the magnitude of the result is always less than the magnitude of the divisor. If the value of the divisor for an integer remainder operator is 0, then an ArithmeticException is thrown.",10.89,239.11,360.01,1049,72,76.09,432.01,315.2,FALSE,FALSE
706,2,BODY,"At run time, the left-hand operand expression is evaluated first; if the result has type Boolean, it is subjected to unboxing conversion (§5.1.8). If the resulting value is false, the value of the conditional-and expression is false and the right-hand operand expression is not evaluated. If the value of the left-hand operand is true, then the right-hand expression is evaluated; if the result has type Boolean, it is subjected to unboxing conversion (§5.1.8). The resulting value becomes the value of the conditional-and expression. Thus, && computes the same result as & on boolean operands. It differs only in that the right-hand operand expression is evaluated conditionally rather than always.",10.89,128.14,360.01,699,72,76.06,432.01,204.2,FALSE,FALSE
714,4,BODY,"15.25.2Numeric Conditional Expressions Numeric conditional expressions are standalone expressions (§15.2). The type of a numeric conditional expression is determined as follows: •If the second and third operands have the same type, then that is the type of the conditional expression. •If one of the second and third operands is of primitive type T, and the type of the other is the result of applying boxing conversion (§5.1.7) to T, then the type of the conditional expression is T. •If one of the operands is of type byte or Byte and the other is of type short or Short, then the type of the conditional expression is short. •If one of the operands is of type T where T is byte, short, or char, and the other operand is a constant expression (§15.29) of type int whose value is representable in type T, then the type of the conditional expression is T. •If one of the operands is of type T, where T is Byte, Short, or Character, and the other operand is a constant expression of type int whose value is representable in the type U which is the result of applying unboxing conversion to T, then the type of the conditional expression is U.",10.89,258.11,360.01,1141,72,308.09,432.01,566.2,FALSE,FALSE
743,3,BODY,"15.28.2Run-Time Evaluation of switch Expressions A switch expression is evaluated by first evaluating the selector expression. If evaluation of the selector expression completes abruptly, then evaluation of the entire switch expression completes abruptly for the same reason. If evaluation of the selector expression completes normally then evaluation of the switch expression continues by determining if a switch label associated with the switch block applies to the value of the selector expression (§14.11.1.2). Then:",10.89,98.11,360,520,72,493.09,432,591.2,FALSE,FALSE
753,6,BODY,16.1.2Conditional-And Operator && •V is [un]assigned after a && b (§15.23) when true iff V is [un]assigned after b when true. •V is [un]assigned after a && b when false iff V is [un]assigned after a when false and V is [un]assigned after b when false.,10.89,72.11,360,251,72,519.09,432,591.2,FALSE,FALSE
754,4,BODY,16.1.4Logical Complement Operator ! •V is [un]assigned after !a (§15.15.6) when true iff V is [un]assigned after a when false. •V is [un]assigned after !a when false iff V is [un]assigned after a when true. •V is [un]assigned before a iff V is [un]assigned before !a. •V is [un]assigned after !a iff V is [un]assigned after !a when true and V is [un]assigned after !a when false.,10.89,110.11,360,379,72,314.09,432,424.2,FALSE,FALSE
757,2,BODY,"•V is definitely unassigned after a switch expression when false iff for every switch rule, one of the following is true: –It introduces a switch rule expression e and V is definitely unassigned after e when false. –It introduces a switch rule block B and for every yield statement with expression e contained in B that may exit the switch expression, V is definitely unassigned before the yield statement and V is definitely unassigned after e when false. –It introduces a switch rule throw statement. •V is [un]assigned before any switch rule expression or switch rule statement in the switch block iff V is [un]assigned after the selector expression. Suppose that a switch expression has result expressions e1, ..., en, not all of which are boolean-valued. •V is [un]assigned after a switch expression iff all of the following are true: –V is [un]assigned before every yield statement that may exit the switch expression. –For each switch rule in the switch block, V is [un]assigned after the switch rule expression, switch rule block, or switch rule throw statement introduced by the switch rule.",10.89,288.14,360,1100,72,76.06,432,364.2,FALSE,FALSE
761,2,BODY,"the scope of V and before the declaration of any class declared within the scope of V. •A local variable V declared by a statement S is definitely unassigned (and moreover is not definitely assigned) before the block that is the body of the constructor, method, instance initializer or static initializer which contains S. •Let C be a class declared within the scope of V. Then V is definitely assigned before the block that is the body of any constructor, method, instance initializer, or static initializer declared in C iff V is definitely assigned before the declaration of C.",10.89,122.14,360.01,580,72,76.06,432.01,198.2,FALSE,FALSE
763,2,BODY,16.2.6Expression Statements •V is [un]assigned after an expression statement e; (§14.8) iff it is [un]assigned after e. •V is [un]assigned before e iff it is [un]assigned before e;.,10.89,59.11,360,181,72,76.09,432,135.2,FALSE,FALSE
778,4,BODY,"2.Thread t does not execute any further instructions until it has been removed from m's wait set. The thread may be removed from the wait set due to any one of the following actions, and will resume sometime afterward: –A notify action being performed on m in which t is selected for removal from the wait set. –A notifyAll action being performed on m. –An interrupt action being performed on t. –If this is a timed wait, an internal action removing t from m's wait set that occurs after at least millisecs milliseconds plus nanosecs nanoseconds elapse since the beginning of this wait action. –An internal action by the implementation. Implementations are permitted, although not encouraged, to perform 'spurious wake-ups', that is, to remove threads from wait sets and thus enable resumption without explicit instructions to do so.",10.89,205.14,350,833,82,127.06,432,332.2,FALSE,FALSE
814,3,BODY,"–If T is a type variable, there are three cases: ›If S is an intersection type of which T is an element, the constraint reduces to true. ›Otherwise, if T has a lower bound, B, the constraint reduces to ‹S <: B›. ›Otherwise, the constraint reduces to false. –If T is an intersection type, I1 & ... & In, the constraint reduces to the following new constraints: for all i (1 ≤ i ≤ n), ‹S <: Ii›.",10.89,109.17,350,393,82,236.06,432,345.23,FALSE,FALSE
821,2,BODY,"Dependencies in the bound set may require that the variables be resolved in a particular order, or that additional variables be resolved. Dependencies are specified as follows: •Given a bound of one of the following forms, where T is either an inference variable β or a type that mentions β: –α = T –α <: T –T = α –T <: α If α appears on the left-hand side of another bound of the form G<..., α, ...> = capture(G<...>), then β depends on the resolution of α. Otherwise, α depends on the resolution of β. •An inference variable α appearing on the left-hand side of a bound of the form G<..., α, ...> = capture(G<...>) depends on the resolution of every other inference variable mentioned in this bound (on both sides of the = sign). •An inference variable α depends on the resolution of an inference variable β if there exists an inference variable γ such that α depends on the resolution of γ and γ depends on the resolution of β. •An inference variable α depends on the resolution of itself. Given a set of inference variables to resolve, let V be the union of this set and all variables upon which the resolution of at least one variable in this set depends. If every variable in V has an instantiation, then resolution succeeds and this procedure terminates. Otherwise, let { α1, ..., αn } be a non-empty subset of uninstantiated variables in V such that (i) for all i (1 ≤ i ≤ n), if αi depends on the resolution of a variable β, then either β has an instantiation or there is some j such that β = αj; and (ii) there exists no non-empty proper subset of { α1, ..., αn } with this property. Resolution proceeds by generating an instantiation for each of α1, ..., αn based on the bounds in the bound set:",10.89,442.14,360.01,1706,72,76.06,432.01,518.2,FALSE,FALSE
117,5,BODY,"4.12.4final Variables A variable can be declared final. A final variable may only be assigned to once. It is a compile-time error if a final variable is assigned to unless it is definitely unassigned immediately prior to the assignment (§16 (Definite Assignment)). Once a final variable has been assigned, it always contains the same value. If a final variable holds a reference to an object, then the state of the object may be changed by operations on the object, but the variable will always refer to the same object. This applies also to arrays, because arrays are objects; if a final variable holds a reference to an array, then the components of the array may be changed by operations on the array, but the variable will always refer to the same array.",10.88,137.11,360.01,758,72,466.09,432.01,603.2,FALSE,FALSE
131,8,BODY,"b.The value must be too large (a positive value of large magnitude or positive infinity), and the result of the first step is the largest representable value of type int or long.",10.88,32.14,332,178,100,416.06,432,448.2,FALSE,FALSE
196,3,BODY,6.5.1Syntactic Classification of a Name According to Context A name is syntactically classified as a ModuleName in these contexts: •In a requires directive in a module declaration (§7.7.1) •To the right of to in an exports or opens directive in a module declaration (§7.7.2) A name is syntactically classified as a PackageName in these contexts: •To the right of exports or opens in a module declaration •To the left of the '.' in a qualified PackageName A name is syntactically classified as a TypeName in these contexts:,10.88,154.11,360,522,72,393.09,432,547.2,FALSE,FALSE
249,2,BODY,"It is a compile-time error if the package specified by exports is not declared by a compilation unit associated with the current module (§7.3). It is permitted for opens to specify a package which is not declared by a compilation unit associated with the current module. (If the package should happen to be declared by an observable compilation unit associated with another module, the opens directive has no effect on that other module.) It is a compile-time error if more than one exports directive in a module declaration specifies the same package name. It is a compile-time error if more than one opens directive in a module declaration specifies the same package name. It is a compile-time error if an opens directive appears in the declaration of an open module. If an exports or opens directive has a to clause, then the directive is qualified; otherwise, it is unqualified. For a qualified directive, the public and protected types in the package, and their public and protected members, are accessible solely to code in the modules specified in the to clause. The modules specified in the to clause are referred to as friends of the current module. For an unqualified directive, these types and their members are accessible to code in any module. It is permitted for the to clause of an exports or opens directive to specify a module which is not observable (§7.7.6). It is a compile-time error if the to clause of a given exports directive specifies the same module name more than once. It is a compile-time error if the to clause of a given opens directive specifies the same module name more than once.",10.88,353.14,360.01,1615,72,76.06,432.01,429.2,FALSE,FALSE
299,4,BODY,"8.4.2Method Signature Two methods or constructors, M and N, have the same signature if they have the same name, the same type parameters (if any) (§8.4.4), and, after adapting the formal parameter types of N to the type parameters of M, the same formal parameter types. The signature of a method m1 is a subsignature of the signature of a method m2 if either: •m2 has the same signature as m1, or •the signature of m1 is the same as the erasure (§4.6) of the signature of m2. Two method signatures m1 and m2 are override-equivalent iff either m1 is a subsignature of m2 or m2 is a subsignature of m1. It is a compile-time error to declare two methods with override-equivalent signatures in a class.",10.88,200.11,360,698,72,147.09,432,347.2,FALSE,FALSE
302,6,BODY,"8.4.3.2static Methods A method that is declared static is called a class method. A class method is always invoked without reference to a particular object. The declaration of a class method introduces a static context (§8.1.3), which limits the use of constructs that refer to the current object. Notably, the keywords this and super are prohibited in a static context (§15.8.3, §15.11.2), as are unqualified references to instance variables, instance methods, and type parameters of lexically enclosing declarations (§6.5.5.1, §6.5.6.1, §15.12.3). A method that is not declared static is called an instance method, and sometimes called a non-static method. An instance method is always invoked with respect to an object, which becomes the current object to which the keywords this and super refer during execution of the method body. References to an instance method from a static context or a nested class or interface are restricted, as specified in §15.12.3.",10.88,219.2,360.01,962,72,366.13,432.01,585.33,FALSE,FALSE
314,5,BODY,"8.4.8.2Hiding (by Class Methods) If a class C declares or inherits a static method m, then m is said to hide any method m' declared in a class or interface A for which all of the following are true: •A is a superclass or superinterface of C. •If A is an interface, m' is an instance method. •m' is accessible to C (§6.6). •The signature of m is a subsignature (§8.4.2) of the signature of m' as a member of the supertype of C that names A. It is a compile-time error if a static method hides an instance method.",10.88,147.2,360,511,72,410.13,432,557.33,FALSE,FALSE
349,3,BODY,"It is a compile-time error for a record declaration to have two record components with the same name. The declared type of a record component depends on whether it is a variable arity record component: •If the record component is not a variable arity record component, then the declared type is denoted by UnannType. •If the record component is a variable arity record component, then the declared type is an array type specified by §10.2. If the declared type of a variable arity record component has a non-reifiable element type (§4.7), then a compile-time unchecked warning occurs for the declaration of the variable arity record component, unless the canonical constructor (§8.10.4) is annotated with @SafeVarargs (§9.6.4.7) or the warning is suppressed by @SuppressWarnings (§9.6.4.5).",10.88,186.14,360.01,790,72,188.06,432.01,374.2,FALSE,FALSE
376,7,BODY,"9.4.3Interface Method Body A default method has a block body. This block of code provides an implementation of the method in the event that a class implements the interface but does not provide its own implementation of the method. A private or static interface method also has a block body, which provides the implementation of the method. It is a compile-time error if an interface method declaration is abstract (explicitly or implicitly) and has a block for its body. It is a compile-time error if an interface method declaration is default, private, or static, and has a semicolon for its body. The rules for return statements in a method body are specified in §14.17.",10.88,168.11,360.01,673,72,430.09,432.01,598.2,FALSE,FALSE
394,4,BODY,"9.6.4.6@Deprecated Programmers are sometimes discouraged from using certain program elements (modules, classes, interfaces, fields, methods, and constructors) because they are considered dangerous or because a better alternative exists. The annotation interface Deprecated allows a compiler to warn about uses of these program elements. A deprecated program element is a module, class, interface, field, method, or constructor whose declaration is annotated with @Deprecated. The manner in which a program element is deprecated depends on the value of the forRemoval element of the annotation: •If forRemoval=false (the default), then the program element is ordinarily deprecated. An ordinarily deprecated program element is not intended to be removed in a future release, but programmers should nevertheless migrate away from using it. •If forRemoval=true, then the program element is terminally deprecated. A terminally deprecated program element is intended to be removed in a future release. Programmers should stop using it or risk source and binary incompatibilities (§13.2) when upgrading to a newer release. A Java compiler must produce a deprecation warning when an ordinarily deprecated program element is used (overridden, invoked, or referenced by name) in the declaration of a program element (whether explicitly or implicitly declared), unless: •The use is within a declaration that is itself deprecated, either ordinarily or terminally; or",10.88,354.2,360.01,1454,72,247.13,432.01,601.33,FALSE,FALSE
461,2,BODY,"The package java.lang.ref describes weak references, which interact with garbage collection and finalization. As with any API that has special interactions with the Java programming language, implementors must be cognizant of any requirements imposed by the java.lang.ref API. This specification does not discuss weak references in any way. Readers are referred to the API documentation for details.",10.88,71.14,360,399,72,76.06,432,147.2,FALSE,FALSE
497,3,BODY,"13.5.7Interface Method Declarations The considerations for changing method declarations in interfaces include those for changing methods in classes, as described in §13.4.7, §13.4.14, §13.4.15, §13.4.19, §13.4.21, §13.4.22, and §13.4.23. Adding a default method, or changing a method from abstract to default, does not break compatibility with pre-existing binaries, but may cause an IncompatibleClassChangeError if a pre-existing binary attempts to invoke the method. This error occurs if the qualifying interface of the method invocation, K, is a subinterface of two interfaces, I and J, where both I and J declare a default method with the same signature and result, and neither I nor J is a subinterface of the other. In other words, adding a default method is a binary-compatible change because it does not introduce errors at link time, even if it introduces errors at compile time or invocation time. In practice, the risk of accidental clashes occurring by introducing a default method are similar to those associated with adding a new method to a non-final class. In the event of a clash, adding a method to a class is unlikely to trigger a LinkageError, but an accidental override of the method in a child can lead to unpredictable method behavior. Both changes can cause errors at compile time.",10.88,247.11,360.01,1305,72,142.09,432.01,389.2,FALSE,FALSE
512,6,BODY,"14.9.1The if-then Statement An if-then statement is executed by first evaluating the Expression. If the result is of type Boolean, it is subjected to unboxing conversion (§5.1.8). If evaluation of the Expression or the subsequent unboxing conversion (if any) completes abruptly for some reason, the if-then statement completes abruptly for the same reason. Otherwise, execution continues by making a choice based on the resulting value: •If the value is true, then the contained Statement is executed; the if-then statement completes normally if and only if execution of the Statement completes normally. •If the value is false, no further action is taken and the if-then statement completes normally.",10.88,181.11,360,701,72,379.09,432,560.2,FALSE,FALSE
513,5,BODY,"To ease the presentation, the first Expression in both forms of the assert statement is referred to as Expression1. In the second form of the assert statement, the second Expression is referred to as Expression2. It is a compile-time error if Expression1 does not have type boolean or Boolean. It is a compile-time error if, in the second form of the assert statement, Expression2 is void (§15.1). An assert statement that is executed after its class or interface has completed initialization is enabled if and only if the host system has determined that the",10.88,115.14,360,558,72,463.06,432,578.2,FALSE,FALSE
554,2,BODY,"•Otherwise, let the non-null value of the Expression be V. The executing thread locks the monitor associated with V. Then the Block is executed, and then there is a choice: –If execution of the Block completes normally, then the monitor is unlocked and the synchronized statement completes normally. –If execution of the Block completes abruptly for any reason, then the monitor is unlocked and the synchronized statement completes abruptly for the same reason.",10.88,109.14,360,461,72,76.06,432,185.2,FALSE,FALSE
567,2,BODY,"•If the initialization of every resource completes normally, and the try block completes normally, then: –If one automatic closing of an initialized resource completes abruptly because of a throw of value V, and all other automatic closings of initialized resources complete normally, then the try-with-resources statement completes abruptly because of a throw of the value V. –If more than one automatic closing of an initialized resource completes abruptly because of throws of values V1...Vn (where V1 is the exception from the rightmost resource failing to close and Vn is the exception from the leftmost resource failing to close), then the try-with-resources statement completes abruptly because of a throw of the value V1, with any remaining values V2...Vn added to the suppressed exception list of V1.",10.88,161.14,360.01,809,72,76.06,432.01,237.2,FALSE,FALSE
571,4,BODY,•A switch block is reachable iff its switch statement is reachable. •A statement in a switch block that consists of switch labeled statement groups is reachable iff the switch block is reachable and at least one of the following is true: –It bears a case or default label. –There is a statement preceding it in the switch block and that preceding statement can complete normally.,10.88,102.14,360,379,72,357.06,432,459.2,FALSE,FALSE
627,2,BODY,"•If the field is not static: –The Primary expression is evaluated. If evaluation of the Primary expression completes abruptly, the field access expression completes abruptly for the same reason. –If the value of the Primary is null, then a NullPointerException is thrown. –If the field is a non-blank final, then the result is the value of the named member field in type T found in the object referenced by the value of the Primary. –If the field is not final, or is a blank final and the field access occurs in an instance variable initializer (§8.3.2), instance initializer (§8.6), or constructor (§8.8), then the result is a variable, namely the named member field in type T found in the object referenced by the value of the Primary.",10.88,173.14,360,737,72,76.06,432,249.2,FALSE,FALSE
631,2,BODY,"MethodInvocation: MethodName ( [ArgumentList] ) TypeName . [TypeArguments] Identifier ( [ArgumentList] ) ExpressionName . [TypeArguments] Identifier ( [ArgumentList] ) Primary . [TypeArguments] Identifier ( [ArgumentList] ) super . [TypeArguments] Identifier ( [ArgumentList] ) TypeName . super . [TypeArguments] Identifier ( [ArgumentList] ) ArgumentList: Expression {, Expression}",10.88,121.05,314.65,382,90,76.13,404.65,197.18,FALSE,TRUE
645,2,BODY,"15.12.2.4Phase 3: Identify Methods Applicable by Variable Arity Invocation Where a variable arity method has formal parameter types F1, ..., Fn-1, Fn[], let the i'th variable arity parameter type of the method be defined as follows: •For i ≤ n-1, the i'th variable arity parameter type is Fi. •For i ≥ n, the i'th variable arity parameter type is Fn. Let m be a potentially applicable method (§15.12.2.1) with variable arity, let T1, ..., Tk be the first k variable arity parameter types of m, and let e1, ..., ek be the actual argument expressions of the method invocation. Then: •If m is a generic method and the method invocation does not provide explicit type arguments, then the applicability of the method is inferred as specified in §18.5.1. •If m is a generic method and the method invocation provides explicit type arguments, then let R1, ..., Rp (p ≥ 1) be the type parameters of m, let Bl be the declared bound of Rl (1 ≤ l ≤ p), and let U1, ..., Up be the explicit type arguments given in the method invocation. Then m is applicable by variable arity invocation if: –For 1 ≤ i ≤ k, if ei is pertinent to applicability (§15.12.2.2) then ei is compatible in a loose invocation context with Ti[R1:=U1, ..., Rp:=Up] (§5.3). –For 1 ≤ l ≤ p, Ul <: Bl[R1:=U1, ..., Rp:=Up]. •If m is not a generic method, then m is applicable by variable arity invocation if, for 1 ≤ i ≤ k, either ei is compatible in a loose invocation context with Ti (§5.3) or ei is not pertinent to applicability. If no method applicable by variable arity invocation is found, then a compile-time error occurs. Otherwise, the most specific method (§15.12.2.5) is chosen among the methods applicable by variable arity invocation. 15.12.2.5Choosing the Most Specific Method If more than one member method is both accessible and applicable to a method invocation, it is necessary to choose one to provide the descriptor for the run- time method dispatch. The Java programming language uses the rule that the most specific method is chosen. The informal intuition is that one method is more specific than another if any invocation handled by the first method could be passed on to the other one without a compile-time error. In cases such as an explicitly typed lambda expression",10.88,516.34,360.01,2250,72,76.13,432.01,592.47,FALSE,FALSE
651,3,BODY,"•If the chosen method is generic and the method invocation provides explicit type arguments, let Pi be the type parameters of the method and let Ti be the explicit type arguments provided for the method invocation (1 ≤ i ≤ p). Then: –If unchecked conversion was necessary for the method to be applicable, then the invocation type's parameter types are obtained by applying the substitution [P1:=T1, ..., Pp:=Tp] to the parameter types of the method's type, and the invocation type's return type and thrown types are given by the erasure of the return type and thrown types of the method's type. –If unchecked conversion was not necessary for the method to be applicable, then the invocation type is obtained by applying the substitution [P1:=T1, ..., Pp:=Tp] to the method's type.",10.88,148.14,360.01,780,72,102.06,432.01,250.2,FALSE,FALSE
686,9,BODY,"The type of a multiplicative expression is the promoted type of its operands. If the promoted type is int or long, then integer arithmetic is performed. If the promoted type is float or double, then floating-point arithmetic is performed.",10.88,57.14,360,238,72,531.06,432,588.2,FALSE,FALSE
702,7,BODY,"15.21.2Boolean Equality Operators == and != If the operands of an equality operator are both of type boolean, or if one operand is of type boolean and the other is of type Boolean, then the operation is boolean equality. The boolean equality operators are associative. If one of the operands is of type Boolean, it is subjected to unboxing conversion (§5.1.8).",10.88,104.11,360,360,72,495.09,432,599.2,FALSE,FALSE
724,2,BODY,"If the left-hand operand expression is an array access expression (§15.10.3), then: •First, the array reference subexpression of the left-hand operand array access expression is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the index subexpression (of the left-hand operand array access expression) and the right- hand operand are not evaluated and no assignment occurs. •Otherwise, the index subexpression of the left-hand operand array access expression is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and the right-hand operand is not evaluated and no assignment occurs. •Otherwise, if the value of the array reference subexpression is null, then no assignment occurs and a NullPointerException is thrown. •Otherwise, the value of the array reference subexpression indeed refers to an array. If the value of the index subexpression is less than zero, or greater than or equal to the length of the array, then no assignment occurs and an ArrayIndexOutOfBoundsException is thrown. •Otherwise, the value of the index subexpression is used to select a component of the array referred to by the value of the array reference subexpression. The value of this component is saved and then the right-hand operand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.",10.88,296.14,360,1504,72,76.06,432,372.2,FALSE,FALSE
735,7,BODY,"A block lambda body is void-compatible if every return statement in the block has the form return;. A block lambda body is value-compatible if it cannot complete normally (§14.22) and every return statement in the block has the form return Expression;. It is a compile-time error if a block lambda body is neither void-compatible nor value-compatible. In a value-compatible block lambda body, the result expressions are any expressions that may produce an invocation's value. Specifically, for each statement of the form return Expression ; contained by the body, the Expression is a result expression.",10.88,141.14,360,602,72,407.06,432,548.2,FALSE,FALSE
745,3,BODY,"A constant expression is an expression denoting a value of primitive type or a String that does not complete abruptly and is composed using only the following: •Literals of primitive type (§3.10.1, §3.10.2, §3.10.3, §3.10.4), string literals (§3.10.5), and text blocks (§3.10.6) •Casts to primitive types and casts to type String (§15.16) •The unary operators +, -, ~, and ! (but not ++ or --) (§15.15.3, §15.15.4, §15.15.5, §15.15.6) •The multiplicative operators *, /, and % (§15.17) •The additive operators + and - (§15.18) •The shift operators <<, >>, and >>> (§15.19) •The relational operators <, <=, >, and >= (but not instanceof) (§15.20) •The equality operators == and != (§15.21) •The bitwise and logical operators &, ^, and | (§15.22) •The conditional-and operator && and the conditional-or operator || (§15.23, §15.24) •The ternary conditional operator ? : (§15.25) •Parenthesized expressions (§15.8.5) whose contained expression is a constant expression. •Simple names (§6.5.6.1) that refer to constant variables (§4.12.4). •Qualified names (§6.5.6.2) of the form TypeName . Identifier that refer to constant variables (§4.12.4). Constant expressions of type String are always 'interned' so as to share unique instances, using the method String.intern.",10.88,382.14,360.01,1264,72,145.06,432.01,527.2,FALSE,FALSE
765,3,BODY,•V is [un]assigned before S iff V is [un]assigned after e when true.,10.88,6.14,294.01,68,72,263.06,366.01,269.2,FALSE,FALSE
799,4,BODY,"17.5.3Subsequent Modification of final Fields In some cases, such as deserialization, the system will need to change the final fields of an object after construction. final fields can be changed via reflection and other implementation-dependent means. The only pattern in which this has reasonable semantics is one in which an object is constructed and then the final fields of the object are updated. The object should not be made visible to other threads, nor should the final fields be read, until all updates to the final fields of the object are complete. Freezes of a final field occur both at the end of the constructor in which the final field is set, and immediately after each modification of a final field via reflection or other special mechanism. Even then, there are a number of complications. If a final field is initialized to a constant expression (§15.29) in the field declaration, changes to the final field may not be observed, since uses of that final field are replaced at compile time with the value of the constant expression. Another problem is that the specification allows aggressive optimization of final fields. Within a thread, it is permissible to reorder reads of a final field with those modifications of a final field that do not take place in the constructor.",10.88,234.11,360.01,1294,72,264.09,432.01,498.2,FALSE,FALSE
806,2,BODY,"•S <: T, where at least one of S or T is an inference variable: S is a subtype of T. •false: No valid choice of inference variables exists. •G<α1, ..., αn> = capture(G<A1, ..., An>): The variables α1, ..., αn represent the result of capture conversion (§5.1.10) applied to G<A1, ..., An> (where A1, ..., An may be types or wildcards and may mention inference variables). •throws α: The inference variable α appears in a throws clause. A bound is satisfied by an inference variable substitution if, after applying the substitution, the assertion is true. The bound false can never be satisfied. Some bounds relate an inference variable to a proper type. Let T be a proper type. Given a bound of the form α = T or T = α, we say T is an instantiation of α. Similarly, given a bound of the form α <: T, we say T is a proper upper bound of α, and given a bound of the form T <: α, we say T is a proper lower bound of α. Other bounds relate two inference variables, or an inference variable to a type that contains inference variables. Such bounds, of the form S = T or S <: T, are called dependencies. A bound of the form G<α1, ..., αn> = capture(G<A1, ..., An>) indicates that α1, ..., αn are placeholders for the results of capture conversion. This is necessary because capture conversion can only be performed on a proper type, and the inference variables in A1, ..., An may not yet be resolved. A bound of the form throws α is purely informational: it directs resolution to optimize the instantiation of α so that, if possible, it is not a checked exception type. An important intermediate result of inference is a bound set. It is sometimes convenient to refer to an empty bound set with the symbol true; this is merely out of convenience, and the two are interchangeable.",10.88,359.14,360.01,1772,72,76.06,432.01,435.2,FALSE,FALSE
862,1,BODY,"ResourceList: Resource {; Resource} Resource: LocalVariableDeclaration VariableAccess Pattern: TypePattern RecordPattern TypePattern: LocalVariableDeclaration RecordPattern: ReferenceType ( [ComponentPatternList] ) ComponentPatternList: ComponentPattern {, ComponentPattern } ComponentPattern: Pattern MatchAllPattern MatchAllPattern: _",10.88,315.75,203.2,336,90,76.13,293.2,391.88,FALSE,TRUE
86,4,BODY,TypeParameter: {TypeParameterModifier} TypeIdentifier [TypeBound] TypeParameterModifier: Annotation TypeBound: extends TypeVariable extends ClassOrInterfaceType {AdditionalBound} AdditionalBound: & InterfaceType,10.87,143.05,252.22,211,90,327.13,342.22,470.18,FALSE,TRUE
89,4,BODY,"TypeArguments: < TypeArgumentList > TypeArgumentList: TypeArgument {, TypeArgument} TypeArgument: ReferenceType Wildcard Wildcard: {Annotation} ? [WildcardBounds] WildcardBounds: extends ReferenceType super ReferenceType",10.87,193.05,161.1,220,90,301.13,251.1,494.18,FALSE,TRUE
102,3,BODY,"4.10.4Least Upper Bound The least upper bound, or 'lub', of a set of reference types is a shared supertype that is more specific than any other shared supertype (that is, no other shared supertype is a subtype of the least upper bound). This type, lub(U1, ..., Uk), is determined as follows. If k = 1, then the lub is the type itself: lub(U) = U. Otherwise: •For each Ui (1 ≤ i ≤ k): Let ST(Ui) be the set of supertypes of Ui. Let EST(Ui), the set of erased supertypes of Ui, be: EST(Ui) = { |W| | W in ST(Ui) } where |W| is the erasure of W.",10.87,180.11,360.01,542,72,241.09,432.01,421.2,FALSE,FALSE
116,5,BODY,7.An exception parameter is created each time an exception is caught by a catch,10.87,6.14,360,79,72,295.06,432,301.2,FALSE,FALSE
187,3,BODY,"6.3.3Scope for Pattern Variables in case Labels Pattern variables can be introduced by case labels with a case pattern, either by the pattern itself or by a guard, and are in scope for the relevant parts of the associated switch expression (§6.3.1.6) or switch statement (§6.3.2.6). The following rules applies to case labels: •A pattern variable is introduced by a case label with a case pattern p if p contains a declaration of the pattern variable. •If a case pattern in a guarded case label contains a declaration of a pattern variable then the pattern variable is definitely matched in the associated guard. •A pattern variable is introduced by a guarded case label if it is introduced by the associated guard when true (§6.3.1).",10.87,168.11,360.01,734,72,290.22,432.01,458.33,FALSE,FALSE
197,2,BODY,"•To name a class or interface: 1.In a uses or provides directive in a module declaration (§7.7.1) 2.In a single-type-import declaration (§7.5.1) 3.To the left of the . in a single-static-import declaration (§7.5.3) 4.To the left of the . in a static-import-on-demand declaration (§7.5.4) 5.In a permits clause of a sealed class or interface declaration (§8.1.6,",10.87,101.14,360,361,72,76.06,432,177.2,FALSE,FALSE
280,2,BODY,"FieldDeclaration: {FieldModifier} UnannType VariableDeclaratorList ; VariableDeclaratorList: VariableDeclarator {, VariableDeclarator} VariableDeclarator: VariableDeclaratorId [= VariableInitializer] VariableDeclaratorId: Identifier [Dims] _ VariableInitializer: Expression ArrayInitializer UnannType: UnannPrimitiveType UnannReferenceType UnannPrimitiveType: NumericType boolean UnannReferenceType: UnannClassOrInterfaceType UnannTypeVariable UnannArrayType UnannClassOrInterfaceType: UnannClassType UnannInterfaceType UnannClassType: TypeIdentifier [TypeArguments] PackageName . {Annotation} TypeIdentifier [TypeArguments] UnannClassOrInterfaceType . {Annotation} TypeIdentifier [TypeArguments] UnannInterfaceType: UnannClassType",10.87,519.05,287.56,731,90,76.13,377.56,595.18,FALSE,TRUE
365,4,BODY,"If a sealed interface I is associated with a named module (§7.3), then every class or interface specified in the permits clause of I's declaration must be associated with the same module as I, or a compile-time error occurs. If a sealed interface I is associated with an unnamed module (§7.7.5), then every class or interface specified in the permits clause of I's declaration must belong to the same package as I, or a compile-time error occurs.",10.87,77.14,360.01,446,72,303.06,432.01,380.2,FALSE,FALSE
413,3,BODY,"type parameters of the function type (§8.4.4). If the function type is not generic but at least one method in M is generic, the throws clauses are first erased.",10.87,38.14,332,160,100,140.06,432,178.2,FALSE,FALSE
454,3,BODY,current thread can acquire LC.,10.87,6.14,130.83,30,90,326.06,220.83,332.2,FALSE,FALSE
491,10,BODY,"Changing a class (static) method that is not declared final to be declared final does not break compatibility with existing binaries, because the method could not have been overridden.",10.87,32.14,360,184,72,433.06,432,465.2,FALSE,FALSE
559,6,BODY,"•If execution of the try block completes abruptly because of a throw of a value V, then there is a choice: –If the run-time type of V is assignment compatible with a catchable exception class of any catch clause of the try statement, then the first (leftmost) such catch clause is selected. The value V is assigned to the parameter of the",10.87,64.14,360,338,72,428.06,432,492.2,FALSE,FALSE
571,3,BODY,•A switch statement whose switch block consists of switch rules can complete normally iff at least one of the following is true: –One of the switch rules introduces a switch rule expression (which is necessarily a statement expression). –One of the switch rules introduces a switch rule block that can complete normally. –One of the switch rules introduces a switch rule block that contains a reachable break statement which exits the switch statement. –The switch statement is not enhanced (§14.11.2) and its switch block does not contain a default label.,10.87,147.14,360.01,556,72,197.06,432.01,344.2,FALSE,FALSE
604,2,BODY,UnqualifiedClassInstanceCreationExpression: new [TypeArguments] ClassOrInterfaceTypeToInstantiate ( [ArgumentList] ) [ClassBody],10.87,32.05,325.06,128,90,76.13,415.06,108.18,FALSE,TRUE
663,4,BODY,"15.12.4.5Create Frame, Synchronize, Transfer Control A method m in some class S has been identified as the one to be invoked. Now a new activation frame is created, containing the target reference (if any) and the argument values (if any), as well as enough space for the local variables and stack for the method to be invoked and any other bookkeeping information that may be required by the implementation (stack pointer, program counter, reference to previous activation frame, and the like). If there is not sufficient memory available to create such an activation frame, a StackOverflowError is thrown. The newly created activation frame becomes the current activation frame. The effect of this is to assign the argument values to corresponding freshly created parameter variables of the method, and to make the target reference available as this, if there is a target reference. Before each argument value is assigned to its corresponding parameter variable, it is subjected to invocation conversion (§5.3). If the erasure (§4.6) of the type of the method being invoked differs in its signature from the erasure of the type of the compile-time declaration for the method invocation (§15.12.3), then if any of the argument values is an object which is not an instance of a subclass or subinterface of the erasure of the corresponding formal parameter type in the compile-time declaration for the method invocation, then a ClassCastException is thrown. If the method m is a native method but the necessary native, implementation- dependent binary code has not been loaded or otherwise cannot be dynamically linked, then an UnsatisfiedLinkError is thrown. If the method m is not synchronized, control is transferred to the body of the method m to be invoked. If the method m is synchronized, then an object must be locked before the transfer of control. No further progress can be made until the current thread can obtain the lock. If there is a target reference, then the target object must be locked; otherwise the Class object for class S, the class of the method m, must be locked. Control is then transferred to the body of the method m to be invoked. The object is",10.87,413.2,360.01,2173,72,182.13,432.01,595.33,FALSE,FALSE
702,2,BODY,"If the promoted type of the operands is int or long, then an integer equality test is performed. If the promoted type is float or double, then a floating-point equality test is performed. Floating-point equality testing is performed in accordance with the rules of the IEEE 754 standard: •If either operand is NaN, then the result of == is false but the result of != is true. Indeed, the test x!=x is true if and only if the value of x is NaN.",10.87,121.14,360,443,72,76.06,432,197.2,FALSE,FALSE
744,4,BODY,"If execution of any statement or expression in the switch block completes abruptly, it is handled as follows: •If evaluation of an expression completes abruptly, then evaluation of the switch expression completes abruptly for the same reason. •If execution of a statement completes abruptly because of a yield with value V, then evaluation of the switch expression completes normally and the value of the switch expression is V. •If execution of a statement completes abruptly for any reason other than a yield with a value, then evaluation of the switch expression completes abruptly for the same reason.",10.87,141.14,360.01,605,72,377.06,432.01,518.2,FALSE,FALSE
762,5,BODY,16.2.5Labeled Statements •V is [un]assigned after a labeled statement L : S (where L is a label) (§14.7) iff V is [un]assigned after S and V is [un]assigned before every break statement that may exit the labeled statement L : S. •V is [un]assigned before S iff V is [un]assigned before L : S.,10.87,72.11,360,292,72,524.09,432,596.2,FALSE,FALSE
765,6,BODY,"16.2.12for Statements The rules herein cover the basic for statement (§14.14.1). Since the enhanced for statement (§14.14.2) is defined by translation to a basic for statement, no special rules need to be provided for it.",10.87,53.11,360,221,72,508.09,432,561.2,FALSE,FALSE
787,2,BODY,"•The write of the default value (zero, false, or null) to each variable synchronizes-with the first action in every thread.",10.87,19.14,360,123,72,76.06,432,95.2,FALSE,FALSE
793,3,BODY,"9.If y is in Ci, x is an external action and hbi(x, y), then x in Ci.",10.87,6.36,283.94,69,72,198.06,355.94,204.42,FALSE,FALSE
800,4,BODY,"An implementation may provide a way to execute a block of code in a final-field- safe context. If an object is constructed within a final-field-safe context, the reads of a final field of that object will not be reordered with modifications of that final field that occur within that final-field-safe context. A final-field-safe context has additional protections. If a thread has seen an incorrectly published reference to an object that allows the thread to see the default value of a final field, and then, within a final-field-safe context, reads a properly published reference to the object, it will be guaranteed to see the correct value of the final field. In the formalism, code executed within a final-field-safe context is treated as a separate thread (for the purposes of final field semantics only). In an implementation, a compiler should not move an access to a final field into or out of a final-field-safe context (although it can be moved around the execution of such a context, so long as the object is not constructed within that context).",10.87,174.14,360.01,1058,72,260.06,432.01,434.2,FALSE,FALSE
815,3,BODY,"18.2.4Type Equality Constraints A constraint formula of the form ‹S = T›, where S and T are types, is reduced as follows: •If S and T are proper types, the constraint reduces to true if S is the same as T (§4.3.4), and false otherwise. •Otherwise, if S or T is the null type, the constraint reduces to false. •Otherwise, if S is an inference variable, α, and T is not a primitive type, the constraint reduces to the bound α = T. •Otherwise, if T is an inference variable, α, and S is not a primitive type, the constraint reduces to the bound S = α. •Otherwise, if S and T are class or interface types with the same erasure, where S has type arguments B1, ..., Bn and T has type arguments A1, ..., An, the constraint reduces to the following new constraints: for all i (1 ≤ i ≤ n), ‹Bi = Ai›. •Otherwise, if S and T are array types, S'[] and T'[], the constraint reduces to ‹S' = T'›. •Otherwise, if S and T are intersection types, a correspondence between the elements of S and the elements of T is established. An element of S, Si, corresponds to an element of T, Tj, if Si and Tj are either the same type, or both parameterizations of the same generic class or interface, or both array types. If each element of S corresponds to exactly one element of T, and vice versa, then the constraint reduces to the following new constraints: for each element Si of S and the corresponding element Tj of T, ‹Si = Tj›. If not, the constraint reduces to false.",10.87,348.11,360,1450,72,165.09,432,513.2,FALSE,FALSE
817,2,BODY,"expression or a block containing a poly result expression, let the targeted return type be the function type's return type. Let X1, ..., Xm be the checked exception types that the lambda body can throw (§11.2). Then there are two cases: –If n = 0 (the function type's throws clause consists only of proper types), then if there exists some i (1 ≤ i ≤ m) such that Xi is not a subtype of any proper type in the throws clause, the constraint reduces to false; otherwise, the constraint reduces to true. –If n > 0, the constraint reduces to a set of subtyping constraints: for all i (1 ≤ i ≤ m), if Xi is not a subtype of any proper type in the throws clause, then the constraints include, for all j (1 ≤ j ≤ n), ‹Xi <: Ej›. In addition, for all j (1 ≤ j ≤ n), the constraint reduces to the bound throws Ej.",10.87,149.17,350,804,82,76.06,432,225.23,FALSE,FALSE
833,6,BODY,"The process to determine if m1 is more specific than m2 is as follows: •First, an initial bound set, B, is generated from the declared bounds of P1, ..., Pp, as specified in §18.1.3.",10.87,38.14,360,182,72,522.06,432,560.2,FALSE,FALSE
62,4,BODY,"At run time, a string literal is a reference to an instance of class String (§4.3.3) that denotes the string represented by the string literal. Moreover, a string literal always refers to the same instance of class String. This is because string literals - or, more generally, strings that are the values of constant expressions (§15.29) - are 'interned' so as to share unique instances, as if by execution of the method String.intern (§12.5).",10.86,77.14,360.01,443,72,274.06,432.01,351.2,FALSE,FALSE
77,3,BODY,"4.2.4Floating-Point Operations The Java programming language provides a number of operators that act on floating-point values: •The comparison operators, which result in a value of type boolean: –The numerical comparison operators <, <=, >, and >= (§15.20.1) –The numerical equality operators == and != (§15.21.1) •The numerical operators, which result in a value of type float or double: –The unary plus and minus operators + and - (§15.15.3, §15.15.4) –The multiplicative operators *, /, and % (§15.17) –The additive operators + and - (§15.18.2) –The increment operator ++, both prefix (§15.15.1) and postfix (§15.14.2) –The decrement operator --, both prefix (§15.15.2) and postfix (§15.14.3) •The conditional operator ? : (§15.25) •The cast operator (§15.16), which can convert from a floating-point value to a value of any specified numeric type •The string concatenation operator + (§15.18.1), which, when given a String operand and a floating-point operand, will convert the floating-point operand to a String representing its value in decimal form (without information loss), and then produce a newly created String by concatenating the two strings Other useful constructors, methods, and constants are predefined in the classes Float, Double, and Math. If at least one of the operands to a binary operator is of floating-point type, then the operation is a floating-point operation, even if the other operand is integral.",10.86,384.11,360.01,1430,72,216.09,432.01,600.2,FALSE,FALSE
100,3,BODY,"4.10Subtyping The subtype and supertype relations are binary relations on types. The supertypes of a type are obtained by reflexive and transitive closure over the direct supertype relation, written S >1 T, which is defined by rules given later in this section. We write S :> T to indicate that the supertype relation holds between S and T. S is a proper supertype of T, written S > T, if S :> T and S ≠ T. The subtypes of a type T are all types U such that T is a supertype of U, and the null type. We write T <: S to indicate that that the subtype relation holds between types T and S. T is a proper subtype of S, written T < S, if T <: S and S ≠ T. T is a direct subtype of S, written T <1 S, if S >1 T. Subtyping does not extend through parameterized types: T <: S does not imply that C<T> <: C<S>.",10.86,228.64,360.01,802,72,135.56,432.01,364.2,FALSE,FALSE
154,2,BODY,"•an unboxing conversion (§5.1.8) •an unboxing conversion followed by a widening primitive conversion If the expression has the null type, then the expression may be cast to any reference type. If a casting context makes use of a narrowing reference conversion that is checked or partially unchecked (§5.1.6.2, §5.1.6.3), then a run time check will be performed on the class of the expression's value, possibly causing a ClassCastException. Otherwise, no run time check is performed. The following tables enumerate which conversions are used in certain casting contexts. Each conversion is signified by a symbol: •- signifies no conversion allowed •≈ signifies identity conversion (§5.1.1) •ω signifies widening primitive conversion (§5.1.2) •η signifies narrowing primitive conversion (§5.1.3) •ωη signifies widening and narrowing primitive conversion (§5.1.4) •⇑ signifies widening reference conversion (§5.1.5) •⇓ signifies narrowing reference conversion (§5.1.6) •⊕ signifies boxing conversion (§5.1.7) •⊗ signifies unboxing conversion (§5.1.8) In the tables, a comma between symbols indicates that a casting context uses one conversion followed by another. The type Object means any reference type other than the eight wrapper classes Boolean, Byte, Short, Character, Integer, Long, Float, Double.",10.86,376.14,360.01,1301,72,76.06,432.01,452.2,FALSE,FALSE
192,2,BODY,"•any type named n imported by a type-import-on-demand declaration in c •any type named n imported by a static-import-on-demand declaration in c A single-static-import declaration d in a compilation unit c of package p that imports a field named n shadows the declaration of any static field named n imported by a static-import-on-demand declaration in c, throughout c. A single-static-import declaration d in a compilation unit c of package p that imports a method named n with signature s shadows the declaration of any static method named n with signature s imported by a static-import-on-demand declaration in c, throughout c. A single-static-import declaration d in a compilation unit c of package p that imports a type named n shadows, throughout c, the declarations of: •any static type named n imported by a static-import-on-demand declaration in c; •any top level type (§7.6) named n declared in another compilation unit (§7.3) of p; •any type named n imported by a type-import-on-demand declaration (§7.5.2) in c.",10.86,243.14,360,1022,72,76.06,432,319.2,FALSE,FALSE
198,2,BODY,"argument of a parameterized type) in the 17 contexts where types are used (§4.11): 1.In an extends or implements clause of a class declaration (§8.1.4, §8.1.5) 2.In an extends clause of an interface declaration (§9.1.3) 3.The return type of a method (§8.4.5, §9.4), including the type of an element",10.86,76.14,350,298,82,76.06,432,152.2,FALSE,FALSE
230,5,BODY,"An ordinary compilation unit consists of three parts, each of which is optional: •A package declaration (§7.4), giving the fully qualified name (§6.7) of the package to which the compilation unit belongs. A compilation unit that has no package declaration is part of an unnamed package (§7.4.2). •import declarations (§7.5) that allow classes and interfaces from other packages, and static members of classes and interfaces, to be referred to using their simple names. •Top level declarations of classes and interfaces (§7.6). A modular compilation unit consists of a module declaration (§7.7), optionally preceded by import declarations. The import declarations allow classes and interfaces from packages in this module and other modules, as well as static members of classes and interfaces, to be referred to using their simple names within the module declaration. Every compilation unit implicitly imports every public class or interface declared in the predefined package java.lang, as if the declaration import java.lang.*; appeared at the beginning of each compilation unit immediately after any package declaration. As a result, the names of all those classes and interfaces are available as simple names in every compilation unit. The host system determines which compilation units are observable, except for the compilation units in the predefined package java and its subpackages lang and io, which are all always observable.",10.86,321.14,360,1435,72,282.06,432,603.2,FALSE,FALSE
249,3,BODY,"7.7.3Service Consumption The uses directive specifies a service for which code in the current module may discover providers via java.util.ServiceLoader. It is a compile-time error if a uses directive specifies an enum class (§8.9). The service may be declared in the current module or in another module. If the service is not declared in the current module, then the service must be accessible to code in the current module (§6.6), or a compile-time error occurs. It is a compile-time error if more than one uses directive in a module declaration specifies the same service.",10.86,136.11,360,574,72,455.09,432,591.2,FALSE,FALSE
250,2,BODY,"7.7.4Service Provision The provides directive specifies a service for which the with clause specifies one or more service providers to java.util.ServiceLoader. It is a compile-time error if a provides directive specifies an enum class (§8.9) as the service. The service may be declared in the current module or in another module. If the service is not declared in the current module, then the service must be accessible to code in the current module (§6.6), or a compile-time error occurs. Every service provider must be a public class or interface that is either top level or static, or a compile-time error occurs. Every service provider must be declared in the current module, or a compile-time error occurs. If a service provider explicitly declares a public constructor with no formal parameters, or implicitly declares a public default constructor (§8.8.9), then that constructor is called the provider constructor. If a service provider explicitly declares a public static method called provider with no formal parameters, then that method is called the provider method. If a service provider has a provider method, then its return type must (i) either be declared in the current module, or be declared in another module and be accessible to code in the current module; and (ii) be a subtype of the service specified in the provides directive; or a compile-time error occurs.",10.86,316.11,360,1382,72,76.09,432,392.2,FALSE,FALSE
273,4,BODY,"If a sealed class C is associated with a named module (§7.3), then every class specified in the permits clause of C's declaration must be associated with the same module as C, or a compile-time error occurs. If a sealed class C is associated with an unnamed module (§7.7.5), then every class specified in the permits clause of C's declaration must belong to the same package as C, or a compile-time error occurs.",10.86,77.14,360.01,412,72,248.06,432.01,325.2,FALSE,FALSE
311,4,BODY,"An instance method mC declared in or inherited by class C, overrides from C another method mI declared in interface I, iff all of the following are true: •I is a superinterface of C.",10.86,38.14,360,182,72,556.2,432,594.33,FALSE,FALSE
315,10,BODY,"8.4.8.3Requirements in Overriding and Hiding If a method declaration d1 with return type R1 overrides or hides the declaration of another method d2 with return type R2, then d1 must be return-type-substitutable (§8.4.5) for d2, or a compile-time error occurs.",10.86,52.2,360,259,72,456.13,432,508.33,FALSE,FALSE
386,9,BODY,"The @Repeatable annotation cannot be repeated, so only one containing annotation interface can be specified by a repeatable annotation interface.",10.86,19.14,360.01,145,72,375.06,432.01,394.2,FALSE,FALSE
449,5,BODY,"12.3.3Resolution of Symbolic References The binary representation of a class or interface references other classes and interfaces and their fields, methods, and constructors symbolically, using the binary names (§13.1) of the other classes and interfaces. For fields and methods, these symbolic references include the name of the class or interface of which the field or method is a member, as well as the name of the field or method itself, together with appropriate type information. Before a symbolic reference can be used it must undergo resolution, wherein a symbolic reference is checked to be correct and, typically, replaced with a direct reference that can be more efficiently processed if the reference is used repeatedly. If an error occurs during resolution, then an error will be thrown. Most typically, this will be an instance of one of the following subclasses of the class IncompatibleClassChangeError, but it may also be an instance of some other subclass of IncompatibleClassChangeError or even an instance of the class IncompatibleClassChangeError itself. This error may be thrown at any point in the program that uses a symbolic reference, directly or indirectly:",10.86,221.11,360.01,1184,72,378.09,432.01,599.2,FALSE,FALSE
450,6,BODY,"•NoSuchFieldError: A symbolic reference has been encountered that refers to a specific field of a specific class or interface, but the class or interface does not contain a field of that name.",10.86,32.14,360,192,72,299.06,432,331.2,FALSE,FALSE
471,2,BODY,"declared (§9.2)) in a (possibly distinct) class or interface D, we define the qualifying class or interface of the method invocation as follows: •If D is Object then the qualifying class or interface of the method invocation is Object. •Otherwise: –If the method is referenced by a simple name, then if m is a member of the current class or interface C, let Q be C; otherwise, let Q be the innermost lexically enclosing class or interface declaration of which m is a member. In either case, Q is the qualifying class or interface of the method invocation. –If the expression is of the form TypeName.m or ReferenceType::m, then the class or interface denoted by TypeName, or the erasure of ReferenceType, is the qualifying class or interface of the method invocation. –If the expression is of the form ExpressionName.m or Primary.m or ExpressionName::m or Primary::m, then: ›If the compile-time type of ExpressionName or Primary is an intersection type V1 & ... & Vn, then the qualifying class or interface of the method invocation is the erasure of V1. ›Otherwise, the erasure of the compile-time type of ExpressionName or Primary is the qualifying class or interface of the method invocation. –If the expression is of the form super.m or super::m, then the superclass of C is the qualifying class or interface of the method invocation. –If the expression is of the form TypeName.super.m or TypeName.super::m, then if TypeName denotes a class X, the superclass of X is the qualifying class or interface of the method invocation; if TypeName denotes an interface X, X is the qualifying class or interface of the method invocation.",10.86,398.14,342.01,1629,90,76.06,432.01,474.2,FALSE,FALSE
517,3,BODY,"A switch block can consist of either: •Switch rules, which use -> to introduce either a switch rule expression, a switch rule block, or a switch rule throw statement; or •Switch labeled statement groups, which use : to introduce switch labeled block statements. Every switch rule and switch labeled statement group starts with a switch label, which is either a case label or a default label. Multiple switch labels are permitted for a switch labeled statement group. A case label has either a (non-empty) list of case constants, a null literal, or a (non-empty) list of case patterns. Every case constant must be either a constant expression (§15.29), or the name of an enum constant (§8.9.1), otherwise a compile-time error occurs. A case label with a null literal may have an optional default. A case label with case patterns may have an optional when expression, known as a guard, which represents a further test on values that match the patterns. A case",10.86,230.14,360.01,957,72,363.06,432.01,593.2,FALSE,FALSE
521,4,BODY,"•A case label with a case constant c is dominated if one of the following holds: –c is a constant expression of a primitive type S, and there is a preceding case label in the switch block with an unguarded case pattern p, where p is unconditional for the wrapper class of S. –c is a constant expression of a reference type T, and there is a preceding case label in the switch block with an unguarded case pattern p, where p is unconditional for the type T. –c names an enum constant of enum class E, and there is a preceding case label in the switch block with an unguarded case pattern p, where p is unconditional for the type E.",10.86,141.14,360,630,72,236.06,432,377.2,FALSE,FALSE
536,7,BODY,"The Expression must have type boolean or Boolean, or a compile-time error occurs. A do statement is executed by first executing the Statement. Then there is a choice:",10.86,38.14,360.01,166,72,468.06,432.01,506.2,FALSE,FALSE
541,7,BODY,"sequence from left to right; their values, if any, are discarded. If the ForUpdate is not present, no action is taken. 2.Second, another for iteration step is performed. –If the for statement does not have label L, the for statement completes abruptly because of a continue with label L.",10.86,76.14,350,287,82,443.2,432,519.33,FALSE,FALSE
544,2,BODY,"•If the type of Expression is a subtype of Iterable, then the basic for statement has this form:",10.86,19.14,360,96,72,76.06,432,95.2,FALSE,FALSE
558,3,BODY,"14.20.1Execution of try-catch A try statement without a finally block is executed by first executing the try block. Then there is a choice: •If execution of the try block completes normally, then no further action is taken and the try statement completes normally. •If execution of the try block completes abruptly because of a throw of a value V, then there is a choice: –If the run-time type of V is assignment compatible with (§5.2) a catchable exception class of any catch clause of the try statement, then the first (leftmost) such catch clause is selected. The value V is assigned to the parameter of the selected catch clause, and the Block of that catch clause is executed, and then there is a choice: ›If that block completes normally, then the try statement completes normally. ›If that block completes abruptly for any reason, then the try statement completes abruptly for the same reason.",10.86,239.11,360,900,72,192.09,432,431.2,FALSE,FALSE
566,3,BODY,"•If the initialization of the resource completes normally, and the try block completes normally, and the automatic closing of the resource completes abruptly because of a throw of a value V, then the try-with-resources statement completes abruptly because of a throw of the value V. In a basic try-with-resources statement that manages multiple resources: •If the initialization of a resource completes abruptly because of a throw of a value V, then: –If the automatic closings of all successfully initialized resources (possibly zero) complete normally, then the try-with-resources statement completes abruptly because of a throw of the value V. –If the automatic closings of all successfully initialized resources (possibly zero) complete abruptly because of throws of values V1...Vn, then the try- with-resources statement completes abruptly because of a throw of the value V, with any remaining values V1...Vn added to the suppressed exception list of V. •If the initialization of all resources completes normally, and the try block completes abruptly because of a throw of a value V, then: –If the automatic closings of all initialized resources complete normally, then the try-with-resources statement completes abruptly because of a throw of the value V. –If the automatic closings of one or more initialized resources complete abruptly because of throws of values V1...Vn, then the try-with-resources statement completes abruptly because of a throw of the value V, with any remaining values V1...Vn added to the suppressed exception list of V.",10.86,334.14,360.01,1551,72,243.06,432.01,577.2,FALSE,FALSE
629,6,BODY,"Suppose that a field access expression T.super.f appears within class C, and the immediate superclass of the class denoted by T is a class whose fully qualified name",10.86,19.14,360,165,72,562.06,432,581.2,FALSE,FALSE
701,8,BODY,"The equality operators are commutative if the operand expressions have no side effects. The equality operators are analogous to the relational operators except for their lower precedence. Thus, a<b==c<d is true whenever a<b and c<d have the same truth value. The equality operators may be used to compare two operands that are convertible (§5.1.8) to numeric type, or two operands of type boolean or Boolean, or two operands that are each of either reference type or the null type. All other cases result in a compile-time error. The type of an equality expression is always boolean. In all cases, a!=b produces the same result as !(a==b).",10.86,160.14,360,639,72,320.06,432,480.2,FALSE,FALSE
707,2,BODY,"Thus, || computes the same result as | on boolean or Boolean operands. It differs only in that the right-hand operand expression is evaluated conditionally rather than always.",10.86,32.14,360.01,175,72,76.06,432.01,108.2,FALSE,FALSE
764,2,BODY,"16.2.9switch Statements •V is [un]assigned after a switch statement (§14.11) iff all of the following are true: –V is [un]assigned before every break statement (§14.15) that may exit the switch statement. –For each switch rule (§14.11.1) in the switch block, V is [un]assigned after the switch rule expression, switch rule block, or switch rule throw statement introduced by the switch rule. –If there is a switch labeled statement group in the switch block, then V is [un]assigned after the last block statement of the last switch labeled statement group. –If the switch statement is not exhaustive (§14.11.1.1), or if the switch block ends with a switch label followed by the } separator, then V is [un]assigned after the selector expression.",10.86,207.11,360.01,744,72,76.09,432.01,283.2,FALSE,FALSE
765,4,BODY,"16.2.11do Statements •V is [un]assigned after do S while (e); (§14.13) iff V is [un]assigned after e when false and V is [un]assigned before every break statement for which the do statement is the break target. •V is definitely assigned before S iff V is definitely assigned before the do statement. •V is definitely unassigned before S iff all of the following are true: –V is definitely unassigned before the do statement. –Assuming V is definitely unassigned before S, V is definitely unassigned after e when true.",10.86,155.11,360,517,72,295.09,432,450.2,FALSE,FALSE
811,2,BODY,"•Otherwise, if there does not exist a potentially applicable method for the method reference when targeting T, the constraint reduces to false. •Otherwise, if the method reference is exact (§15.13.1), then let P1, ..., Pn be the parameter types of the function type of T, and let F1, ..., Fk be the parameter types of the potentially applicable method. The constraint reduces to a new set of constraints, as follows: –In the special case where n = k+1, the parameter of type P1 is to act as the target reference of the invocation. The method reference expression necessarily has the form ReferenceType :: [TypeArguments] Identifier. The constraint reduces to ‹P1 <: ReferenceType› and, for all i (2 ≤ i ≤ n), ‹Pi → Fi-1›. In all other cases, n = k, and the constraint reduces to, for all i (1 ≤ i ≤ n), ‹Pi → Fi›. –If the function type's result is not void, let R be its return type. Then, if the result of the potentially applicable compile-time declaration is void, the constraint reduces to false. Otherwise, the constraint reduces to ‹R' → R›, where R' is the result of applying capture conversion (§5.1.10) to the return type of the potentially applicable compile-time declaration. •Otherwise, the method reference is inexact, and: –If one or more of the function type's parameter types is not a proper type, the constraint reduces to false.",10.86,289.14,360.01,1346,72,76.06,432.01,365.2,FALSE,FALSE
832,2,BODY,"•For ‹ConditionalExpression → T›: Where the conditional expression has the form e1 ? e2 : e3, the input variables are the input variables of ‹e2 → T› and ‹e3 → T›. •For ‹SwitchExpression → T›: Where the switch expression has result expressions e1, ..., en, the input variables are, for all i (1 ≤ i ≤ n), the input variables of ‹ei → T›. •For all other constraint formulas, there are no input variables. The output variables of these constraints are all inference variables mentioned by the type on the right-hand side of the constraint, T, that are not input variables.",10.86,140.14,360.01,570,72,76.06,432.01,216.2,FALSE,FALSE
837,3,BODY,"3.A type T' is derived from T, as follows:",10.86,6.14,192.77,42,72,206.06,264.77,212.2,FALSE,FALSE
43,2,BODY,•// text An end-of-line comment: all the text from the ASCII characters // to the end of the line is ignored (as in C++). Comment: TraditionalComment EndOfLineComment TraditionalComment: / * CommentTail CommentTail: * CommentTailStar NotStar CommentTail CommentTailStar: / * CommentTailStar NotStarNotSlash CommentTail NotStar: InputCharacter but not * LineTerminator NotStarNotSlash: InputCharacter but not * or / LineTerminator EndOfLineComment: / / {InputCharacter},10.85,375.38,360,468,72,76.06,432,451.44,FALSE,TRUE
49,5,BODY,An integer literal is of type long if it is suffixed with an ASCII letter L or l (ell); otherwise it is of type int (§4.2.1).,10.85,19.14,360,125,72,531.06,432,550.2,FALSE,FALSE
58,3,BODY,"A floating-point literal is of type float if it is suffixed with an ASCII letter F or f; otherwise its type is double and it can optionally be suffixed with an ASCII letter D or d. The elements of the types float and double are those values that can be represented using the IEEE 754 binary32 and IEEE 754 binary64 floating-point formats, respectively (§4.2.3).",10.85,77.14,360,361,72,263.06,432,340.2,FALSE,FALSE
103,3,BODY,"•For any element G of MEC that is a generic type: Let the 'relevant' parameterizations of G, Relevant(G), be: Relevant(G) = { V | 1 ≤ i ≤ k: V in ST(Ui) and V = G<...> }",10.85,45.17,265.3,169,72,166.06,337.3,211.23,FALSE,FALSE
135,10,BODY,"•An interface named I is disjoint from a class named C if C is disjoint from I. •A class named C is disjoint from another class named D if (i) it is not the case that C <: D, and (ii) it is not the case that D <: C.",10.85,38.14,360,215,72,505.06,432,543.2,FALSE,FALSE
186,3,BODY,"6.3.2.3while Statements The following rules apply to a statement while (e) S (§14.12): •A pattern variable introduced by e when true is definitely matched at S. •A pattern variable is introduced by while (e) S iff (i) it is introduced by e when false and (ii) S does not contain a reachable break statement for which the while statement is the break target (§14.15). 6.3.2.4do Statements The following rule applies to a statement do S while (e) (§14.13): •A pattern variable is introduced by do S while (e) iff (i) it is introduced by e when false and (ii) S does not contain a reachable break statement for which the do statement is the break target (§14.15). 6.3.2.5for Statements The following rules apply to a basic for statement (§14.14.1): •A pattern variable introduced by the condition expression when true is definitely matched at both the incrementation part and the contained statement. •A pattern variable is introduced by a basic for statement iff (i) it is introduced by the condition expression when false and (ii) the contained statement, S, does not contain a reachable break for which the basic for statement is the break target (§14.15). An enhanced for statement (§14.14.2) is defined by translation to a basic for statement, so no special rules need to be provided for it. 6.3.2.6switch Statements The following rule applies to a switch statement with a switch block consisting of switch rules (§14.11.1): •A pattern variable introduced by a switch label is definitely matched in the associated switch rule expression, switch rule block, or switch rule throw statement.",10.85,456.6,360.01,1590,72,140.13,432.01,596.73,FALSE,FALSE
197,4,BODY,6.To the left of the ( in a constructor declaration (§8.8) 7.After the @ sign in an annotation (§9.7) 8.To the left of .class in a class literal (§15.8.2) 9.To the left of .this in a qualified this expression (§15.8.4) 10.To the left of .super in a qualified superclass field access expression,10.85,82.14,350,293,82,203.06,432,285.2,FALSE,FALSE
272,10,BODY,It is a compile-time error if a class declaration has a permits clause but no sealed modifier.,10.85,19.14,360,94,72,554.06,432,573.2,FALSE,FALSE
288,7,BODY,"8.3.1.4volatile Fields The Java programming language allows threads to access shared variables (§17.1). As a rule, to ensure that shared variables are consistently and reliably updated, a thread should ensure that it has exclusive use of such variables by obtaining a lock that, conventionally, enforces mutual exclusion for those shared variables. The Java programming language provides a second mechanism, volatile fields, that is more convenient than locking for some purposes. A field may be declared volatile, in which case the Java Memory Model ensures that all threads see a consistent value for the variable (§17.4). It is a compile-time error if a final variable is also declared volatile.",10.85,148.2,360.01,698,72,424.39,432.01,572.6,FALSE,FALSE
308,4,BODY,The relationship between the throws clause of a method and the throws clauses of overridden or hidden methods is specified in §8.4.8.3.,10.85,19.14,360,135,72,270.06,432,289.2,FALSE,FALSE
353,3,BODY,"•A method public final int hashCode() that returns a hash code value derived from the hash code values at every record component of R. The hash code value of an instance a of a record class at a record component c is as follows: –If the type of the record component c is a reference type, then the hash code value is determined as if by invoking the hashCode method on the value of the component field c of a. –If the type of the record component c is a primitive type T, then the hash code value is determined as if by subjecting the value of the component field c of a to boxing conversion (§5.1.7) and then invoking the method hashCode of the wrapper class corresponding to T on the resulting object.",10.85,154.14,360.01,703,72,176.06,432.01,330.2,FALSE,FALSE
361,6,BODY,"9.1.1.2strictfp Interfaces The strictfp modifier on an interface declaration is obsolete and should not be used in new code. Its presence or absence has no effect at compile time or run time. 9.1.1.3static Interfaces A nested interface is implicitly static. That is, every member interface and local interface is static. It is permitted for the declaration of a member interface to redundantly specify the static modifier (§9.5), but it is not permitted for the declaration of a local interface (§14.3). Because a nested interface is static, it has no immediately enclosing instance (§8.1.3). References from a nested interface to type parameters, instance variables, local variables, formal parameters, exception parameters, or instance methods in lexically enclosing class, interface, or method declarations are disallowed (§6.5.5.1, §6.5.6.1, §15.12.3).",10.85,196.34,360,856,72,374.26,432,570.6,FALSE,FALSE
365,2,BODY,"It is a compile-time error if an interface declaration has a permits clause but no sealed modifier. Every TypeName must name an accessible class or interface (§6.6), or a compile- time error occurs. It is a compile-time error if the same class or interface is specified more than once in a permits clause. This is true even if the class or interface is named in different ways.",10.85,96.14,360,377,72,76.06,432,172.2,FALSE,FALSE
394,2,BODY,"•Unchecked warnings (§4.8, §5.1.6, §5.1.9, §8.4.1, §8.4.8.3, §15.12.4.2, §15.13.2, §15.27.3) are specified by the string 'unchecked'. •Deprecation warnings (§9.6.4.6) are specified by the string 'deprecation'. •Removal warnings (§9.6.4.6) are specified by the string 'removal'. •Preview warnings (§1.5) are specified by the string 'preview'. Any other string specifies a non-standard warning. A Java compiler must ignore any such string that it does not recognize.",10.85,108.14,360,464,72,76.06,432,184.2,FALSE,FALSE
408,8,BODY,"A functional interface is an interface that is not declared sealed and has just one abstract method (aside from the methods of Object), and thus represents a single function contract. This 'single' method may take the form of multiple abstract methods with override-equivalent signatures inherited from superinterfaces; in this case, the inherited methods logically represent a single method. For an interface I that is not declared sealed, let M be the set of abstract methods that are members of I that do not have the same signature as any public instance method of the class Object (§4.3.2). Then, I is a functional interface if there exists a method m in M for which both of the following are true: •The signature of m is a subsignature (§8.4.2) of every method's signature in M. •m is return-type-substitutable (§8.4.5) for every method in M.",10.85,154.14,360.01,848,72,417.06,432.01,571.2,FALSE,FALSE
435,3,BODY,"A throw statement whose thrown expression is a final or effectively final exception parameter of a catch clause C can throw an exception class E iff: •E is an exception class that the try block of the try statement which declares C can throw; and •E is assignment compatible with any of C's catchable exception classes; and •E is not assignment compatible with any of the catchable exception classes of the catch clauses declared to the left of C in the same try statement. A try statement (§14.20) can throw an exception class E iff either: •The try block can throw E, or an expression used to initialize a resource (in a try-with-resources statement) can throw E, or the automatic invocation of the close() method of a resource (in a try-with-resources statement) can throw E, and E is not assignment compatible with any catchable exception class of any catch clause of the try statement, and either no finally block is present or the finally block can complete normally; or •Some catch block of the try statement can throw E and either no finally block is present or the finally block can complete normally; or •A finally block is present and can throw E. An explicit constructor invocation statement (§8.8.7.1) can throw an exception class E iff either: •Some expression of the constructor invocation's parameter list can throw E; or •E is determined to be an exception class of the throws clause of the constructor that is invoked (§15.12.2.6). A switch statement (§14.11) can throw an exception class E iff either: •The selector expression can throw E; or •Some switch rule expression, switch rule block, switch rule throw statement, or switch labeled statement group in the switch block can throw E. Any other statement S can throw an exception class E iff an expression or statement immediately contained in S can throw E.",10.85,441.14,360.01,1830,72,118.06,432.01,559.2,FALSE,FALSE
450,8,BODY,"•NoSuchMethodError: A symbolic reference has been encountered that refers to a specific method of a specific class or interface, but the class or interface does not contain a method of that signature.",10.85,32.14,360,200,72,376.06,432,408.2,FALSE,FALSE
454,7,BODY,"5.If the Class object for C is in an erroneous state, then initialization is not",10.85,6.14,359.99,80,72,467.06,431.99,473.2,FALSE,FALSE
454,9,BODY,"6.Otherwise, record the fact that initialization of the Class object for C is in",10.85,6.14,360,80,72,499.06,432,505.2,FALSE,FALSE
455,2,BODY,"the superinterface hierarchy of each interface directly implemented by C (in the left-to-right order of C's implements clause). For each interface I directly implemented by C, the enumeration recurs on I's superinterfaces (in the left- to-right order of I's extends clause) before returning I. For each S in the list [ SC, SI1, ..., SIn ], if S has not yet been initialized, then recursively perform this entire procedure for S. If necessary, verify and prepare S first. If the initialization of S completes abruptly because of a thrown exception, then acquire LC, label the Class object for C as erroneous, notify all waiting threads, release LC, and complete abruptly, throwing the same exception that resulted from initializing S.",10.85,148.14,342.01,733,90,76.06,432.01,224.2,FALSE,FALSE
491,11,BODY,"13.4.18native Methods Adding or deleting a native modifier of a method does not break compatibility with pre-existing binaries. The impact of changes to types on pre-existing native methods that are not recompiled is beyond the scope of this specification and should be provided with the description of an implementation. Implementations are encouraged, but not required, to implement native methods in a way that limits such impact.",10.85,98.11,360,433,72,491.09,432,589.2,FALSE,FALSE
495,7,BODY,Deleting the sealed modifier from an interface that does not have a sealed direct superinterface does not break compatibility with pre-existing binaries.,10.85,19.14,360,153,72,530.06,432,549.2,FALSE,FALSE
512,4,BODY,IfThenStatement: if ( Expression ) Statement IfThenElseStatement: if ( Expression ) StatementNoShortIf else Statement IfThenElseStatementNoShortIf: if ( Expression ) StatementNoShortIf else StatementNoShortIf,10.85,93.05,292.14,208,90,223.13,382.14,316.18,FALSE,TRUE
516,6,BODY,"14.11.1Switch Blocks The body of both a switch statement and a switch expression (§15.28) is called a switch block. This subsection presents general rules which apply to all switch blocks, whether they appear in switch statements or switch expressions. Other subsections present additional rules which apply either to switch blocks in switch statements (§14.11.2) or to switch blocks in switch expressions (§15.28.1).",10.85,79.11,360,417,72,429.09,432,508.2,FALSE,FALSE
548,5,BODY,"A continue statement may occur only in a while, do, or for statement; statements of these three kinds are called iteration statements. Control passes to the loop- continuation point of an iteration statement.",10.85,32.14,360,208,72,318.06,432,350.2,FALSE,FALSE
553,1,BODY,"If a throw statement is contained in a constructor declaration, but its value is not caught by some try statement that contains it, then the class instance creation expression that invoked the constructor will complete abruptly because of the throw (§15.9.4). If a throw statement is contained in a static initializer (§8.7), then a compile-time check (§11.2.3) ensures that either its value is always an unchecked exception or its value is always caught by some try statement that contains it. If at run time, despite this check, the value is not caught by some try statement that contains the throw statement, then the value is rethrown if it is an instance of class Error or one of its subclasses; otherwise, it is wrapped in an ExceptionInInitializerError object, which is then thrown (§12.4.2). If a throw statement is contained in an instance initializer (§8.6), then a compile- time check (§11.2.3) ensures that either its value is always an unchecked exception or its value is always caught by some try statement that contains it, or the type of the thrown exception (or one of its superclasses) occurs in the throws clause of every constructor of the class.",10.85,213.14,360,1166,72,76.06,432,289.2,FALSE,FALSE
556,2,BODY,"It is a compile-time error if final appears more than once as a modifier for an exception parameter declaration. The scope and shadowing of an exception parameter is specified in §6.3 and §6.4. References to an exception parameter from a nested class or interface, or a lambda expression, are restricted, as specified in §6.5.6.1. An exception parameter may denote its type as either a single class type or a union of two or more class types (called alternatives). The alternatives of a union are syntactically separated by |. A catch clause whose exception parameter is denoted as a single class type is called a uni-catch clause. A catch clause whose exception parameter is denoted as a union of types is called a multi-catch clause. Each class type used in the denotation of the type of an exception parameter must be the class Throwable or a subclass of Throwable, or a compile-time error occurs. It is a compile-time error if a type variable is used in the denotation of the type of an exception parameter. It is a compile-time error if a union of types contains two alternatives Di and Dj (i ≠ j) where Di is a subtype of Dj (§4.10.2). The declared type of an exception parameter that denotes its type with a single class type is that class type. The declared type of an exception parameter that denotes its type as a union with alternatives D1 | D2 | ... | Dn is lub(D1, D2, ..., Dn). An exception parameter of a multi-catch clause is implicitly declared final if it is not explicitly declared final. It is a compile-time error if an exception parameter that is implicitly or explicitly declared final is assigned to within the body of the catch clause. An exception parameter of a uni-catch clause is never implicitly declared final, but it may be explicitly declared final or be effectively final (§4.12.4).",10.85,435.14,360.01,1816,72,76.06,432.01,511.2,FALSE,FALSE
560,2,BODY,"selected catch clause, and the Block of that catch clause is executed. Then there is a choice: ›If the catch block completes normally, then the finally block is executed. Then there is a choice: »If the finally block completes normally, then the try statement completes normally. »If the finally block completes abruptly for any reason, then the try statement completes abruptly for the same reason.",10.85,115.14,340,399,92,76.06,432,191.2,FALSE,FALSE
573,2,BODY,"•A try statement can complete normally iff both of the following are true: –The try block can complete normally or any catch block can complete normally. –If the try statement has a finally block, then the finally block can complete normally.",10.85,70.14,360,242,72,76.06,432,146.2,FALSE,FALSE
576,4,BODY,"Pattern: TypePattern RecordPattern TypePattern: LocalVariableDeclaration RecordPattern: ReferenceType ( [ComponentPatternList] ) ComponentPatternList: ComponentPattern {, ComponentPattern } ComponentPattern: Pattern MatchAllPattern MatchAllPattern: _",10.85,228.75,203.2,250,90,263.13,293.2,491.88,FALSE,TRUE
601,4,BODY,"15.8.3this The keyword this may be used as an expression in the following contexts: •in the body of an instance method of a class (§8.4.3.2) •in the body of a constructor of a class (§8.8.7) •in an instance initializer of a class (§8.6) •in the initializer of an instance variable of a class (§8.3.2) •in the body of an instance method of an interface, that is, a default method or a non-static private interface method (§9.4) When used as an expression, the keyword this denotes a value that is a reference either to the object for which the instance method was invoked (§15.12), or to the object being constructed. The value denoted by this in a lambda body (§15.27.2) is the same as the value denoted by this in the surrounding context.",10.85,193.11,360,739,72,338.09,432,531.2,FALSE,FALSE
674,3,BODY,"If unchecked conversion was necessary for the compile-time declaration to be applicable, and this conversion would cause an unchecked warning in an invocation context, then a compile-time unchecked warning occurs, unless suppressed by @SuppressWarnings (§9.6.4.5). If unchecked conversion was necessary for the return type R', described above, to be compatible with the function type's return type, R, and this conversion would cause an unchecked warning in an assignment context, then a compile-time unchecked warning occurs, unless suppressed by @SuppressWarnings. If a method reference expression is compatible with a target type T, then the type of the expression, U, is the ground target type derived from T. It is a compile-time error if any class or interface mentioned by either U or the function type of U is not accessible (§6.6) from the class or interface in which the method reference expression appears.",10.85,180.14,360.01,917,72,398.06,432.01,578.2,FALSE,FALSE
742,4,BODY,"The result expressions of a switch expression are determined as follows: •If the switch block consists of switch rules, then each switch rule is considered in turn: –If the switch rule is of the form ... -> Expression ; then Expression is a result expression of the switch expression. –If the switch rule is of the form ... -> Block then every expression which is immediately contained in a yield statement in Block whose yield target is the given switch expression, is a result expression of the switch expression.",10.85,115.14,360.01,515,72,462.06,432.01,577.2,FALSE,FALSE
743,2,BODY,"•If the switch block consists of switch labeled statement groups, then every expression immediately contained in a yield statement in the switch block whose yield target is the given switch expression, is a result expression of the switch expression. It is a compile-time error if a switch expression has no result expressions. A switch expression is a poly expression if it appears in an assignment context or an invocation context (§5.2, §5.3). Otherwise, it is a standalone expression. Where a poly switch expression appears in a context of a particular kind with target type T, its result expressions similarly appear in a context of the same kind with target type T. A poly switch expression is compatible with a target type T if each of its result expressions is compatible with T. The type of a poly switch expression is the same as its target type. The type of a standalone switch expression is determined as follows: •If the result expressions all have the same type (which may be the null type (§4.1)), then that is the type of the switch expression. •Otherwise, if the type of each result expression is boolean or Boolean, then an unboxing conversion (§5.1.8) is applied to each result expression of type Boolean, and the switch expression has type boolean. •Otherwise, if the type of each result expression is convertible to a numeric type (§5.1.8), then the type of the switch expression is the result of general numeric promotion (§5.6) applied to the result expressions. •Otherwise, boxing conversion (§5.1.7) is applied to each result expression that has a primitive type, after which the type of the switch expression is the result of applying capture conversion (§5.1.10) to the least upper bound (§4.10.4) of the types of the result expressions.",10.85,391.14,360,1764,72,76.06,432,467.2,FALSE,FALSE
754,6,BODY,16.1.5Conditional Operator ? : Suppose that b and c are boolean-valued expressions. •V is [un]assigned after a ? b : c (§15.25) when true iff V is [un]assigned after b when true and V is [un]assigned after c when true. •V is [un]assigned after a ? b : c when false iff V is [un]assigned after b when false and V is [un]assigned after c when false. •V is [un]assigned before a iff V is [un]assigned before a ? b : c. •V is [un]assigned before b iff V is [un]assigned after a when true.,10.85,129.11,360,484,72,472.09,432,601.2,FALSE,FALSE
798,4,BODY,"Given a write w, a freeze f, an action a (that is not a read of a final field), a read r1 of the final field frozen by f, and a read r2 such that hb(w, f), hb(f, a), mc(a, r1), and dereferences(r1, r2), then when determining which values can be seen by r2,",10.85,32.36,360,256,72,547.06,432,579.42,FALSE,FALSE
809,3,BODY,"›If the function type's result is void and the lambda body is neither a statement expression nor a void-compatible block, the constraint reduces to false. ›If the function type's result is not void and the lambda body is a block that is not value-compatible, the constraint reduces to false. ›Otherwise, the constraint reduces to all of the following constraint formulas: »If the lambda parameters have explicitly declared types F1, ..., Fn and the function type has parameter types G1, ..., Gn, then (i) for all i (1 ≤ i ≤ n), ‹Fi = Gi›, and (ii) ‹T' <: T›. »If the function type's return type is a (non-void) type R, assume the lambda's parameter types are the same as the function type's parameter types. Then: •If R is a proper type, and if the lambda body or some result expression in the lambda body is not compatible in an assignment context with R, then false. •Otherwise, if R is not a proper type, then where the lambda body has the form Expression, the constraint ‹Expression → R›; or where the lambda body is a block with result expressions e1, ..., em, for all i (1 ≤ i ≤ m), ‹ei → R›.",10.85,277.17,340.01,1098,92,323.06,432.01,600.23,FALSE,FALSE
328,8,BODY,"The rules concerning annotation modifiers for a constructor declaration are specified in §9.7.4 and §9.7.5. It is a compile-time error if the same keyword appears more than once as a modifier in a constructor declaration, or if a constructor declaration has more than one of the access modifiers public, protected, and private (§6.6).",10.84,64.14,360.01,334,72,535.06,432.01,599.2,FALSE,FALSE
330,3,BODY,8.8.5Constructor Throws The throws clause for a constructor is identical in structure and behavior to the throws clause for a method (§8.4.6).,10.84,40.11,360,142,72,134.09,432,174.2,FALSE,FALSE
340,7,BODY,"Any constructor or member declarations in the body of an enum declaration apply to the enum class exactly as if they had been present in the body of a normal class declaration, unless explicitly stated otherwise. It is a compile-time error if a constructor declaration in an enum declaration is public or protected (§6.6). It is a compile-time error if a constructor declaration in an enum declaration contains a superclass constructor invocation statement (§8.8.7.1).",10.84,96.14,360.01,468,72,476.06,432.01,572.2,FALSE,FALSE
384,8,BODY,9.6.3Repeatable Annotation Interfaces An annotation interface A is repeatable if its declaration is (meta-)annotated with an @Repeatable annotation (§9.6.4.8) whose value element indicates a containing annotation interface of A. An annotation interface AC is a containing annotation interface of A if all of the following are true: 1.AC declares a value() method whose return type is A[]. 2.Any methods declared by AC other than value() have a default value.,10.84,123.11,360,458,72,480.09,432,603.2,FALSE,FALSE
386,4,BODY,It is a compile-time error if an annotation interface A is (meta-)annotated with an @Repeatable annotation whose value element indicates a type which is not a containing annotation interface of A.,10.84,32.14,360,196,72,143.06,432,175.2,FALSE,FALSE
396,3,BODY,"9.6.4.7@SafeVarargs A variable arity parameter with a non-reifiable element type (§4.7) can cause heap pollution (§4.12.2) and give rise to compile-time unchecked warnings (§5.1.9). However, such warnings are uninformative if the body of the variable arity method is well-behaved with respect to the variable arity parameter. The annotation interface SafeVarargs, when used to annotate a method or constructor declaration, makes a programmer assertion that prevents a Java compiler from reporting unchecked warnings for the declaration or invocation of a variable arity method or constructor where the compiler would otherwise do so due to the variable arity parameter having a non-reifiable element type.",10.84,136.2,360.01,705,72,222.13,432.01,358.33,FALSE,FALSE
422,5,BODY,"For an array whose type is A[], where A is a reference type, an assignment to a component of the array is checked at run time to ensure that the value being assigned is assignable to the component. If the type of the value being assigned is not assignment-compatible (§5.2) with the component type, an ArrayStoreException is thrown.",10.84,64.14,360,332,72,294.06,432,358.2,FALSE,FALSE
425,4,BODY,An array thus has the same public fields and methods as the following class:,10.84,6.14,340.66,76,72,300.06,412.66,306.2,FALSE,FALSE
450,4,BODY,"•InstantiationError: A symbolic reference has been encountered that is used in class instance creation expression, but an instance cannot be created because the reference turns out to refer to an interface or to an abstract class.",10.84,32.14,360,230,72,212.06,432,244.2,FALSE,FALSE
518,2,BODY,"label is said to be unguarded if either (i) it has no guard, or (ii) it has a guard that is a constant expression (§15.29) with value true; and guarded otherwise. It is a compile-time error for a case label to have more than one case pattern and declare any pattern variables (other than those declared by a guard associated with the case label).",10.84,64.14,360.01,346,72,76.06,432.01,140.2,FALSE,FALSE
524,3,BODY,"14.11.1.1Exhaustive Switch Blocks The switch block of a switch expression or switch statement is exhaustive for a selector expression e if one of the following cases applies: •There is a default label associated with the switch block. •There is a case null, default label associated with the switch block. •The set containing all the case constants and case patterns appearing in an unguarded case label (collectively known as case elements) associated with the switch block is non-empty and covers the type of the selector expression e. A set of case elements, P, covers a type T if one of the following cases applies: •P covers a type U where T and U have the same erasure. •P contains a pattern that is unconditional for T. •T is a type variable with upper bound B and P covers B. •T is an intersection type T1& ... &Tn and P covers Ti, for one of the types Ti (1≤ i ≤ n). •The type T is an enum class type E and P contains all of the names of the enum constants of E.",10.84,262.2,360,971,72,160.13,432,422.33,FALSE,FALSE
531,4,BODY,"•If the switch statement is an enhanced switch statement, then it must be exhaustive (§14.11.1.1).",10.84,19.14,360,98,72,313.06,432,332.2,FALSE,FALSE
546,7,BODY,"There are two kinds of break statement: •A break statement with no label. •A break statement with the label Identifier. A break statement with no label attempts to transfer control to the innermost enclosing switch, while, do, or for statement; this enclosing statement, which is called the break target, then immediately completes normally. A break statement with label Identifier attempts to transfer control to the enclosing labeled statement (§14.7) that has the same Identifier as its label; this enclosing statement, which is called the break target, then immediately completes normally. In this case, the break target need not be a switch, while, do, or for statement. It is a compile-time error if a break statement has no break target. It is a compile-time error if the break target contains any method, constructor, instance initializer, static initializer, lambda expression, or switch expression that encloses the break statement. That is, there are no non-local jumps. Execution of a break statement with no label always completes abruptly, the reason being a break with no label. Execution of a break statement with label Identifier always completes abruptly, the reason being a break with label Identifier.",10.84,275.14,360.01,1221,72,324.06,432.01,599.2,FALSE,FALSE
571,2,BODY,•A switch statement whose switch block consists of switch labeled statement groups can complete normally iff at least one of the following is true: –The last statement in the switch block can complete normally. –There is at least one switch label after the last switch block statement group. –There is a reachable break statement that exits the switch statement. –The switch statement is not enhanced (§14.11.2) and its switch block does not contain a default label.,10.84,108.14,360,466,72,76.06,432,184.2,FALSE,FALSE
573,3,BODY,"•The try block is reachable iff the try statement is reachable. •A catch block C is reachable iff both of the following are true: –Either the type of C's parameter is an unchecked exception type or Exception or a superclass of Exception, or some expression or throw statement in the try block is reachable and can throw a checked exception whose type is assignment compatible (§5.2) with the type of C's parameter. (An expression is reachable iff the innermost statement containing it is reachable.)",10.84,96.14,360,499,72,159.06,432,255.2,FALSE,FALSE
616,4,BODY,"An anonymous class is always an inner class (§8.1.3). Like a local class or interface (§14.3), an anonymous class is not a member of any package, class, or interface (§7.1, §8.5). The direct superclass type or direct superinterface type of an anonymous class declared by a class instance creation expression is given by the expression (§15.9.1), with type arguments inferred as necessary while choosing a constructor (§15.9.3). If a direct superinterface type is given, the direct superclass type is Object. The direct superclass type of an anonymous class declared by an enum constant is the type of the declaring enum class. The ClassBody of the class instance creation expression or enum constant declares fields (§8.3), methods (§8.4), member classes (§8.5), member interfaces (§9.1.1.3), instance initializers (§8.6), and static initializers (§8.7) of the anonymous class. The constructor of an anonymous class is always implicit (§15.9.5.1). If a class instance creation expression with a ClassBody uses a diamond (<>) for the type arguments of the class to be instantiated, then for all non-private methods declared in the ClassBody, it is as if the method declaration is annotated with @Override (§9.6.4.4).",10.84,257.14,360.01,1215,72,195.06,432.01,452.2,FALSE,FALSE
644,6,BODY,"Let m be a potentially applicable method (§15.12.2.1) with arity n and formal parameter types F1, ..., Fn, and let e1, ..., en be the actual argument expressions of the method invocation. Then: •If m is a generic method and the method invocation does not provide explicit type arguments, then the applicability of the method is inferred as specified in §18.5.1. •If m is a generic method and the method invocation provides explicit type arguments, then let R1, ..., Rp (p ≥ 1) be the type parameters of m, let Bl be the declared bound of Rl (1 ≤ l ≤ p), and let U1, ..., Up be the explicit type arguments given in the method invocation. Then m is applicable by loose invocation if both of the following are true: –For 1 ≤ i ≤ n, if ei is pertinent to applicability (§15.12.2.2) then ei is compatible in a loose invocation context with Fi[R1:=U1, ..., Rp:=Up] (§5.3). –For 1 ≤ l ≤ p, Ul <: Bl[R1:=U1, ..., Rp:=Up]. •If m is not a generic method, then m is applicable by loose invocation if, for 1 ≤ i ≤ n, either ei is compatible in a loose invocation context with Fi (§5.3) or ei is not pertinent to applicability. If no method applicable by loose invocation is found, the search for applicable methods continues with phase 3 (§15.12.2.4). Otherwise, the most specific method (§15.12.2.5) is chosen among the methods that are applicable by loose invocation.",10.84,295.14,360.01,1357,72,278.2,432.01,573.33,FALSE,FALSE
706,5,BODY,"The conditional-or operator is syntactically left-associative (it groups left-to-right). The conditional-or operator is fully associative with respect to both side effects and result value. That is, for any expressions a, b, and c, evaluation of the expression ((a) || (b)) || (c) produces the same result, with the same side effects occurring in the same order, as evaluation of the expression (a) || ((b) || (c)). Each operand of the conditional-or operator must be of type boolean or Boolean, or a compile-time error occurs. The type of a conditional-or expression is always boolean. At run time, the left-hand operand expression is evaluated first; if the result has type Boolean, it is subjected to unboxing conversion (§5.1.8). If the resulting value is true, the value of the conditional-or expression is true and the right-hand operand expression is not evaluated. If the value of the left-hand operand is false, then the right-hand expression is evaluated; if the result has type Boolean, it is subjected to unboxing conversion (§5.1.8). The resulting value becomes the value of the conditional-or expression.",10.84,224.14,360.01,1118,72,358.06,432.01,582.2,FALSE,FALSE
708,2,BODY,"•If both the second and the third operand expressions are boolean expressions, the conditional expression is a boolean conditional expression. For the purpose of classifying a conditional, the following expressions are boolean expressions: –An expression of a standalone form (§15.2) that has type boolean or Boolean. –A parenthesized boolean expression (§15.8.5). –A class instance creation expression (§15.9) for class Boolean. –A method invocation expression (§15.12) for which the chosen most specific method (§15.12.2.5) has return type boolean or Boolean.",10.84,140.14,360,561,72,76.06,432,216.2,FALSE,FALSE
714,3,BODY,"15.25.1Boolean Conditional Expressions Boolean conditional expressions are standalone expressions (§15.2). The type of a boolean conditional expression is determined as follows: •If the second and third operands are both of type Boolean, the conditional expression has type Boolean. •Otherwise, the conditional expression has type boolean.",10.84,97.11,360,339,72,185.09,432,282.2,FALSE,FALSE
797,2,BODY,It will also see versions of any object or array referenced by those final fields that are at least as up-to-date as the final fields are.,10.84,19.14,360,138,72,76.06,432,95.2,FALSE,FALSE
823,4,BODY,"18.5.1Invocation Applicability Inference Given a method invocation that provides no explicit type arguments, the process to determine whether a potentially applicable generic method m is applicable is as follows: •Where P1, ..., Pp (p ≥ 1) are the type parameters of m, let α1, ..., αp be inference variables, and let θ be the substitution [P1:=α1, ..., Pp:=αp]. •An initial bound set, B0, is generated from the declared bounds of P1, ..., Pp, as described in §18.1.3. •For all i (1 ≤ i ≤ p), if Pi appears in the throws clause of m, then the bound throws αi is implied. These bounds, if any, are incorporated with B0 to produce a new bound set, B1. •A set of constraint formulas, C, is generated as follows. Let F1, ..., Fn be the formal parameter types of m, and let e1, ..., ek be the actual argument expressions of the invocation. Then: –To test for applicability by strict invocation: If k ≠ n, or if there exists an i (1 ≤ i ≤ n) such that ei is pertinent to applicability (§15.12.2.2) and either (i) ei is a standalone expression of a primitive type but Fi is a reference type, or (ii) Fi is a primitive type but ei is not a standalone",10.84,277.11,360.01,1142,72,251.09,432.01,528.2,FALSE,FALSE
830,3,BODY,"2.The selected constraint(s) are removed from C. 3.The input variables α1, ..., αm of all the selected constraint(s) are resolved. 4.Where T1, ..., Tm are the instantiations of α1, ..., αm, the substitution",10.84,45.17,350,206,82,211.06,432,256.23,FALSE,FALSE
851,2,BODY,SimpleTypeName: TypeIdentifier ConstructorBody: { [ExplicitConstructorInvocation] [BlockStatements] } ExplicitConstructorInvocation: [TypeArguments] this ( [ArgumentList] ) ; [TypeArguments] super ( [ArgumentList] ) ; ExpressionName . [TypeArguments] super ( [ArgumentList] ) ; Primary . [TypeArguments] super ( [ArgumentList] ) ;,10.84,132.05,298.45,330,90,387.13,388.45,519.18,FALSE,TRUE
108,6,BODY,"4.A type in the throws clause of a method or constructor (§8.4.6, §8.8.5, §9.4) 5.A type in the extends clause of a type parameter declaration of a generic",10.83,25.14,350,155,82,178.06,432,203.2,FALSE,FALSE
119,4,BODY,"4.12.5Initial Values of Variables Every variable in a program must have a value before its value is used: •Each class variable, instance variable, or array component is initialized with a default value when it is created (§15.9, §15.10.2): –For type byte, the default value is zero, that is, the value of (byte)0. –For type short, the default value is zero, that is, the value of (short)0. –For type int, the default value is zero, that is, 0. –For type long, the default value is zero, that is, 0L. –For type float, the default value is positive zero, that is, 0.0f. –For type double, the default value is positive zero, that is, 0.0d. –For type char, the default value is the null character, that is, '\u0000'. –For type boolean, the default value is false. –For all reference types (§4.3), the default value is null. •Each method parameter (§8.4.1) is initialized to the corresponding argument value provided by the invoker of the method (§15.12).",10.83,262.11,360,950,72,333.09,432,595.2,FALSE,FALSE
120,2,BODY,"•Each constructor parameter (§8.8.1) is initialized to the corresponding argument value provided by a class instance creation expression (§15.9) or explicit constructor invocation (§8.8.7). •An exception parameter (§14.20) is initialized to the thrown object representing the exception (§11.3, §14.18). •A local variable declared by a statement (§14.4.2, §14.14.1, §14.14.2, §14.20.3) must be explicitly given a value before it is used, by either initialization (§14.4) or assignment (§15.26), in a way that can be verified using the rules for definite assignment (§16 (Definite Assignment)). A local variable declared by a pattern (§14.30.1) is initialized implicitly, by the process of pattern matching (§14.30.2). Example 4.12.5-1. Initial Values of Variables",10.83,172.74,360.01,762,72,76.06,432.01,248.81,FALSE,FALSE
178,4,BODY,The scope of a parameter of an exception handler that is declared in a catch clause of a try statement (§14.20) is the entire block associated with the catch.,10.83,19.14,360,158,72,360.06,432,379.2,FALSE,FALSE
248,7,BODY,"7.7.2Exported and Opened Packages The exports directive specifies the name of a package to be exported by the current module. For code in other modules, this grants access at compile time and run time to the public and protected types in the package, and the public and protected members of those types (§6.6). It also grants reflective access to those types and members for code in other modules. The opens directive specifies the name of a package to be opened by the current module. For code in other modules, this grants access at run time, but not compile time, to the public and protected types in the package, and the public and protected members of those types. It also grants reflective access to all types in the package, and all their members, for code in other modules.",10.83,150.11,360.01,781,72,439.09,432.01,589.2,FALSE,FALSE
259,5,BODY,"8.1.1.3strictfp Classes The strictfp modifier on a class declaration is obsolete and should not be used in new code. Its presence or absence has no effect at compile time or run time. 8.1.1.4static Classes The static modifier specifies that a nested class is not an inner class (§8.1.3). Just as a static method of a class has no current instance of the class in its body, a static nested class has no immediately enclosing instance in its body. References from a static nested class to type parameters, instance variables, local variables, formal parameters, exception parameters, or instance methods of lexically enclosing class, interface, or method declarations are disallowed (§6.5.5.1, §6.5.6.1, and §15.12.3). The static modifier does not pertain to all nested classes. It pertains only to member classes, whose declarations may use the static modifier, and not to local classes or anonymous classes, whose declarations may not use the static modifier (§14.3, §15.9.5). However, some local classes are implicitly static, namely local enum classes and local record classes, because all nested enum classes and nested record classes are implicitly static (§8.9, §8.10).",10.83,254.34,360,1174,72,222.13,432,476.46,FALSE,FALSE
274,6,BODY,ClassBody: { {ClassBodyDeclaration} } ClassBodyDeclaration: ClassMemberDeclaration InstanceInitializer StaticInitializer ConstructorDeclaration ClassMemberDeclaration: FieldDeclaration MethodDeclaration ClassDeclaration InterfaceDeclaration ;,10.83,182.75,135.32,242,90,336.13,225.32,518.88,FALSE,TRUE
340,2,BODY,"methods declared in these class bodies may be invoked outside the enclosing enum class only if they override accessible methods in the enclosing enum class (§8.4.8). It is a compile-time error for the class body of an enum constant to declare an abstract method. Because there is only one instance of each enum constant, it is permitted to use the == operator in place of the equals method when comparing two object references if it is known that at least one of them refers to an enum constant.",10.83,96.14,360.01,495,72,76.06,432.01,172.2,FALSE,FALSE
352,4,BODY,"A record class provides implementations of all the abstract methods declared in class Record. For each of the following methods, if a record class R does not explicitly declare a method with the same modifiers, name, and signature (§8.4.2), then the method is implicitly declared as follows: •A method public final boolean equals(Object) that returns true if and only if the argument is an instance of R, and the current instance is equal to the argument instance at every record component of R; otherwise false is returned. Equality of an instance a of a record class R with another instance b of the same record class at a record component c is determined as follows: –If the type of the record component c is a reference type, equality is determined as follows: if the value of the component field c of both a and b is the null reference then true is returned; if the value of the component field c of either a or b, but not both, is the null reference then false is returned; otherwise equality is determined by invoking the equals method on the value of the component field c of a, with an argument that is the value of the component field c of b. –If the type of the record component c is a primitive type T, equality is determined as if by invoking the static method compare of the wrapper class",10.83,251.14,360,1302,72,345.06,432,596.2,FALSE,FALSE
412,7,BODY,method in M.,10.83,6.14,55.21,12,100,553.06,155.21,559.2,FALSE,FALSE
454,5,BODY,"4.If the Class object for C indicates that C has already been initialized, then no",10.83,6.14,359.99,82,72,435.06,431.99,441.2,FALSE,FALSE
482,12,BODY,"13.4.7Access to Members and Constructors Changing the declared access of a member or constructor to permit less access may break compatibility with pre-existing binaries, causing a linkage error to be thrown when these binaries are resolved. Less access is permitted if the access modifier is changed from package access to private access; from protected access to package or private access; or from public access to protected,",10.83,79.11,360,427,72,520.09,432,599.2,FALSE,FALSE
486,3,BODY,"13.4.9final Fields and static Constant Variables If a field that was not declared final is changed to be declared final, then it can break compatibility with pre-existing binaries that attempt to assign new values to the field.",10.83,53.11,360.01,227,72,179.09,432.01,232.2,FALSE,FALSE
491,2,BODY,13.4.17final Methods Changing a method that is declared final to no longer be declared final does not break compatibility with pre-existing binaries. Changing an instance method that is not declared final to be declared final may break compatibility with existing binaries that depend on the ability to override the method.,10.83,85.11,360,323,72,76.09,432,161.2,FALSE,FALSE
513,2,BODY,"14.9.2The if-then-else Statement An if-then-else statement is executed by first evaluating the Expression. If the result is of type Boolean, it is subjected to unboxing conversion (§5.1.8). If evaluation of the Expression or the subsequent unboxing conversion (if any) completes abruptly for some reason, then the if-then-else statement completes abruptly for the same reason. Otherwise, execution continues by making a choice based on the resulting value: •If the value is true, then the first contained Statement (the one before the else keyword) is executed; the if-then-else statement completes normally if and only if execution of that statement completes normally. •If the value is false, then the second contained Statement (the one after the else keyword) is executed; the if-then-else statement completes normally if and only if execution of that statement completes normally.",10.83,194.11,360,885,72,76.09,432,270.2,FALSE,FALSE
542,2,BODY,14.14.2The enhanced for statement The enhanced for statement has the form:,10.83,27.11,186.05,74,72,76.09,258.05,103.2,FALSE,FALSE
613,2,BODY,"–If C is not an anonymous class, then cj is chosen as the constructor of C. The throws clause of the chosen constructor is the same as the throws clause determined for mj. The return type corresponding to the chosen constructor is the return type determined for mj (§15.12.2.6). –If C is an anonymous class, then C's anonymous constructor is chosen as the constructor of C. Its body consists of an explicit constructor invocation (§8.8.7.1) of cj. The throws clause of the chosen constructor includes the exceptions in the throws clause determined for mj. The return type corresponding to the chosen constructor is the anonymous class type. If the class instance creation expression is a poly expression, then its compatibility with a target type is as determined by §18.5.2.1, using mj as the selected method m.",10.83,224.14,350,812,82,76.06,432,300.2,FALSE,FALSE
703,4,BODY,"15.21.3Reference Equality Operators == and != If the operands of an equality operator are both of either reference type or the null type, then the operation is object equality. It is a compile-time error if it is impossible to convert the type of either operand to the type of the other by a casting conversion (§5.5). The run-time values of the two operands would necessarily be unequal (ignoring the case where both values are null). At run time, the result of == is true if the operand values are both null or both refer to the same object or array; otherwise, the result is false. The result of != is false if the operand values are both null or both refer to the same object or array; otherwise, the result is true. While == may be used to compare references of type String, such an equality test determines whether or not the two operands refer to the same String object. The result is false if the operands are distinct String objects, even if they contain the same sequence of characters (§3.10.5, §3.10.6). The contents of two strings s and t can be tested for equality by the method invocation s.equals(t).",10.83,233.11,360.01,1116,72,175.09,432.01,408.2,FALSE,FALSE
716,7,BODY,AssignmentExpression: ConditionalExpression Assignment Assignment: LeftHandSide AssignmentOperator Expression LeftHandSide: ExpressionName FieldAccess ArrayAccess AssignmentOperator: (one of) =  *=  /=  %=  +=  -=  <<=  >>=  >>>=  &=  ^=  |=,10.83,180.24,274.6,241,90,406.13,364.6,586.37,FALSE,TRUE
754,3,BODY,16.1.3Conditional-Or Operator || •V is [un]assigned after a || b (§15.24) when true iff V is [un]assigned after a when true and V is [un]assigned after b when true. •V is [un]assigned after a || b when false iff V is [un]assigned after b when false. •V is [un]assigned before a iff V is [un]assigned before a || b. •V is [un]assigned before b iff V is [un]assigned after a when false. •V is [un]assigned after a || b iff V is [un]assigned after a || b when true and V is [un]assigned after a || b when false.,10.83,129.11,360,508,72,159.09,432,288.2,FALSE,FALSE
813,4,BODY,"18.2.3Subtyping Constraints A constraint formula of the form ‹S <: T› is reduced as follows: •If S and T are proper types, the constraint reduces to true if S is a subtype of T (§4.10), and false otherwise. •Otherwise, if S is the null type, the constraint reduces to true. •Otherwise, if T is the null type, the constraint reduces to false. •Otherwise, if S is an inference variable, α, the constraint reduces to the bound α <: T. •Otherwise, if T is an inference variable, α, the constraint reduces to the bound S <: α. •Otherwise, the constraint is reduced according to the form of T: –If T is a parameterized class or interface type, or an inner class type of a parameterized class or interface type (directly or indirectly), let A1, ..., An be the type arguments of T. Among the supertypes of S, a corresponding class or interface type is identified, with type arguments B1, ..., Bn. If no such type",10.83,238.11,360,904,72,245.09,432,483.2,FALSE,FALSE
837,5,BODY,"4.If T' is a parameterization of a generic class G, and there exists a supertype of R<α1, ..., αn> that is also a parameterization of G, let R' be that supertype.",10.83,20.17,360,162,72,527.06,432,547.23,FALSE,FALSE
69,5,BODY,"It is a compile-time error if the character following a backslash in an escape sequence is not a LineTerminator or an ASCII b, s, t, n, f, r, ', ', \, 0, 1, 2, 3, 4, 5, 6, or 7. An escape sequence in the content of a character literal, string literal, or text block is interpreted by replacing its \ and trailing character(s) with the single",10.82,64.14,360,341,72,534.52,432,598.65,FALSE,FALSE
73,3,BODY,"4.2.1Integral Types and Values The values of the integral types are integers in the following ranges: •For byte, from -128 to 127, inclusive •For short, from -32768 to 32767, inclusive •For int, from -2147483648 to 2147483647, inclusive •For long, from -9223372036854775808 to 9223372036854775807, inclusive •For char, from '\u0000' to '\uffff' inclusive, that is, from 0 to 65535",10.82,122.11,351.21,380,72,153.09,423.21,275.2,FALSE,FALSE
74,2,BODY,"•The cast operator (§15.16), which can convert from an integral value to a value of any specified numeric type •The string concatenation operator + (§15.18.1), which, when given a String operand and an integral operand, will convert the integral operand to a String (the decimal form of a byte, short, int, or long operand, or the character of a char operand), and then produce a newly created String that is the concatenation of the two strings Other useful constructors, methods, and constants are predefined in the classes Byte, Short, Integer, Long, and Character. If an integer operator other than a shift operator has at least one operand of type long, then the operation is carried out using 64-bit precision, and the result of the numerical operator is of type long. If the other operand is not long, it is first widened (§5.1.5) to type long by numeric promotion (§5.6). Otherwise, the operation is carried out using 32-bit precision, and the result of the numerical operator is of type int. If either operand is not an int, it is first widened to type int by numeric promotion. The integer operators do not indicate overflow or underflow in any way. Any value of any integral type may be cast to or from any numeric type. There are no casts between integral types and the type boolean.",10.82,276.14,360.01,1295,72,76.06,432.01,352.2,FALSE,FALSE
84,7,BODY,"4.3.2The Class Object The class Object is a superclass (§8.1.4) of all other classes. All class and array types inherit (§8.4.8) the methods of class Object, which are summarized as follows: •The method clone is used to make a duplicate of an object. •The method equals defines a notion of object equality, which is based on value, not reference, comparison. •The method finalize is run just before an object is destroyed (§12.6).",10.82,129.11,360.01,430,72,362.09,432.01,491.2,FALSE,FALSE
99,4,BODY,"An intersection type takes the form T1 & ... & Tn (n > 0), where Ti (1 ≤ i ≤ n) are types. Intersection types can be derived from type parameter bounds (§4.4) and cast expressions (§15.16); they also arise in the processes of capture conversion (§5.1.10) and least upper bound computation (§4.10.4). The values of an intersection type are those objects that are values of all of the types Ti for 1 ≤ i ≤ n. Every intersection type T1 & ... & Tn induces a notional class or interface for the purpose of identifying the members of the intersection type, as follows: •For each Ti (1 ≤ i ≤ n), let Ci be the most specific class or array type such that Ti <: Ci. Then there must be some Ck such that Ck <: Ci for any i (1 ≤ i ≤ n), or a compile-time error occurs. •For 1 ≤ j ≤ n, if Tj is a type variable, then let Tj' be an interface whose members are the same as the public members of Tj; otherwise, if Tj is an interface, then let Tj' be Tj. •If Ck is Object, a notional interface is induced; otherwise, a notional class is induced with direct superclass type Ck. This class or interface has direct superinterface types T1', ..., Tn' and is declared in the package in which the intersection type appears. The members of an intersection type are the members of the class or interface it induces.",10.82,295.14,360.01,1292,72,248.06,432.01,543.2,FALSE,FALSE
131,6,BODY,result of the first step is the int value V.,10.82,6.14,176.19,44,118,333.06,294.19,339.2,FALSE,FALSE
135,4,BODY,"3.S is an array type SC[], that is, an array of components of type SC; T is an array type TC[], that is, an array of components of type TC; and a narrowing reference conversion exists from SC to TC.",10.82,32.14,350,198,82,185.06,432,217.2,FALSE,FALSE
135,6,BODY,upper bound of S to T.,10.82,6.14,97.57,22,100,243.06,197.57,249.2,FALSE,FALSE
162,2,BODY,"is representable in the type char, then the promoted type is char, and the int expressions undergo narrowing primitive conversion to char. –Otherwise, the promoted type is int, and all the expressions that are not of type int undergo widening primitive conversion to int.",10.82,51.14,332,271,100,76.06,432,127.2,FALSE,FALSE
198,4,BODY,"4.In the throws clause of a method or constructor (§8.4.6, §8.8.5, §9.4) 5.In an extends clause of a type parameter declaration of a generic class,",10.82,25.14,349.99,147,82,178.06,431.99,203.2,FALSE,FALSE
284,5,BODY,"The rules concerning annotation modifiers for a field declaration are specified in §9.7.4 and §9.7.5. It is a compile-time error if the same keyword appears more than once as a modifier for a field declaration, or if a field declaration has more than one of the access modifiers public, protected, and private (§6.6).",10.82,64.14,360.01,317,72,222.06,432.01,286.2,FALSE,FALSE
304,2,BODY,"8.4.3.4native Methods A method that is native is implemented in platform-dependent code, typically written in another programming language such as C. The body of a native method is given as a semicolon only, indicating that the implementation is omitted, instead of a block (§8.4.7).",10.82,65.2,360.01,283,72,76.13,432.01,141.33,FALSE,FALSE
309,4,BODY,"The body of a method must be a semicolon if the method is abstract or native (§8.4.3.1, §8.4.3.4). More precisely: •It is a compile-time error if a method declaration is either abstract or native and has a block for its body. •It is a compile-time error if a method declaration is neither abstract nor native and has a semicolon for its body.",10.82,83.14,360,342,72,184.06,432,267.2,FALSE,FALSE
354,7,BODY,"Either way, an explicitly declared canonical constructor must provide at least as much access as the record class, as follows: •If the record class is public, then the canonical constructor must be public; otherwise, a compile-time error occurs. •If the record class is protected, then the canonical constructor must be protected or public; otherwise, a compile-time error occurs.",10.82,83.14,360,380,72,501.06,432,584.2,FALSE,FALSE
366,4,BODY,It is a compile-time error if the declaration of a sealed interface I lacks a permits clause and I has no permitted direct subclasses or subinterfaces.,10.82,19.14,360,151,72,166.06,432,185.2,FALSE,FALSE
413,4,BODY,"2.Then, the function type's throws clause includes every type E which satisfies",10.82,6.14,350,79,82,191.06,432,197.2,FALSE,FALSE
472,3,BODY,"6.Given a class instance creation expression (§15.9) or an explicit constructor invocation statement (§8.8.7.1) or a method reference expression of the form ClassType :: new (§15.13) in a class or interface C, referencing a constructor m declared in a (possibly distinct) class or interface D, we define the qualifying class of the constructor invocation as follows: •If the expression is of the form new D(...) or ExpressionName.new D(...) or Primary.new D(...) or D :: new, then the qualifying class of the constructor invocation is D. •If the expression is of the form new D(...){...} or ExpressionName.new D(...){...} or Primary.new D(...){...}, then the qualifying class of the constructor invocation is the anonymous class declared by the expression. •If the expression is of the form super(...) or ExpressionName.super(...) or Primary.super(...), then the qualifying class of the constructor invocation is the direct superclass of C. •If the expression is of the form this(...), then the qualifying class of the constructor invocation is C. A reference to a constructor must be resolved at compile time to a symbolic reference to the qualifying class of the constructor invocation, plus the declared signature of the constructor (§8.8.2). The signature of a constructor must include both: •The number of parameters of the constructor •A symbolic reference to the type of each formal parameter",10.82,321.14,360.01,1399,72,210.06,432.01,531.2,FALSE,FALSE
520,2,BODY,"•A case label with a case pattern q is dominated if there is a preceding unguarded case label in the switch block with a case pattern p, and p dominates q (§14.30.3).",10.82,32.14,360.01,166,72,76.06,432.01,108.2,FALSE,FALSE
532,5,BODY,"14.11.3Execution of a switch Statement A switch statement is executed by first evaluating the selector expression. If evaluation of the selector expression completes abruptly, then the entire switch statement completes abruptly for the same reason. If evaluation of the selector expression completes normally, then execution of the switch statement continues by determining if a switch label associated with the switch block applies to the value of the selector expression (§14.11.1.2). Then: •If the process of determining which switch label applies completes abruptly, then the entire switch statement completes abruptly for the same reason. •If no switch label applies, then one of the following holds: –If the value of the selector expression is null, then a NullPointerException is thrown and the entire switch statement completes abruptly for that reason. –If the switch statement is an enhanced switch statement, then a MatchException is thrown and the entire switch statement completes abruptly for that reason. –If the value of the selector expression is not null, and the switch statement is not an enhanced switch statement, then the entire switch statement completes normally.",10.82,271.11,360.01,1188,72,231.09,432.01,502.2,FALSE,FALSE
536,2,BODY,"14.12.1Abrupt Completion of while Statement Abrupt completion of the contained Statement is handled in the following manner: •If execution of the Statement completes abruptly because of a break with no label, no further action is taken and the while statement completes normally. •If execution of the Statement completes abruptly because of a continue with no label, then the entire while statement is executed again. •If execution of the Statement completes abruptly because of a continue with label L, then there is a choice: –If the while statement has label L, then the entire while statement is executed again. –If the while statement does not have label L, the while statement completes abruptly because of a continue with label L.",10.82,187.11,360.01,737,72,76.09,432.01,263.2,FALSE,FALSE
550,6,BODY,"There are two kinds of return statement: •A return statement with no value. •A return statement with value Expression. A return statement attempts to transfer control to the invoker of the innermost enclosing constructor, method, or lambda expression; this enclosing declaration or expression is called the return target. In the case of a return statement with value Expression, the value of the Expression becomes the value of the invocation. It is a compile-time error if a return statement has no return target. It is a compile-time error if the return target contains either (i) an instance or static initializer that encloses the return statement, or (ii) a switch expression that encloses the return statement. It is a compile-time error if the return target of a return statement with no value is a method, and that method is not declared void.",10.82,198.14,360,851,72,392.06,432,590.2,FALSE,FALSE
555,5,BODY,"The Block immediately after the keyword try is called the try block of the try statement. The Block immediately after the keyword finally is called the finally block of the try statement. A try statement may have catch clauses, also called exception handlers. A catch clause declares exactly one parameter, which is called an exception parameter.",10.82,102.14,360,346,72,501.06,432,603.2,FALSE,FALSE
558,4,BODY,"–If the run-time type of V is not assignment compatible with a catchable exception class of any catch clause of the try statement, then the try statement completes abruptly because of a throw of the value V.",10.82,32.14,350,207,82,444.06,432,476.2,FALSE,FALSE
560,3,BODY,"›If the catch block completes abruptly for reason R, then the finally block is executed. Then there is a choice: »If the finally block completes normally, then the try statement completes abruptly for reason R. »If the finally block completes abruptly for reason S, then the try statement completes abruptly for reason S (and reason R is discarded). –If the run-time type of V is not assignment compatible with a catchable exception class of any catch clause of the try statement, then the finally block is executed. Then there is a choice: ›If the finally block completes normally, then the try statement completes abruptly because of a throw of the value V. ›If the finally block completes abruptly for reason S, then the try statement completes abruptly for reason S (and the throw of value V is discarded and forgotten).",10.82,205.14,350,824,82,204.06,432,409.2,FALSE,FALSE
560,4,BODY,"•If execution of the try block completes abruptly for any other reason R, then the finally block is executed, and then there is a choice: –If the finally block completes normally, then the try statement completes abruptly for reason R. –If the finally block completes abruptly for reason S, then the try statement completes abruptly for reason S (and reason R is discarded).",10.82,83.14,360,374,72,422.06,432,505.2,FALSE,FALSE
566,2,BODY,"•If the initialization of the resource completes abruptly because of a throw of a value V, then the try-with-resources statement completes abruptly because of a throw of the value V. •If the initialization of the resource completes normally, and the try block completes abruptly because of a throw of a value V, then: –If the automatic closing of the resource completes normally, then the try-with- resources statement completes abruptly because of a throw of the value V. –If the automatic closing of the resource completes abruptly because of a throw of a value V2, then the try-with-resources statement completes abruptly because of a throw of the value V, with V2 added to the suppressed exception list of V.",10.82,154.14,360,712,72,76.06,432,230.2,FALSE,FALSE
623,3,BODY,"15.10.4Run-Time Evaluation of Array Access Expressions At run time, evaluation of an array access expression behaves as follows: •First, the array reference expression is evaluated. If this evaluation completes abruptly, then the array access completes abruptly for the same reason and the index expression is not evaluated. •Otherwise, the index expression is evaluated. If this evaluation completes abruptly, then the array access completes abruptly for the same reason. •Otherwise, if the value of the array reference expression is null, then a NullPointerException is thrown. •Otherwise, the value of the array reference expression indeed refers to an array. If the value of the index expression is less than zero, or greater than or equal to the array's length, then an ArrayIndexOutOfBoundsException is thrown. •Otherwise, the result of the array access is the variable of type T, within the array, selected by the value of the index expression.",10.82,213.11,360.01,951,72,217.09,432.01,430.2,FALSE,FALSE
755,2,BODY,•V is [un]assigned before c iff V is [un]assigned after a when false. •V is [un]assigned after a ? b : c iff V is [un]assigned after a ? b : c when true and V is [un]assigned after a ? b : c when false. Suppose that b and c are expressions that are not boolean-valued. •V is [un]assigned after a ? b : c iff V is [un]assigned after b and V is [un]assigned after c. •V is [un]assigned before a iff V is [un]assigned before a ? b : c. •V is [un]assigned before b iff V is [un]assigned after a when true. •V is [un]assigned before c iff V is [un]assigned after a when false.,10.82,146.14,360,571,72,76.06,432,222.2,FALSE,FALSE
758,6,BODY,"16.1.9Operators ++ and -- •V is definitely assigned after ++a (§15.15.1), --a (§15.15.2), a++ (§15.14.2), or a-- (§15.14.3) iff either a is V or V is definitely assigned after the operand expression.",10.82,53.11,360,199,72,533.09,432,586.2,FALSE,FALSE
79,6,BODY,"4.2.5The boolean Type and boolean Values The boolean type represents a logical quantity with two possible values, indicated by the literals true and false (§3.10.3). The boolean operators are: •The relational operators == and != (§15.21.2) •The logical complement operator ! (§15.15.6) •The logical operators &, ^, and | (§15.22.2)",10.81,116.11,360,331,72,473.09,432,589.2,FALSE,FALSE
101,2,BODY,"•The direct superclass type of C (§8.1.4), if C is a class. •The direct superinterface types of C (§8.1.5, §9.1.3). •The type Object, if C is an interface with no direct superinterface types (§9.1.3). Given a generic class or interface C with type parameters F1,...,Fn (n > 0), the direct supertypes of the raw type C (§4.8) are all of the following: •The erasure (§4.6) of the direct superclass type of C, if C is a class. •The erasure of the direct superinterface types of C. •The type Object, if C is an interface with no direct superinterface types. Given a generic class or interface C with type parameters F1,...,Fn (n > 0), the direct supertypes of the parameterized type C<T1,...,Tn>, where each of Ti (1 ≤ i ≤ n) is a type, are all of the following: •The substitution [F1:=T1,...,Fn:=Tn] applied to the direct superclass type of C, if C is a class. •The substitution [F1:=T1,...,Fn:=Tn] applied to the direct superinterface types of C. •C<S1,...,Sn>, where Si contains Ti (1 ≤ i ≤ n) (§4.5.1). •The type Object, if C is an interface with no direct superinterface types. •The raw type C. Given a generic class or interface C with type parameters F1,...,Fn (n > 0), the direct supertypes of the parameterized type C<R1,...,Rn> where at least one of the Ri (1 ≤ i ≤ n) is a wildcard type argument, are the direct supertypes of the parameterized type C<X1,...,Xn> which is the result of applying capture conversion to C<R1,...,Rn> (§5.1.10). The direct supertypes of an intersection type T1 & ... & Tn are Ti (1 ≤ i ≤ n). The direct supertypes of a type variable are the types listed in its bound. A type variable is a direct supertype of its lower bound. The direct supertypes of the null type are all reference types other than the null type itself.",10.81,459.14,360,1756,72,76.06,432,535.2,FALSE,FALSE
131,10,BODY,"•If T is int or long, the result of the conversion is the result of the first step. •If T is byte, char, or short, the result of the conversion is the result of a narrowing conversion to type T (§5.1.3) of the result of the first step.",10.81,38.14,341.99,235,90,480.06,431.99,518.2,FALSE,FALSE
135,9,BODY,"6.S is an intersection type S1 & ... & Sn, and for all i (1 ≤ i ≤ n), either a widening reference conversion or a narrowing reference conversion exists from Si to T. 7.T is an intersection type T1 & ... & Tn, and for all i (1 ≤ i ≤ n), either a widening reference conversion or a narrowing reference conversion exists from S to Ti. A class or interface is disjoint from another class or interface if it can be determined statically that they have no instances in common (other than the null value). The rules for disjointess are as follows: •A class named C is disjoint from an interface named I if (i) it is not the case that C <: I, and (ii) one of the following cases applies: –C is final. –C is sealed, and all of the permitted direct subclasses of C are disjoint from I. –C is freely extensible (§8.1.1.2), and I is sealed, and C is disjoint from all of the permitted direct subclasses and subinterfaces of I.",10.81,198.14,360.01,914,72,294.06,432.01,492.2,FALSE,FALSE
143,2,BODY,"5.1.9Unchecked Conversion Let G name a generic type declaration with n type parameters. There is an unchecked conversion from the raw class or interface type (§4.8) G to any parameterized type of the form G<T1,...,Tn>. There is an unchecked conversion from the raw array type G[] to any array type of the form G<T1,...,Tn>[]. (The notation [] indicates an array type of k dimensions.) Use of an unchecked conversion causes a compile-time unchecked warning unless all type arguments Ti (1 ≤ i ≤ n) are unbounded wildcards (§4.5.1), or the warning is suppressed by @SuppressWarnings (§9.6.4.5).",10.81,136.11,360.01,592,72,76.09,432.01,212.2,FALSE,FALSE
153,3,BODY,"String contexts apply only to an operand of the binary + operator which is not a String when the other operand is a String. The target type in these contexts is always String, and a string conversion (§5.1.11) of the non-String operand always occurs. Evaluation of the + operator then proceeds as specified in §15.18.1.",10.81,64.14,360,319,72,108.06,432,172.2,FALSE,FALSE
164,2,BODY,"If a testing context makes use of a narrowing reference conversion, then a run time check will be performed on the class of the expression's value, possibly causing a ClassCastException. Otherwise, no run time check is performed.",10.81,32.14,360.01,229,72,76.06,432.01,108.2,FALSE,FALSE
258,5,BODY,"A class can be declared final if its definition is complete and no subclasses are desired or required. It is a compile-time error if a class is declared both final and abstract, because the implementation of such a class could never be completed (§8.1.1.1). Because a final class never has any subclasses, the methods of a final class are never overridden (§8.4.8.1). A class is freely extensible if its direct superclass is not sealed (§8.1.4), and none of its direct superinterfaces are sealed (§8.1.5), and it is neither sealed nor final itself. A class that has a sealed direct superclass or a sealed direct superinterface is freely extensible if and only if it is declared non-sealed. It is a compile-time error if a class has a sealed direct superclass or a sealed direct superinterface, and is not declared final, sealed, or non-sealed either explicitly or implicitly.",10.81,205.14,360,875,72,396.2,432,601.33,FALSE,FALSE
269,7,BODY,"ClassImplements: implements InterfaceTypeList InterfaceTypeList: InterfaceType {, InterfaceType}",10.81,56.05,151.89,96,90,276.63,241.89,332.68,FALSE,TRUE
330,4,BODY,8.8.6The Type of a Constructor The type of a constructor consists of its signature and the exception types given by its throws clause.,10.81,40.11,359.99,134,72,200.09,431.99,240.2,FALSE,FALSE
372,3,BODY,"It is a compile-time error if the same keyword appears more than once as a modifier for an interface method declaration, or if an interface method declaration has more than one of the access modifiers public and private (§6.6). It is a compile-time error if an interface method declaration has more than one of the keywords abstract, default, or static. It is a compile-time error if an interface method declaration that contains the keyword private also contains the keyword abstract or default. It is permitted for an interface method declaration to contain both private and static. It is a compile-time error if an interface method declaration that contains the keyword abstract also contains the keyword strictfp. It is a compile-time error for the body of an interface declaration to declare, explicitly or implicitly, two methods with override-equivalent signatures (§8.4.2). However, an interface may inherit several abstract methods with such signatures (§9.4.1). A method declared in an interface may be generic. The rules for type parameters of a generic method in an interface are the same as for a generic method in a class (§8.4.4).",10.81,244.14,360.01,1145,72,108.06,432.01,352.2,FALSE,FALSE
431,2,BODY,"The checked exception classes are all exception classes other than the unchecked exception classes. That is, the checked exception classes are Throwable and all its subclasses other than RuntimeException and its subclasses and Error and its subclasses.",10.81,45.14,360,252,72,76.06,432,121.2,FALSE,FALSE
479,2,BODY,"If a class that was declared public is changed to not be declared public, then an IllegalAccessError is thrown if a pre-existing binary is linked that needs but no longer has access to the class type; such a change is not recommended for widely distributed classes.",10.81,45.14,360.01,265,72,76.06,432.01,121.2,FALSE,FALSE
512,5,BODY,"The Expression must have type boolean or Boolean, or a compile-time error occurs.",10.81,19.14,360,81,72,334.06,432,353.2,FALSE,FALSE
516,5,BODY,"The Expression is called the selector expression. The type of the selector expression must be char, byte, short, int, or a reference type, or a compile-time error occurs.",10.81,19.14,360.01,170,72,384.06,432.01,403.2,FALSE,FALSE
519,2,BODY,"•No more than one default label may be associated with a switch block. A guard associated with a case label must satisfy all of the following conditions, otherwise a compile-time error occurs: •A guard must have type boolean or Boolean. •Any local variable, formal parameter, or exception parameter used but not declared in a guard must either be final or effectively final (§4.12.4). •Any blank final variable used but not declared in a guard must be definitely assigned (§16 (Definite Assignment)) before the guard. •A guard cannot be a constant expression (§15.29) with the value false. The switch block of a switch statement or a switch expression is switch compatible with the type of the selector expression, T, if all of the following are true: •If a null literal is associated with the switch block, then T is a reference type. •For every case constant associated with the switch block that names an enum constant, the type of the case constant is assignment compatible with T (§5.2). •For each case constant associated with the switch block that is a constant expression, the constant is assignment compatible with T, and T is one of char, byte, short, int, Character, Byte, Short, Integer, or String. •Every pattern p associated with the switch block is applicable at type T (§14.30.3).",10.81,313.14,360,1296,72,76.06,432,389.2,FALSE,FALSE
567,3,BODY,14.20.3.2Extended try-with-resources A try-with-resources statement with at least one catch clause and/or a finally clause is called an extended try-with-resources statement. The meaning of an extended try-with-resources statement:,10.81,58.2,360,231,72,258.13,432,316.33,FALSE,FALSE
602,6,BODY,"15.8.4Qualified this Any lexically enclosing instance (§8.1.3) can be referred to by explicitly qualifying the keyword this. Let n be an integer such that TypeName denotes the n'th lexically enclosing class or interface declaration of the class or interface whose declaration immediately encloses the qualified this expression. The value of a qualified this expression TypeName.this is the n'th lexically enclosing instance of this. If TypeName denotes a generic class, with type parameters F1,...,Fn, the type of the qualified this expression is TypeName<F1,...,Fn>. Otherwise, the type of the qualified this expression is TypeName. It is a compile-time error if a qualified this expression occurs in a static context (§8.1.3).",10.81,194.11,360.01,728,72,391.09,432.01,585.2,FALSE,FALSE
612,2,BODY,"•If the class instance creation expression uses <>, then: If C is not an anonymous class, let D be the same as C. If C is an anonymous class, let D be the superclass or superinterface of C named by the class instance creation expression. If D is a class, let c1, ..., cn be the constructors of class D. If D is an interface, let c1, ..., cn be a singleton list (n = 1) containing the zero-argument constructor of the class Object. A list of methods m1, ..., mn is defined for the purpose of overload resolution and type argument inference. For all j (1 ≤ j ≤ n), mj is defined in terms of cj as follows: –A substitution θj is first defined to instantiate the types in cj. Let F1, ..., Fp be the type parameters of D, and let G1, ..., Gq be the type parameters (if any) of cj. Let X1, ..., Xp and Y1, ..., Yq be type variables with distinct names that are not in scope in the body of D.",10.81,205.14,360.01,885,72,76.06,432.01,281.2,FALSE,FALSE
740,2,BODY,"15.27.4Run-Time Evaluation of Lambda Expressions At run time, evaluation of a lambda expression is similar to evaluation of a class instance creation expression, insofar as normal completion produces a reference to an object. Evaluation of a lambda expression is distinct from execution of the lambda body. Either a new instance of a class with the properties below is allocated and initialized, or an existing instance of a class with the properties below is referenced. If a new instance is to be created, but there is insufficient space to allocate the object, evaluation of the lambda expression completes abruptly by throwing an OutOfMemoryError.",10.81,137.11,360.01,651,72,76.09,432.01,213.2,FALSE,FALSE
741,5,BODY,"The Expression is called the selector expression. The type of the selector expression must be char, byte, short, int, or a reference type, or a compile-time error occurs.",10.81,19.14,360.01,170,72,386.06,432.01,405.2,FALSE,FALSE
744,2,BODY,"•If the process of determining which switch label applies completes abruptly, then the entire switch expression completes abruptly for the same reason. •If no switch label applies, then one of the following holds: –If the value of the selector expression is null, then a NullPointerException is thrown and evaluation of the switch expression completes abruptly for that reason. –Otherwise, a MatchException is thrown and evaluation of the switch expression completes abruptly for that reason.",10.81,115.14,360.01,492,72,76.06,432.01,191.2,FALSE,FALSE
755,3,BODY,"16.1.6switch Expressions Suppose that a switch expression (§15.28) has result expressions e1, ..., en, all of which are boolean-valued. The following rules apply only if the switch block of the switch expression consists of switch labeled statement groups (§14.11.1): •V is definitely assigned after a switch expression when true iff for every yield statement with expression e (§14.21) in the switch block that may exit the switch expression, V is definitely assigned after e when true. •V is definitely assigned after a switch expression when false iff for every yield statement with expression e in the switch block that may exit the switch expression, V is definitely assigned after e when false. •V is definitely unassigned after a switch expression when true iff for every yield statement with expression e in the switch block that may exit the switch expression, V is definitely unassigned before the yield statement and V is definitely unassigned after e when true. •V is definitely unassigned after a switch expression when false iff for every yield statement with expression e in the switch block that may exit the switch expression, V is definitely unassigned before the yield statement and V is definitely unassigned after e when false. •V is [un]assigned before the selector expression iff V is [un]assigned before the switch expression. •V is [un]assigned before the first statement of the first switch labeled statement group in the switch block iff V is [un]assigned after the selector expression.",10.81,342.11,360,1513,72,248.09,432,590.2,FALSE,FALSE
765,2,BODY,"16.2.10while Statements •V is [un]assigned after while (e) S (§14.12) iff V is [un]assigned after e when false and V is [un]assigned before every break statement for which the while statement is the break target. •V is definitely assigned before e iff V is definitely assigned before the while statement. •V is definitely unassigned before e iff all of the following are true: –V is definitely unassigned before the while statement. –Assuming V is definitely unassigned before e, V is definitely unassigned after S. –Assuming V is definitely unassigned before e, V is definitely unassigned before every continue statement for which the while statement is the continue target.",10.81,174.11,360.01,675,72,76.09,432.01,250.2,FALSE,FALSE
765,5,BODY,•V is [un]assigned before e iff V is [un]assigned after S and V is [un]assigned before every continue statement for which the do statement is the continue target.,10.81,19.14,360,162,72,463.06,432,482.2,FALSE,FALSE
792,2,BODY,"Starting with the empty set as C0, we perform a sequence of steps where we take actions from the set of actions A and add them to a set of committed actions Ci to get a new set of committed actions Ci+1. To demonstrate that this is reasonable, for each Ci we need to demonstrate an execution E containing Ci that meets certain conditions. Formally, an execution E satisfies the causality requirements of the Java programming language memory model if and only if there exist: •Sets of actions C0, C1, ... such that: –C0 is the empty set –Ci is a proper subset of Ci+1 –A = ∪ (C0, C1, ...) If A is finite, then the sequence C0, C1, ... will be finite, ending in a set Cn = A. If A is infinite, then the sequence C0, C1, ... may be infinite, and it must be the case that the union of all elements of this infinite sequence is equal to A. •Well-formed executions E1, ..., where Ei = < P, Ai, poi, soi, Wi, Vi, swi, hbi >. Given these sets of actions C0, ... and executions E1, ... , every action in Ci must be one of the actions in Ei. All actions in Ci must share the same relative happens- before order and synchronization order in both Ei and E. Formally: 1.Ci is a subset of Ai 2.hbi|C = hb| 3.soi|C = so| The values written by the writes in Ci must be the same in both Ei and E. Only the reads in Ci-1 need to see the same writes in Ei as in E. Formally: 4.Vi|C = V| 5.Wi|C = W| All reads in Ei that are not in Ci-1 must see writes that happen-before them. Each read r in Ci - Ci-1 must see writes in Ci-1 in both Ei and E, but may see a different write in Ei from the one it sees in E. Formally: 6.For any read r in Ai - Ci-1, we have hbi(Wi(r), r) 7.For any read r in (Ci - Ci-1), we have Wi(r) in Ci-1 and W(r) in Ci-1",10.81,491.36,360.01,1722,72,76.06,432.01,567.42,FALSE,FALSE
826,2,BODY,"•Let B3 be the bound set derived from B2 as follows. Let R be the return type of m, and let θ be the substitution [P1:=α1, ..., Pp:=αp] defined in §18.5.1 to replace the type parameters of m with inference variables, and let T be the invocation's target type. Then: –If unchecked conversion was necessary for the method to be applicable during constraint set reduction in §18.5.1, the constraint formula ‹|R| → T› is reduced and incorporated with B2. –Otherwise, if R θ is a parameterized type, G<A1, ..., An>, and one of A1, ..., An is a wildcard, then, for fresh inference variables β1, ..., βn, the constraint formula ‹G<β1, ..., βn> → T› is reduced and incorporated, along with the bound G<β1, ..., βn> = capture(G<A1, ..., An>), with B2. –Otherwise, if R θ is an inference variable α, and one of the following is true: ›T is a reference type, but is not a wildcard-parameterized type, and either (i) B2 contains a bound of one of the forms α = S or S <: α, where S is a wildcard-parameterized type, or (ii) B2 contains two bounds of the forms S1 <: α and S2 <: α, where S1 and S2 have supertypes that are two different parameterizations of the same generic class or interface. ›T is a parameterization of a generic class or interface, G, and B2 contains a bound of one of the forms α = S or S <: α, where there exists no type of the form G<...> that is a supertype of S, but the raw type |G<...>| is a supertype of S. ›T is a primitive type, and one of the primitive wrapper classes mentioned in §5.1.7 is an instantiation, upper bound, or lower bound for α in B2. then α is resolved in B2, and where the capture of the resulting instantiation of α is U, the constraint formula ‹U → T› is reduced and incorporated with B2. –Otherwise, the constraint formula ‹R θ → T› is reduced and incorporated with",10.81,386.17,360.01,1805,72,76.06,432.01,462.23,FALSE,FALSE
832,3,BODY,"18.5.3Functional Interface Parameterization Inference Where a lambda expression with explicit parameter types P1, ..., Pn targets a functional interface type F<A1, ..., Am> with at least one wildcard type argument, then a parameterization of F may be derived as the ground target type of the lambda expression as follows. Let Q1, ..., Qk be the parameter types of the function type of the type F<α1, ..., αm>, where α1, ..., αm are fresh inference variables. If n ≠ k, no valid parameterization exists. Otherwise, a set of constraint formulas is formed with, for all i (1 ≤ i ≤ n), ‹Pi = Qi›. This constraint formula set is reduced to form the bound set B. If B contains the bound false, no valid parameterization exists. Otherwise, a new parameterization of the functional interface type, F<A'1, ..., A'm>, is constructed as follows, for 1 ≤ i ≤ m: •If B contains an instantiation (§18.1.3) for αi, T, then A'i = T. •Otherwise, A'i = Ai. If F<A'1, ..., A'm> is not a well-formed type (that is, the type arguments are not within their bounds), or if F<A'1, ..., A'm> is not a subtype of F<A1, ..., Am>, no valid parameterization exists. Otherwise, the inferred parameterization is either F<A'1, ..., A'm>, if all the type arguments are types, or the non-wildcard parameterization (§9.9) of F<A'1, ..., A'm>, if one or more type arguments are still wildcards.",10.81,310.11,360.01,1358,72,242.09,432.01,552.2,FALSE,FALSE
833,4,BODY,"18.5.4More Specific Method Inference When testing that one applicable method is more specific than another (§15.12.2.5), where the second method is generic, it is necessary to test whether some instantiation of the second method's type parameters can be inferred to make the first method more specific than the second. Let m1 be the first method and m2 be the second method. Where m2 has type parameters P1, ..., Pp, let α1, ..., αp be inference variables, and let θ be the substitution [P1:=α1, ..., Pp:=αp]. Let e1, ..., ek be the argument expressions of the corresponding invocation. Then: •If m1 and m2 are applicable by strict or loose invocation (§15.12.2.2, §15.12.2.3), then let S1, ..., Sk be the formal parameter types of m1, and let T1, ..., Tk be the result of θ applied to the formal parameter types of m2. •If m1 and m2 are applicable by variable arity invocation (§15.12.2.4), then let S1, ..., Sk be the first k variable arity parameter types of m1, and let T1, ..., Tk be the result of θ applied to the first k variable arity parameter types of m2.",10.81,221.14,360,1065,72,251.09,432,472.23,FALSE,FALSE
842,3,BODY,Type: PrimitiveType ReferenceType PrimitiveType: {Annotation} NumericType {Annotation} boolean NumericType: IntegralType FloatingPointType IntegralType: (one of) byte short int long char FloatingPointType: (one of) float double ReferenceType: ClassOrInterfaceType TypeVariable ArrayType ClassOrInterfaceType: ClassType InterfaceType,10.81,345.05,129.71,332,90,215.13,219.71,560.18,FALSE,TRUE
866,1,BODY,"Expression: LambdaExpression AssignmentExpression LambdaExpression: LambdaParameters -> LambdaBody LambdaParameters: ( [LambdaParameterList] ) ConciseLambdaParameter LambdaParameterList: NormalLambdaParameter {, NormalLambdaParameter} ConciseLambdaParameter {, ConciseLambdaParameter} NormalLambdaParameter: {VariableModifier} LambdaParameterType VariableDeclaratorId VariableArityParameter LambdaParameterType: UnannType var ConciseLambdaParameter: Identifier _ LambdaBody: Expression Block",10.81,369.05,302.34,491,90,76.13,392.34,445.18,FALSE,TRUE
23,4,BODY,"To shorten the description of some rules, especially those that systematically analyze the constructs of the Java programming language, the customary abbreviation 'iff' is used to mean 'if and only if'. The type system of the Java programming language occasionally relies on the notion of a substitution. The notation [F1:=T1,...,Fn:=Tn] denotes substitution of Fi by Ti for 1 ≤ i ≤ n.",10.8,78.17,360,385,72,181.06,432,259.23,FALSE,FALSE
59,7,BODY,"3.10.3Boolean Literals The boolean type has two values, represented by the boolean literals true and false, formed from ASCII letters.",10.8,40.11,360,134,72,503.09,432,543.2,FALSE,FALSE
61,7,BODY,"The string represented by a string literal is the content of the string literal with every escape sequence interpreted, as if by execution of String.translateEscapes on the content.",10.8,32.14,360.01,181,72,569.2,432.01,601.33,FALSE,FALSE
84,6,BODY,"Each object is associated with a monitor (§17.1), which is used by synchronized methods (§8.4.3) and the synchronized statement (§14.19) to provide control over concurrent access to state by multiple threads (§17 (Threads and Locks)).",10.8,32.14,360,234,72,304.06,432,336.2,FALSE,FALSE
106,3,BODY,"–If Ai is an upper-bounded wildcard that mentions a restricted type variable, then let U be the upward projection of the wildcard bound. Ai' is an upper- bounded wildcard, ? extends U. –If Ai is a lower-bounded wildcard that mentions a restricted type variable, then if the downward projection of the wildcard bound is L, then Ai' is a lower- bounded wildcard, ? super L; if the downward projection of the wildcard bound is undefined, then Ai' is an unbounded wildcard, ?.",10.8,90.14,350,472,82,281.06,432,371.2,FALSE,FALSE
220,2,BODY,"•If the access is by a superclass constructor invocation super(...), or a qualified superclass constructor invocation E.super(...), where E is a Primary expression, then the access is permitted. •If the access is by an anonymous class instance creation expression new C(...) {...}, or a qualified anonymous class instance creation expression E.new C(...){...}, where E is a Primary expression, then the access is permitted. •If the access is by a simple class instance creation expression new C(...), or a qualified class instance creation expression E.new C(...), where E is a Primary expression, or a method reference expression C :: new, where C is a ClassType, then the access is not permitted. A protected constructor can be accessed by a class instance creation expression (that does not declare an anonymous class) or a method reference expression only from within the package in which it is defined.",10.8,161.14,360.01,907,72,76.06,432.01,237.2,FALSE,FALSE
273,6,BODY,"If the declaration of a sealed class C has a permits clause, then the permitted direct subclasses of C are the classes specified by the permits clause. Every permitted direct subclass specified by the permits clause must be a direct subclass of C (§8.1.4), or a compile-time error occurs. If the declaration of a sealed class C lacks a permits clause, then the permitted direct subclasses of C are as follows:",10.8,83.14,360,409,72,426.06,432,509.2,FALSE,FALSE
308,2,BODY,It is permitted but not required to mention unchecked exception classes (§11.1.1) in a throws clause. The relationship between a throws clause and the exception checking for a method or constructor body is specified in §11.2.3.,10.8,51.14,360.01,227,72,76.06,432.01,127.2,FALSE,FALSE
333,5,BODY,"•Otherwise, if the superclass constructor invocation is qualified, then the Primary expression or the ExpressionName immediately preceding '.super', p, is evaluated. If p evaluates to null, a NullPointerException is raised, and the superclass constructor invocation completes abruptly. Otherwise, the result of this evaluation is the immediately enclosing instance of i with respect to S.",10.8,96.14,342.01,388,90,342.06,432.01,438.2,FALSE,FALSE
338,4,BODY,"An enum declaration may specify a top level enum class (§7.6), a member enum class (§8.5, §9.5), or a local enum class (§14.3). The TypeIdentifier in an enum declaration specifies the name of the enum class. It is a compile-time error if an enum declaration has the modifier abstract, final, sealed, or non-sealed. An enum class is either implicitly final or implicitly sealed, as follows: •An enum class is implicitly final if its declaration contains no enum constants that have a class body (§8.9.1). •An enum class E is implicitly sealed if its declaration contains at least one enum constant that has a class body. The permitted direct subclasses (§8.1.6) of E are the anonymous classes implicitly declared by the enum constants that have a class body. A nested enum class is implicitly static. That is, every member enum class and local enum class is static. It is permitted for the declaration of a member enum class to redundantly specify the static modifier, but it is not permitted for the declaration of a local enum class (§14.3). It is a compile-time error if the same keyword appears more than once as a modifier for an enum declaration, or if an enum declaration has more than one of the access modifiers public, protected, and private (§6.6). The direct superclass type of an enum class E is Enum<E> (§8.1.4).",10.8,301.14,360.01,1325,72,182.06,432.01,483.2,FALSE,FALSE
430,4,BODY,"11.1.1The Kinds of Exceptions An exception is represented by an instance of the class Throwable (a direct subclass of Object) or one of its subclasses. Throwable and all its subclasses are, collectively, the exception classes. The classes Exception and Error are direct subclasses of Throwable: •Exception is the superclass of all the exceptions from which ordinary programs may wish to recover. The class RuntimeException is a direct subclass of Exception. RuntimeException is the superclass of all the exceptions which may be thrown for many reasons during expression evaluation, but from which recovery may still be possible. RuntimeException and all its subclasses are, collectively, the run-time exception classes. •Error is the superclass of all the exceptions from which ordinary programs are not ordinarily expected to recover. Error and all its subclasses are, collectively, the error classes. The unchecked exception classes are the run-time exception classes and the error classes.",10.8,283.11,360,992,72,313.09,432,596.2,FALSE,FALSE
450,2,BODY,"•IllegalAccessError: A symbolic reference has been encountered that specifies a use or assignment of a field, or invocation of a method, or creation of an instance of a class, to which the code containing the reference does not have access because the field or method was declared with private, protected, or package access (not public), or because the class was not declared public in a package that is exported or opened to the code containing the reference.",10.8,71.14,360.01,460,72,76.06,432.01,147.2,FALSE,FALSE
502,5,BODY,"Local class and interface declarations may be intermixed freely with statements (including local variable declaration statements) in the containing block. It is a compile-time error if a local class or interface declaration has any of the access modifiers public, protected, or private (§6.6). It is a compile-time error if a local class or interface declaration has the modifier static (§8.1.1.4), sealed, or non-sealed (§8.1.1.2, §9.1.1.4). It is a compile-time error if the direct superclass or a direct superinterface of a local class is sealed. It is a compile-time error if a direct superinterface of a local interface is sealed. A local class may be a normal class (§8.1), an enum class (§8.9), or a record class (§8.10). Every local normal class is an inner class (§8.1.3). Every local enum class and local record class is implicitly static (§8.1.1.4), and therefore not an inner class.",10.8,192.14,360.01,894,72,406.06,432.01,598.2,FALSE,FALSE
529,4,BODY,"Equality is defined in terms of the == operator (§15.21). •A case label with a case constant c applies to a value that is of type char, byte, short, int, or String or an enum type if the constant c is equal to the value. Equality is defined in terms of the == operator unless the value is a String, in which case equality is defined in terms of the equals method of class String. •Determining that a case label with case patterns p1, ..., pn (n≥1) applies to a value proceeds by finding the first (if any) case pattern pi (1≤i≤n) that applies to the value. Determining that a case pattern applies to a value proceeds first by checking the value matches the pattern (§14.30.2). Then: –If pattern matching completes abruptly then the whole process of determining which switch label applies completes abruptly for the same reason. –If pattern matching succeeds and the case label is unguarded then this case pattern applies. –If pattern matching succeeds and the case label is guarded, then the guard is evaluated. If the result is of type Boolean, it is subjected to unboxing conversion (§5.1.8). If evaluation of the guard or the subsequent unboxing conversion (if any) completes abruptly for some reason, then the whole process of determining which switch label applies completes abruptly for the same reason. Otherwise, if the resulting value is true then the case pattern applies.",10.8,359.14,342.01,1382,90,191.06,432.01,550.2,FALSE,FALSE
548,7,BODY,"There are two kinds of continue statement: •A continue statement with no label. •A continue statement with the label Identifier. A continue statement with no label attempts to transfer control to the innermost enclosing while, do, or for statement; this enclosing statement, which is called the continue target, then immediately ends the current iteration and begins a new one. A continue statement with label Identifier attempts to transfer control to the enclosing labeled statement (§14.7) that has the same Identifier as its label; this enclosing statement, which is called the continue target, then immediately ends the current iteration and begins a new one. In this case, the continue target must be a while, do, or for statement, or a compile-time error occurs. It is a compile-time error if a continue statement has no continue target.",10.8,179.14,360.01,844,72,405.06,432.01,584.2,FALSE,FALSE
549,2,BODY,"It is a compile-time error if the continue target contains any method, constructor, instance initializer, static initializer, lambda expression, or switch expression that encloses the continue statement. That is, there are no non-local jumps. Execution of a continue statement with no label always completes abruptly, the reason being a continue with no label. Execution of a continue statement with label Identifier always completes abruptly, the reason being a continue with label Identifier.",10.8,96.14,360,494,72,76.06,432,172.2,FALSE,FALSE
564,2,BODY,"with-resources statement with n-1 resources. After n such translations, there are n nested try-catch-finally statements, and the overall translation is complete. 14.20.3.1Basic try-with-resources A try-with-resources statement with no catch clauses or finally clause is called a basic try-with-resources statement. If a basic try-with-resources statement is of the form:",10.8,98.27,360,370,72,76.06,432,174.33,FALSE,FALSE
573,5,BODY,"–There is no earlier catch block A in the try statement such that the type of C's parameter is the same as, or a subclass of, the type of A's parameter. •The Block of a catch block is reachable iff the catch block is reachable. •If a finally block is present, it is reachable iff the try statement is reachable.",10.8,57.14,360,311,72,290.06,432,347.2,FALSE,FALSE
602,2,BODY,"Let C be the innermost enclosing class or interface declaration of a this expression. If C is generic, with type parameters F1,...,Fn, the type of this is C<F1,...,Fn>. Otherwise, the type of this is C. At run time, the class of the actual object referred to may be C or a subclass of C (§8.1.5.",10.8,64.14,360,295,72,76.06,432,140.2,FALSE,FALSE
618,4,BODY,ArrayCreationExpression: ArrayCreationExpressionWithoutInitializer ArrayCreationExpressionWithInitializer ArrayCreationExpressionWithoutInitializer: new PrimitiveType DimExprs [Dims] new ClassOrInterfaceType DimExprs [Dims] ArrayCreationExpressionWithInitializer: new PrimitiveType Dims ArrayInitializer new ClassOrInterfaceType Dims ArrayInitializer DimExprs: DimExpr {DimExpr} DimExpr: {Annotation} [ Expression ] The following production from §4.3 is shown here for convenience:,10.8,227.99,244.46,481,90,155.13,334.46,383.12,FALSE,TRUE
680,8,BODY,"The operators +, -, ++, --, ~, !, and the cast operator (§15.16) are called the unary operators. A unary expression is either a unary operator applied to an operand, or a switch expression (§15.28).",10.8,32.14,360.01,198,72,482.06,432.01,514.2,FALSE,FALSE
697,4,BODY,"The numerical comparison operators <, >, <=, and >=, and the instanceof operator, are called the relational operators.",10.8,19.14,360.01,118,72,296.06,432.01,315.2,FALSE,FALSE
754,2,BODY,•V is [un]assigned before a iff V is [un]assigned before a && b. •V is [un]assigned before b iff V is [un]assigned after a when true. •V is [un]assigned after a && b iff V is [un]assigned after a && b when true and V is [un]assigned after a && b when false.,10.8,57.14,360,257,72,76.06,432,133.2,FALSE,FALSE
758,3,BODY,"16.1.7Other Expressions of Type boolean Suppose that e is an expression of type boolean and is not a boolean constant expression, logical complement expression !a, conditional-and expression a && b, conditional-or expression a || b, or conditional expression a ? b : c. •V is [un]assigned after e when true iff V is [un]assigned after e. •V is [un]assigned after e when false iff V is [un]assigned after e.",10.8,91.11,360,406,72,121.09,432,212.2,FALSE,FALSE
836,2,BODY,"second step is repeated to infer constraints under which RS is more specific than RT θ' for the given result expression. »Otherwise, if RS is a primitive type and RT is not, and ei has at least one result expression, and each result expression of ei is a standalone expression (§15.2) of a primitive type, true. »Otherwise, if RT is a primitive type and RS is not, and ei has at least one result expression, and each result expression of ei is either a standalone expression of a reference type or a poly expression, true. »Otherwise, ‹RS <: RT θ'›. ›Otherwise, if ei is an exact method reference: »If RT is void, true. »Otherwise, if RS is a primitive type and RT is not, and the compile-time declaration for ei has a primitive return type, true. »Otherwise if RT is a primitive type and RS is not, and the compile-time declaration for ei has a reference return type, true. »Otherwise, ‹RS <: RT θ'›. ›Otherwise, if ei is a parenthesized expression, these rules for constraints derived from RS and RT are applied recursively for the contained expression. ›Otherwise, if ei is a conditional expression, these rules for constraints derived from RS and RT are applied recursively for each of the second and third operands. ›Otherwise, if ei is a switch expression, these rules for constraints derived from RS and RT are applied recursively for each of its result expressions. ›Otherwise, false.",10.8,377.14,340,1392,92,76.06,432,453.2,FALSE,FALSE
837,4,BODY,"If T is a parameterized type, let Tc be the result of capture conversion (§5.1.10) applied to T, and let Z1, ..., Zk (k ≥ 0) be the type variables produced by capture that are type arguments in Tc. (This includes type variables produced by the capture conversion in this step, and type variables produced by capture conversion elsewhere.) Let β1, ..., βk (k ≥ 0) be inference variables, and let θ be the substitution [Z1:=β1, ..., Zk:=βk]. T' is Tc θ. Additional bounds for β1, ..., βk are incorporated into B0 to form a bound set B1, as follows: •If βi (1 ≤ i ≤ k) replaced a type variable with an upper bound U, then the bound βi <: U θ appears in the bound set. •If βi (1 ≤ i ≤ k) replaced a type variable with a lower bound L, then the bound L θ <: βi appears in the bound set. •If no proper upper bounds otherwise exist for βi (1 ≤ i ≤ k), the bound βi <: Object appears in the bound set. •If T is any other class or interface type, then T' is the same as T, and B1 is the same as B0. •If T is a type variable or an intersection type, then for each upper bound of the type variable or element of the intersection type, this step and step 4 are repeated recursively. All bounds produced in steps 3 and 4 are incorporated into a single bound set.",10.8,289.14,342.01,1249,90,225.06,432.01,514.2,FALSE,FALSE
846,1,BODY,ModuleDeclaration: {Annotation} [open] module Identifier {. Identifier} { {ModuleDirective} },10.8,32.05,240.09,93,90,76.13,330.09,108.18,FALSE,TRUE
73,2,BODY,"The floating-point types are float, whose values exactly correspond to the 32- bit IEEE 754 binary32 floating-point numbers, and double, whose values exactly correspond to the 64-bit IEEE 754 binary64 floating-point numbers. The boolean type has exactly two values: true and false.",10.79,51.14,360,281,72,76.06,432,127.2,FALSE,FALSE
131,3,BODY,"long, or to an int, if T is byte, short, char, or int, as follows: •If the floating-point number is NaN (§4.2.3), the result of the first step of the conversion is an int or long 0. •Otherwise, if the floating-point number is not an infinity, the floating-point value is rounded to an integer value V using the round toward zero rounding policy (§4.2.4). Then there are two cases: a.If T is long, and this integer value can be represented as a long, then the",10.79,102.14,342,458,90,192.06,432,294.2,FALSE,FALSE
161,2,BODY,"2.Next, widening primitive conversion (§5.1.2) and narrowing primitive conversion (§5.1.3) are applied to some expressions, according to the following rules: •If any expression is of type double, then the promoted type is double, and other expressions that are not of type double undergo widening primitive conversion to double. •Otherwise, if any expression is of type float, then the promoted type is float, and other expressions that are not of type float undergo widening primitive conversion to float. •Otherwise, if any expression is of type long, then the promoted type is long, and other expressions that are not of type long undergo widening primitive conversion to long. •Otherwise, none of the expressions are of type double, float, or long. In this case, the kind of context determines how the promoted type is chosen. In a numeric arithmetic context or a numeric array context, the promoted type is int, and any expressions that are not of type int undergo widening primitive conversion to int. In a numeric choice context, the following rules apply: –If any expression is of type int and is not a constant expression (§15.29), then the promoted type is int, and other expressions that are not of type int undergo widening primitive conversion to int. –Otherwise, if any expression is of type short, and every other expression is either of type short or of type byte or a constant expression of type int with a value that is representable in the type short, then the promoted type is short, and the byte expressions undergo widening primitive conversion to short, and the int expressions undergo narrowing primitive conversion to short. –Otherwise, if any expression is of type byte, and every other expression is either of type byte or a constant expression of type int with a value that is representable in the type byte, then the promoted type is byte, and the int expressions undergo narrowing primitive conversion to byte. –Otherwise, if any expression is of type char, and every other expression is either of type char or a constant expression of type int with a value that",10.79,482.14,360.01,2092,72,76.06,432.01,558.2,FALSE,FALSE
365,6,BODY,"If the declaration of a sealed interface I has a permits clause, then the permitted direct subclasses and subinterfaces of I are the classes and interfaces specified by the permits clause. Every permitted direct subclass and subinterface specified by the permits clause must be a direct subclass of I (§8.1.5) or a direct subinterface of I (§9.1.3), or a compile-time error occurs. If the declaration of a sealed interface I lacks a permits clause, then the permitted direct subclasses and subinterfaces of I are those classes and interfaces declared",10.79,109.14,360,550,72,491.06,432,600.2,FALSE,FALSE
380,3,BODY,AnnotationInterfaceBody: { {AnnotationInterfaceMemberDeclaration} } AnnotationInterfaceMemberDeclaration: AnnotationInterfaceElementDeclaration ConstantDeclaration ClassDeclaration InterfaceDeclaration ; AnnotationInterfaceElementDeclaration: {AnnotationInterfaceElementModifier} UnannType Identifier ( ) [Dims] [DefaultValue] ;,10.79,158.05,330.55,328,90,160.13,420.55,318.18,FALSE,TRUE
450,10,BODY,"Additionally, an UnsatisfiedLinkError, a subclass of LinkageError, may be thrown if a class declares a native method for which no implementation can be found. The error will occur if the method is used, or earlier, depending on what kind of resolution strategy is being used by an implementation of the Java Virtual Machine (§12.3).",10.79,58.14,360,332,72,453.06,432,511.2,FALSE,FALSE
477,5,BODY,"13.4.2.1sealed Classes If a class that was freely extensible (§8.1.1.2) is changed to be declared sealed, then an IncompatibleClassChangeError is thrown if a binary of a pre-existing subclass of this class is loaded and is not a permitted direct subclass of this class (§8.1.6); such a change is not recommended for widely distributed classes. Changing a class that was declared final to be declared sealed does not break compatibility with pre-existing binaries. Adding a class to the set of permitted direct subclasses of a sealed class will not break compatibility with pre-existing binaries.",10.79,129.2,360,595,72,317.13,432,446.33,FALSE,FALSE
485,11,BODY,"Deleting a field from a class will break compatibility with any pre-existing binaries that reference this field, and a NoSuchFieldError will be thrown when such a",10.79,19.14,360.01,162,72,560.06,432.01,579.2,FALSE,FALSE
495,3,BODY,"13.5.2sealed and non-sealed Interfaces If an interface that was freely extensible (§9.1.1.4) is changed to be declared sealed, then an IncompatibleClassChangeError is thrown if a binary of a pre- existing subclass or subinterface of this interface is loaded and is not a permitted direct subclass or subinterface of this interface (§9.1.4); such a change is not recommended for widely distributed classes. Adding a class or interface to the set of permitted direct subclasses or subinterfaces, respectively, of a sealed interface will not break compatibility with pre-existing binaries.",10.79,124.11,360.01,586,72,200.09,432.01,324.2,FALSE,FALSE
531,2,BODY,"14.11.2The Switch Block of a switch Statement In addition to the general rules for switch blocks (§14.11.1), there are further rules for switch blocks in switch statements. An enhanced switch statement is one where either (i) the type of the selector expression is not char, byte, short, int, Character, Byte, Short, Integer, String, or an enum type, or (ii) there is a case pattern or null literal associated with the switch block. All of the following must be true for the switch block of a switch statement, or a compile-time error occurs: •Every switch rule expression in the switch block is a statement expression (§14.8).",10.79,162.11,360,627,72,76.09,432,238.2,FALSE,FALSE
535,4,BODY,WhileStatement: while ( Expression ) Statement WhileStatementNoShortIf: while ( Expression ) StatementNoShortIf,10.79,56.05,194.46,111,90,233.13,284.46,289.18,FALSE,TRUE
552,4,BODY,"If there are any enclosing try statements (§14.20) whose try blocks contain the throw statement, then any finally clauses of those try statements are executed as control is transferred outward, until the thrown value is caught. Note that abrupt completion of a finally clause can disrupt the transfer of control initiated by a throw statement. If a throw statement is contained in a method declaration or a lambda expression, but its value is not caught by some try statement that contains it, then the invocation of the method completes abruptly because of the throw.",10.79,103.14,360.01,568,72,486.06,432.01,589.2,FALSE,FALSE
592,2,BODY,"If, however, evaluation of an expression throws an exception, then the expression is said to complete abruptly. An abrupt completion always has an associated reason, which is always a throw with a given value. Run-time exceptions are thrown by the predefined operators as follows: •A class instance creation expression (§15.9.4), array creation expression (§15.10.2), method reference expression (§15.13.3), array initializer expression (§10.6), string concatenation operator expression (§15.18.1), or lambda expression (§15.27.4) throws an OutOfMemoryError if there is insufficient memory available. •An array creation expression (§15.10.2) throws a NegativeArraySizeException if the value of any dimension expression is less than zero. •An array access expression (§15.10.4) throws a NullPointerException if the value of the array reference expression is null. •An array access expression (§15.10.4) throws an ArrayIndexOutOfBoundsException if the value of the array index expression is negative or greater than or equal to the length of the array. •A field access expression (§15.11) throws a NullPointerException if the value of the object reference expression is null. •A method invocation expression (§15.12) that invokes an instance method throws a NullPointerException if the target reference is null. •A cast expression (§15.16) throws a ClassCastException if a cast is found to be impermissible at run time. •An integer division (§15.17.2) or integer remainder (§15.17.3) operator throws an ArithmeticException if the value of the right-hand operand expression is zero. •An assignment to an array component of reference type (§15.26.1), a method invocation expression (§15.12), or a prefix or postfix increment (§15.14.2, §15.15.1) or decrement operator (§15.14.3, §15.15.2) may all throw an OutOfMemoryError as a result of boxing conversion (§5.1.7). •An assignment to an array component of reference type (§15.26.1) throws an ArrayStoreException when the value to be assigned is not compatible with the component type of the array (§10.5). •A switch expression (§15.28) or enhanced switch statement (§14.11.2) throws a MatchException if no switch label applies to the value of the selector expression.",10.79,520.14,360.01,2213,72,76.06,432.01,596.2,FALSE,FALSE
698,6,BODY,"Subject to these considerations for floating-point numbers, the following rules then hold for integer operands or for floating-point operands other than NaN: •The value produced by the < operator is true if the value of the left-hand operand is less than the value of the right-hand operand, and otherwise is false. •The value produced by the <= operator is true if the value of the left-hand operand is less than or equal to the value of the right-hand operand, and otherwise is false. •The value produced by the > operator is true if the value of the left-hand operand is greater than the value of the right-hand operand, and otherwise is false. •The value produced by the >= operator is true if the value of the left-hand operand is greater than or equal to the value of the right-hand operand, and otherwise is false.",10.79,173.14,360.01,821,72,343.06,432.01,516.2,FALSE,FALSE
707,5,BODY,"The conditional operator is syntactically right-associative (it groups right-to-left). Thus, a?b:c?d:e?f:g means the same as a?b:(c?d:(e?f:g)). The conditional operator has three operand expressions. ? appears between the first and second expressions, and : appears between the second and third expressions. The first expression must be of type boolean or Boolean, or a compile-time error occurs. It is a compile-time error for either the second or the third operand expression to be an invocation of a void method.",10.79,115.14,360,515,72,275.06,432,390.2,FALSE,FALSE
822,2,BODY,"•If the bound set does not contain a bound of the form G<..., αi, ...> = capture(G<...>) for all i (1 ≤ i ≤ n), then a candidate instantiation Ti is defined for each αi: –If αi has one or more proper lower bounds, L1, ..., Lk, then Ti = lub(L1, ..., Lk) (§4.10.4). –Otherwise, if the bound set contains throws αi, and each proper upper bound of αi is a supertype of RuntimeException, then Ti = RuntimeException. –Otherwise, where αi has proper upper bounds U1, ..., Uk, Ti = glb(U1, ..., Uk) (§5.1.10). The bounds α1 = T1, ..., αn = Tn are incorporated with the current bound set. If the result does not contain the bound false, then the result becomes the new bound set, and resolution proceeds by selecting a new set of variables to instantiate (if necessary), as described above. Otherwise, the result contains the bound false, so a second attempt is made to instantiate { α1, ..., αn } by performing the step below. •If the bound set contains a bound of the form G<..., αi, ...> = capture(G<...>) for some i (1 ≤ i ≤ n), or; If the bound set produced in the step above contains the bound false; then let Y1, ..., Yn be fresh type variables whose bounds are as follows: –For all i (1 ≤ i ≤ n), if αi has one or more proper lower bounds L1, ..., Lk, then let the lower bound of Yi be lub(L1, ..., Lk); if not, then Yi has no lower bound. –For all i (1 ≤ i ≤ n), where αi has upper bounds U1, ..., Uk, let the upper bound of Yi be glb(U1 θ, ..., Uk θ), where θ is the substitution [α1:=Y1, ..., αn:=Yn]. If the type variables Y1, ..., Yn do not have well-formed bounds (that is, a lower bound is not a subtype of an upper bound, or an intersection type is inconsistent), then resolution fails. Otherwise, for all i (1 ≤ i ≤ n), all bounds of the form G<..., αi, ...> = capture(G<...>) are removed from the current bound set, and the bounds α1 = Y1, ..., αn = Yn are incorporated. If the result does not contain the bound false, then the result becomes the new bound set, and resolution proceeds by selecting a new set of variables to instantiate (if necessary), as described above. Otherwise, the result contains the bound false, and resolution fails.",10.79,512.14,360.01,2152,72,76.06,432.01,588.2,FALSE,FALSE
844,1,BODY,Wildcard: {Annotation} ? [WildcardBounds] WildcardBounds: extends ReferenceType super ReferenceType Productions from §6 (Names),10.79,93.3,179.1,127,72,76.13,251.1,169.43,FALSE,TRUE
865,1,BODY,"FieldAccess: Primary . Identifier super . Identifier TypeName . super . Identifier MethodInvocation: MethodName ( [ArgumentList] ) TypeName . [TypeArguments] Identifier ( [ArgumentList] ) ExpressionName . [TypeArguments] Identifier ( [ArgumentList] ) Primary . [TypeArguments] Identifier ( [ArgumentList] ) super . [TypeArguments] Identifier ( [ArgumentList] ) TypeName . super . [TypeArguments] Identifier ( [ArgumentList] ) ArgumentList: Expression {, Expression} MethodReference: ExpressionName :: [TypeArguments] Identifier Primary :: [TypeArguments] Identifier ReferenceType :: [TypeArguments] Identifier super :: [TypeArguments] Identifier TypeName . super :: [TypeArguments] Identifier ClassType :: [TypeArguments] new ArrayType :: new",10.79,299.05,314.65,742,90,76.13,404.65,375.18,FALSE,TRUE
108,2,BODY,"•In declarations: 1.A type in the extends or implements clause of a class declaration (§8.1.4,",10.78,25.14,360,94,72,76.06,432,101.2,FALSE,FALSE
131,4,BODY,result of the first step is the long value V.,10.78,6.14,181.59,45,118,301.06,299.59,307.2,FALSE,FALSE
133,5,BODY,"5.1.4Widening and Narrowing Primitive Conversion The following conversion combines both widening and narrowing primitive conversions: •byte to char First, the byte is converted to an int via widening primitive conversion (§5.1.2), and then the resulting int is converted to a char by narrowing primitive conversion (§5.1.3).",10.78,104.11,360,324,72,269.09,432,373.2,FALSE,FALSE
197,6,BODY,11.To the left of .Identifier or .super.Identifier in a qualified method,10.78,6.14,350,72,82,311.06,432,317.2,FALSE,FALSE
296,4,BODY,"FormalParameterList: FormalParameter {, FormalParameter} FormalParameter: {VariableModifier} UnannType VariableDeclaratorId VariableArityParameter VariableArityParameter: {VariableModifier} UnannType {Annotation} ... Identifier VariableModifier: Annotation final",10.78,154.75,272.96,262,90,321.13,362.96,475.88,FALSE,TRUE
301,4,BODY,An instance method that is not abstract can be overridden by an abstract method.,10.78,19.14,360,80,72,233.06,432,252.2,FALSE,FALSE
309,8,BODY,"8.4.8Inheritance, Overriding, and Hiding A class C inherits from its direct superclass type D all concrete methods m (both static and instance) for which all of the following are true: •m is a member of D. •m is public, protected, or declared with package access in the same package as C.",10.78,91.11,360,288,72,508.09,432,599.2,FALSE,FALSE
413,6,BODY,"The function type of a functional interface type is specified as follows: •The function type of the type of a non-generic functional interface I is simply the function type of the functional interface I, as defined above. •The function type of a parameterized functional interface type I<A1...An>, where A1...An are types and the corresponding type parameters of I are P1...Pn, is derived by applying the substitution [P1:=A1, ..., Pn:=An] to the function type of the generic functional interface I<P1...Pn>. •The function type of a parameterized functional interface type I<A1...An>, where one or more of A1...An is a wildcard, is the function type of the non-",10.78,128.14,360,661,72,431.06,432,559.2,FALSE,FALSE
447,2,BODY,"12.2.1The Loading Process The loading process is implemented by the class ClassLoader and its subclasses. The method defineClass of class ClassLoader may be used to construct Class objects from binary representations in the class file format (§1.4). Different subclasses of ClassLoader may implement different loading policies. In particular, a class loader may cache binary representations of classes and interfaces, prefetch them based on expected usage, or load a group of related classes together. These activities may not be completely transparent to a running application if, for example, a newly compiled version of a class is not found because an older version is cached by a class loader. It is the responsibility of a class loader, however, to reflect loading errors only at points in the program where they could have arisen without prefetching or group loading. If an error occurs during class loading, then an instance of one of the following subclasses of class LinkageError will be thrown at any point in the program that (directly or indirectly) uses the requested class or interface: •ClassCircularityError: A requested class or interface could not be loaded because it would be its own superclass or superinterface (§8.1.4, §9.1.3, §13.4.4). •ClassFormatError: The binary data that purports to specify a requested compiled class or interface is malformed. •NoClassDefFoundError: No definition for a requested class or interface could be found by the relevant class loader. Because loading involves the allocation of new data structures, it may fail with an OutOfMemoryError.",10.78,336.11,360.01,1592,72,76.09,432.01,412.2,FALSE,FALSE
465,5,BODY,"2.A thread invoked System.exit or Runtime.exit, and all of the shutdown hooks which consequently were started by the Java Virtual Machine, if any, have terminated.",10.78,32.14,360,163,72,300.06,432,332.2,FALSE,FALSE
478,2,BODY,"If a class is removed from the set of permitted direct subclasses of a sealed class, then an IncompatibleClassChangeError is thrown if the pre-existing binary of the removed class is loaded. Deleting the sealed modifier from a class that does not have a sealed direct superclass or a sealed direct superinterface does not break compatibility with pre- existing binaries.",10.78,77.14,360,370,72,76.06,432,153.2,FALSE,FALSE
495,2,BODY,"13.5.1public Interfaces Changing an interface that is not declared public to be declared public does not break compatibility with pre-existing binaries. If an interface that is declared public is changed to not be declared public, then an IllegalAccessError is thrown if a pre-existing binary is linked that needs but no longer has access to the interface type, so such a change is not recommended for widely distributed interfaces.",10.78,98.11,360.01,432,72,76.09,432.01,174.2,FALSE,FALSE
553,6,BODY,"The type of Expression must be a reference type, or a compile-time error occurs. A synchronized statement is executed by first evaluating the Expression. Then: •If evaluation of the Expression completes abruptly for some reason, then the synchronized statement completes abruptly for the same reason. •Otherwise, if the value of the Expression is null, a NullPointerException is thrown.",10.78,89.14,360,386,72,475.06,432,564.2,FALSE,FALSE
554,3,BODY,The locks acquired by synchronized statements are the same as the locks that are acquired implicitly by synchronized methods (§8.4.3.6). A single thread may acquire a lock more than once. Acquiring the lock associated with an object does not in itself prevent other threads from accessing fields of the object or invoking un-synchronized methods on the object. Other threads can also use synchronized methods or the synchronized statement in a conventional manner to achieve mutual exclusion.,10.78,90.14,360,492,72,198.06,432,288.2,FALSE,FALSE
572,2,BODY,"•A while statement can complete normally iff at least one of the following is true: –The while statement is reachable and the condition expression is not a constant expression (§15.29) with value true. –There is a reachable break statement that exits the while statement. The contained statement is reachable iff the while statement is reachable and the condition expression is not a constant expression whose value is false. •A do statement can complete normally iff at least one of the following is true: –The contained statement can complete normally and the condition expression is not a constant expression (§15.29) with value true. –The do statement contains a reachable continue statement with no label, and the do statement is the innermost while, do, or for statement that contains that continue statement, and the continue statement continues that do statement, and the condition expression is not a constant expression with value true. –The do statement contains a reachable continue statement with label L, and the do statement has label L, and the continue statement continues that do statement, and the condition expression is not a constant expression with value true. –There is a reachable break statement that exits the do statement. The contained statement is reachable iff the do statement is reachable. •A basic for statement can complete normally iff at least one of the following is true: –The for statement is reachable, there is a condition expression, and the condition expression is not a constant expression (§15.29) with value true. –There is a reachable break statement that exits the for statement. The contained statement is reachable iff the for statement is reachable and the condition expression is not a constant expression whose value is false. •An enhanced for statement can complete normally iff it is reachable. •A break, continue, return, throw, or yield statement cannot complete normally. •A synchronized statement can complete normally iff the contained statement can complete normally. The contained statement is reachable iff the synchronized statement is reachable.",10.78,524.14,360.01,2111,72,76.06,432.01,600.2,FALSE,FALSE
684,6,BODY,"15.15.6Logical Complement Operator ! The type of the operand expression of the unary ! operator must be boolean or Boolean, or a compile-time error occurs. The type of the unary logical complement expression is boolean. At run time, the operand is subject to unboxing conversion (§5.1.8) if necessary. The value of the unary logical complement expression is true if the (possibly converted) operand value is false, and false if the (possibly converted) operand value is true.",10.78,117.11,360,475,72,421.09,432,538.2,FALSE,FALSE
768,3,BODY,"16.2.15try Statements The rules herein cover the try-catch and try-catch-finally statements (§14.20.1, §14.20.2). Since the try-with-resources statement (§14.20.3) is defined by translation to a try-catch-finally statement, no special rules need to be provided for it. These rules apply to every try statement (§14.20), whether or not it has a finally block: •V is [un]assigned before the try block iff V is [un]assigned before the try statement. •V is definitely assigned before a catch block iff V is definitely assigned before the try block. •V is definitely unassigned before a catch block iff all of the following are true: –V is definitely unassigned after the try block. –V is definitely unassigned before every return statement that belongs to the try block. –V is definitely unassigned after e in every statement of the form throw e that belongs to the try block. –V is definitely unassigned after every assert statement that occurs in the try block. –V is definitely unassigned before every break statement that belongs to the try block and whose break target contains (or is) the try statement. –V is definitely unassigned before every continue statement that belongs to the try block and whose continue target contains the try statement.",10.78,360.11,360,1249,72,140.09,432,500.2,FALSE,FALSE
769,2,BODY,•V is definitely assigned after the try statement iff at least one of the following is true: –V is definitely assigned after the try block and V is definitely assigned after every catch block in the try statement. –V is definitely assigned after the finally block. •V is definitely unassigned after the try statement iff V is definitely unassigned after the finally block. •V is definitely assigned before the finally block iff V is definitely assigned before the try statement. •V is definitely unassigned before the finally block iff all of the following are true: –V is definitely unassigned after the try block. –V is definitely unassigned before every return statement that belongs to the try block. –V is definitely unassigned after e in every statement of the form throw e that belongs to the try block. –V is definitely unassigned after every assert statement that occurs in the try block. –V is definitely unassigned before every break statement that belongs to the try block and whose break target contains (or is) the try statement. –V is definitely unassigned before every continue statement that belongs to the try block and whose continue target contains the try statement. –V is definitely unassigned after every catch block of the try statement.,10.78,364.14,360,1261,72,76.06,432,440.2,FALSE,FALSE
807,2,BODY,"When inference begins, a bound set is typically generated from a list of type parameter declarations P1, ..., Pp and associated inference variables α1, ..., αp. Such a bound set is generated as follows. For each l (1 ≤ l ≤ p): •If Pl has no TypeBound, the bound αl <: Object appears in the set. •Otherwise, for each type T delimited by & in the TypeBound, the bound αl <: T[P1:=α1, ..., Pp:=αp] appears in the set; if this results in no proper upper bounds for αl (only dependencies), then the bound αl <: Object also appears in the set.",10.78,97.17,360.01,537,72,76.06,432.01,173.23,FALSE,FALSE
47,8,BODY,"•For record, when recognized as a terminal in a RecordDeclaration (§8.10). •For non-sealed, permits, and sealed, when recognized as a terminal in a NormalClassDeclaration (§8.1) or a NormalInterfaceDeclaration (§9.1). •For when, when recognized as a terminal in a Guard (§14.11.1).",10.77,57.14,342,281,90,533.06,432,590.2,FALSE,FALSE
60,7,BODY,"The character represented a character literal is the content of the character literal with any escape sequence interpreted, as if by execution of String.translateEscapes on the content. Character literals can only represent UTF-16 code units (§3.1), i.e., they are limited to values from \u0000 to \uffff. Supplementary characters must be represented either as a surrogate pair within a char sequence, or as an integer, depending on the API they are used with.",10.77,90.14,360,460,72,416.2,432,506.33,FALSE,FALSE
107,2,BODY,"•If T is a parameterized class type or a parameterized interface type, G<A1,...,An>, then the result is G<A1',...,An'>, if, for 1 ≤ i ≤ n, a type argument Ai' can be derived from Ai as follows; if not, the result is undefined: –If Ai is does not mention a restricted type variable, then Ai' = Ai. –If Ai is a type that mentions a restricted type variable, then Ai' is undefined. –If Ai is an upper-bounded wildcard that mentions a restricted type variable, then if the downward projection of the wildcard bound is U, then Ai' is an upper- bounded wildcard, ? extends U; if the downward projection of the wildcard bound is undefined, then Ai' is undefined. –If Ai is a lower-bounded wildcard that mentions a restricted type variable, then let L be the upward projection of the wildcard bound. Ai' is a lower-bounded wildcard, ? super L.",10.77,173.14,360,835,72,76.06,432,249.2,FALSE,FALSE
288,2,BODY,"8.3.1.2final Fields A field can be declared final (§4.12.4). Both class and instance variables (static and non-static fields) may be declared final. A blank final class variable must be definitely assigned by a static initializer of the class in which it is declared, or a compile-time error occurs (§8.7, §16.8). A blank final instance variable must be definitely assigned and moreover not definitely unassigned at the end of every constructor of the class in which it is declared, or a compile-time error occurs (§8.8, §16.9). 8.3.1.3transient Fields Variables may be marked transient to indicate that they are not part of the persistent state of an object.",10.77,176.34,360,659,72,76.13,432,252.46,FALSE,FALSE
552,3,BODY,"At least one of the following three conditions must be true, or a compile-time error occurs: •The type of the Expression is an unchecked exception class (§11.1.1) or the null type (§4.1). •The throw statement is contained in the try block of a try statement (§14.20) and it is not the case that the try statement can throw an exception of the type of the Expression. (In this case we say the thrown value is caught by the try statement.) •The throw statement is contained in a method or constructor declaration and the type of the Expression is assignable (§5.2) to at least one type listed in the throws clause (§8.4.6, §8.8.5) of the declaration. The exception types that a throw statement can throw are specified in §11.2.2. A throw statement first evaluates the Expression. Then: •If evaluation of the Expression completes abruptly for some reason, then the throw completes abruptly for that reason. •If evaluation of the Expression completes normally, producing a non-null value V, then the throw statement completes abruptly, the reason being a throw with value V. •If evaluation of the Expression completes normally, producing a null value, then an instance V' of class NullPointerException is created and thrown instead of null. The throw statement then completes abruptly, the reason being a throw with value V'. It can be seen, then, that a throw statement always completes abruptly.",10.77,349.06,360.01,1393,72,118.06,432.01,467.12,FALSE,FALSE
570,2,BODY,"The rules are as follows: •The block that is the body of a constructor, method, instance initializer, static initializer, lambda expression, or switch expression is reachable. •An empty block that is not a switch block can complete normally iff it is reachable. A non-empty block that is not a switch block can complete normally iff the last statement in it can complete normally. The first statement in a non-empty block that is not a switch block is reachable iff the block is reachable. Every other statement S in a non-empty block that is not a switch block is reachable iff the statement preceding S can complete normally. •A local class declaration statement can complete normally iff it is reachable. •A local variable declaration statement can complete normally iff it is reachable. •An empty statement can complete normally iff it is reachable. •A labeled statement can complete normally if at least one of the following is true: –The contained statement can complete normally. –There is a reachable break statement that exits the labeled statement. The contained statement is reachable iff the labeled statement is reachable. •An expression statement can complete normally iff it is reachable. •An if-then statement can complete normally iff it is reachable. The then-statement is reachable iff the if-then statement is reachable. An if-then-else statement can complete normally iff the then-statement can complete normally or the else-statement can complete normally. The then-statement is reachable iff the if-then-else statement is reachable. The else-statement is reachable iff the if-then-else statement is reachable. This handling of an if statement, whether or not it has an else part, is rather unusual. The rationale is given at the end of this section.",10.77,458.06,360.01,1772,72,76.06,432.01,534.12,FALSE,FALSE
699,3,BODY,"If the operand to the right of the instanceof keyword is a ReferenceType, then the instanceof keyword is the type comparison operator. If the operand to the right of the instanceof keyword is a Pattern, then the instanceof keyword is the pattern match operator. The following rules apply when instanceof is the type comparison operator: •The type of the expression RelationalExpression must be a reference type or the null type, or a compile-time error occurs. •The RelationalExpression must be checked cast compatible with the ReferenceType (§5.5), or a compile-time error occurs. •At run time, the result of the type comparison operator is determined as follows: –If the value of the RelationalExpression is the null reference (§4.1), then the result is false. –If the value of the RelationalExpression is not the null reference, then the result is true if the value could be cast to the ReferenceType without raising a ClassCastException, and false otherwise.",10.77,230.14,360.01,962,72,126.06,432.01,356.2,FALSE,FALSE
861,1,BODY,BreakStatement: break [Identifier] ; YieldStatement: yield Expression ; ContinueStatement: continue [Identifier] ; ReturnStatement: return [Expression] ; ThrowStatement: throw Expression ; SynchronizedStatement: synchronized ( Expression ) Block TryStatement: try Block Catches try Block [Catches] Finally TryWithResourcesStatement Catches: CatchClause {CatchClause} CatchClause: catch ( CatchFormalParameter ) Block CatchFormalParameter: {VariableModifier} CatchType VariableDeclaratorId CatchType: UnannClassType {| ClassType} Finally: finally Block TryWithResourcesStatement: try ResourceSpecification Block [Catches] [Finally] ResourceSpecification: ( ResourceList [;] ),10.77,526.05,245.51,674,90,76.13,335.51,602.18,FALSE,TRUE
58,2,BODY,HexadecimalFloatingPointLiteral: HexSignificand BinaryExponent [FloatTypeSuffix] HexSignificand: HexNumeral [.] 0 x [HexDigits] . HexDigits 0 X [HexDigits] . HexDigits BinaryExponent: BinaryExponentIndicator SignedInteger BinaryExponentIndicator: (one of) p P,10.76,167.75,233.65,259,90,76.13,323.65,243.88,FALSE,TRUE
219,2,BODY,6.6.2Details on protected Access A protected member or constructor of an object may be accessed from outside the package in which it is declared only by code that is responsible for the implementation of that object. 6.6.2.1Access to a protected Member Let C be the class in which a protected member is declared. Access is permitted only within the body of a subclass S of C.,10.76,113.24,360,375,72,76.09,432,189.33,FALSE,FALSE
219,6,BODY,6.6.2.2Access to a protected Constructor Let C be the class in which a protected constructor is declared and let S be the innermost class in whose declaration the use of the protected constructor occurs. Then:,10.76,52.2,360,209,72,538.26,432,590.47,FALSE,FALSE
310,2,BODY,"•No method declared in C has a signature that is a subsignature (§8.4.2) of the signature of m as a member of D. A class C inherits from its direct superclass type and direct superinterface types all abstract and default (§9.4) methods m for which all of the following are true: •m is a member of the direct superclass type or a direct superinterface type of C, known in either case as D. •m is public, protected, or declared with package access in the same package as C. •No method declared in C has a signature that is a subsignature (§8.4.2) of the signature of m as a member of D. •No concrete method inherited by C from its direct superclass type has a signature that is a subsignature of the signature of m as a member of D. •There exists no method m' that is a member of the direct superclass type or a direct superinterface type of C, D' (m distinct from m', D distinct from D'), such that m' overrides from the class or interface of D' the declaration of the method m (§8.4.8.1, §9.4.1.1). Inheritance for interfaces is defined in §9.1.3.",10.76,259.06,360,1047,72,76.06,432,335.12,FALSE,FALSE
347,4,BODY,"A record declaration may specify a top level record class (§7.6), a member record class (§8.5, §9.5), or a local record class (§14.3). The TypeIdentifier in a record declaration specifies the name of the record class. It is a compile-time error if a record declaration has the modifier abstract, sealed, or non-sealed. A record class is implicitly final. It is permitted for the declaration of a record class to redundantly specify the final modifier. A nested record class is implicitly static. That is, every member record class and local record class is static. It is permitted for the declaration of a member record class to redundantly specify the static modifier, but it is not permitted for the declaration of a local record class (§14.3). It is a compile-time error if the same keyword appears more than once as a modifier for a record declaration, or if a record declaration has more than one of the access modifiers public, protected, and private (§6.6). The direct superclass type of a record class is Record (§8.1.4).",10.76,224.14,360.01,1029,72,195.06,432.01,419.2,FALSE,FALSE
361,2,BODY,"The rules concerning annotation modifiers for an interface declaration are specified in §9.7.4 and §9.7.5. The access modifier public (§6.6) pertains only to top level interfaces (§7.6) and member interfaces (§8.5, §9.5), not to local interfaces (§14.3). The access modifiers protected and private pertain only to member interfaces. The modifier static pertains only to member interfaces and local interfaces. It is a compile-time error if the same keyword appears more than once as a modifier for an interface declaration, or if a interface declaration has more than one of the access modifiers public, protected, and private. It is a compile-time error if an interface declaration has more than one of the modifiers sealed and non-sealed.",10.76,166.14,360.01,740,72,76.06,432.01,242.2,FALSE,FALSE
422,3,BODY,"Arrays must be indexed by int values; short, byte, or char values may also be used as index values because they are subjected to unary numeric promotion (§5.6) and become int values. An attempt to access an array component with a long index value results in a compile-time error. All array accesses are checked at run time; an attempt to use an index that is less than zero or greater than or equal to the length of the array causes an ArrayIndexOutOfBoundsException to be thrown (§15.10.4).",10.76,109.14,360,491,72,118.06,432,227.2,FALSE,FALSE
496,3,BODY,"13.5.4Interface Members Adding an abstract, private, or static method to an interface does not break compatibility with pre-existing binaries. Adding a field to a superinterface of C may hide a field inherited from a superclass of C. If the original reference was to an instance field, an IncompatibleClassChangeError will result. If the original reference was an assignment, an IllegalAccessError will result. Deleting a member from an interface may cause linkage errors in pre-existing binaries.",10.76,130.11,360,497,72,168.09,432,298.2,FALSE,FALSE
516,4,BODY,SwitchStatement: switch ( Expression ) SwitchBlock,10.76,19.05,167.47,50,90,347.13,257.47,366.18,FALSE,TRUE
558,2,BODY,"A finally clause ensures that the finally block is executed after the try block and any catch block that might be executed, no matter how control leaves the try block or catch block. Handling of the finally block is rather complex, so the two cases of a try statement with and without a finally block are described separately (§14.20.1, §14.20.2). A try statement is permitted to omit catch clauses and a finally clause if it is a try-with-resources statement (§14.20.3).",10.76,90.14,360.01,471,72,76.06,432.01,166.2,FALSE,FALSE
559,5,BODY,"14.20.2Execution of try-finally and try-catch-finally A try statement with a finally block is executed by first executing the try block. Then there is a choice: •If execution of the try block completes normally, then the finally block is executed, and then there is a choice: –If the finally block completes normally, then the try statement completes normally. –If the finally block completes abruptly for reason S, then the try statement completes abruptly for reason S.",10.76,136.11,360,471,72,279.09,432,415.2,FALSE,FALSE
630,2,BODY,"is S. If f in S is accessible from C, then T.super.f is treated as if it had been the expression this.f in the body of class S. Otherwise, a compile-time error occurs.",10.76,19.14,359.99,167,72,76.06,431.99,95.2,FALSE,FALSE
702,6,BODY,"•Otherwise, two distinct floating-point values are considered unequal by the equality operators. In particular, there is one value representing positive infinity and one value representing negative infinity; each compares equal only to itself, and each compares unequal to all other values. Subject to these considerations for floating-point numbers, the following rules then hold for integer operands or for floating-point operands other than NaN: •The value produced by the == operator is true if the value of the left-hand operand is equal to the value of the right-hand operand; otherwise, the result is false. •The value produced by the != operator is true if the value of the left-hand operand is not equal to the value of the right-hand operand; otherwise, the result is false.",10.76,186.14,360.01,784,72,283.06,432.01,469.2,FALSE,FALSE
723,5,BODY,"15.26.2Compound Assignment Operators A compound assignment expression of the form E1 op= E2 is equivalent to E1 = (T) ((E1) op (E2)), where T is the type of E1, except that E1 is evaluated only once.",10.76,53.11,360,199,72,199.09,432,252.2,FALSE,FALSE
741,4,BODY,SwitchExpression: switch ( Expression ) SwitchBlock,10.76,19.05,167.47,51,90,349.13,257.47,368.18,FALSE,TRUE
758,4,BODY,"16.1.8Assignment Expressions Consider an assignment expression a = b, a += b, a -= b, a *= b, a /= b, a %= b, a <<= b, a >>= b, a >>>= b, a &= b, a |= b, or a ^= b (§15.26). •V is definitely assigned after the assignment expression iff either: –a is V, or –V is definitely assigned after b. •V is definitely unassigned after the assignment expression iff a is not V and V is definitely unassigned after b. •V is [un]assigned before a iff V is [un]assigned before the assignment expression. •V is [un]assigned before b iff V is [un]assigned after a.",10.76,167.11,360,548,72,238.09,432,405.2,FALSE,FALSE
838,2,BODY,"The constraint formula ‹T'=R'› is reduced (§18.2) and the resulting bounds are incorporated into B1 to produce a new bound set, B2. Otherwise, B2 is the same as B1. If B2 contains the bound false, inference fails.",10.76,57.14,342,213,90,76.06,432,133.2,FALSE,FALSE
845,3,BODY,ModularCompilationUnit: {ImportDeclaration} ModuleDeclaration PackageDeclaration: {PackageModifier} package Identifier {. Identifier} ; PackageModifier: Annotation ImportDeclaration: SingleTypeImportDeclaration TypeImportOnDemandDeclaration SingleStaticImportDeclaration StaticImportOnDemandDeclaration SingleTypeImportDeclaration: import TypeName ; TypeImportOnDemandDeclaration: import PackageOrTypeName . * ; SingleStaticImportDeclaration: import static TypeName . Identifier ; StaticImportOnDemandDeclaration: import static TypeName . * ; TopLevelClassOrInterfaceDeclaration: ClassDeclaration InterfaceDeclaration ;,10.76,378.75,248.21,619,90,200.13,338.21,578.88,FALSE,TRUE
847,3,BODY,"ClassModifier: (one of) Annotation public protected private abstract static final sealed non-sealed strictfp TypeParameters: < TypeParameterList > TypeParameterList: TypeParameter {, TypeParameter} ClassExtends: extends ClassType ClassImplements: implements InterfaceTypeList InterfaceTypeList: InterfaceType {, InterfaceType} ClassPermits: permits TypeName {, TypeName} ClassBody: { {ClassBodyDeclaration} } ClassBodyDeclaration: ClassMemberDeclaration InstanceInitializer StaticInitializer ConstructorDeclaration",10.76,380.05,255.95,514,90,213.13,345.95,593.18,FALSE,TRUE
851,1,BODY,"ExceptionType: ClassType TypeVariable MethodBody: Block ; InstanceInitializer: Block StaticInitializer: static Block ConstructorDeclaration: {ConstructorModifier} ConstructorDeclarator [Throws] ConstructorBody ConstructorModifier: (one of) Annotation public protected private ConstructorDeclarator: [TypeParameters] SimpleTypeName ( [ReceiverParameter ,] [FormalParameterList] )",10.76,293.05,338.13,378,90,76.13,428.13,369.18,FALSE,TRUE
53,2,BODY,"An octal numeral consists of an ASCII digit 0 followed by one or more of the ASCII digits 0 through 7 interspersed with underscores, and can represent a positive, zero, or negative integer. OctalNumeral: 0 OctalDigits 0 Underscores OctalDigits OctalDigits: OctalDigit OctalDigit [OctalDigitsAndUnderscores] OctalDigit OctalDigit: (one of) 0 1 2 3 4 5 6 7 OctalDigitsAndUnderscores: OctalDigitOrUnderscore {OctalDigitOrUnderscore} OctalDigitOrUnderscore: OctalDigit _",10.75,267.81,360.01,466,72,76.06,432.01,343.88,FALSE,TRUE
63,6,BODY,"TextBlock: ' ' ' {TextBlockWhiteSpace} LineTerminator {TextBlockCharacter} ' ' ' TextBlockWhiteSpace: WhiteSpace but not LineTerminator TextBlockCharacter: InputCharacter but not \ EscapeSequence LineTerminator The following productions from §3.3, §3.4, and §3.6 are shown here for convenience:",10.75,141.25,336.8,294,90,435.13,426.8,576.38,FALSE,TRUE
76,11,BODY,"Positive zero and negative zero compare equal, so the result of the expression 0.0==-0.0 is true and the result of 0.0>-0.0 is false. Other operations can distinguish positive and negative zero; for example, 1.0/0.0 has the value positive infinity, while the value of 1.0/-0.0 is negative infinity.",10.75,45.14,360,298,72,558.06,432,603.2,FALSE,FALSE
77,2,BODY,"NaN is unordered, so: •The numerical comparison operators <, <=, >, and >= return false if either or both operands are NaN (§15.20.1). In particular, (x<y) == !(x>=y) will be false if x or y is NaN. •The equality operator == returns false if either operand is NaN. •The inequality operator != returns true if either operand is NaN (§15.21.1). In particular, x!=x is true if and only if x is NaN.",10.75,114.14,360,395,72,76.06,432,190.2,FALSE,FALSE
131,11,BODY,"A narrowing conversion from double to float occurs as determined by the rules of IEEE 754 for converting between binary floating-point formats, using the round to nearest rounding policy (§15.4). This conversion can lose precision, but also lose range, resulting in a float zero from a nonzero double and a float infinity from a finite double. A double NaN is converted to a float NaN and a double infinity is converted to the same-signed float infinity.",10.75,71.14,360.01,454,72,531.06,432.01,602.2,FALSE,FALSE
300,10,BODY,"8.4.3.1abstract Methods An abstract method declaration introduces the method as a member, providing its signature (§8.4.2), result (§8.4.5), and throws clause if any (§8.4.6), but does not provide an implementation (§8.4.7). A method that is not abstract may be referred to as a concrete method.",10.75,65.2,360,295,72,532.13,432,597.33,FALSE,FALSE
301,2,BODY,"The declaration of an abstract method m must appear directly within an abstract class (call it A) unless it occurs within an enum declaration (§8.9); otherwise, a compile-time error occurs. Every subclass of A that is not abstract (§8.1.1.1) must provide an implementation for m, or a compile-time error occurs. An abstract class can override an abstract method by providing another abstract method declaration.",10.75,96.14,360.01,411,72,76.06,432.01,172.2,FALSE,FALSE
339,4,BODY,"EnumBody: { [EnumConstantList] [,] [EnumBodyDeclarations] } EnumConstantList: EnumConstant {, EnumConstant} EnumConstant: {EnumConstantModifier} Identifier [( [ArgumentList] )] [ClassBody] EnumConstantModifier: Annotation The following production from §15.12 is shown here for convenience:",10.75,151.99,320.81,289,90,205.13,410.81,357.12,FALSE,TRUE
362,2,BODY,"9.1.1.4sealed and non-sealed Interfaces An interface can be declared sealed if all its direct subclasses and direct subinterfaces are known when the interface is declared (§9.1.4), and no other direct subclasses or direct subinterfaces are desired or required.",10.75,52.2,360,260,72,76.13,432,128.33,FALSE,FALSE
373,4,BODY,"An interface does not inherit private or static methods from its superinterfaces. If an interface I declares a private or static method m, and the signature of m is a subsignature of a public instance method m' in a superinterface type of I, and m' would otherwise be accessible to code in I, then a compile-time error occurs.",10.75,51.14,360,326,72,210.06,432,261.2,FALSE,FALSE
378,6,BODY,"It is a compile-time error if an annotation interface declaration has the modifier sealed or non-sealed (§9.1.1.4). An annotation interface declaration may specify a top level interface or a member interface, but not a local interface (§14.3).",10.75,51.14,360,243,72,311.06,432,362.2,FALSE,FALSE
379,7,BODY,"An annotation interface inherits several methods from java.lang.annotation.Annotation, including the implicitly declared methods corresponding to the instance methods of Object (§9.2), yet these methods do not define elements of the annotation interface (§9.6.1).",10.75,45.14,360,263,72,455.06,432,500.2,FALSE,FALSE
478,6,BODY,"13.4.2.3final Classes If a class that was not declared final is changed to be declared final, then an IncompatibleClassChangeError is thrown if a binary of a pre-existing subclass of this class is loaded, because final classes can have no subclasses; such a change is not recommended for widely distributed classes. Deleting the final modifier from a class that does not have a sealed direct superclass or a sealed direct superinterface does not break compatibility with pre- existing binaries.",10.75,110.2,360,494,72,370.26,432,480.46,FALSE,FALSE
522,2,BODY,"It is a compile-time error if there is a case label with n (n>1) case patterns p1, ..., pn in a switch block where one of the patterns pi (1≤i<n) dominates another of the patterns pj (i<j≤n). It is a compile-time error if any of the following holds: •There is a default label in the switch block that precedes a case label with case patterns. •There is a default label in the switch block that precedes a case label with a null literal. •There is a case null, default label in the switch block followed by any other switch label.",10.75,147.14,360,529,72,76.06,432,223.2,FALSE,FALSE
654,2,BODY,"•It is declared in the java.lang.invoke.MethodHandle class or the java.lang.invoke.VarHandle class. •It has a single variable arity parameter (§8.4.1) whose declared type is Object[]. •It is native. The following compile-time information is then associated with the method invocation for use at run time: •The name of the method. •The qualifying class or interface of the method invocation (§13.1). •The number of parameters and the compile-time parameter types, in order. •The compile-time result. •The invocation mode, computed as follows: –If the compile-time declaration has the static modifier, then the invocation mode is static. –Otherwise, if the part of the method invocation before the left parenthesis is of the form super . Identifier or of the form TypeName . super . Identifier, then the invocation mode is super. –Otherwise, if the qualifying class or interface of the method invocation is in fact an interface, then the invocation mode is interface. –Otherwise, the invocation mode is virtual. If the result of the invocation type of the compile-time declaration is not void, then the type of the method invocation expression is obtained by applying capture conversion (§5.1.10) to the return type of the invocation type of the compile-time declaration.",10.75,370.14,360.01,1269,72,76.06,432.01,446.2,FALSE,FALSE
665,2,BODY,MethodReference: ExpressionName :: [TypeArguments] Identifier Primary :: [TypeArguments] Identifier ReferenceType :: [TypeArguments] Identifier super :: [TypeArguments] Identifier TypeName . super :: [TypeArguments] Identifier ClassType :: [TypeArguments] new ArrayType :: new,10.75,97.05,232.54,276,90,76.13,322.54,173.18,FALSE,TRUE
768,4,BODY,"If a try statement does not have a finally block, then this rule also applies: •V is [un]assigned after the try statement iff V is [un]assigned after the try block and V is [un]assigned after every catch block in the try statement. If a try statement does have a finally block, then these rules also apply:",10.75,57.14,360,306,72,513.06,432,570.2,FALSE,FALSE
814,4,BODY,"A constraint formula of the form ‹S <= T›, where S and T are type arguments (§4.5.1), is reduced as follows: •If T is a type: –If S is a type, the constraint reduces to ‹S = T›. –If S is a wildcard, the constraint reduces to false. •If T is a wildcard of the form ?, the constraint reduces to true. •If T is a wildcard of the form ? extends T': –If S is a type, the constraint reduces to ‹S <: T'›. –If S is a wildcard of the form ?, the constraint reduces to ‹Object <: T'›. –If S is a wildcard of the form ? extends S', the constraint reduces to ‹S' <: T'›. –If S is a wildcard of the form ? super S', the constraint reduces to ‹Object = T'›.",10.75,203.14,360,644,72,357.06,432,560.2,FALSE,FALSE
815,2,BODY,"•If T is a wildcard of the form ? super T': –If S is a type, the constraint reduces to ‹T' <: S›. –If S is a wildcard of the form ? super S', the constraint reduces to ‹T' <: S'›. –Otherwise, the constraint reduces to false.",10.75,63.14,360.01,224,72,76.06,432.01,139.2,FALSE,FALSE
817,3,BODY,"A constraint formula of the form ‹MethodReference →throws T› is reduced as follows: •If T is not a functional interface type, or if T is a functional interface type but does not have a function type (§9.9), the constraint reduces to false. •Otherwise, let the target function type for the method reference expression be the function type of T. If the method reference is inexact (§15.13.1) and one or more of the function type's parameter types is not a proper type, the constraint reduces to false. •Otherwise, if the method reference is inexact and the function type's result is neither void nor a proper type, the constraint reduces to false. •Otherwise, let E1, ..., En be the types in the function type's throws clause that are not proper types. Let X1, ..., Xm be the checked exceptions in the throws clause of the invocation type of the method reference's compile-time declaration (§15.13.2) (as derived from the function type's parameter types and return type). Then there are two cases: –If n = 0 (the function type's throws clause consists only of proper types), then if there exists some i (1 ≤ i ≤ m) such that Xi is not a subtype of any proper type in the throws clause, the constraint reduces to false; otherwise, the constraint reduces to true. –If n > 0, the constraint reduces to a set of subtyping constraints: for all i (1 ≤ i ≤ m), if Xi is not a subtype of any proper type in the throws clause, then the constraints include, for all j (1 ≤ j ≤ n), ‹Xi <: Ej›. In addition, for all j (1 ≤ j ≤ n), the constraint reduces to the bound throws Ej. Constraints on checked exceptions are handled separately from constraints on return types, because return type compatibility influences applicability of methods (§18.5.1),",10.75,360.06,360.01,1735,72,237.06,432.01,597.12,FALSE,FALSE
60,2,BODY,A boolean literal is always of type boolean (§4.2.5).,10.74,6.14,231.8,53,72,76.06,303.8,82.2,FALSE,FALSE
78,2,BODY,"If at least one of the operands to a numerical operator is of type double, then the operation is carried out using 64-bit floating-point arithmetic, and the result of the numerical operator is a value of type double. If the other operand is not a double, it is first widened (§5.1.5) to type double by numeric promotion (§5.6). Otherwise, at least one of the operands is of type float; the operation is carried out using 32-bit floating-point arithmetic, and the result of the numerical operator is a value of type float. If the other operand is not a float, it is first widened to type float by numeric promotion. Floating-point arithmetic is carried out in accordance with the rules of the IEEE 754 Standard, including for overflow and underflow (§15.4), with the exception of the remainder operator % (§15.17.3). Any value of a floating-point type may be cast to or from any numeric type. There are no casts between floating-point types and the type boolean. See §4.2.5 for an idiom to convert floating-point expressions to boolean.",10.74,202.06,360.01,1035,72,76.06,432.01,278.12,FALSE,FALSE
102,5,BODY,"•Let EC, the erased candidate set for U1, ..., Uk, be the intersection of all the sets EST(Ui) (1 ≤ i ≤ k).",10.74,20.17,360,107,72,570.06,432,590.23,FALSE,FALSE
141,4,BODY,"•If p is a value of any other type, boxing conversion is equivalent to an identity conversion (§5.1.1). If the value p being boxed is the result of evaluating a constant expression (§15.29) of type boolean, byte, char, short, int, or long, and the result is true, false, a character in the range '\u0000' to '\u007f' inclusive, or an integer in the range -128 to 127 inclusive, then let a and b be the results of any two boxing conversions of p. It is always the case that a == b.",10.74,90.14,360.01,480,72,242.06,432.01,332.2,FALSE,FALSE
219,4,BODY,"In addition, access to an instance field or instance method is permitted based on the form of the qualified name, field access expression (§15.11), method invocation expression (§15.12), or method reference expression (§15.13): •If the access is by (i) a qualified name of the form ExpressionName.Id or TypeName.Id, or (ii) a field access expression of the form Primary.Id, then access to the instance field Id is permitted if and only if the qualifying type is S or a subclass of S. The qualifying type is the type of the ExpressionName or Primary, or the type denoted by TypeName. •If the access is by (i) a method invocation expression of the form ExpressionName.Id(...) or TypeName.Id(...) or Primary.Id(...), or (ii) a method reference expression of the form ExpressionName :: Id or Primary :: Id or ReferenceType :: Id, then access to the instance method Id is permitted if and only if the qualifying type is S or a subclass of S. The qualifying type is the type of the ExpressionName or Primary, or the type denoted by TypeName or ReferenceType.",10.74,225.14,360,1052,72,250.2,432,475.33,FALSE,FALSE
367,2,BODY,"unless an abstract method with the same signature, same return type, and a compatible throws clause is explicitly declared by the interface. It is a compile-time error if the interface explicitly declares such a method m in the case where m is declared to be final in Object. It is a compile-time error if the interface explicitly declares a method with a signature that is override-equivalent (§8.4.2) to a public method of Object, but which has a different return type, or an incompatible throws clause, or is not abstract. The interface inherits, from the interfaces it extends, all members of those interfaces, except for (i) fields, classes, and interfaces that it hides, (ii) abstract methods and default methods that it overrides (§9.4.1), (iii) private methods, and (iv) static methods. Fields, methods, member classes, and member interfaces of an interface may have the same name, since they are used in different contexts and are disambiguated by different lookup procedures (§6.5). However, this is discouraged as a matter of style.",10.74,225.14,360.01,1043,72,76.06,432.01,301.2,FALSE,FALSE
381,4,BODY,"The declaration of a method that returns an array is allowed to place the bracket pair that denotes the array type after the empty formal parameter list. This syntax is supported for compatibility with early versions of the Java programming language. It is very strongly recommended that this syntax is not used in new code. It is a compile-time error if any method declared in an annotation interface has a signature that is override-equivalent (§8.4.2) to that of any public or protected method declared in class Object or in interface java.lang.annotation.Annotation. It is a compile-time error if the declaration of an annotation interface T contains an element of type T, either directly or indirectly.",10.74,135.14,360,707,72,258.06,432,393.2,FALSE,FALSE
399,4,BODY,"•T is not an array type, and the type of v is assignment compatible (§5.2) with T, and: –If T is a primitive type or String, then v is a constant expression (§15.29). –If T is Class or an invocation of Class (§4.5), then v is a class literal (§15.8.2). –If T is an enum class type (§8.9), then v is an enum constant (§8.9.1). –v is not null.",10.74,95.14,360,341,72,488.06,432,583.2,FALSE,FALSE
492,2,BODY,"13.4.19static Methods If a method that is not declared private is also declared static (that is, a class method) and is changed to not be declared static (that is, to an instance method), or vice versa, then compatibility with pre-existing binaries may be broken, resulting in a linkage time error, namely an IncompatibleClassChangeError, if these methods are used by the pre-existing binaries. Such changes are not recommended in code that has been widely distributed.",10.74,92.11,360.01,469,72,76.09,432.01,168.2,FALSE,FALSE
495,5,BODY,"If a class or interface is removed from the set of permitted direct subclasses or subinterfaces of a sealed interface, then an IncompatibleClassChangeError is thrown if the pre-existing binary of the removed class or interface is loaded. Changing an interface that was declared sealed to be declared non-sealed does not break compatibility with pre-existing binaries.",10.74,64.14,360,367,72,405.06,432,469.2,FALSE,FALSE
540,2,BODY,"•If the ForInit code is a list of statement expressions (§14.8), the expressions are evaluated in sequence from left to right; their values, if any, are discarded. If evaluation of any expression completes abruptly for some reason, the for statement completes abruptly for the same reason; any ForInit statement expressions to the right of the one that completed abruptly are not evaluated. •If the ForInit code is a local variable declaration (§14.4), it is executed as if it were a local variable declaration statement appearing in a block (§14.4.2). If execution of the local variable declaration completes abruptly for any reason, the for statement completes abruptly for the same reason. •If the ForInit part is not present, no action is taken. 14.14.1.2Iteration of for Statement Next, a for iteration step is performed, as follows: •If the Expression is present, it is evaluated. If the result is of type Boolean, it is subjected to unboxing conversion (§5.1.8). If evaluation of the Expression or the subsequent unboxing conversion (if any) completes abruptly, the for statement completes abruptly for the same reason. Otherwise, there is then a choice based on the presence or absence of the Expression and the resulting value if the Expression is present; see next bullet.",10.74,290.19,360.01,1282,72,76.06,432.01,366.25,FALSE,FALSE
648,2,BODY,"•Let RS be the return type of MTS, adapted to the type parameters of MTT, and let RT be the return type of MTT. One of the following must be true: –e is an explicitly typed lambda expression (§15.27.1), and one of the following is true: ›RT is void. ›RS <: RT. ›RS and RT are functional interface types, and there is at least one result expression, and RS is more specific than RT for each result expression of e. The result expression of a lambda expression with a block body is defined in §15.27.2; the result expression of a lambda expression with an expression body is simply the body itself. ›RS is a primitive type, and RT is a reference type, and there is at least one result expression, and each result expression of e is a standalone expression (§15.2) of a primitive type. ›RS is a reference type, and RT is a primitive type, and there is at least one result expression, and each result expression of e is either a standalone expression of a reference type or a poly expression.",10.74,256.14,360.01,988,72,76.06,432.01,332.2,FALSE,FALSE
697,8,BODY,The type of a relational expression is always boolean.,10.74,6.14,239.12,54,72,502.06,311.12,508.2,FALSE,FALSE
708,4,BODY,–A boolean conditional expression. –A switch expression (§15.28) whose result expressions are all boolean expressions.,10.74,38.14,350,118,82,261.06,432,299.2,FALSE,FALSE
759,2,BODY,"•V is definitely unassigned after ++a, --a, a++, or a-- iff a is not V and V is definitely unassigned after the operand expression. •V is [un]assigned before a iff V is [un]assigned before ++a, --a, a++, or a--.",10.74,38.14,360,211,72,76.06,432,114.2,FALSE,FALSE
763,3,BODY,16.2.7if Statements The following rules apply to a statement if (e) S (§14.9.1): •V is [un]assigned after if (e) S iff V is [un]assigned after S and V is [un]assigned after e when false. •V is [un]assigned before e iff V is [un]assigned before if (e) S. •V is [un]assigned before S iff V is [un]assigned after e when true. The following rules apply to a statement if (e) S else T (§14.9.2): •V is [un]assigned after if (e) S else T iff V is [un]assigned after S and V is [un]assigned after T. •V is [un]assigned before e iff V is [un]assigned before if (e) S else T. •V is [un]assigned before S iff V is [un]assigned after e when true. •V is [un]assigned before T iff V is [un]assigned after e when false.,10.74,205.11,360,705,72,161.09,432,366.2,FALSE,FALSE
780,4,BODY,"Thread.sleep causes the currently executing thread to sleep (temporarily cease execution) for the specified duration, subject to the precision and accuracy of system timers and schedulers. The thread does not lose ownership of any monitors, and resumption of execution will depend on scheduling and the availability of processors on which to execute the thread. It is important to note that neither Thread.sleep nor Thread.yield have any synchronization semantics. In particular, the compiler does not have to flush writes cached in registers out to shared memory before a call to Thread.sleep or Thread.yield, nor does the compiler have to reload values cached in registers after a call to Thread.sleep or Thread.yield.",10.74,129.14,360.01,720,72,413.06,432.01,542.2,FALSE,FALSE
859,1,BODY,"IfThenStatement: if ( Expression ) Statement IfThenElseStatement: if ( Expression ) StatementNoShortIf else Statement IfThenElseStatementNoShortIf: if ( Expression ) StatementNoShortIf else StatementNoShortIf AssertStatement: assert Expression ; assert Expression : Expression ; SwitchStatement: switch ( Expression ) SwitchBlock SwitchBlock: { SwitchRule {SwitchRule} } { {SwitchBlockStatementGroup} {SwitchLabel :} } SwitchRule: SwitchLabel -> Expression ; SwitchLabel -> Block SwitchLabel -> ThrowStatement SwitchBlockStatementGroup: SwitchLabel : {SwitchLabel :} BlockStatements SwitchLabel: case CaseConstant {, CaseConstant} case null [, default] case CasePattern {, CasePattern} [Guard] default CaseConstant: ConditionalExpression CasePattern: Pattern Guard: when Expression",10.74,517.05,292.14,781,90,76.13,382.14,593.18,FALSE,TRUE
54,3,BODY,BinaryNumeral: 0 b BinaryDigits 0 B BinaryDigits BinaryDigits: BinaryDigit BinaryDigit [BinaryDigitsAndUnderscores] BinaryDigit BinaryDigit: (one of) 0 1 BinaryDigitsAndUnderscores: BinaryDigitOrUnderscore {BinaryDigitOrUnderscore} BinaryDigitOrUnderscore: BinaryDigit _,10.73,217.75,259.94,270,90,126.13,349.94,343.88,FALSE,TRUE
106,2,BODY,"•If T is a parameterized class type or a parameterized interface type, G<A1,...,An>, then the result is G<A1',...,An'>, where, for 1 ≤ i ≤ n, Ai' is derived from Ai as follows: –If Ai does not mention any restricted type variable, then Ai' = Ai. –If Ai is a type that mentions a restricted type variable, then let U be the upward projection of Ai. Ai' is a wildcard, defined by three cases: ›If U is not Object, and if either the declared bound of the ith parameter of G, Bi, mentions a type parameter of G, or Bi is not a subtype of U, then Ai' is an upper-bounded wildcard, ? extends U. ›Otherwise, if the downward projection of Ai is L, then Ai' is a lower-bounded wildcard, ? super L. ›Otherwise, the downward projection of Ai is undefined and Ai' is an unbounded wildcard, ?.",10.73,192.14,360,780,72,76.06,432,268.2,FALSE,FALSE
256,2,BODY,"The rules concerning annotation modifiers for a class declaration are specified in §9.7.4 and §9.7.5. The access modifier public (§6.6) pertains only to top level classes (§7.6) and member classes (§8.5, §9.5), not to local classes (§14.3) or anonymous classes (§15.9.5). The access modifiers protected and private pertain only to member classes. The modifier static pertains only to member classes and local classes. It is a compile-time error if the same keyword appears more than once as a modifier for a class declaration, or if a class declaration has more than one of the access modifiers public, protected, and private. It is a compile-time error if a class declaration has more than one of the modifiers sealed, non-sealed, and final.",10.73,179.14,360.01,742,72,76.06,432.01,255.2,FALSE,FALSE
366,6,BODY,InterfaceBody: { {InterfaceMemberDeclaration} } InterfaceMemberDeclaration: ConstantDeclaration InterfaceMethodDeclaration ClassDeclaration InterfaceDeclaration ;,10.73,106.75,164.63,162,90,269.13,254.63,375.88,FALSE,TRUE
850,1,BODY,"MethodDeclaration: {MethodModifier} MethodHeader MethodBody MethodModifier: (one of) Annotation public protected private abstract static final synchronized native strictfp MethodHeader: Result MethodDeclarator [Throws] TypeParameters {Annotation} Result MethodDeclarator [Throws] Result: UnannType void MethodDeclarator: Identifier ( [ReceiverParameter ,] [FormalParameterList] ) [Dims] ReceiverParameter: {Annotation} UnannType [Identifier .] this FormalParameterList: FormalParameter {, FormalParameter} FormalParameter: {VariableModifier} UnannType VariableDeclaratorId VariableArityParameter VariableArityParameter: {VariableModifier} UnannType {Annotation} ... Identifier VariableModifier: Annotation final Throws: throws ExceptionTypeList ExceptionTypeList: ExceptionType {, ExceptionType}",10.73,504.05,314.62,795,90,76.13,404.62,580.18,FALSE,TRUE
37,5,BODY,UnicodeInputCharacter: UnicodeEscape RawInputCharacter UnicodeEscape: \ UnicodeMarker HexDigit HexDigit HexDigit HexDigit UnicodeMarker: u {u} HexDigit: (one of) 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F,10.72,154.75,260.71,205,90,429.13,350.71,583.88,FALSE,TRUE
85,2,BODY,"•The method getClass returns the Class object that represents the class of the object. A Class object exists for each reference type. It can be used, for example, to discover the fully qualified name of a class, its members, its immediate superclass, and any interfaces that it implements. The type of a method invocation expression of getClass is Class<? extends |T|>, where T is the class or interface that was searched for getClass (§15.12.1) and |T| denotes the erasure of T (§4.6). A class method that is declared synchronized (§8.4.3.6) synchronizes on the monitor associated with the Class object of the class. •The method hashCode is very useful, together with the method equals, in hashtables such as java.util.HashMap. •The methods wait, notify, and notifyAll are used in concurrent programming using threads (§17.2). •The method toString returns a String representation of the object.",10.72,224.14,360,895,72,76.06,432,300.2,FALSE,FALSE
143,6,BODY,"5.1.10Capture Conversion Let G name a generic type declaration (§8.1.2, §9.1.2) with n type parameters A1,...,An with corresponding bounds U1,...,Un. There exists a capture conversion from a parameterized type G<T1,...,Tn> (§4.5) to a parameterized type G<S1,...,Sn>, where, for 1 ≤ i ≤ n : •If Ti is a wildcard type argument (§4.5.1) of the form ?, then Si is a fresh type variable whose upper bound is Ui[A1:=S1,...,An:=Sn] and whose lower bound is the null type (§4.1).",10.72,117.11,360,472,72,402.09,432,519.2,FALSE,FALSE
272,9,BODY,"ClassPermits: permits TypeName {, TypeName}",10.72,19.05,164.34,43,90,517.13,254.34,536.18,FALSE,TRUE
304,5,BODY,"8.4.3.5strictfp Methods The strictfp modifier on a method declaration is obsolete and should not be used in new code. Its presence or absence has has no effect at run time. 8.4.3.6synchronized Methods A synchronized method acquires a monitor (§17.1) before it executes. For a class (static) method, the monitor associated with the Class object for the method's class is used. For an instance method, the monitor associated with this (the object for which the method was invoked) is used.",10.72,150.34,360.01,487,72,356.26,432.01,506.6,FALSE,FALSE
364,4,BODY,"InterfacePermits: permits TypeName {, TypeName}",10.72,19.05,164.34,47,90,582.13,254.34,601.18,FALSE,TRUE
601,3,BODY,"The TypeName must denote a class or interface that is accessible (§6.6). It is a compile-time error if the TypeName denotes a class or interface that is not accessible, or denotes a type variable. The type of C.class, where C is the name of a class, interface, or array type (§4.3), is Class<C>. The type of p.class, where p is the name of a primitive type (§4.2), is Class<B>, where B is the type of an expression of type p after boxing conversion (§5.1.7). The type of void.class (§8.4.5) is Class<Void>. A class literal evaluates to the Class object for the named class, interface, array type, or primitive type (or for void), as defined by the defining class loader (§12.2) of the class of the current instance.",10.72,160.14,360,715,72,152.06,432,312.2,FALSE,FALSE
658,3,BODY,"The implementation must also ensure, during linkage, that the method m can still be found in Q or a superclass or superinterface of Q. If m cannot be found, then a NoSuchMethodError (which is a subclass of IncompatibleClassChangeError) occurs. If m can be found, then let C be the class or interface that declares m. The implementation must ensure, during linkage, that the declaration of m in C is accessible to D: •If m is public, then m is accessible. •If m is protected, then m is accessible iff (i) either D is in the same package as C, or D is a subclass of C or C itself; and (ii) if m is a protected instance method, then Q must be a subclass of D or D itself.",10.72,135.14,360,668,72,148.06,432,283.2,FALSE,FALSE
659,2,BODY,"•If the invocation mode is static, no target reference is needed and overriding is not allowed. Method m of class or interface C is the one to be invoked. •Otherwise, an instance method is to be invoked and there is a target reference. If the target reference is null, a NullPointerException is thrown at this point. Otherwise, the target reference is said to refer to a target object and will be used as the value of the keyword this in the invoked method. The other three possibilities for the invocation mode are then considered: –If the invocation mode is super, overriding is not allowed. Method m of class or interface C is the one to be invoked. If m is abstract, an AbstractMethodError is thrown. –Otherwise, if the invocation mode is virtual, and Q and m jointly indicate a signature polymorphic method (§15.12.3), then the target object is an instance of java.lang.invoke.MethodHandle or java.lang.invoke.VarHandle. The target object encapsulates state which is matched against the information associated with the method invocation at compile time. Details of this matching are given in The Java Virtual Machine Specification, Java SE 23 Edition and the Java SE Platform API. If matching succeeds, then either the method referenced by the java.lang.invoke.MethodHandle instance is directly and immediately invoked, or the variable represented by the java.lang.invoke.VarHandle instance is directly and immediately accessed, and in either case the procedure in §15.12.4.5 is not executed. If matching fails, then a java.lang.invoke.WrongMethodTypeException is thrown. –Otherwise, the invocation mode is interface or virtual. If the method m of class or interface C is private, then it is the method to be invoked. Otherwise, overriding may occur. A dynamic method lookup, specified below, is used to locate the method to invoke. The lookup procedure starts from class R, the actual run-time class of the target object.",10.72,406.14,360.01,1927,72,76.06,432.01,482.2,FALSE,FALSE
725,4,BODY,"The saved value of the array component and the value of the right-hand operand are used to perform the binary operation (string concatenation) indicated by the compound assignment operator (which is necessarily +=). If this operation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs. Otherwise, the String result of the binary operation is stored into the array component. Example 15.26.2-1. Compound Assignment To An Array Component",10.72,111.74,342,499,90,332.06,432,443.81,FALSE,FALSE
732,3,BODY,"LambdaParameters: ( [LambdaParameterList] ) ConciseLambdaParameter LambdaParameterList: NormalLambdaParameter {, NormalLambdaParameter} ConciseLambdaParameter {, ConciseLambdaParameter} NormalLambdaParameter: {VariableModifier} LambdaParameterType VariableDeclaratorId VariableArityParameter LambdaParameterType: UnannType var ConciseLambdaParameter: Identifier _",10.72,230.75,302.34,363,90,248.13,392.34,478.88,FALSE,TRUE
779,3,BODY,"17.2.3Interruptions Interruption actions occur upon invocation of Thread.interrupt, as well as methods defined to invoke it in turn, such as ThreadGroup.interrupt. Let t be the thread invoking u.interrupt, for some thread u, where t and u may be the same. This action causes u's interruption status to be set to true. Additionally, if there exists some object m whose wait set contains u, then u is removed from m's wait set. This enables u to resume in a wait action, in which case this wait will, after re-locking m's monitor, throw InterruptedException. Invocations of Thread.isInterrupted can determine a thread's interruption status. The static method Thread.interrupted may be invoked by a thread to observe and clear its own interruption status.",10.72,162.11,360.01,752,72,379.09,432.01,541.2,FALSE,FALSE
819,3,BODY,"18.3.1Complementary Pairs of Bounds (In this section, S and T are inference variables or types, and U is a proper type. For conciseness, a bound of the form α = T may also match a bound of the form T = α.) When a bound set contains a pair of bounds that match one of the following rules, a new constraint formula is implied: •α = S and α = T imply ‹S = T› •α = S and α <: T imply ‹S <: T› •α = S and T <: α imply ‹T <: S› •S <: α and α <: T imply ‹S <: T› •α = U and S = T imply ‹S[α:=U] = T[α:=U]› •α = U and S <: T imply ‹S[α:=U] <: T[α:=U]› When a bound set contains a pair of bounds α <: S and α <: T, and there exists a supertype of S of the form G<S1, ..., Sn> and a supertype of T of the form G<T1, ..., Tn> (for some generic class or interface, G), then for all i (1 ≤ i ≤ n), if Si and Ti are types (not wildcards), the constraint formula ‹Si = Ti› is implied.",10.72,244.11,360.01,869,72,295.09,432.01,539.2,FALSE,FALSE
855,1,BODY,InterfaceMethodDeclaration: {InterfaceMethodModifier} MethodHeader MethodBody InterfaceMethodModifier: (one of) Annotation public private abstract default static strictfp AnnotationInterfaceDeclaration: {InterfaceModifier} @ interface TypeIdentifier AnnotationInterfaceBody AnnotationInterfaceBody: { {AnnotationInterfaceMemberDeclaration} } AnnotationInterfaceMemberDeclaration: AnnotationInterfaceElementDeclaration ConstantDeclaration ClassDeclaration InterfaceDeclaration ; AnnotationInterfaceElementDeclaration: {AnnotationInterfaceElementModifier} UnannType Identifier ( ) [Dims] [DefaultValue] ;,10.72,295.05,335.55,602,90,76.13,425.55,371.18,FALSE,TRUE
57,3,BODY,FloatingPointLiteral: DecimalFloatingPointLiteral HexadecimalFloatingPointLiteral DecimalFloatingPointLiteral: Digits . [Digits] [ExponentPart] [FloatTypeSuffix] . Digits [ExponentPart] [FloatTypeSuffix] Digits ExponentPart [FloatTypeSuffix] Digits [ExponentPart] FloatTypeSuffix ExponentPart: ExponentIndicator SignedInteger ExponentIndicator: (one of) e E SignedInteger: [Sign] Digits Sign: (one of) + - FloatTypeSuffix: (one of) f F d D,10.71,330.75,237.25,439,90,242.13,327.25,572.88,FALSE,TRUE
281,2,BODY,UnannTypeVariable: TypeIdentifier UnannArrayType: UnannPrimitiveType Dims UnannClassOrInterfaceType Dims UnannTypeVariable Dims The following production from §4.3 is shown here for convenience:,10.71,103.99,244.46,193,90,76.13,334.46,180.12,FALSE,TRUE
374,2,BODY,"The presence or absence of the strictfp modifier has absolutely no effect on the rules for overriding methods. For example, it is permitted for a method that is not strictfp to override a strictfp method, and it is permitted for a strictfp method to override a method that is not strictfp.",10.71,45.14,360,289,72,76.06,432,121.2,FALSE,FALSE
398,6,BODY,"NormalAnnotation: @ TypeName ( [ElementValuePairList] ) ElementValuePairList: ElementValuePair {, ElementValuePair} ElementValuePair: Identifier = ElementValue ElementValue: ConditionalExpression ElementValueArrayInitializer Annotation ElementValueArrayInitializer: { [ElementValueList] [,] } ElementValueList: ElementValue {, ElementValue} Note that the at sign (@) is a token unto itself (§3.11). It is possible to put whitespace between it and the TypeName, but this is discouraged as a matter of style.",10.71,261.99,324,506,90,331.13,414,593.12,FALSE,TRUE
536,6,BODY,DoStatement: do Statement while ( Expression ) ;,10.71,19.05,172.77,48,90,431.13,262.77,450.18,FALSE,TRUE
646,2,BODY,"argument (§15.27.1) or a variable arity invocation (§15.12.2.4), some flexibility is allowed to adapt one signature to the other. One applicable method m1 is more specific than another applicable method m2, for an invocation with argument expressions e1, ..., ek, if any of the following are true: •m2 is generic, and m1 is inferred to be more specific than m2 for argument expressions e1, ..., ek by §18.5.4. •m2 is not generic, and m1 and m2 are applicable by strict or loose invocation, and where m1 has formal parameter types S1, ..., Sn and m2 has formal parameter types T1, ..., Tn, the type Si is more specific than Ti for argument ei for all i (1 ≤ i ≤ n, n = k). •m2 is not generic, and m1 and m2 are applicable by variable arity invocation, and where the first k variable arity parameter types of m1 are S1, ..., Sk and the first k variable arity parameter types of m2 are T1, ..., Tk, the type Si is more specific than Ti for argument ei for all i (1 ≤ i ≤ k). Additionally, if m2 has k+1 parameters, then the k+1'th variable arity parameter type of m1 is a subtype of the k+1'th variable arity parameter type of m2. The above conditions are the only circumstances under which one method may be more specific than another. A type S is more specific than a type T for any expression if S <: T (§4.10). A functional interface type S is more specific than a functional interface type T for an expression e if all of the following are true: •The interface of S is neither a superinterface nor a subinterface of the interface of T. If S or T is an intersection type, it is not the case that any interface of S is a superinterface or a subinterface of any interface of T. (The 'interfaces of' an intersection type refers here to the set of interfaces that appear as (possibly parameterized) interface types in the intersection.) •Let MTS be the function type of the capture of S, and let MTT be the function type of T. MTS and MTT must have the same type parameters (if any) (§8.4.4). •Let P1, ..., Pn be the formal parameter types of MTS, adapted to the type parameters of MTT. Let P1', ..., Pn' be the formal parameter types of the function type of S (without capture), adapted to the type parameters of MTT. Let Q1, ..., Qn be the formal parameter types of MTT. Then, for all i (1 ≤ i ≤ n), Qi <: Pi and Qi = Pi'. Generally, this rule asserts that the formal parameter types derived from S and T are the same. But in the case in which S is a wildcard-parameterized type, the check is more",10.71,520.06,360.01,2496,72,76.06,432.01,596.12,FALSE,FALSE
709,2,BODY,"The process for determining the type of a conditional expression depends on the kind of conditional expression, as outlined in the following sections. The following tables summarize the rules above by giving the type of a conditional expression for all possible types of its second and third operands. bnp(..) means to apply binary numeric promotion. The form 'T | bnp(..)' is used where one operand is a constant expression of type int and may be representable in type T, where binary numeric promotion is used if the operand is not representable in type T. The operand type Object means any reference type other than the null type and the eight wrapper classes Boolean, Byte, Short, Character, Integer, Long, Float, Double. Table 15.25-A. Conditional expression type (Primitive 3rd operand, Part I)",10.71,155.37,360.01,800,72,76.06,432.01,231.43,FALSE,FALSE
820,2,BODY,"18.3.2Bounds Involving Capture Conversion When a bound set contains a bound of the form G<α1, ..., αn> = capture(G<A1, ..., An>), new bounds are implied and new constraint formulas may be implied, as follows. Let P1, ..., Pn represent the type parameters of G and let B1, ..., Bn represent the bounds of these type parameters. Let θ represent the substitution [P1:=α1, ..., Pn:=αn]. Let R be a type that is not an inference variable (but is not necessarily a proper type). A set of bounds on α1, ..., αn is implied, generated from the declared bounds of P1, ..., Pn as specified in §18.1.3. In addition, for all i (1 ≤ i ≤ n): •If Ai is not a wildcard, then the bound αi = Ai is implied. •If Ai is a wildcard of the form ?: –αi = R implies the bound false –αi <: R implies the constraint formula ‹Bi θ <: R› –R <: αi implies the bound false •If Ai is a wildcard of the form ? extends T: –αi = R implies the bound false –If Bi is Object, then αi <: R implies the constraint formula ‹T <: R› –If T is Object, then αi <: R implies the constraint formula ‹Bi θ <: R› –R <: αi implies the bound false •If Ai is a wildcard of the form ? super T: –αi = R implies the bound false –αi <: R implies the constraint formula ‹Bi θ <: R› –R <: αi implies the constraint formula ‹R <: T›",10.71,416.14,360.01,1272,72,76.09,432.01,492.23,FALSE,FALSE
838,4,BODY,"6.Otherwise, let A1, ..., An be the resolved instantiations for α1, ..., αn, and let",10.71,7.17,360,84,72,236.06,432,243.23,FALSE,FALSE
237,12,BODY,TypeImportOnDemandDeclaration: import PackageOrTypeName . * ;,10.7,19.05,166.74,61,90,569.13,256.74,588.18,FALSE,TRUE
259,3,BODY,It is a compile-time error if a class is declared non-sealed but has neither a sealed direct superclass nor a sealed direct superinterface.,10.7,19.14,360,139,72,160.06,432,179.2,FALSE,FALSE
312,6,BODY,"The presence or absence of the strictfp modifier has absolutely no effect on the rules for overriding methods and implementing abstract methods. For example, it is permitted for a method that is not strictfp to override a strictfp method, and it is permitted for a strictfp method to override a method that is not strictfp.",10.7,45.14,360,323,72,426.06,432,471.2,FALSE,FALSE
373,6,BODY,"9.4.1.1Overriding (by Instance Methods) An instance method mI declared in or inherited by interface I, overrides from I another instance method mJ declared in interface J, iff all of the following are true: •I is a subinterface of J. •I does not inherit mJ. •The signature of mI is a subsignature (§8.4.2) of the signature of mJ as a member of the supertype of I that names J. •mJ is public.",10.7,128.2,360,391,72,466.13,432,594.33,FALSE,FALSE
478,8,BODY,13.4.3public Classes Changing a class that is not declared public to be declared public does not break compatibility with pre-existing binaries.,10.7,40.11,360,144,72,558.35,432,598.47,FALSE,FALSE
487,7,BODY,"13.4.10static Fields If a field that is not declared private was not declared static and is changed to be declared static, or vice versa, then a linkage error, specifically an IncompatibleClassChangeError, will result if the field is used by a pre-existing binary which expected a field of the other kind. Such changes are not recommended in code that has been widely distributed.",10.7,79.11,360,380,72,321.09,432,400.2,FALSE,FALSE
521,6,BODY,"•A default label or a case null, default label is dominated if there is a preceding unguarded case label in the switch block with a case pattern p where p is unconditional for the type of the selector expression (§14.30.3).",10.7,32.14,360,223,72,504.06,432,536.2,FALSE,FALSE
546,6,BODY,BreakStatement: break [Identifier] ;,10.7,19.05,97.4,36,90,287.13,187.4,306.18,FALSE,TRUE
595,7,BODY,"15.7.2Evaluate Operands before Operation The Java programming language guarantees that every operand of an operator (except the conditional operators &&, ||, and ? :) appears to be fully evaluated before any part of the operation itself is performed. If the binary operator is an integer division / (§15.17.2) or integer remainder % (§15.17.3), then its execution may raise an ArithmeticException, but this exception is thrown only after both operands of the binary operator have been evaluated and only if these evaluations completed normally. Example 15.7.2-1. Evaluation of Operands Before Operation",10.7,131.72,360,602,72,342.09,432,473.81,FALSE,FALSE
603,3,BODY,"15.8.5Parenthesized Expressions A parenthesized expression is a primary expression whose type is the type of the contained expression and whose value at run time is the value of the contained expression. If the contained expression denotes a variable then the parenthesized expression also denotes that variable. The use of parentheses affects only the order of evaluation, except for a corner case whereby (-2147483648) and (-9223372036854775808L) are legal but - (2147483648) and -(9223372036854775808L) are illegal.",10.7,111.11,360,518,72,134.09,432,245.2,FALSE,FALSE
669,2,BODY,"•Second, given a targeted function type with n parameters, a set of potentially applicable methods is identified: –If the method reference expression has the form ReferenceType :: [TypeArguments] Identifier, then the potentially applicable methods are: ›the member methods of the type to search that would be potentially applicable (§15.12.2.1) for a method invocation which names Identifier, has arity n, has type arguments TypeArguments, and appears in the same class as the method reference expression; plus ›the member methods of the type to search that would be potentially applicable for a method invocation which names Identifier, has arity n-1, has type arguments TypeArguments, and appears in the same class as the method reference expression. Two different arities, n and n-1, are considered, to account for the possibility that this form refers to either a static method or an instance method.",10.7,199.06,360,904,72,76.06,432,275.12,FALSE,FALSE
780,2,BODY,"17.2.4Interactions of Waits, Notification, and Interruption The above specifications allow us to determine several properties having to do with the interaction of waits, notification, and interruption. If a thread is both notified and interrupted while waiting, it may either: •return normally from wait, while still having a pending interrupt (in other words, a call to Thread.interrupted would return true) •return from wait by throwing an InterruptedException. The thread may not reset its interrupt status and return normally from the call to wait. Similarly, notifications cannot be lost due to interrupts. Assume that a set s of threads is in the wait set of an object m, and another thread performs a notify on m. Then either: •at least one thread in s must return normally from wait, or •all of the threads in s must exit wait by throwing InterruptedException. Note that if a thread is both interrupted and woken via notify, and that thread returns from wait by throwing an InterruptedException, then some other thread in the wait set must be notified.",10.7,270.11,360.01,1060,72,76.09,432.01,346.2,FALSE,FALSE
863,2,BODY,Primary: PrimaryNoNewArray ArrayCreationExpression PrimaryNoNewArray: Literal ClassLiteral this TypeName . this ( Expression ) ClassInstanceCreationExpression FieldAccess ArrayAccess MethodInvocation MethodReference ClassLiteral: TypeName {[ ]} . class NumericType {[ ]} . class boolean {[ ]} . class void . class ClassInstanceCreationExpression: UnqualifiedClassInstanceCreationExpression ExpressionName . UnqualifiedClassInstanceCreationExpression Primary . UnqualifiedClassInstanceCreationExpression UnqualifiedClassInstanceCreationExpression: new [TypeArguments] ClassOrInterfaceTypeToInstantiate ( [ArgumentList] ) [ClassBody],10.7,375.05,325.06,631,90,100.13,415.06,475.18,FALSE,TRUE
203,3,BODY,"6.5.5Meaning of Type Names The meaning of a name classified as a TypeName is determined as follows. 6.5.5.1Simple Type Names If a type name consists of a single Identifier, then the identifier must occur in the scope of exactly one declaration of a class, interface, or type parameter with this name (§6.3), or a compile-time error occurs. If the declaration denotes a type parameter of a generic class or interface C (§8.1.2, §9.1.2), then both of the following must be true, or a compile-time error occurs: •The type name does not occur in a static context (§8.1.3). •If the type name appears in a nested class or interface declaration of C, then the immediately enclosing class or interface declaration of the type name is an inner class of C. For example, the type name must not appear in the body of a static method declared by C, nor in the body of an instance method of a static class nested within C.",10.69,228.16,360,908,72,239.22,432,467.38,FALSE,FALSE
256,4,BODY,"8.1.1.1abstract Classes An abstract class is a class that is incomplete, or to be considered incomplete. It is a compile-time error if an attempt is made to create an instance of an abstract class using a class instance creation expression (§15.9.1). A subclass of an abstract class that is not itself abstract may be instantiated, resulting in the execution of a constructor for the abstract class and, therefore, the execution of the field initializers for instance variables of that class. A normal class may have abstract methods, that is, methods that are declared but not yet implemented (§8.4.3.1), only if it is an abstract class. It is a compile-time error if a normal class that is not abstract has an abstract method. A class C has abstract methods if either of the following is true: •Any of the member methods (§8.2) of C - either declared or inherited - is abstract. •Any of C's superclasses has an abstract method declared with package access, and there exists no method that overrides the abstract method from C or from a superclass of C. It is a compile-time error to declare an abstract class type such that it is not possible to create a subclass that implements all of its abstract methods. This",10.69,276.2,360.01,1215,72,318.13,432.01,594.33,FALSE,FALSE
307,5,BODY,It is a compile-time error if an ExceptionType mentioned in a throws clause is not a subtype (§4.10) of Throwable. Type variables are allowed in a throws clause even though they are not allowed in a catch clause (§14.20).,10.69,51.14,360,221,72,524.06,432,575.2,FALSE,FALSE
517,2,BODY,"SwitchRule: SwitchLabel -> Expression ; SwitchLabel -> Block SwitchLabel -> ThrowStatement SwitchBlockStatementGroup: SwitchLabel : {SwitchLabel :} BlockStatements SwitchLabel: case CaseConstant {, CaseConstant} case null [, default] case CasePattern {, CasePattern} [Guard] default CaseConstant: ConditionalExpression CasePattern: Pattern Guard: when Expression",10.69,269.05,222.1,362,90,76.13,312.1,345.18,FALSE,TRUE
625,11,BODY,FieldAccess: Primary . Identifier super . Identifier TypeName . super . Identifier,10.69,45.05,146.79,82,90,527.13,236.79,572.18,FALSE,TRUE
648,5,BODY,A method m1 is strictly more specific than another method m2 if and only if m1 is more specific than m2 and m2 is not more specific than m1.,10.69,19.14,360,140,72,575.06,432,594.2,FALSE,FALSE
660,5,BODY,"Dynamic method lookup may cause the following errors to occur: •If the method to be invoked is abstract, an AbstractMethodError is thrown. •If the method to be invoked is default, and more than one default method appears in the set of candidates in step 3 above, an IncompatibleClassChangeError is thrown. •If the invocation mode is interface and the method to be invoked is neither public nor private, an IllegalAccessError is thrown. The above procedure (if it terminates without error) will find a non-abstract, accessible method to invoke, provided that all classes and interfaces in the program have been consistently compiled. However, if this is not the case, then various errors may occur, as specified above; additional details about the behavior of the Java Virtual Machine under these circumstances are given by The Java Virtual Machine Specification, Java SE 23 Edition.",10.69,186.14,360.01,882,72,295.06,432.01,481.2,FALSE,FALSE
684,2,BODY,"range of two's-complement values is not symmetric, so negation of the maximum negative int or long results in that same maximum negative number. Overflow occurs in this case, but no exception is thrown. For all integer values x, -x equals (~x)+1. For floating-point values, negation is not the same as subtraction from zero, because if x is +0.0, then 0.0-x is +0.0, but -x is -0.0. Unary minus merely inverts the sign of a floating-point number. Special cases of interest: •If the operand is NaN, the result is NaN. (Recall that NaN has no sign (§4.2.3).)",10.69,109.14,360,556,72,76.06,432,185.2,FALSE,FALSE
708,5,BODY,"•If both the second and the third operand expressions are numeric expressions, the conditional expression is a numeric conditional expression. For the purpose of classifying a conditional, the following expressions are numeric expressions: –An expression of a standalone form (§15.2) with a type that is convertible to a numeric type (§4.2, §5.1.8). –A parenthesized numeric expression (§15.8.5). –A class instance creation expression (§15.9) for a class that is convertible to a numeric type. –A method invocation expression (§15.12) for which the chosen most specific method (§15.12.2.5) has a return type that is convertible to a numeric type. Note that, for a generic method, this is the type before instantiating the method's type arguments.",10.69,198.06,360,746,72,312.06,432,510.12,FALSE,FALSE
740,4,BODY,"The value of a lambda expression is a reference to an instance of a class with the following properties: •The class implements the targeted functional interface type and, if the target type is an intersection type, every other interface type mentioned in the intersection. •Where the lambda expression has type U, for each non-static member method m of U: If the function type of U has a subsignature of the signature of m, then the class declares a method that overrides m. The method's body has the effect of evaluating the lambda body, if it is an expression, or of executing the lambda body, if it is a block; if a result is expected, it is returned from the method. If the erasure of the type of a method being overridden differs in its signature from the erasure of the function type of U, then before evaluating or executing the lambda body, the method's body checks that each argument value is an instance of a subclass or subinterface of the erasure of the corresponding parameter type in the function type of U; if not, a ClassCastException is thrown. •The class overrides no other methods of the targeted functional interface type or other interface types mentioned above, although it may override methods of the Object class. These rules are meant to offer flexibility to implementations of the Java programming language, in that:",10.69,289.06,360.01,1342,72,304.06,432.01,593.12,FALSE,FALSE
45,2,BODY,or digit. An ignorable character is a character for which the method Character.isIdentifierIgnorable(int) returns true. Identifiers that have the same external appearance may yet be different.,10.68,32.14,360,192,72,76.06,432,108.2,FALSE,FALSE
80,2,BODY,"•The conditional-and and conditional-or operators && (§15.23) and || (§15.24) •The conditional operator ? : (§15.25) •The string concatenation operator + (§15.18.1), which, when given a String operand and a boolean operand, will convert the boolean operand to a String (either 'true' or 'false'), and then produce a newly created String that is the concatenation of the two strings Boolean expressions determine the control flow in several kinds of statements: •The if statement (§14.9) •The while statement (§14.12) •The do statement (§14.13) •The for statement (§14.14) A boolean expression also determines which subexpression is evaluated in the conditional ? : operator (§15.25). Only boolean and Boolean expressions can be used in control flow statements and as the first operand of the conditional operator ? :. An integer or floating-point expression x can be converted to a boolean value, following the C language convention that any nonzero value is true, by the expression x!=0. An object reference obj can be converted to a boolean value, following the C language convention that any reference other than null is true, by the expression obj!=null. A boolean value can be converted to a String by string conversion (§5.4). A boolean value may be cast to type boolean, Boolean, or Object (§5.5). No other casts on type boolean are allowed.",10.68,383.14,360,1348,72,76.06,432,459.2,FALSE,FALSE
245,3,BODY,"If and only if packages are stored in a file system (§7.2), the host system may choose to enforce the restriction that it is a compile-time error if a module declaration is not found in a file under a name composed of module-info plus an extension (such as .java or .jav).",10.68,45.14,360.01,272,72,215.06,432.01,260.2,FALSE,FALSE
310,3,BODY,A class does not inherit private or static methods from its superinterface types.,10.68,6.14,360,81,72,354.06,432,360.2,FALSE,FALSE
341,2,BODY,"It is a compile-time error to refer to a static field of an enum class from a constructor, instance initializer, or instance variable initializer in the enum declaration of the class, unless the field is a constant variable (§4.12.4). In an enum declaration, a constructor declaration with no access modifiers is private. In an enum declaration with no constructor declarations, a default constructor is implicitly declared. The default constructor is private, has no formal parameters, and has no throws clause.",10.68,109.14,360,512,72,76.06,432,185.2,FALSE,FALSE
446,3,BODY,"12.1.4Invoke Test.main Finally, after completion of the initialization for class Test (during which other consequential loading, linking, and initializing may have occurred), the method main of Test is invoked. The method main must be declared public, static, and void. It must specify a formal parameter (§8.4.1) whose declared type is array of String. Therefore, either of the following declarations is acceptable:",10.68,98.11,360,416,72,230.09,432,328.2,FALSE,FALSE
477,3,BODY,"13.4.1abstract Classes If a class that was not declared abstract is changed to be declared abstract, then pre-existing binaries that attempt to create new instances of that class will throw either an InstantiationError at link time, or (if a reflective method is used) an InstantiationException at run time; such a change is therefore not recommended for widely distributed classes. Changing a class that is declared abstract to no longer be declared abstract does not break compatibility with pre-existing binaries.",10.68,111.11,360,516,72,153.09,432,264.2,FALSE,FALSE
478,4,BODY,13.4.2.2non-sealed Classes Changing a class that was declared sealed to be declared non-sealed does not break compatibility with pre-existing binaries. Changing a class that was declared final to be declared non-sealed does not break compatibility with pre-existing binaries.,10.68,71.2,360,275,72,226.13,432,297.33,FALSE,FALSE
538,3,BODY,"–If the do statement does not have label L, the do statement completes abruptly because of a continue with label L.",10.68,19.14,350,115,82,204.06,432,223.2,FALSE,FALSE
698,7,BODY,15.20.2The instanceof Operator An instanceof expression may perform either type comparison or pattern matching.,10.68,40.11,359.99,111,72,542.09,431.99,582.2,FALSE,FALSE
699,2,BODY,InstanceofExpression: RelationalExpression instanceof ReferenceType RelationalExpression instanceof Pattern,10.68,32.05,229.58,107,90,76.13,319.58,108.18,FALSE,TRUE
705,7,BODY,"The conditional-and operator is syntactically left-associative (it groups left-to- right). The conditional-and operator is fully associative with respect to both side effects and result value. That is, for any expressions a, b, and c, evaluation of the expression ((a) && (b)) && (c) produces the same result, with the same side effects occurring in the same order, as evaluation of the expression (a) && ((b) && (c)). Each operand of the conditional-and operator must be of type boolean or Boolean, or a compile-time error occurs. The type of a conditional-and expression is always boolean.",10.68,141.14,360,591,72,452.06,432,593.2,FALSE,FALSE
733,3,BODY,"A formal parameter of a lambda expression may be declared final, or annotated, only if specified by a normal parameter specifier. If a formal parameter is specified by a concise formal specifier instead, then the formal parameter is not final and has no annotations. A formal parameter of a lambda expression may be a variable arity parameter, indicated by an ellipsis following the type in a normal parameter specifier. At most one variable arity parameter is permitted for a lambda expression. It is a compile- time error if a variable arity parameter appears anywhere in the list of normal parameter specifiers except the last position. Each formal parameter of a lambda expression has either an inferred type or a declared type: •If a formal parameter is specified either by a normal parameter specifier that uses var, or by a concise parameter specifier, then the formal parameter has an inferred type. The type is inferred from the functional interface type targeted by the lambda expression (§15.27.3). •If a formal parameter is specified by a normal parameter specifier that does not use var, then the formal parameter has a declared type. The declared type is determined as follows: –If the formal parameter is not a variable arity parameter, then the declared type is denoted by UnannType if no bracket pairs appear in UnannType and VariableDeclaratorId, and specified by §10.2 otherwise. –If the formal parameter is a variable arity parameter, then the declared type is an array type specified by §10.2. No distinction is made between the following lambda parameter lists: (int... x) -> BODY (int[] x) -> BODY",10.68,381.04,360.01,1620,72,144.06,432.01,525.11,FALSE,FALSE
836,3,BODY,"•Third, if m2 is applicable by variable arity invocation and has k+1 parameters, then where Sk+1 is the k+1'th variable arity parameter type of m1 and Tk+1 is the result of θ applied to the k+1'th variable arity parameter type of m2, the constraint ‹Sk+1 <: Tk+1› is generated. •Fourth, the generated bounds and constraint formulas are reduced and incorporated with B to produce a bound set B'. If B' does not contain the bound false, and resolution of all the inference variables in B' succeeds, then m1 is more specific than m2. Otherwise, m1 is not more specific than m2.",10.68,128.14,360,574,72,466.06,432,594.2,FALSE,FALSE
52,3,BODY,HexNumeral: 0 x HexDigits 0 X HexDigits HexDigits: HexDigit HexDigit [HexDigitsAndUnderscores] HexDigit HexDigit: (one of) 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F HexDigitsAndUnderscores: HexDigitOrUnderscore {HexDigitOrUnderscore} HexDigitOrUnderscore: HexDigit _,10.67,217.75,242.2,268,90,171.13,332.2,388.88,FALSE,TRUE
135,3,BODY,"2.S is the class type Object or the interface type java.io.Serializable or Cloneable (the only interfaces implemented by arrays (§10.8)), and T is an array type.",10.67,32.14,350,161,82,140.06,432,172.2,FALSE,FALSE
139,2,BODY,"•Otherwise, let R be the class of the object referred to by the value, and let T be the erasure (§4.6) of the type being converted to. Then: –If R is an ordinary class (not an array class): ›If T is a class type, then R must be either the same class as T (§4.3.4) or a subclass of T, or a ClassCastException is thrown. ›If T is an interface type, then R must implement interface T (§8.1.5), or a ClassCastException is thrown. ›If T is an array type, then a ClassCastException is thrown. –If R is an interface:",10.67,140.14,360,509,72,76.06,432,216.2,FALSE,FALSE
148,4,BODY,"•An OutOfMemoryError as a result of a boxing conversion. •A NullPointerException as a result of an unboxing conversion on a null reference. •An ArrayStoreException in special cases involving array elements or field access (§10.5, §15.26.1).",10.67,70.14,360,240,72,250.06,432,320.2,FALSE,FALSE
269,2,BODY,"It is a compile-time error if a class depends on itself. If circularly declared classes are detected at run time, as classes are loaded, then a ClassCircularityError is thrown (§12.2.1).",10.67,38.14,359.99,186,72,76.06,431.99,114.2,FALSE,FALSE
389,3,BODY,"9.6.4Predefined Annotation Interfaces Several annotation interfaces are predefined in the Java SE Platform API. Some of the predefined annotation interfaces have special semantics in the Java programming language and require special behavior on the part of a Java compiler, as specified in this section. This section does not provide a complete specification for the predefined annotation interfaces, for which the reader is referred to the Java SE Platform API documentation (§1.4). 9.6.4.1@Target An annotation of type java.lang.annotation.Target is used on the declaration of an annotation interface A to specify the contexts in which A is applicable. java.lang.annotation.Target has a single element, value, of type java.lang.annotation.ElementType[], to specify contexts. Annotation interfaces may be applicable in declaration contexts, where annotations apply to declarations, or in type contexts, where annotations apply to types used in declarations and expressions. There are ten declaration contexts, each corresponding to an enum constant of java.lang.annotation.ElementType: 1.Module declarations (§7.7)",10.67,274.24,360.01,1115,72,175.09,432.01,449.33,FALSE,FALSE
390,15,BODY,"9.6.4.2@Retention Annotations may be present only in source code, or they may be present in the binary form of a class or interface. An annotation that is present in the binary form may or may not be available at run time via the reflection libraries of the Java SE Platform. The annotation interface java.lang.annotation.Retention is used to choose among these possibilities.",10.67,78.2,360.01,376,72,498.13,432.01,576.33,FALSE,FALSE
392,2,BODY,"9.6.4.4@Override Programmers occasionally overload a method declaration when they mean to override it, leading to subtle problems. The annotation interface Override supports early detection of such problems.",10.67,52.2,360,207,72,76.13,432,128.33,FALSE,FALSE
414,2,BODY,"wildcard parameterization of I, I<T1...Tn>. The non-wildcard parameterization is determined as follows. Let P1...Pn be the type parameters of I with corresponding bounds B1...Bn. For all i (1 ≤ i ≤ n), Ti is derived according to the form of Ai: –If Ai is a type, then Ti = Ai. –If Ai is a wildcard, and the corresponding type parameter's bound, Bi, mentions one of P1...Pn, then Ti is undefined and there is no function type. –Otherwise: ›If Ai is an unbound wildcard ?, then Ti = Bi. ›If Ai is a upper-bounded wildcard ? extends Ui, then Ti = glb(Ui, Bi) (§5.1.10). ›If Ai is a lower-bounded wildcard ? super Li, then Ti = Li.",10.67,191.14,350,627,82,76.06,432,267.2,FALSE,FALSE
436,4,BODY,"It is a compile-time error if a catch clause can catch checked exception class E1 and it is not the case that the try block corresponding to the catch clause can throw a checked exception class that is a subclass or superclass of E1, unless E1 is Exception or a superclass of Exception. It is a compile-time error if a catch clause can catch an exception class E1 and a preceding catch clause of the immediately enclosing try statement can catch E1 or a superclass of E1.",10.67,90.14,360,471,72,408.06,432,498.2,FALSE,FALSE
550,5,BODY,ReturnStatement: return [Expression] ;,10.67,19.05,110.74,38,90,355.13,200.74,374.18,FALSE,TRUE
568,3,BODY,YieldStatement: yield Expression ;,10.67,19.05,96.78,34,90,145.13,186.78,164.18,FALSE,TRUE
569,8,BODY,"•A continue statement continues a do statement if, within the do statement, either there are no try statements whose try blocks contain the continue statement, or there are try statements whose try blocks contain the continue statement and all finally clauses of those try statements can complete normally.",10.67,45.14,360,306,72,557.06,432,602.2,FALSE,FALSE
835,4,BODY,"–Let RS be the return type of MTS, and let RT be the return type of MTT. Then: ›If RS mentions one of A1, ..., An, and RT is not a proper type, false. ›Otherwise, if ei is an explicitly typed lambda expression: »If RT is void, true. »Otherwise, if RS and RT are functional interface types, and ei has at least one result expression, then for each result expression in ei, this entire",10.67,95.14,350,383,82,198.06,432,293.2,FALSE,FALSE
848,1,BODY,"ClassMemberDeclaration: FieldDeclaration MethodDeclaration ClassDeclaration InterfaceDeclaration ; FieldDeclaration: {FieldModifier} UnannType VariableDeclaratorList ; FieldModifier: (one of) Annotation public protected private static final transient volatile VariableDeclaratorList: VariableDeclarator {, VariableDeclarator} VariableDeclarator: VariableDeclaratorId [= VariableInitializer] VariableDeclaratorId: Identifier [Dims] _ VariableInitializer: Expression ArrayInitializer",10.67,345.05,249.39,481,90,76.13,339.39,421.18,FALSE,TRUE
74,4,BODY,"An integer operator can throw an exception (§11 (Exceptions)) for the following reasons: •Any integer operator can throw a NullPointerException if unboxing conversion (§5.1.8) of a null reference is required. •The integer divide operator / (§15.17.2) and the integer remainder operator % (§15.17.3) can throw an ArithmeticException if the right-hand operand is zero. •The increment and decrement operators ++ (§15.14.2, §15.15.1) and -- (§15.14.3, §15.15.2) can throw an OutOfMemoryError if boxing conversion (§5.1.7) is required and there is not sufficient memory available to perform the conversion. Example 4.2.2-1. Integer Operations",10.66,160.74,360.01,637,72,393.06,432.01,553.81,FALSE,FALSE
413,2,BODY,"•throws clause: The function type's throws clause is derived from the throws clauses of the methods in M, as follows: 1.If the function type is generic, the throws clauses are first adapted to the",10.66,57.14,360,196,72,76.06,432,133.2,FALSE,FALSE
465,6,BODY,3.A thread invoked Runtime.halt. (No shutdown hooks are started in this,10.66,6.14,360,71,72,345.06,432,351.2,FALSE,FALSE
487,8,BODY,13.4.11transient Fields Adding or deleting a transient modifier of a field does not break compatibility with pre-existing binaries.,10.66,40.11,359.99,131,72,426.09,431.99,466.2,FALSE,FALSE
719,4,BODY,"If class RC is not assignable to type SC, then no assignment occurs and an ArrayStoreException is thrown. Otherwise, the reference value of the right-hand operand is stored into the selected array component.",10.66,51.14,340,207,92,146.06,432,197.2,FALSE,FALSE
734,6,BODY,"The rules concerning annotation modifiers for a formal parameter declaration are specified in §9.7.4 and §9.7.5. It is a compile-time error if final appears more than once as a modifier for a formal parameter declaration. It is a compile-time error if the LambdaParameterType of a formal parameter is var and the VariableDeclaratorId of the same formal parameter has one or more bracket pairs. The scope and shadowing of a formal parameter is specified in §6.3 and §6.4. References to a formal parameter from a nested class or interface, or a nested lambda expression, are restricted, as specified in §6.5.6.1. It is a compile-time error for a lambda expression to declare two formal parameters with the same name. (That is, their declarations mention the same Identifier.) Note that, in contrast, it is possible for a lambda expression to declare more than one unnamed lambda parameter, such as (_, _) -> BODY or (String _, int _) -> BODY.",10.66,211.06,360.01,940,72,292.06,432.01,503.12,FALSE,FALSE
72,5,BODY,PrimitiveType: {Annotation} NumericType {Annotation} boolean NumericType: IntegralType FloatingPointType IntegralType: (one of) byte short int long char FloatingPointType: (one of) float double,10.65,182.05,129.71,193,90,314.13,219.71,496.18,FALSE,TRUE
78,3,BODY,"A floating-point operator can throw an exception (§11 (Exceptions)) for the following reasons: •Any floating-point operator can throw a NullPointerException if unboxing conversion (§5.1.8) of a null reference is required. •The increment and decrement operators ++ (§15.14.2, §15.15.1) and -- (§15.14.3, §15.15.2) can throw an OutOfMemoryError if boxing conversion (§5.1.7) is required and there is not sufficient memory available to perform the conversion. Example 4.2.4-1. Floating-point Operations",10.65,126.74,360,499,72,297.06,432,423.81,FALSE,FALSE
81,2,BODY,"ReferenceType: ClassOrInterfaceType TypeVariable ArrayType ClassOrInterfaceType: ClassType InterfaceType ClassType: {Annotation} TypeIdentifier [TypeArguments] PackageName . {Annotation} TypeIdentifier [TypeArguments] ClassOrInterfaceType . {Annotation} TypeIdentifier [TypeArguments] InterfaceType: ClassType TypeVariable: {Annotation} TypeIdentifier ArrayType: PrimitiveType Dims ClassOrInterfaceType Dims TypeVariable Dims Dims: {Annotation} [ ] {{Annotation} [ ]} The sample code: class Point { int[] metrics; } interface Move { void move(int deltax, int deltay); }",10.65,384.98,321.79,569,90,76.13,411.79,461.11,FALSE,TRUE
362,4,BODY,"An interface is freely extensible if none of its direct superinterfaces are sealed (§9.1.3), and it is not sealed itself. An interface that has a sealed direct superinterface is freely extensible if and only if it is declared non-sealed. It is a compile-time error if an interface has a sealed direct superinterface and is not declared sealed or non-sealed. It is a compile-time error if an interface is declared non-sealed but has no sealed direct superinterface.",10.65,115.14,360,464,72,179.2,432,294.33,FALSE,FALSE
393,7,BODY,"9.6.4.5@SuppressWarnings Java compilers are increasingly capable of issuing helpful 'lint-like' warnings. To encourage the use of such warnings, there should be some way to disable a warning in a part of the program when the programmer knows that the warning is inappropriate. The annotation interface SuppressWarnings supports programmer control over warnings otherwise issued by a Java compiler. It defines a single element that is an array of String. If a declaration is annotated with @SuppressWarnings(value = {S1, ..., Sk}), then a Java compiler must suppress (that is, not report) any warning specified by one of S1 ... Sk if that warning would have been generated as a result of the annotated declaration or any of its parts. The Java programming language defines four kinds of warnings that can be specified by @SuppressWarnings:",10.65,200.2,360.01,838,72,394.13,432.01,594.33,FALSE,FALSE
526,4,BODY,"•P rewrites to a set Q and Q covers T. A set of case elements, P, rewrites to the set Q, if a subset of P reduces to a pattern p, and Q consists of the remaining elements of P along with the pattern p. A non-empty set of patterns, RP, reduces to a single pattern rp if one of the following holds: –RP covers some type U, and rp is a type pattern of type U. –RP consists of record patterns whose types all erase to the same record class R with k (k≥1) components and there is a distinguished component cr (1≤r≤k) of R such that for every other component ci (1≤i≤k, i≠r) the set containing the component patterns from the record patterns corresponding to component ci is equivalent to a single pattern qi, the set containing the component patterns from the record patterns corresponding to the component cr reduces to a single pattern q, and rp is the record pattern of type R with a pattern list consisting of the patterns q1, ..., qr-1, q, qr+1, ..., qk. A non-empty set of patterns EP is equivalent to a single pattern ep if one of the following holds: ›EP consists of type patterns whose types all have the same erasure T, and ep is a type pattern of type T. ›EP consists of record patterns whose types all erase to the same record class R with k (k≥1) components and for every record component the set containing the corresponding component patterns from the record patterns is equivalent to a single pattern qj (1≤j≤k), and ep is the record pattern of type R with a component pattern list consisting of the component patterns q1,...qk. Ordinarily record patterns match only a subset of the values of the record type. However, a number of record patterns in a switch block can combine to actually match all of the values of the record type. For example:",10.65,376.06,360,1756,72,225.06,432,601.12,FALSE,FALSE
658,5,BODY,"•If m has package access, then m is accessible iff D is in the same package as C. •If m is private, then m is accessible iff D is C, or D encloses C, or C encloses D, or C and D are both enclosed by a third class or interface. If either Q or m is not accessible, then an IllegalAccessError occurs (§12.3). If the invocation mode is interface, then the implementation must check that the target reference class still implements the specified interface. If the target reference class does not still implement the interface, then an IncompatibleClassChangeError occurs.",10.65,115.14,360,566,72,338.06,432,453.2,FALSE,FALSE
206,3,BODY,"If the declaration denotes a local variable, formal parameter, or exception parameter, let X be the innermost method declaration, constructor declaration, instance initializer, static initializer, field declaration, or explicit constructor invocation statement which encloses the local variable or parameter declaration. If the expression name appears directly or indirectly in the body of a local class, local interface, or anonymous class D declared directly in X, then both of the following must be true, or a compile-time error occurs: •The expression name does not occur in a static context. •D is an inner class, and the immediately enclosing class or interface declaration of the expression name is D or an inner class of D. For example, the expression name must not appear in the body of a static method declared by D, nor (if D is a local interface) in the body of a default method of D.",10.64,167.06,360,896,72,159.06,432,326.12,FALSE,FALSE
349,5,BODY,RecordBody: { {RecordBodyDeclaration} } RecordBodyDeclaration: ClassBodyDeclaration CompactConstructorDeclaration The following productions from §8.1.7 are shown here for convenience:,10.64,90.99,259.7,183,90,458.13,349.7,549.12,FALSE,TRUE
370,6,BODY,"9.4Method Declarations InterfaceMethodDeclaration: {InterfaceMethodModifier} MethodHeader MethodBody InterfaceMethodModifier: (one of) Annotation public private abstract default static strictfp The following productions from §8.4, §8.4.5, and §8.4.7 are shown here for convenience:",10.64,134.56,340.19,281,72,423.56,412.19,558.12,FALSE,FALSE
703,2,BODY,"The result of == is true if the operands (after any required unboxing conversion) are both true or both false; otherwise, the result is false. The result of != is false if the operands are both true or both false; otherwise, the result is true.",10.64,51.14,360,244,72,76.06,432,127.2,FALSE,FALSE
705,4,BODY,"15.22.2Boolean Logical Operators &, ^, and | When both operands of a &, ^, or | operator are of type boolean or Boolean, then the type of the bitwise operator expression is boolean. In all cases, the operands are subject to unboxing conversion (§5.1.8) as necessary. For &, the result value is true if both operand values are true; otherwise, the result is false. For ^, the result value is true if the operand values are different; otherwise, the result is false. For |, the result value is false if both operand values are false; otherwise, the result is true.",10.64,149.11,360,562,72,149.09,432,298.2,FALSE,FALSE
777,2,BODY,"When an object is first created, its wait set is empty. Elementary actions that add threads to and remove threads from wait sets are atomic. Wait sets are manipulated solely through the methods Object.wait, Object.notify, and Object.notifyAll. Wait set manipulations can also be affected by the interruption status of a thread, and by the Thread class's methods dealing with interruption. Additionally, the Thread class's methods for sleeping and joining other threads have properties derived from those of wait and notification actions.",10.64,103.14,360,537,72,76.06,432,179.2,FALSE,FALSE
60,3,BODY,"3.10.4Character Literals A character literal is expressed as a character or an escape sequence (§3.10.7), enclosed in ASCII single quotes. (The single-quote, or apostrophe, character is \u0027.)",10.63,53.11,360,194,72,108.09,432,161.2,FALSE,FALSE
144,2,BODY,"•If Ti is a wildcard type argument of the form ? extends Bi, then Si is a fresh type variable whose upper bound is glb(Bi, Ui[A1:=S1,...,An:=Sn]) and whose lower bound is the null type. glb(V1,...,Vm) is defined as V1 & ... & Vm. It is a compile-time error if, for any two classes (not interfaces) Vi and Vj, Vi is not a subclass of Vj or vice versa. •If Ti is a wildcard type argument of the form ? super Bi, then Si is a fresh type variable whose upper bound is Ui[A1:=S1,...,An:=Sn] and whose lower bound is Bi. •Otherwise, Si = Ti. Capture conversion on any type other than a parameterized type (§4.5) acts as an identity conversion (§5.1.1). Capture conversion is not applied recursively. Capture conversion never requires a special action at run time and therefore never throws an exception at run time.",10.63,230.14,360,809,72,76.06,432,306.2,FALSE,FALSE
258,3,BODY,"8.1.1.2sealed, non-sealed, and final Classes A class can be declared sealed if all its direct subclasses are known when the class is declared (§8.1.6), and no other direct subclasses are desired or required.",10.63,39.2,360.01,207,72,286.13,432.01,325.33,FALSE,FALSE
381,2,BODY,•A primitive type •String •Class or an invocation of Class (§4.5) •An enum class type •An annotation interface type •An array type whose component type is one of the preceding types (§10.1).,10.63,101.14,341.15,190,72,76.06,413.15,177.2,FALSE,FALSE
767,6,BODY,"•In a yield statement with expression e, or a return statement with expression e, or a throw statement with expression e, V is [un]assigned before e iff V is [un]assigned before the yield, return, or throw statement.",10.63,32.14,360,216,72,510.2,432,542.33,FALSE,FALSE
239,3,BODY,SingleStaticImportDeclaration: import static TypeName . Identifier ;,10.62,19.05,187.34,68,90,113.13,277.34,132.18,FALSE,TRUE
246,4,BODY,"7.7.1Dependences The requires directive specifies the name of a module on which the current module has a dependence. A requires directive must not appear in the declaration of the java.base module, or a compile-time error occurs, because it is the primordial module and has no dependences (§8.1.4). If the declaration of a module does not express a dependence on the java.base module, and the module is not itself java.base, then the module has an implicitly declared dependence on the java.base module. The requires keyword may be followed by the modifier transitive. This causes any module which requires the current module to have an implicitly declared dependence on the module specified by the requires transitive directive. The requires keyword may be followed by the modifier static. This specifies that the dependence, while mandatory at compile time, is optional at run time. If the declaration of a module expresses a dependence on the java.base module, and the module is not itself java.base, then it is a compile-time error if a modifier appears after the requires keyword. It is a compile-time error if more than one requires directive in a module declaration specifies the same module name. It is a compile-time error if resolution, as described in the java.lang.module package specification, with the current module as the only root module, fails for any of the reasons described in the java.lang.module package specification. For example, if a requires directive specifies a module that is not observable, or if the current module directly or indirectly expresses a dependence on itself.",10.62,361.03,360.01,1603,72,177.09,432.01,538.12,FALSE,FALSE
555,3,BODY,"TryStatement: try Block Catches try Block [Catches] Finally TryWithResourcesStatement Catches: CatchClause {CatchClause} CatchClause: catch ( CatchFormalParameter ) Block CatchFormalParameter: {VariableModifier} CatchType VariableDeclaratorId CatchType: UnannClassType {| ClassType} Finally: finally Block See §8.3 for UnannClassType. The following productions from §4.3, §8.3, and §8.4.1 are shown here for convenience:",10.62,261.99,324,420,90,113.13,414,375.12,FALSE,TRUE
455,7,BODY,"11.Otherwise, the initializers must have completed abruptly by throwing some exception E. If the class of E is not Error or one of its subclasses, then create a new instance of the class ExceptionInInitializerError, with E as the argument, and use this object in place of E in the following step. If a new instance of ExceptionInInitializerError cannot be created because an OutOfMemoryError occurs, then instead use an OutOfMemoryError object in place of E in the following step.",10.61,84.14,360,480,72,359.06,432,443.2,FALSE,FALSE
548,6,BODY,ContinueStatement: continue [Identifier] ;,10.61,19.05,113.6,42,90,368.13,203.6,387.18,FALSE,TRUE
504,3,BODY,LocalVariableDeclaration: {VariableModifier} LocalVariableType VariableDeclaratorList LocalVariableType: UnannType var,10.6,67.75,290.14,118,90,193.13,380.14,260.88,FALSE,TRUE
612,3,BODY,"θj is [F1:=X1, ..., Fp:=Xp, G1:=Y1, ..., Gq:=Yq]. –The type parameters of mj are X1, ..., Xp, Y1, ..., Yq. The bound of each type parameter, if any, is θj applied to the corresponding type parameter bound in D or cj. –The return type of mj is θj applied to D<F1, ..., Fp>. –The (possibly empty) list of argument types of mj is θj applied to the argument types of cj. –The (possibly empty) list of thrown types of mj is θj applied to the thrown types of cj. –The modifiers of mj are those of cj. –The name of mj is #m, an automatically generated name that is distinct from all constructor and method names in D and is shared by m1, ..., mn. –The body of mj is irrelevant. To choose a constructor, we temporarily consider m1, ..., mn to be members of D. One of m1, ..., mn is chosen, as determined by the class instance creation expression's argument expressions, using the process specified in §15.12.2. If there is no unique most specific method that is both applicable and accessible, then a compile-time error occurs. Otherwise, where mj is the chosen method:",10.6,300.14,350.01,1061,82,294.06,432.01,594.2,FALSE,FALSE
642,4,BODY,"•A lambda expression or a method reference expression is potentially compatible with a type variable if the type variable is a type parameter of the candidate method. •A parenthesized expression (§15.8.5) is potentially compatible with a type if its contained expression is potentially compatible with that type. •A conditional expression (§15.25) is potentially compatible with a type if each of its second and third operand expressions are potentially compatible with that type. •A switch expression (§15.28) is potentially compatible with a type if all of its result expressions are potentially compatible with that type. •A class instance creation expression, a method invocation expression, or an expression of a standalone form (§15.2) is potentially compatible with any type. The definition of potential applicability goes beyond a basic arity check to also take into account the presence and 'shape' of functional interface target types. In some cases involving type argument inference, a lambda expression appearing as a method invocation",10.6,215.06,360.01,1047,72,384.06,432.01,599.12,FALSE,FALSE
816,2,BODY,"A constraint formula of the form ‹S = T›, where S and T are type arguments (§4.5.1), is reduced as follows: •If S and T are types, the constraint is reduced as described above. •If S has the form ? and T has the form ?, the constraint reduces to true. •If S has the form ? and T has the form ? extends T', the constraint reduces to ‹Object = T'›. •If S has the form ? extends S' and T has the form ?, the constraint reduces to ‹S' = Object›. •If S has the form ? extends S' and T has the form ? extends T', the constraint reduces to ‹S' = T'›. •If S has the form ? super S' and T has the form ? super T', the constraint reduces to ‹S' = T'›. •Otherwise, the constraint reduces to false.",10.6,204.14,360.01,686,72,76.06,432.01,280.2,FALSE,FALSE
854,3,BODY,"InterfaceModifier: (one of) Annotation public protected private abstract static sealed non-sealed strictfp InterfaceExtends: extends InterfaceTypeList InterfacePermits: permits TypeName {, TypeName} InterfaceBody: { {InterfaceMemberDeclaration} } InterfaceMemberDeclaration: ConstantDeclaration InterfaceMethodDeclaration ClassDeclaration InterfaceDeclaration ; ConstantDeclaration: {ConstantModifier} UnannType VariableDeclaratorList ; ConstantModifier: (one of) Annotation public static final",10.6,345.05,265.9,494,90,200.13,355.9,545.18,FALSE,TRUE
85,3,BODY,4.3.3The Class String Instances of class String represent sequences of Unicode code points. A String object has a constant (unchanging) value. String literals (§3.10.5) and text blocks (§3.10.6) are references to instances of class String. The string concatenation operator + (§15.18.1) implicitly creates a new String object when the result is not a constant expression (§15.29).,10.59,110.11,360.01,380,72,326.09,432.01,436.2,FALSE,FALSE
129,3,BODY,"5.1.2Widening Primitive Conversion 19 specific conversions on primitive types are called the widening primitive conversions: •byte to short, int, long, float, or double •short to int, long, float, or double •char to int, long, float, or double •int to long, float, or double •long to float or double •float to double A widening primitive conversion does not lose information about the overall magnitude of a numeric value in the following cases, where the numeric value is preserved exactly: •from an integral type to another integral type •from byte, short, or char to a floating-point type •from int to double •from float to double A widening primitive conversion from int to float, or from long to float, or from long to double, may result in loss of precision, that is, the result may lose some of the least significant bits of the value. In this case, the resulting floating- point value will be a correctly rounded version of the integer value, using the round to nearest rounding policy (§15.4). A widening conversion of a signed integer value to an integral type T simply sign- extends the two's-complement representation of the integer value to fill the wider format. A widening conversion of a char to an integral type T zero-extends the representation of the char value to fill the wider format. A widening conversion from int to float, or from long to float, or from int to double, or from long to double occurs as determined by the rules of IEEE 754 for converting from an integer format to a binary floating-point format.",10.59,468.11,360.01,1535,72,115.09,432.01,583.2,FALSE,FALSE
141,2,BODY,"•If p is a value of type float then: –If p is not NaN, then boxing conversion converts p into a reference r of class and type Float, such that r.floatValue() evaluates to p –Otherwise, boxing conversion converts p into a reference r of class and type Float such that r.isNaN() evaluates to true",10.59,70.14,360,294,72,76.06,432,146.2,FALSE,FALSE
147,2,BODY,"•a widening reference conversion followed by an unboxing conversion, then followed by a widening primitive conversion •a boxing conversion (§5.1.7) •a boxing conversion followed by a widening reference conversion •an unboxing conversion (§5.1.8) •an unboxing conversion followed by a widening primitive conversion If, after the conversions listed above have been applied, the resulting type is a raw type (§4.8), an unchecked conversion (§5.1.9) may then be applied. In addition, if the expression is a constant expression (§15.29) of type byte, short, char, or int: •A narrowing primitive conversion may be used if the variable is of type byte, short, or char, and the value of the constant expression is representable in the type of the variable. •A narrowing primitive conversion followed by a boxing conversion may be used if the variable is of type Byte, Short, or Character, and the value of the constant expression is representable in the type byte, short, or char respectively. The compile-time narrowing of constant expressions means that code such as: byte theAnswer = 42;",10.59,292.05,360.01,1082,72,76.06,432.01,368.11,FALSE,FALSE
235,5,BODY,SingleTypeImportDeclaration: import TypeName ;,10.59,19.05,135.65,46,90,412.13,225.65,431.18,FALSE,TRUE
266,7,BODY,ClassExtends: extends ClassType,10.59,19.05,96.39,31,90,541.13,186.39,560.18,FALSE,TRUE
300,8,BODY,"The rules concerning annotation modifiers for a method declaration are specified in §9.7.4 and §9.7.5. It is a compile-time error if the same keyword appears more than once as a modifier for a method declaration, or if a method declaration has more than one of the access modifiers public, protected, and private (§6.6). It is a compile-time error if a method declaration that contains the keyword abstract also contains any one of the keywords private, static, final, native, strictfp, or synchronized. It is a compile-time error if a method declaration that contains the keyword native also contains strictfp.",10.59,141.14,360.01,611,72,328.06,432.01,469.2,FALSE,FALSE
492,3,BODY,13.4.20synchronized Methods Adding or deleting a synchronized modifier of a method does not break compatibility with pre-existing binaries.,10.59,40.11,360,139,72,194.09,432,234.2,FALSE,FALSE
513,4,BODY,AssertStatement: assert Expression ; assert Expression : Expression ;,10.59,32.05,161.97,69,90,413.13,251.97,445.18,FALSE,TRUE
140,2,BODY,"5.1.7Boxing Conversion Boxing conversion treats expressions of a primitive type as expressions of a corresponding reference type. Specifically, the following nine conversions are called the boxing conversions: •From type boolean to type Boolean •From type byte to type Byte •From type short to type Short •From type char to type Character •From type int to type Integer •From type long to type Long •From type float to type Float •From type double to type Double •From the null type to the null type",10.58,224.11,360,499,72,76.09,432,300.2,FALSE,FALSE
328,7,BODY,ConstructorModifier: (one of) Annotation public protected private,10.58,32.05,185.94,65,90,485.13,275.94,517.18,FALSE,TRUE
553,5,BODY,SynchronizedStatement: synchronized ( Expression ) Block,10.58,19.05,170.53,56,90,438.13,260.53,457.18,FALSE,TRUE
786,2,BODY,"A set of actions is sequentially consistent if all actions occur in a total order (the execution order) that is consistent with program order, and furthermore, each read r of a variable v sees the value written by the write w to v such that: •w comes before r in the execution order, and •there is no other write w' such that w comes before w' and w' comes before r in the execution order. Sequential consistency is a very strong guarantee that is made about visibility and ordering in an execution of a program. Within a sequentially consistent execution, there is a total order over all individual actions (such as reads and writes) which is consistent with the order of the program, and each individual action is atomic and is immediately visible to every thread. If a program has no data races, then all executions of the program will appear to be sequentially consistent. Sequential consistency and/or freedom from data races still allows errors arising from groups of operations that need to be perceived atomically and are not. If we were to use sequential consistency as our memory model, many of the compiler and processor optimizations that we have discussed would be illegal. For example, in the trace in Table 17.4-C, as soon as the write of 3 to p.x occurred, subsequent reads of that location would be required to see that value.",10.58,270.06,360.01,1343,72,76.06,432.01,346.12,FALSE,FALSE
809,2,BODY,"•If T is not a functional interface type (§9.8), the constraint reduces to false. •Otherwise, let T' be the ground target type derived from T, as specified in §15.27.3. If §18.5.3 is used to derive a functional interface type which is parameterized, then the test that F<A'1, ..., A'm> is a subtype of F<A1, ..., Am> is not performed (instead, it is asserted with a constraint formula below). Let the target function type for the lambda expression be the function type of T'. Then: –If no valid function type can be found, the constraint reduces to false. –Otherwise, the congruence of LambdaExpression with the target function type is asserted as follows: ›If the number of lambda parameters differs from the number of parameter types of the function type, the constraint reduces to false. ›If the lambda expression is implicitly typed and one or more of the function type's parameter types is not a proper type, the constraint reduces to false. This condition never arises in practice, due to the handling of implicitly typed lambda expressions in §18.5.1 and the substitution applied to the target type in §18.5.2.2.",10.58,234.06,360.01,1119,72,76.06,432.01,310.12,FALSE,FALSE
59,3,BODY,"•The largest positive finite double value is numerically equal to (2 - 2) ⋅ 2. The shortest decimal literal which rounds to this value is 1.7976931348623157e308. A hexadecimal literal for this value is 0x1.f_ffff_ffff_ffffP+1023. •The smallest positive finite non-zero double value is numerically equal to 2. The shortest decimal literal which rounds to this value is 4.9e-324. Two hexadecimal literals for this value are 0x0.0_0000_0000_0001P-1022 and 0x1.0P-1074. It is a compile-time error if a non-zero floating-point literal is too large, so that on rounded conversion to its internal representation, it becomes an IEEE 754 infinity. A program can represent infinities without producing a compile-time error by using constant expressions such as 1f/0f or -1d/0d or by using the predefined constants POSITIVE_INFINITY and NEGATIVE_INFINITY of the classes Float and Double. It is a compile-time error if a non-zero floating-point literal is too small, so that, on rounded conversion to its internal representation, it becomes a zero. A compile-time error does not occur if a non-zero floating-point literal has a small value that, on rounded conversion to its internal representation, becomes a non- zero subnormal number. Predefined constants representing Not-a-Number values are defined in the classes Float and Double as Float.NaN and Double.NaN.",10.57,313.14,360.01,1352,72,76.06,432.01,389.2,FALSE,FALSE
75,8,BODY,"IEEE 754 includes not only positive and negative numbers that consist of a sign and magnitude, but also positive and negative zeros, positive and negative infinities, and special Not-a-Number values (hereafter abbreviated NaN). A NaN value is used to represent the result of certain invalid operations such as dividing zero by zero. NaN constants of both float and double type are predefined as Float.NaN and Double.NaN. The finite nonzero values of a floating-point type can all be expressed in the form s ⋅ m ⋅ 2, where: •s is +1 or -1, •m is a positive integer less than 2, N •e is an integer between Emin = -(2-2) and Emax = 2-1, inclusive, and K-1K-1 •N and K are parameters that depend on the type. Some values can be represented in this form in more than one way. For example, supposing that a value v of a floating-point type might be represented in this form",10.57,211.14,360,867,72,385.06,432,596.2,FALSE,FALSE
104,3,BODY,"Let the 'candidate' parameterization of G, Candidate(G), be the most specific parameterization of the generic type G that contains all the relevant parameterizations of G: Candidate(G) = lcp(Relevant(G)) where lcp(), the least containing parameterization, is: –lcp(S) = lcp(e1, ..., en) where ei (1 ≤ i ≤ n) in S –lcp(e1, ..., en) = lcp(lcp(e1, e2), e3, ..., en) –lcp(G<X1, ..., Xn>, G<Y1, ..., Yn>) = G<lcta(X1, Y1), ..., lcta(Xn, Yn)> –lcp(G<X1, ..., Xn>) = G<lcta(X1), ..., lcta(Xn)> and where lcta(), the least containing type argument, is: (assuming U and V are types) –lcta(U, V) = U if U = V, otherwise ? extends lub(U, V) –lcta(U, ? extends V) = ? extends lub(U, V) –lcta(U, ? super V) = ? super glb(U, V) –lcta(? extends U, ? extends V) = ? extends lub(U, V) –lcta(? extends U, ? super V) = ? –lcta(? super U, ? super V) = ? super glb(U, V) –lcta(U) = ? if U's upper bound is Object, otherwise ? extends lub(U,Object) and where glb() is as defined in §5.1.10. •Let lub(U1, ..., Uk) be: Best(W1) & ... & Best(Wr) where Wi (1 ≤ i ≤ r) are the elements of MEC, the minimal erased candidate set of U1, ..., Uk; and where, if any of these elements are generic, we use the candidate parameterization (so as to recover type arguments): Best(X) = Candidate(X) if X is generic; X otherwise. Strictly speaking, this lub() function only approximates a least upper bound. Formally, there may exist some other type T such that all of U1, ..., Uk are subtypes",10.57,483.14,360,1454,72,108.06,432,591.2,FALSE,FALSE
648,3,BODY,"–e is an exact method reference expression (§15.13.1), and one of the following is true: ›RT is void. ›RS <: RT. ›RS is a primitive type, RT is a reference type, and the compile-time declaration for the method reference has a return type which is a primitive type. ›RS is a reference type, RT is a primitive type, and the compile-time declaration for the method reference has a return type which is a reference type.",10.57,121.14,350,416,82,345.06,432,466.2,FALSE,FALSE
715,4,BODY,"15.25.3Reference Conditional Expressions A reference conditional expression is a poly expression if it appears in an assignment context or an invocation context (§5.2. §5.3). Otherwise, it is a standalone expression. Where a poly reference conditional expression appears in a context of a particular kind with target type T, its second and third operand expressions similarly appear in a context of the same kind with target type T. A poly reference conditional expression is compatible with a target type T if its second and third operand expressions are compatible with T. The type of a poly reference conditional expression is the same as its target type. The type of a standalone reference conditional expression is determined as follows: •If the second and third operands have the same type (which may be the null type), then that is the type of the conditional expression. •If the type of one of the second and third operands is the null type, and the type of the other operand is a reference type, then the type of the conditional expression is that reference type. •Otherwise, the second and third operands are of types S1 and S2 respectively. Let T1 be the type that results from applying boxing conversion to S1, and let T2 be the type that results from applying boxing conversion to S2. The type of the conditional expression is the result of applying capture conversion (§5.1.10) to lub(T1, T2). Because reference conditional expressions can be poly expressions, they can 'pass down' context to their operands. This allows lambda expressions and method reference expressions to appear as operands: return ... ? (x -> x) : (x -> -x);",10.57,379.02,360.01,1644,72,156.09,432.01,535.11,FALSE,FALSE
763,4,BODY,16.2.8assert Statements The following rules apply both to a statement assert e1 and to a statement assert e1 : e2 (§14.10): •V is [un]assigned before e1 iff V is [un]assigned before the assert statement. •V is definitely assigned after the assert statement iff V is definitely assigned before the assert statement. •V is definitely unassigned after the assert statement iff V is definitely unassigned before the assert statement and V is definitely unassigned after e1 when true. The following rule applies to a statement assert e1 : e2 : •V is [un]assigned before e2 iff V is [un]assigned after e1 when false.,10.57,161.11,360,610,72,392.09,432,553.2,FALSE,FALSE
51,3,BODY,DecimalNumeral: 0 NonZeroDigit [Digits] NonZeroDigit Underscores Digits NonZeroDigit: (one of) 1 2 3 4 5 6 7 8 9 Digits: Digit Digit [DigitsAndUnderscores] Digit Digit: 0 NonZeroDigit DigitsAndUnderscores: DigitOrUnderscore {DigitOrUnderscore} DigitOrUnderscore: Digit _ Underscores: _ {_},10.56,319.05,195.09,289,90,126.13,285.09,445.18,FALSE,TRUE
141,3,BODY,"•If p is a value of type double, then: –If p is not NaN, boxing conversion converts p into a reference r of class and type Double, such that r.doubleValue() evaluates to p –Otherwise, boxing conversion converts p into a reference r of class and type Double such that r.isNaN() evaluates to true",10.56,70.14,360,294,72,159.06,432,229.2,FALSE,FALSE
426,10,BODY,"10.8Class Objects for Arrays Every array has an associated Class object, shared with all other arrays with the same component type. Although an array type is not a class, the Class object of every array acts as if: •The direct superclass of every array type is Object. •Every array type implements the interfaces Cloneable and java.io.Serializable. Example 10.8-1. Class Object Of Array",10.56,141.25,360,386,72,372.56,432,513.81,FALSE,FALSE
777,5,BODY,"A thread returns normally from a wait if it returns without throwing an InterruptedException. Let thread t be the thread executing the wait method on object m, and let n be the number of lock actions by t on m that have not been matched by unlock actions. One of the following actions occurs: •If n is zero (i.e., thread t does not already possess the lock for target m), then an IllegalMonitorStateException is thrown. •If this is a timed wait and the nanosecs argument is not in the range of 0-999999 or the millisecs argument is negative, then an IllegalArgumentException is thrown. •If thread t is interrupted, then an InterruptedException is thrown and t's interruption status is set to false.",10.56,173.14,360,698,72,306.06,432,479.2,FALSE,FALSE
800,6,BODY,"17.5.4Write-Protected Fields Normally, a field that is final and static may not be modified. However, System.in, System.out, and System.err are static final fields that, for legacy reasons, must be allowed to be changed by the methods System.setIn, System.setOut, and System.setErr. We refer to these fields as being write- protected to distinguish them from ordinary final fields.",10.56,79.11,360,381,72,512.09,432,591.2,FALSE,FALSE
58,5,BODY,The largest and smallest positive literals of type float are as follows: •The largest positive finite float value is numerically equal to (2 - 2) ⋅ 2. The shortest decimal literal which rounds to this value is 3.4028235e38f. A hexadecimal literal for this value is 0x1.fffffeP+127f. •The smallest positive finite non-zero float value is numerically equal to 2. The shortest decimal literal which rounds to this value is 1.4e-45f. Two hexadecimal literals for this value are 0x0.000002P-126f and 0x1.0P-149f. The largest and smallest positive literals of type double are as follows:,10.55,152.14,360,581,72,401.06,432,553.2,FALSE,FALSE
69,3,BODY,"EscapeSequence: \ b   (backspace BS, Unicode \u0008) \ s   (space SP, Unicode \u0020) \ t   (horizontal tab HT, Unicode \u0009) \ n   (linefeed LF, Unicode \u000a) \ f   (form feed FF, Unicode \u000c) \ r   (carriage return CR, Unicode \u000d) \ LineTerminator  (line continuation, no Unicode representation) \ '   (double quote ', Unicode \u0022) \ '   (single quote ', Unicode \u0027) \ \   (backslash \, Unicode \u005c) OctalEscape  (octal value, Unicode \u0000 to \u00ff) OctalEscape: \ OctalDigit \ OctalDigit OctalDigit \ ZeroToThree OctalDigit OctalDigit OctalDigit: (one of) 0 1 2 3 4 5 6 7 ZeroToThree: (one of) 0 1 2 3",10.55,312.2,296.48,628,90,160.13,386.48,472.33,FALSE,FALSE
130,8,BODY,"5.1.3Narrowing Primitive Conversion 22 specific conversions on primitive types are called the narrowing primitive conversions: •short to byte or char •char to byte or short •int to byte, short, or char •long to byte, short, char, or int •float to byte, short, char, int, or long •double to byte, short, char, int, long, or float A narrowing primitive conversion may lose information about the overall magnitude of a numeric value, and may also lose precision and range. A narrowing conversion of a signed integer to an integral type T simply discards all but the n lowest order bits, where n is the number of bits used to represent type T. In addition to a possible loss of information about the magnitude of the numeric value, this may cause the sign of the resulting value to differ from the sign of the input value.",10.55,257.11,360.01,818,72,342.09,432.01,599.2,FALSE,FALSE
182,5,BODY,It is a compile-time error if any of the following conditions hold: •A pattern variable is both (i) introduced by a when true and (ii) introduced by c when true. •A pattern variable is both (i) introduced by a when true and (ii) introduced by c when false. •A pattern variable is both (i) introduced by a when false and (ii) introduced by b when true. •A pattern variable is both (i) introduced by a when false and (ii) introduced by b when false. •A pattern variable is both (i) introduced by b when true and (ii) introduced by c when true. •A pattern variable is both (i) introduced by b when false and (ii) introduced by c when false. These error cases are analogous to similar error cases for the && and || operators. They eliminate confusing cases where multiple declarations of the same pattern variable may occur across the operands of the ? : operator.,10.55,240.06,360,860,72,346.33,432,586.38,FALSE,FALSE
260,7,BODY,It is a compile-time error if a generic class is a direct or indirect subclass of Throwable (§11.1.1).,10.55,19.14,360,102,72,572.06,432,591.2,FALSE,FALSE
397,5,BODY,"9.6.4.9@FunctionalInterface The annotation interface FunctionalInterface is used to indicate that an interface is meant to be a functional interface (§9.8). It facilitates early detection of inappropriate method declarations appearing in or inherited by an interface that is meant to be functional. It is a compile-time error if an interface declaration is annotated with @FunctionalInterface but is not, in fact, a functional interface. Because some interfaces are functional incidentally, it is not necessary or desirable that all declarations of functional interfaces be annotated with @FunctionalInterface.",10.55,142.2,360,610,72,325.26,432,467.46,FALSE,FALSE
405,2,BODY,"•a class or interface declaration, but A is not applicable to type declarations or in type contexts; or an annotation interface declaration, but A is not applicable to annotation interface declarations or type declarations or in type contexts. •a method declaration (including an element of an annotation interface), but A is not applicable to method declarations or in type contexts. •a constructor declaration, but A is not applicable to constructor declarations or in type contexts. •a type parameter declaration of a generic class, interface, method, or constructor, but A is not applicable to type parameter declarations or in type contexts. •a field declaration (or an enum constant), but A is not applicable to field declarations or in type contexts. •a formal or exception parameter declaration, but A is not applicable to formal and exception parameter declarations or in type contexts. •a receiver parameter, but A is not applicable in type contexts. •a local variable declaration in either a statement or a pattern, but A is not applicable to local variable declarations or in type contexts. •a record component, but A is not applicable to record component declarations, field declarations, method declarations, or formal and exception parameter declarations, or in type contexts. Six of these eleven clauses mention '... or in type contexts' because they characterize the six syntactic locations, mentioned earlier in this section, where an annotation could plausibly apply to a declaration or a type. Furthermore, two of the eleven clauses - for class and interface declarations, and for type parameter declarations - mention '... or in type contexts' because it is sometimes convenient to be able to apply an annotation whose interface is meta-annotated with @Target(ElementType.TYPE_USE) (thus, applicable in type contexts) to the declaration of a class, interface, or type parameter. A type annotation is admissible if both of the following are true: •The simple name to which the annotation is closest is classified as a TypeName, not a PackageName. •If the simple name to which the annotation is closest is followed by '.' and another TypeName - that is, the annotation appears as @Foo T.U - then U denotes an inner class of T.",10.55,491.14,360.01,2245,72,76.06,432.01,567.2,FALSE,FALSE
423,6,BODY,"ArrayInitializer: { [VariableInitializerList] [,] } VariableInitializerList: VariableInitializer {, VariableInitializer} The following production from §8.3 is shown here for convenience:",10.55,77.99,244.46,186,90,406.13,334.46,484.12,FALSE,TRUE
600,7,BODY,"15.8.2Class Literals A class literal is an expression consisting of the name of a class, interface, array type, or primitive type, or the pseudo-type void, followed by a '.' and the token class.",10.55,53.11,360,194,72,543.09,432,596.2,FALSE,FALSE
685,3,BODY,CastExpression: ( PrimitiveType ) UnaryExpression ( ReferenceType {AdditionalBound} ) UnaryExpressionNotPlusMinus ( ReferenceType {AdditionalBound} ) LambdaExpression The following production from §4.4 is shown here for convenience:,10.55,66.99,321.08,232,90,184.13,411.08,251.12,FALSE,TRUE
174,3,BODY,"6.2Names and Identifiers A name is used to refer to an entity declared in a program. There are two forms of names: simple names and qualified names. A simple name is a single identifier. A qualified name consists of a name, a '.' token, and an identifier. In determining the meaning of a name (§6.5), the context in which the name appears is taken into account. The rules of §6.5 distinguish among contexts where a name must denote (refer to) a package (§6.5.3); a class, interface, or type parameter (§6.5.5); a variable or value in an expression (§6.5.6); or a method (§6.5.7). Packages, classes, interfaces, and type parameters have members which may be accessed by qualified names. As background for the discussion of qualified names and the determination of the meaning of names, see the descriptions of membership in §4.4, §4.5.2, §4.8, §4.9, §7.1, §8.2, §9.2, and §10.7.",10.54,203.56,360,877,72,343.56,432,547.12,FALSE,FALSE
490,3,BODY,"13.4.16abstract Methods Changing a method that is declared abstract to no longer be declared abstract does not break compatibility with pre-existing binaries. Changing a method that is not declared abstract to be declared abstract will break compatibility with pre-existing binaries that previously invoked the method, causing an AbstractMethodError.",10.54,85.11,360,350,72,226.09,432,311.2,FALSE,FALSE
67,7,BODY,"2.Incidental white space is removed, as if by execution of String.stripIndent",10.53,6.14,360,77,72,415.56,432,421.7,FALSE,FALSE
699,4,BODY,"The following rules apply when instanceof is the pattern match operator: •The type of the expression RelationalExpression must be a reference type or the null type, or a compile-time error occurs. •The Pattern must be applicable at the type of the expression RelationalExpression (§14.30.3), or a compile-time error occurs. •At run time, the result of the pattern match operator is determined as follows: –If the value of the RelationalExpression is the null reference, then the result is false. –If the value of the RelationalExpression is not the null reference, then the result is true if the value matches the Pattern (§14.30.2), and false otherwise. A side effect of a true result is that all the pattern variables declared in Pattern, if any, will be initialized.",10.53,185.06,360.01,769,72,369.06,432.01,554.12,FALSE,FALSE
76,2,BODY,"using certain values for s, m, and e, then if it happened that m were even and e were less than 2, one could halve m and increase e by 1 to produce a second representation for the same value v. A representation in this form is called normalized if m ≥ 2; otherwise the representation is said to be subnormal. If a value of a floating-point type cannot be represented in such a way that m ≥ 2, then the value is said to be a subnormal value, because its magnitude is below the magnitude of the smallest normalized value. The constraints on the parameters N and K (and on the derived parameters Emin and Emax) for float and double are summarized in Table 4.2.3-A. Table 4.2.3-A. Floating-point parameters Parameterfloatdouble N K",10.52,207.53,360.01,727,72,76.06,432.01,283.59,FALSE,FALSE
315,12,BODY,"If R1 is not a subtype of R2, then a compile-time unchecked warning occurs, unless suppressed by @SuppressWarnings (§9.6.4.5).",10.52,19.14,360,126,72,559.2,432,578.33,FALSE,FALSE
348,6,BODY,"Every declaration of a record component must include an Identifier, otherwise a compile-time error occurs. It is a compile-time error for a record declaration to have a record component with the name clone, finalize, getClass, hashCode, notify, notifyAll, toString, or wait.",10.52,64.14,360,274,72,504.06,432,568.2,FALSE,FALSE
564,8,BODY,is given by the following translation to a local variable declaration and a try-catch- finally statement:,10.52,19.14,360,105,72,418.2,432,437.33,FALSE,FALSE
140,4,BODY,"At run time, boxing conversion proceeds as follows: •If p is a value of type boolean, then boxing conversion converts p into a reference r of class and type Boolean, such that r.booleanValue() == p •If p is a value of type byte, then boxing conversion converts p into a reference r of class and type Byte, such that r.byteValue() == p •If p is a value of type char, then boxing conversion converts p into a reference r of class and type Character, such that r.charValue() == p •If p is a value of type short, then boxing conversion converts p into a reference r of class and type Short, such that r.shortValue() == p •If p is a value of type int, then boxing conversion converts p into a reference r of class and type Integer, such that r.intValue() == p •If p is a value of type long, then boxing conversion converts p into a reference r of class and type Long, such that r.longValue() == p",10.51,198.14,360,891,72,345.06,432,543.2,FALSE,FALSE
245,2,BODY,"ModuleDirective: requires {RequiresModifier} ModuleName ; exports PackageName [to ModuleName {, ModuleName}] ; opens PackageName [to ModuleName {, ModuleName}] ; uses TypeName ; provides TypeName with TypeName {, TypeName} ; RequiresModifier: (one of) transitive static",10.51,121.05,285.33,269,90,76.13,375.33,197.18,FALSE,TRUE
316,4,BODY,"More precisely, suppose that B is a class or interface, and A is a superclass or superinterface of B, and a method declaration m2 in B overrides or hides a method declaration m1 in A. Then: •If m2 has a throws clause that mentions any checked exception types, then m1 must have a throws clause, or a compile-time error occurs. •For every checked exception type listed in the throws clause of m2, that same exception class or one of its supertypes must occur in the erasure (§4.6) of the throws clause of m1; otherwise, a compile-time error occurs. •If the unerased throws clause of m1 does not contain a supertype of each exception type in the throws clause of m2 (adapted, if necessary, to the type parameters of m1), then a compile-time unchecked warning occurs, unless suppressed by @SuppressWarnings (§9.6.4.5). It is a compile-time error if a class or interface C has a member method m1 and there exists a method m2 declared in C or a superclass or superinterface of C, A, such that all of the following are true: •m1 and m2 have the same name. •m2 is accessible (§6.6) from C. •The signature of m1 is not a subsignature (§8.4.2) of the signature of m2 as a member of the supertype of C that names A. •The declared signature of m1 or some method m1 overrides (directly or indirectly) has the same erasure as the declared signature of m2 or some method m2 overrides (directly or indirectly). These restrictions are necessary because generics are implemented via erasure. The rule above implies that methods declared in the same class with the same name must have different erasures. It also implies that a class or interface cannot implement or extend two distinct parameterizations of the same generic interface.",10.51,379.06,360,1717,72,159.06,432,538.12,FALSE,FALSE
787,6,BODY,"•If thread T1 interrupts thread T2, the interrupt by T1 synchronizes-with any point where any other thread (including T2) determines that T2 has been interrupted (by having an InterruptedException thrown or by invoking Thread.interrupted or Thread.isInterrupted). The source of a synchronizes-with edge is called a release, and the destination is called an acquire.",10.51,77.14,360,365,72,204.06,432,281.2,FALSE,FALSE
824,2,BODY,"expression of a primitive type; then the method is not applicable and there is no need to proceed with inference. Otherwise, C includes, for all i (1 ≤ i ≤ k) where ei is pertinent to applicability, ‹ei → Fi θ›. –To test for applicability by loose invocation: If k ≠ n, the method is not applicable and there is no need to proceed with inference. Otherwise, C includes, for all i (1 ≤ i ≤ k) where ei is pertinent to applicability, ‹ei → Fi θ›. –To test for applicability by variable arity invocation: Let F'1, ..., F'k be the first k variable arity parameter types of m (§15.12.2.4). C includes, for all i (1 ≤ i ≤ k) where ei is pertinent to applicability, ‹ei → F'i θ›. •C is reduced (§18.2) and the resulting bounds are incorporated with B1 to produce a new bound set, B2. •Finally, the method m is applicable if B2 does not contain the bound false and resolution of all the inference variables in B2 succeeds (§18.4). Consider the following method invocation and assignment: List<Number> ln = Arrays.asList(1, 2.0);",10.51,292.05,360,1020,72,76.06,432,368.11,FALSE,FALSE
846,2,BODY,"ModuleDirective: requires {RequiresModifier} ModuleName ; exports PackageName [to ModuleName {, ModuleName}] ; opens PackageName [to ModuleName {, ModuleName}] ; uses TypeName ; provides TypeName with TypeName {, TypeName} ; RequiresModifier: (one of) transitive static",10.51,121.05,285.33,269,90,126.13,375.33,247.18,FALSE,TRUE
139,4,BODY,"›If T is a class type, then T must be Object (§4.3.2), or a ClassCastException is thrown. ›If T is an interface type, then R must be either the same interface as T or a subinterface of T, or a ClassCastException is thrown. ›If T is an array type, then a ClassCastException is thrown. –If R is a class representing an array type RC[], that is, an array of components of type RC: ›If T is a class type, then T must be Object (§4.3.2), or a ClassCastException is thrown. ›If T is an interface type, then T must be the type java.io.Serializable or Cloneable (the only interfaces implemented by arrays), or a ClassCastException is thrown. ›If T is an array type TC[], that is, an array of components of type TC, then a ClassCastException is thrown unless either TC and RC are the same primitive type, or TC and RC are reference types and are allowed by a recursive application of these run-time rules.",10.5,237.14,350.01,896,82,277.06,432.01,514.2,FALSE,FALSE
240,4,BODY,TopLevelClassOrInterfaceDeclaration: ClassDeclaration InterfaceDeclaration ;,10.5,43.75,174.15,76,90,519.13,264.15,562.88,FALSE,TRUE
326,2,BODY,StaticInitializer: static Block,10.5,19.05,72.12,31,90,76.13,162.12,95.18,FALSE,FALSE
502,2,BODY,LocalClassOrInterfaceDeclaration: ClassDeclaration NormalInterfaceDeclaration The following productions are shown here for convenience:,10.5,53.99,215.2,135,90,177.13,305.2,231.12,FALSE,TRUE
562,2,BODY,"Resource: LocalVariableDeclaration VariableAccess VariableAccess: ExpressionName FieldAccess The following productions from §4.3, §8.3, §8.4.1, and §14.4 are shown here for convenience:",10.5,113.99,324,185,90,76.13,414,190.12,FALSE,TRUE
778,7,BODY,"3.Thread t performs n lock actions on m. 4.If thread t was removed from m's wait set in step 2 due to an interrupt, then t's interruption status is set to false and the wait method throws InterruptedException.",10.5,51.14,350,209,82,542.06,432,593.2,FALSE,FALSE
146,2,BODY,"A value x of primitive type T is first converted to a reference value as if by giving it as an argument to an appropriate class instance creation expression (§15.9): •If T is boolean, then use new Boolean(x). •If T is char, then use new Character(x). •If T is byte, short, or int, then use new Integer(x). •If T is long, then use new Long(x). •If T is float, then use new Float(x). •If T is double, then use new Double(x). This reference value is then converted to type String by string conversion. Now only reference values need to be considered: •If the reference is null, it is converted to the string 'null' (four ASCII characters n, u, l, l). •Otherwise, the conversion is performed as if by an invocation of the toString method of the referenced object with no arguments; but if the result of invoking the toString method is null, then the string 'null' is used instead.",10.49,248.14,360.01,876,72,76.06,432.01,324.2,FALSE,FALSE
361,4,BODY,9.1.1.1abstract Interfaces Every interface is implicitly abstract.,10.49,26.2,171.82,66,72,305.13,243.82,331.33,FALSE,FALSE
367,3,BODY,9.3Field (Constant) Declarations ConstantDeclaration: {ConstantModifier} UnannType VariableDeclaratorList ; ConstantModifier: (one of) Annotation public static final See §8.3 for UnannType. The following productions from §4.3 and §8.3 are shown here for convenience:,10.49,144.56,342,266,72,337.56,414,482.12,FALSE,TRUE
391,4,BODY,9.6.4.3@Inherited The annotation interface java.lang.annotation.Inherited is used to indicate that annotations on a class C corresponding to a given annotation interface are inherited by subclasses of C.,10.48,52.2,360,203,72,503.13,432,555.33,FALSE,FALSE
397,3,BODY,9.6.4.8@Repeatable The annotation interface java.lang.annotation.Repeatable is used on the declaration of a repeatable annotation interface to indicate its containing annotation interface (§9.6.3).,10.48,52.2,360,197,72,210.13,432,262.33,FALSE,FALSE
311,3,BODY,"8.4.8.1Overriding (by Instance Methods) An instance method mC declared in or inherited by class C, overrides from C another method mA declared in class A, iff all of the following are true: •C is a subclass of A. •C does not inherit mA. •The signature of mC is a subsignature (§8.4.2) of the signature of mA as a member of the supertype of C that names A. •One of the following is true: –mA is public. –mA is protected. –mA is declared with package access in the same package as C, and either C declares mC or mA is a member of the direct superclass type of C. –mA is declared with package access and mC overrides mA from some superclass of C. –mA is declared with package access and mC overrides a method m' from C (m' distinct from mC and mA), such that m' overrides mA from some superclass of C. If mC is non-abstract and overrides from C an abstract method mA, then mC is said to implement mA from C. It is a compile-time error if the overridden method, mA, is a static method. In this respect, overriding of methods differs from hiding of fields (§8.3), for it is permissible for an instance variable to hide a static variable.",10.47,345.12,360.01,1132,72,192.13,432.01,537.25,FALSE,FALSE
830,4,BODY,"[α1:=T1, ..., αm:=Tm] is applied to every constraint.",10.47,7.17,222.05,53,100,262.06,322.05,269.23,FALSE,FALSE
141,6,BODY,"A boxing conversion may result in an OutOfMemoryError if a new instance of one of the wrapper classes (Boolean, Byte, Character, Short, Integer, Long, Float, or Double) needs to be allocated and insufficient storage is available.",10.46,32.14,360,229,72,475.06,432,507.2,FALSE,FALSE
231,2,BODY,"Each observable compilation unit may be associated with a module, as follows: •The host system may determine that an observable ordinary compilation unit is associated with a module chosen by the host system, except for (i) the ordinary compilation units in the predefined package java and its subpackages lang and io, which are all associated with the java.base module, and (ii) any ordinary compilation unit in an unnamed package, which is associated with a module as specified in §7.4.2. •The host system must determine that an observable modular compilation unit is associated with the module declared by the modular compilation unit. The observability of a compilation unit influences the observability of its package (§7.4.3), while the association of an observable compilation unit with a module influences the observability of that module (§7.7.6).",10.46,164.06,360,856,72,76.06,432,240.12,FALSE,FALSE
240,1,BODY,StaticImportOnDemandDeclaration: import static TypeName . * ;,10.46,19.05,162.54,61,90,76.13,252.54,95.18,FALSE,FALSE
567,5,BODY,is given by the following translation to a basic try-with-resources statement nested inside a try-catch or try-finally or try-catch-finally statement:,10.46,19.14,360,150,72,382.2,432,401.33,FALSE,FALSE
796,2,BODY,"•There exists a set O of actions such that B consists of a hang action plus all the external actions in O and for all k ≥ | O |, there exists an execution E of P with actions A, and there exists a set of actions O' such that: –Both O and O' are subsets of A that fulfill the requirements for sets of observable actions. –O ⊆ O' ⊆ A –| O' | ≥ k –O' - O contains no external actions Note that a behavior B does not describe the order in which the external actions in B are observed, but other (internal) constraints on how the external actions are generated and performed may impose such constraints.",10.45,163.06,360,598,72,76.06,432,239.12,FALSE,FALSE
90,4,BODY,"The wildcard ? extends Object is equivalent to the unbounded wildcard ?. Two type arguments are provably distinct if one of the following is true: •Neither argument is a type variable or wildcard, and the two arguments are not the same type. •One type argument is a type variable or wildcard, with a bound (if a type variable) or an upper bound (if a wildcard, using capture conversion (§5.1.10), if necessary) of S; and the other type argument T is not a type variable or wildcard; and neither |S| <: |T| nor |T| <: |S| (§4.8, §4.10). •Each type argument is a type variable or wildcard, with upper bounds (from capture conversion, if necessary) of S and T; and neither |S| <: |T| nor |T| <: |S|. A type argument T1 is said to contain another type argument T2, written T2 <= T1, if the set of types denoted by T2 is provably a subset of the set of types denoted by T1 under the reflexive and transitive closure of the following rules (where <: denotes subtyping (§4.10)): •? extends T <= ? extends S if T <: S •? extends T <= ? •? super T <= ? super S if S <: T •? super T <= ? •? super T <= ? extends Object •T <= T •T <= ? extends T •T <= ? super T",10.44,357.14,360,1150,72,144.06,432,501.2,FALSE,FALSE
331,5,BODY,ExplicitConstructorInvocation: [TypeArguments] this ( [ArgumentList] ) ; [TypeArguments] super ( [ArgumentList] ) ; ExpressionName . [TypeArguments] super ( [ArgumentList] ) ; Primary . [TypeArguments] super ( [ArgumentList] ) ; The following productions from §4.5.1 and §15.12 are shown here for convenience:,10.44,79.99,301.94,309,90,266.26,391.94,346.25,FALSE,TRUE
389,7,BODY,"3.Class declarations (including enum declarations and record declarations) and interface declarations (including annotation interface declarations) (§8.1.1, §8.5, §8.9, §8.10, §9.1.1, §9.5, §9.6) Corresponds to java.lang.annotation.ElementType.TYPE Additionally, annotation interface declarations correspond to java.lang.annotation.ElementType.ANNOTATION_TYPE",10.43,81.75,360,359,72,519.2,432,600.94,FALSE,FALSE
855,2,BODY,AnnotationInterfaceElementModifier: (one of) Annotation public abstract DefaultValue: default ElementValue,10.43,82.05,166.82,106,90,389.13,256.82,471.18,FALSE,TRUE
391,3,BODY,"If m has an element whose value is java.lang.annotation.RetentionPolicy.RUNTIME, the reflection libraries of the Java SE Platform must make a available at run time. If A does not have a (meta-)annotation that corresponds to java.lang.annotation.Retention, then a Java compiler must treat A as if it has a (meta-)annotation that corresponds to java.lang.annotation.Retention with an element whose value is java.lang.annotation.RetentionPolicy.CLASS.",10.41,90.14,360,448,72,392.06,432,482.2,FALSE,FALSE
681,3,BODY,"Expressions with unary operators group right-to-left, so that -~x means the same as -(~x).",10.41,19.14,360,90,72,239.06,432,258.2,FALSE,FALSE
59,8,BODY,BooleanLiteral: (one of) true false,10.4,32.05,70.28,35,90,561.13,160.28,593.18,FALSE,TRUE
386,2,BODY,"6.If the declaration of A has a (meta-)annotation that corresponds to java.lang.annotation.Inherited, then the declaration of AC must have a (meta)-annotation that corresponds to java.lang.annotation.Inherited.",10.4,32.14,360,210,72,76.06,432,108.2,FALSE,FALSE
767,4,BODY,"16.2.13break, yield, continue, return, and throw Statements •By convention, we say that V is [un]assigned after any break, yield, continue, return, or throw statement (§14.15, §14.21, §14.16, §14.17, §14.18).",10.4,40.11,360,208,72,405.22,432,445.33,FALSE,FALSE
835,3,BODY,"–Let U1, ..., Uk be the formal parameter types of MTS, and let V1, ..., Vk be the formal parameter types of MTT. Then, for all j (1 ≤ j ≤ k): ›If Uj mentions one of A1, ..., An, and Vj is not a proper type, false. ›Otherwise, ‹Vj θ' <: Uj›, and, where U1', ..., Uk' are the formal parameter types of MTS', and A1', ..., An' are the type parameters of MTS', ‹Vj[B1:=A1', ..., Bn:=An'] = Uj'›",10.4,83.14,350,390,82,102.06,432,185.2,FALSE,FALSE
196,2,BODY,"TypeName: TypeIdentifier PackageOrTypeName . TypeIdentifier PackageOrTypeName: Identifier PackageOrTypeName . Identifier ExpressionName: Identifier AmbiguousName . Identifier MethodName: UnqualifiedMethodIdentifier AmbiguousName: Identifier AmbiguousName . Identifier The use of context helps to minimize name conflicts between entities of different kinds. Such conflicts will be rare if the naming conventions described in §6.1 are followed. Nevertheless, conflicts may arise unintentionally as types developed by different programmers or different organizations evolve. For example, types, methods, and fields may have the same name. It is always possible to distinguish between a method and a field with the same name, since the context of a use always tells whether a method is intended.",10.39,290.99,324.01,791,90,76.13,414.01,367.12,FALSE,TRUE
385,5,BODY,"5.If the declaration of A has a (meta-)annotation that corresponds to java.lang.annotation.Documented, then the declaration of AC must have a (meta-)annotation that corresponds to java.lang.annotation.Documented.",10.39,32.14,360,212,72,546.06,432,578.2,FALSE,FALSE
808,2,BODY,"•Otherwise, the expression is a poly expression (§15.2). The result depends on the form of the expression: –If the expression is a parenthesized expression of the form ( Expression' ), the constraint reduces to ‹Expression' → T›. –If the expression is a class instance creation expression or a method invocation expression, the constraint reduces to the bound set B3 which would be used to determine the expression's compatibility with target type T, as defined in §18.5.2.1. (For a class instance creation expression, the corresponding 'method' used for inference is defined in §15.9.3.) This bound set may contain new inference variables, as well as dependencies between these new variables and the inference variables in T. –If the expression is a conditional expression of the form e1 ? e2 : e3, the constraint reduces to two constraint formulas, ‹e2 → T› and ‹e3 → T›. –If the expression is a lambda expression or a method reference expression, the result is specified below. –If the expression is a switch expression with result expressions e1, ..., en, the constraint reduces to n constraint formulas, ‹e1 → T›, ..., ‹en → T›. By treating nested generic method invocations as poly expressions, we improve the behavior of inference for nested invocations. For example, the following is illegal in Java SE 7 but legal in Java SE 8: ProcessBuilder b = new ProcessBuilder(Collections.emptyList()); // ProcessBuilder's constructor expects a List<String>",10.39,323.05,360,1455,72,76.06,432,399.11,FALSE,FALSE
834,2,BODY,"•Second, for all i (1 ≤ i ≤ k), a set of constraint formulas or bounds is generated. If Ti is a proper type, the result is true if Si is more specific than Ti for ei (§15.12.2.5), and false otherwise. (Note that Si is always a proper type.) Otherwise, if Si and Ti are not both functional interface types, the constraint formula ‹Si <: Ti› is generated. Otherwise, if the interface of Si is a superinterface or a subinterface of the interface of Ti (or, where Si or Ti is an intersection type, some interface of Si is a superinterface or a subinterface of some interface of Ti), the constraint formula ‹Si <: Ti› is generated. Otherwise, let MTS be the function type of the capture of Si, let MTS' be the function type of Si (without capture), and let MTT be the function type of Ti. If MTS and MTT have a different number of formal parameters or type parameters, or if MTS and MTS' do not have the same type parameters (§8.4.4), the result is false. Otherwise, the following constraint formulas or bounds are generated from the type parameters, formal parameter types, and return types of MTS and MTT: –Let A1, ..., An be the type parameters of MTS, and let B1, ..., Bn be the type parameters of MTT. Let θ' be the substitution [B1:=A1, ..., Bn:=An]. Then, for all j (1 ≤ j ≤ n): ›If the bound of Aj mentions one of A1, ..., An, and the bound of Bj is a not proper type, false. ›Otherwise, where X is the bound of Aj and Y is the bound of Bj, ‹X = Y θ'›. If the bound Aj mentions one of A1, ..., An, and the bound of Bj is not a proper type, then producing an equality constraint would raise the possibility of an inference variable being bounded by an out-of-scope type variable. Since instantiating an inference variable with an out-of-scope type variable is nonsensical, we prefer to avoid the situation by giving up immediately whenever the possibility arises. This",10.39,376.06,360,1870,72,76.06,432,452.12,FALSE,FALSE
312,2,BODY,•mI is not static. •C does not inherit mI. •The signature of mC is a subsignature (§8.4.2) of the signature of mI as a member of the supertype of C that names I. •mI is public.,10.38,76.14,360,176,72,76.06,432,152.2,FALSE,FALSE
529,5,BODY,"•A case null, default label applies to every value.",10.37,6.14,238.45,51,90,563.06,328.45,569.2,FALSE,FALSE
544,3,BODY,"for (I #i = Expression.iterator(); #i.hasNext(); ) { {VariableModifier} T VarDeclId = (TargetType) #i.next(); Statement } where: –If the type of Expression is a subtype of Iterable<X> for some type argument X, then I is the type java.util.Iterator<X>. Otherwise, I is the raw type java.util.Iterator. –#i is an automatically generated identifier that is distinct from any other identifiers (automatically generated or otherwise) that are in scope (§6.3) at the point where the enhanced for statement occurs. –{VariableModifier} is as given in the header of the enhanced for statement. –T is the type of the local variable as determined above. –If T is a reference type, then TargetType is T. Otherwise, TargetType is the upper bound of the capture conversion (§5.1.10) of the type argument of I, or Object if I is raw. –If the declaration of a local variable in the header includes an identifier then VarDeclId is defined to be Identifier as given in the header; otherwise VarDeclId is defined to be _ (underscore).",10.37,276.08,350,1015,82,109.12,432,385.2,FALSE,FALSE
657,2,BODY,"(e1, ..., en-1, en, ..., ek) is evaluated as if it were written as (e1, ..., en-1, new |T[]| { en, ..., ek }), where |T[]| denotes the erasure (§4.6) of T[].",10.37,19.14,360,157,72,76.06,432,95.2,FALSE,FALSE
783,6,BODY,"The memory model determines what values can be read at every point in the program. The actions of each thread in isolation must behave as governed by the semantics of that thread, with the exception that the values seen by each read are determined by the memory model. When we refer to this, we say that the program obeys intra-thread semantics. Intra-thread semantics are the semantics for single- threaded programs, and allow the complete prediction of the behavior of a thread based on the values seen by read actions within the thread. To determine if the actions of thread t in an execution are legal, we simply evaluate the implementation of thread t as it would be performed in a single-threaded context, as defined in the rest of this specification. Each time the evaluation of thread t generates an inter-thread action, it must match the inter-thread action a of t that comes next in program order. If a is a read, then further evaluation of t uses the value seen by a as determined by the memory model. This section provides the specification of the Java programming language memory model except for issues dealing with final fields, which are described in §17.5. The memory model specified herein is not fundamentally based in the object-oriented nature of the Java programming language. For conciseness and simplicity in our examples, we often exhibit code fragments without class or method definitions, or explicit dereferencing. Most examples consist of two or more threads containing statements with access to local variables, shared global variables, or instance fields of an object. We typically use variables names such as r1 or r2 to indicate variables local to a method or thread. Such variables are not accessible by other threads.",10.36,282.06,360.01,1752,72,313.56,432.01,595.62,FALSE,FALSE
767,7,BODY,16.2.14synchronized Statements •V is [un]assigned after synchronized (e) S (§14.19) iff V is [un]assigned after S.,10.35,27.11,360,114,72,568.22,432,595.33,FALSE,FALSE
353,4,BODY,"•A method public final String toString() that returns a string derived from the name of the record class and the names and string representations of every record component of R. The string representation of a record component c of an instance a of a record class is as follows: –If the type of the record component c is a reference type, then the string representation is determined as if by invoking the toString method on the value of the component field c of a. –If the type of the record component c is a primitive type T, then the string representation is determined as if by subjecting the value of the component field c of a to boxing conversion (§5.1.7) and then invoking the method toString method of the wrapper class corresponding to T on the resulting object. Note that equality, hash code values, and string representations are determined by looking at the values of component fields directly, rather than by invoking accessor methods. Consider a record class R that has components c1, ..., cn, and an implicitly declared accessor method for every component, and an implicitly declared equals method. If an instance r1 of R is copied in the following way:",10.34,254.06,360.01,1168,72,343.06,432.01,597.12,FALSE,FALSE
390,14,BODY,"Corresponds to java.lang.annotation.ElementType.RECORD_COMPONENT There are 17 type contexts (§4.11), all represented by the enum constant TYPE_USE of java.lang.annotation.ElementType. It is a compile-time error if the same enum constant appears more than once in the value element of an annotation of type java.lang.annotation.Target. If an annotation of type java.lang.annotation.Target is not present on the declaration of an annotation interface A, then A is applicable in all declaration contexts and in no type contexts.",10.34,115.14,360,525,72,362.06,432,477.2,FALSE,FALSE
70,7,BODY,"Separator: (one of) (   )   {   }   [   ]   ;   ,   .   ...   @   ::",10.33,30.24,269.2,68,90,358.13,359.2,388.37,FALSE,TRUE
306,4,BODY,Result: UnannType void,10.33,30.75,61.33,22,90,508.13,151.33,538.88,FALSE,TRUE
309,3,BODY,MethodBody: Block ;,10.33,30.75,59.87,19,90,134.13,149.87,164.88,FALSE,TRUE
357,3,BODY,"CompactConstructorDeclaration: {ConstructorModifier} SimpleTypeName ConstructorBody The following productions from §8.8, §8.8.3, and §8.8.7 are shown here for convenience:",10.33,40.99,322.19,171,90,159.26,412.19,200.25,FALSE,TRUE
604,4,BODY,TypeArgumentsOrDiamond: TypeArguments <>,10.33,30.75,125.87,40,90,176.13,215.87,206.88,FALSE,TRUE
863,4,BODY,TypeArgumentsOrDiamond: TypeArguments <>,10.33,30.75,125.87,40,90,543.13,215.87,573.88,FALSE,TRUE
40,4,BODY,"Lines are terminated by the ASCII characters CR, or LF, or CR LF. The two characters CR immediately followed by LF are counted as one line terminator, not two. A line terminator specifies the termination of the // form of a comment (§3.7). The lines defined by line terminators may determine the line numbers produced by a Java compiler.",10.32,83.06,360.01,337,72,245.59,432.01,328.65,FALSE,FALSE
380,4,BODY,AnnotationInterfaceElementModifier: (one of) Annotation public abstract,10.32,43.75,166.82,71,90,336.13,256.82,379.88,FALSE,TRUE
56,2,BODY,"The largest positive hexadecimal, octal, and binary literals of type long - each of which represents the decimal value 9223372036854775807L (2-1) - are respectively: •0x7fff_ffff_ffff_ffffL, •07_7777_7777_7777_7777_7777L, and • The most negative hexadecimal, octal, and binary literals of type long - each of which represents the decimal value -9223372036854775808L (-2) - are respectively: •0x8000_0000_0000_0000L, and •010_0000_0000_0000_0000_0000L, and • The following hexadecimal, octal, and binary literals represent the decimal value -1L: •0xffff_ffff_ffff_ffffL, •017_7777_7777_7777_7777_7777L, and • It is a compile-time error if a hexadecimal, octal, or binary long literal does not fit in 64 bits.",10.31,312.14,360,707,72,76.06,432,388.2,FALSE,FALSE
260,2,BODY,"TypeParameterList: TypeParameter {, TypeParameter} The following productions from §4.4 are shown here for convenience:",10.31,40.99,252.95,118,90,76.13,342.95,117.12,FALSE,TRUE
340,5,BODY,EnumBodyDeclarations: ; {ClassBodyDeclaration} The following productions from §8.1.7 are shown here for convenience:,10.31,40.99,259.7,116,90,288.13,349.7,329.12,FALSE,TRUE
92,5,BODY,"4.5.2Members and Constructors of Parameterized Types Let C be a generic class or interface with type parameters A1,...,An, and let C<T1,...,Tn> be a parameterization of C where, for 1 ≤ i ≤ n, Ti is a type (rather than a wildcard). Then: •Let m be a member or constructor declaration in C, whose type as declared is T (§8.2, §8.8.6). The type of m in C<T1,...,Tn> is T[A1:=T1,...,An:=Tn]. •Let m be a member or constructor declaration in D, where D is a class extended by C or an interface implemented by C. Let D<U1,...,Uk> be the supertype (§4.10.2) of C<T1,...,Tn> that corresponds to D. The type of m in C<T1,...,Tn> is the type of m in D<U1,...,Uk>. If any of the type arguments in the parameterization of C are wildcards, then: •The types of the fields, methods, and constructors in C<T1,...,Tn> are the types of the fields, methods, and constructors in the capture conversion of C<T1,...,Tn> (§5.1.10). •Let D be a (possibly generic) class or interface declaration in C. Then the type of D in C<T1,...,Tn> is D where, if D is generic, all type arguments are unbounded wildcards. This is of no consequence, as it is impossible to access a member of a parameterized type without performing capture conversion, and it is impossible to use a wildcard after the keyword new in a class instance creation expression (§15.9). The sole exception to the previous paragraph is when a nested parameterized type is used as the expression in an instanceof operator (§15.20.2), where capture conversion is not applied.",10.3,361.03,360,1510,72,199.09,432,560.12,FALSE,FALSE
768,2,BODY,•V is [un]assigned before e iff V is [un]assigned before the statement synchronized (e) S. •V is [un]assigned before S iff V is [un]assigned after e.,10.29,38.14,360,149,72,76.06,432,114.2,FALSE,FALSE
44,5,BODY,A 'Java letter' is a character for which the method Character.isJavaIdentifierStart(int) returns true. A 'Java letter-or-digit' is a character for which the method Character.isJavaIdentifierPart(int) returns true.,10.28,51.14,360,213,72,360.59,432,411.73,FALSE,FALSE
67,10,BODY,String.translateEscapes on the characters resulting from step 2.,10.28,6.14,298.33,64,90,460.56,388.33,466.7,FALSE,FALSE
390,3,BODY,"§9.4, §9.6.1) Corresponds to java.lang.annotation.ElementType.METHOD",10.28,25.14,280.26,68,90,89.06,370.26,114.2,FALSE,FALSE
391,2,BODY,"If an annotation a corresponds to an annotation interface A, and A has a (meta-)annotation m that corresponds to java.lang.annotation.Retention, then: •If m has an element whose value is java.lang.annotation.RetentionPolicy.SOURCE, then a Java compiler must ensure that a is not present in the binary representation of the class or interface in which a appears. •If m has an element whose value is java.lang.annotation.RetentionPolicy.CLASS or java.lang.annotation.RetentionPolicy.RUNTIME, then a Java compiler must ensure that a is represented in the binary representation of the class or interface in which a appears, unless a annotates a local variable declaration or a annotates a formal parameter declaration of a lambda expression. An annotation on the declaration of a local variable, or on the declaration of a formal parameter of a lambda expression, is never retained in the binary representation. In contrast, an annotation on the type of a local variable, or on the type of a formal parameter of a lambda expression, is retained in the binary representation if the annotation interface specifies a suitable retention policy. Note that it is not illegal for an annotation interface to be meta-annotated with @Target(java.lang.annotation.ElementType.LOCAL_VARIABLE) and @Retention(java.lang.annotation.RetentionPolicy.CLASS) or @Retention(java.lang.annotation.RetentionPolicy.RUNTIME).",10.28,297.06,360,1395,72,76.06,432,373.12,FALSE,FALSE
533,3,BODY,"If execution of any statement or expression in the switch block completes abruptly, it is handled as follows: •If execution of a statement completes abruptly because of a break with no label, then no further action is taken and the switch statement completes normally. Abrupt completion because of a break with a label is handled by the general rule for labeled statements (§14.7).",10.28,83.06,360.01,381,72,262.06,432.01,345.12,FALSE,FALSE
777,3,BODY,"17.2.1Wait Wait actions occur upon invocation of wait(), or the timed forms wait(long millisecs) and wait(long millisecs, int nanosecs).",10.28,40.11,360,136,72,205.09,432,245.2,FALSE,FALSE
838,5,BODY,"Y1, ..., Yp (p ≥ 0) be any fresh type variables introduced by resolution. The type of the record pattern is the upward projection of R<A1, ..., An> with respect to Y1, ..., Yp (§4.10.5). Example 18.5.5-1. Record Pattern Type Inference",10.28,60.24,342,234,90,249.06,432,309.3,FALSE,FALSE
55,3,BODY,"The largest decimal literal of type int is 2147483648 (2). All decimal literals from 0 to 2147483647 may appear anywhere an int literal may appear. The decimal literal 2147483648 may appear only as the operand of the unary minus operator - (§15.15.4). It is a compile-time error if the decimal literal 2147483648 appears anywhere other than as the operand of the unary minus operator; or if a decimal literal of type int is larger than 2147483648 (2). The largest positive hexadecimal, octal, and binary literals of type int - each of which represents the decimal value 2147483647 (2-1) - are respectively: •0x7fff_ffff, •0177_7777_7777, and •0b0111_1111_1111_1111_1111_1111_1111_1111 The most negative hexadecimal, octal, and binary literals of type int - each of which represents the decimal value -2147483648 (-2) - are respectively: •0x8000_0000, •0200_0000_0000, and •0b1000_0000_0000_0000_0000_0000_0000_0000 The following hexadecimal, octal, and binary literals represent the decimal value -1: •0xffff_ffff, •0377_7777_7777, and •0b1111_1111_1111_1111_1111_1111_1111_1111 It is a compile-time error if a hexadecimal, octal, or binary int literal does not fit in 32 bits. The largest decimal literal of type long is 9223372036854775808L (2). All decimal literals from 0L to 9223372036854775807L may appear anywhere a long literal may appear. The decimal literal 9223372036854775808L may appear only as the operand of the unary minus operator - (§15.15.4). It is a compile-time error if the decimal literal 9223372036854775808L appears anywhere other than as the operand of the unary minus operator; or if a decimal literal of type long is larger than 9223372036854775808L (2).",10.27,504.14,360,1682,72,76.06,432,580.2,FALSE,FALSE
390,10,BODY,"8.Formal and exception parameter declarations (§8.4.1, §9.4, §14.20) Corresponds to java.lang.annotation.ElementType.PARAMETER",10.26,25.14,314.64,126,72,254.06,386.64,279.2,FALSE,FALSE
295,2,BODY,ReceiverParameter: {Annotation} UnannType [Identifier .] this The following production from §4.3 is shown here for convenience:,10.25,40.99,244.46,127,90,76.13,334.46,117.12,FALSE,TRUE
742,3,BODY,"15.28.1The Switch Block of a switch Expression In addition to the general rules for switch blocks (§14.11.1), there are further rules for switch blocks in switch expressions. It is a compile-time error if the switch block of a switch expression consists of switch rules, but one or more switch rule blocks can complete normally (§14.22). It is a compile-time error if the switch block of a switch expression consists of switch labeled statement groups, but the last statement in the switch block can complete normally, or the switch block has one or more switch labels after the last switch labeled statement group. It is a compile-time error if a switch expression is not exhaustive (§14.11.1.1). switch expressions differ from switch statements in terms of which expressions may appear to the right of an arrow (->) in the switch block, that is, which expressions may be used as switch rule expressions. In a switch expression, any expression may be used as a switch rule expression, but in a switch statement, only a statement expression may be used (§14.11.1).",10.25,211.03,360.01,1064,72,232.09,432.01,443.12,FALSE,FALSE
255,7,BODY,ClassModifier: (one of) Annotation public protected private abstract static final sealed non-sealed strictfp,10.24,45.05,255.95,108,90,536.13,345.95,581.18,FALSE,FALSE
300,7,BODY,MethodModifier: (one of) Annotation public protected private abstract static final synchronized native strictfp,10.24,45.05,266.75,111,90,265.13,356.75,310.18,FALSE,FALSE
379,5,BODY,The direct superinterface type of an annotation interface is always java.lang.annotation.Annotation (§9.1.3).,10.24,19.14,360,109,72,313.06,432,332.2,FALSE,FALSE
390,7,BODY,"constructors (§8.1.2, §9.1.2, §8.4.4, §8.8.4) Corresponds to java.lang.annotation.ElementType.TYPE_PARAMETER",10.24,25.14,323.46,108,90,178.06,413.46,203.2,FALSE,FALSE
390,12,BODY,§14.20.3) and in patterns (§14.30.1) Corresponds to java.lang.annotation.ElementType.LOCAL_VARIABLE,10.24,25.14,323.46,99,90,305.06,413.46,330.2,FALSE,FALSE
761,4,BODY,"•V is [un]assigned after an empty block iff V is [un]assigned before the empty block. •V is [un]assigned after a non-empty block iff V is [un]assigned after the last statement in the block. •V is [un]assigned before the first statement of the block iff V is [un]assigned before the block. •V is [un]assigned before any other statement S of the block iff V is [un]assigned after the statement immediately preceding S in the block. We say that V is definitely unassigned everywhere in a block B iff: •V is definitely unassigned before B. •V is definitely assigned after e in every assignment expression V = e, V += e, V -= e, V *= e, V /= e, V %= e, V <<= e, V >>= e, V >>>= e, V &= e, V |= e, or V ^= e that occurs in B. •V is definitely assigned before every expression ++V, --V, V++, or V-- that occurs in B. These conditions are counterintuitive and require some explanation. Consider a simple assignment V = e. If V is definitely assigned after e, then either: •The assignment occurs in dead code, and V is vacuously definitely assigned. In this case, the assignment will not actually take place, and we can assume that V is not being assigned by the assignment expression. Or: •V was already assigned by an earlier expression prior to e. In this case the current assignment will cause a compile-time error.",10.24,330.06,360,1310,72,273.06,432,603.12,FALSE,FALSE
201,2,BODY,"•If the name to the left of the '.' is reclassified as a TypeName, then: –If the Identifier is the name of a method or field of the type denoted by TypeName, then this AmbiguousName is reclassified as an ExpressionName. –Otherwise, if the Identifier is a valid TypeIdentifier and is the name of a member type of the type denoted by TypeName, then this AmbiguousName is reclassified as a TypeName. –Otherwise, a compile-time error occurs. •If the name to the left of the '.' is reclassified as an ExpressionName, then this AmbiguousName is reclassified as an ExpressionName. A later step determines whether or not a member with the name Identifier actually exists. The requirement that a potential type name be 'a valid TypeIdentifier' prevents treating var and yield as a type name. It is usually redundant, because the rules for declarations already prevent the introduction of types named var and yield. However, in some cases, a compiler may find a binary class named var or yield, and we want to be clear that such classes can never be named. The simplest solution is to consistently check for a valid TypeIdentifier.",10.23,219.06,360,1121,72,76.06,432,295.12,FALSE,FALSE
284,4,BODY,FieldModifier: (one of) Annotation public protected private static final transient volatile,10.23,45.05,185.94,91,90,159.13,275.94,204.18,FALSE,FALSE
360,7,BODY,InterfaceModifier: (one of) Annotation public protected private abstract static sealed non-sealed strictfp,10.23,45.05,226.2,106,90,549.13,316.2,594.18,FALSE,FALSE
175,2,BODY,"•In declarations (§6.1), where an identifier may occur to specify the name by which the declared entity will be known. •As labels in labeled statements (§14.7) and in break and continue statements (§14.15, §14.16) that refer to statement labels. The identifiers used in labeled statements and their associated break and continue statements are completely separate from those used in declarations. •In field access expressions (§15.11), where an identifier occurs after a '.' token to indicate a member of the object denoted by the expression before the '.' token, or the object denoted by the super or TypeName.super before the '.' token. •In some method invocation expressions (§15.12), wherever an identifier occurs after a '.' token and before a '(' token to indicate a method to be invoked for the object denoted by the expression before the '.' token, or the type denoted by the TypeName before the '.' token, or the object denoted by the super or TypeName.super before the '.' token. •In some method reference expressions (§15.13), wherever an identifier occurs after a '::' token to indicate a method of the object denoted by the expression before the '::' token, or the type denoted by the TypeName before the '::' token, or the object denoted by the super or TypeName.super before the '::' token. •In qualified class instance creation expressions (§15.9), where an identifier occurs to the right of the new token to indicate a type that is a member of the compile-time type of the expression preceding the new token. •In element-value pairs of annotations (§9.7.1), to denote an element of the corresponding annotation interface. In this program: class Test { public static void main(String[] args) { Class c = System.out.getClass(); System.out.println(c.toString().length() + args[0].length() + args.length); } }",10.21,450.04,360,1822,72,76.06,432,526.11,FALSE,FALSE
372,4,BODY,"9.4.1Inheritance and Overriding An interface I inherits from its direct superinterface types all abstract and default methods m for which all of the following are true: •m is a member of a direct superinterface type of I, J. •No method declared in I has a signature that is a subsignature (§8.4.2) of the signature of m as a member of J. •There exists no method m' that is a member of a direct superinterface of I, J' (m distinct from m', J distinct from J'), such that m' overrides from the interface of J' the declaration of the method m (§9.4.1.1). Note that methods are overridden on a signature-by-signature basis. If, for example, an interface declares two public methods with the same name (§9.4.2), and a subinterface overrides one of them, the subinterface still inherits the other method. The third clause above prevents a subinterface from re-inheriting a method that has already been overridden by another of its superinterfaces. For example, in this program:",10.21,210.03,360,971,72,378.09,432,588.12,FALSE,FALSE
142,2,BODY,"•From type Boolean to type boolean •From type Byte to type byte •From type Short to type short •From type Character to type char •From type Integer to type int •From type Long to type long •From type Float to type float •From type Double to type double At run time, unboxing conversion proceeds as follows: •If r is a reference of type Boolean, then unboxing conversion converts r into r.booleanValue() •If r is a reference of type Byte, then unboxing conversion converts r into r.byteValue() •If r is a reference of type Character, then unboxing conversion converts r into r.charValue() •If r is a reference of type Short, then unboxing conversion converts r into r.shortValue() •If r is a reference of type Integer, then unboxing conversion converts r into r.intValue() •If r is a reference of type Long, then unboxing conversion converts r into r.longValue() •If r is a reference of type Float, unboxing conversion converts r into r.floatValue() •If r is a reference of type Double, then unboxing conversion converts r into r.doubleValue() •If r is null, unboxing conversion throws a NullPointerException A type is said to be convertible to a numeric type if it is a numeric type (§4.2), or it is a reference type that may be converted to a numeric type by unboxing conversion. A type is said to be convertible to an integral type if it is an integral type, or it is a reference type that may be converted to an integral type by unboxing conversion.",10.2,497.14,360.01,1452,72,76.06,432.01,573.2,FALSE,FALSE
395,4,BODY,"No deprecation warning or removal warning is produced when: •a local variable or formal parameter is used (referenced by name), even if the declaration of the local variable or formal parameter is annotated with @Deprecated. •the name of a package is used (referenced by a qualified type name, or an import declaration, or an exports or opens directive), even if the declaration of the package is annotated with @Deprecated. •the name of a module is used by a qualified exports or opens directive, even if the declaration of the friend module is annotated with @Deprecated. A module declaration that exports or opens a package is usually controlled by the same programmer or team that controls the package's declaration. As such, there is little benefit in warning that the package declaration is annotated with @Deprecated when the package is",10.2,170.06,360,843,72,432.06,432,602.12,FALSE,FALSE
444,2,BODY,line arguments to be used as strings to be provided as the argument to the method main.,10.2,19.14,360,87,72,76.06,432,95.2,FALSE,FALSE
307,2,BODY,"Return types may vary among methods that override each other if the return types are reference types. The notion of return-type-substitutability supports covariant returns, that is, the specialization of the return type to a subtype. A method declaration d1 with return type R1 is return-type-substitutable for another method d2 with return type R2 iff any of the following is true: •If R1 is void then R2 is void. •If R1 is a primitive type then R2 is identical to R1. •If R1 is a reference type then one of the following is true: –R1, adapted to the type parameters of d2 (§8.4.4), is a subtype of R2. –R1 can be converted to a subtype of R2 by unchecked conversion (§5.1.9). –d1 does not have the same signature as d2 (§8.4.2), and R1 = |R2|. An unchecked conversion is allowed in the definition, despite being unsound, as a special allowance to allow smooth migration from non-generic to generic code. If an unchecked conversion is used to determine that R1 is return-type-substitutable for R2, then R1 is necessarily not a subtype of R2 and the rules for overriding (§8.4.8.3, §9.4.1) will require a compile-time unchecked warning.",10.19,240.06,360,1136,72,76.06,432,316.12,FALSE,FALSE
454,8,BODY,possible. Release LC and throw a NoClassDefFoundError.,10.19,6.14,257.5,54,90,480.06,347.5,486.2,FALSE,FALSE
771,2,BODY,"•V is definitely assigned before an anonymous class declaration (§15.9.5) that is declared within the scope of V iff V is definitely assigned after the class instance creation expression that declares the anonymous class. It should be clear that if an anonymous class is implicitly defined by an enum constant, the rules of §16.5 apply.",10.19,64.06,360.01,336,72,108.06,432.01,172.12,FALSE,FALSE
807,3,BODY,"18.2Reduction Reduction is the process by which a set of constraint formulas (§18.1.2) is simplified to produce a bound set (§18.1.3). Each constraint formula is considered in turn. The rules in this section specify how the formula is reduced to one or both of: •A bound or bound set, which is to be incorporated with the 'current' bound set. Initially, the current bound set is empty. •Further constraint formulas, which are to be reduced recursively. Reduction completes when no further constraint formulas remain to be reduced. The results of a reduction step are always soundness-preserving: if an inference variable instantiation satisfies the reduced constraints and bounds, it will also satisfy the original constraint. On the other hand, reduction is not completeness-preserving: there may exist inference variable instantiations that satisfy the original constraint but do not satisfy a reduced constraint or bound. This is due to inherent limitations of the algorithm, along with a desire to avoid undue complexity. One effect is that there are expressions for which type argument inference fails to find a solution, but that can be well-typed if the programmer explicitly inserts appropriate types.",10.18,243.56,360.01,1209,72,208.56,432.01,452.12,FALSE,FALSE
529,3,BODY,"label in the switch block that applies to the value as follows: •A case label with a case constant c applies to a value of type Character, Byte, Short, or Integer, if the value is first subjected to unboxing conversion (§5.1.8) and the constant c is equal to the unboxed value. Any unboxing conversion will complete normally as the value being unboxed is guaranteed not to be the null reference.",10.17,83.06,342,395,90,89.06,432,172.12,FALSE,FALSE
206,2,BODY,"•If the expression name appears in a nested class or interface declaration of C, then the immediately enclosing class or interface declaration of the expression name is an inner class of C. For example, the expression name must not appear in the body of a static method declared by C, nor in the body of an instance method of a static class nested within C.",10.15,64.06,360,357,72,76.06,432,140.12,FALSE,FALSE
363,4,BODY,InterfaceExtends: extends InterfaceTypeList The following production from §8.1.5 is shown here for convenience:,10.15,40.99,251.21,111,90,436.13,341.21,477.12,FALSE,TRUE
181,4,BODY,6.3.1.2Conditional-Or Operator || The following rules apply to a conditional-or expression a || b (§15.24): •A pattern variable introduced by a when false is definitely matched at b. •A pattern variable is introduced by a || b when false iff either (i) it is introduced by a when false or (ii) it is introduced by b when false. It should be noted that there is no rule for introducing a pattern variable by a || b when true. This is because it cannot be determined at compile time which operand will evaluate to true.,10.13,119.12,360,517,72,311.13,432,430.25,FALSE,FALSE
601,2,BODY,ClassLiteral: TypeName {[ ]} . class NumericType {[ ]} . class boolean {[ ]} . class void . class,10.11,58.05,132.27,97,90,76.13,222.27,134.18,FALSE,TRUE
650,5,BODY,"following constraints: –E is mentioned in one of the throws clauses. –For each throws clause, E is a subtype of some type named in that clause. These rules for deriving a single method type from a group of overloaded methods are also used to identify the function type of a functional interface (§9.9).",10.11,76.06,332.01,302,100,300.06,432.01,376.12,FALSE,FALSE
47,4,BODY,"syntactic grammar (§2.3), as follows: •For module and open, when recognized as a terminal in a ModuleDeclaration (§7.7). •For exports, opens, provides, requires, to, uses, and with, when recognized as a terminal in a ModuleDirective. •For transitive, when recognized as a terminal in a RequiresModifier. For example, recognizing the sequence requires transitive ; does not make use of RequiresModifier, so the term transitive is reduced here to an identifier and not a contextual keyword.",10.1,131.06,342,488,90,274.06,432,405.12,FALSE,FALSE
383,8,BODY,DefaultValue: default ElementValue The following productions from §9.7.1 are shown here for convenience:,10.1,40.99,259.7,104,90,514.13,349.7,555.12,FALSE,TRUE
515,3,BODY,"–If Expression2 is not present, an AssertionError instance with no 'detail message' is created. Then: ›If the instance creation completes abruptly for some reason, the assert statement completes abruptly for the same reason. ›If the instance creation completes normally, the assert statement completes abruptly by throwing the newly created AssertionError object. Typically, assertion checking is enabled during program development and testing, and disabled for deployment, to improve performance. Because assertions may be disabled, programs must not assume that the expressions contained in assertions will be evaluated. Thus, these boolean expressions should generally",10.08,147.06,350,671,82,454.06,432,601.12,FALSE,FALSE
697,2,BODY,"The value of n >>> s is n right-shifted s bit positions with zero-extension, where: •If n is positive, then the result is the same as that of n >> s. •If n is negative and the type of the left-hand operand is int, then the result is equal to that of the expression (n >> s) + (2 << ~s). •If n is negative and the type of the left-hand operand is long, then the result is equal to that of the expression (n >> s) + (2L << ~s). The added term (2 << ~s) or (2L << ~s) cancels out the propagated sign bit. Note that, because of the implicit masking of the right-hand operand of a shift operator, ~s as a shift distance is equivalent to 31-s when shifting an int value and to 63-s when shifting a long value.",10.04,153.06,360,703,72,76.06,432,229.12,FALSE,FALSE
343,2,BODY,"•An implicitly declared method public static E[] values(), which returns an array containing the enum constants of E, in the same order as they appear in the body of the declaration of E. •An implicitly declared method public static E valueOf(String name), which returns the enum constant of E with the specified name. It follows that the declaration of enum class E cannot contain fields that conflict with the implicitly declared fields corresponding to E's enum constants, nor contain methods that conflict with implicitly declared methods or override final methods of class Enum<E>.",10.03,106.06,360,586,72,76.06,432,182.12,FALSE,FALSE
805,3,BODY,"18.1.2Constraint Formulas Constraint formulas are assertions of compatibility or subtyping that may involve inference variables. The formulas may take one of the following forms: •‹Expression → T›: An expression is compatible in a loose invocation context with type T (§5.3). •‹S → T›: A type S is compatible in a loose invocation context with type T (§5.3). •‹S <: T›: A reference type S is a subtype of a reference type T (§4.10). •‹S <= T›: A type argument S is contained by a type argument T (§4.5.1). •‹S = T›: A type S is the same as a type T (§4.3.4), or a type argument S is the same as type argument T. •‹LambdaExpression →throws T›: The checked exceptions thrown by the body of the LambdaExpression are declared by the throws clause of the function type derived from T. •‹MethodReference →throws T›: The checked exceptions thrown by the referenced method are declared by the throws clause of the function type derived from T. Examples of constraint formulas: •From Collections.singleton('hi'), we have the constraint formula ‹'hi' → α›. Through reduction, this will become the constraint formula: ‹String <: α›. •From Arrays.asList(1, 2.0), we have the constraint formulas ‹1 → α› and ‹2.0 → α›. Through reduction, these will become the constraint formulas ‹int → α› and ‹double → α›, and then ‹Integer <: α› and ‹Double <: α›. •From the target type of the constructor invocation List<Thread> lt = new ArrayList<>(), we have the constraint formula ‹ArrayList<α> → List<Thread>›. Through reduction, this will become the constraint formula ‹α <= Thread›, and then ‹α = Thread›.",10.03,374.87,360,1585,72,134.09,432,508.96,FALSE,FALSE
353,2,BODY,"corresponding to T (§5.1.7), with the first argument given by the value of the component field c of a, and the second argument given by the value of the component field c of b; if the method would return 0 then true is returned, otherwise false is returned. The use of compare in wrapper classes ensures that the implicitly declared equals method is reflexive and behaves consistently with the implicitly declared hashCode method for record classes that have floating-point components.",10.02,87.06,340,485,92,76.06,432,163.12,FALSE,FALSE
477,4,BODY,"13.4.2sealed, non-sealed, and final Classes",10.02,6.34,219.61,43,72,290.09,291.61,296.43,TRUE,FALSE
136,2,BODY,"•An interface named I is disjoint from another interface named J if (i) it is not that case that I <: J, and (ii) it is not the case that J <: I, and (iii) one of the following cases applies: –I is sealed, and all of the permitted direct subclasses and subinterfaces of I are disjoint from J. –J is sealed, and I is disjoint from all the permitted direct subclasses and subinterfaces of J. Whether a class is final has the most bearing on whether the class is disjoint from interfaces. Consider the following declarations: interface I   {} final class C {}",10.01,159.05,360,556,72,76.06,432,235.11,FALSE,FALSE
2,0,BODY,"Specification: JSR-398 Java SE 23 Version: 23 Status: Final Release Release: September 2024 Copyright © 1997, 2024, Oracle America, Inc. All rights reserved. The Specification provided herein is provided to you only under the Limited License Grant included herein as Appendix A. Please see Appendix A, Limited License Grant.",10,99.58,360,324,72,84.58,432,184.16,FALSE,FALSE
3,2,BODY,1.1Organization of the Specification2 1.2Example Programs6 1.3Notation6 1.4Relationship to Predefined Classes and Interfaces7 1.5Preview Features7 1.6Feedback10 1.7References10,10,71.58,239.02,176,96,165.83,335.02,237.41,FALSE,FALSE
3,4,BODY,2.1Context-Free Grammars13 2.2The Lexical Grammar13 2.3The Syntactic Grammar14 2.4Grammar Notation14,10,38.58,143.48,100,96,272.83,239.48,311.41,FALSE,FALSE
3,6,BODY,3.1Unicode19 3.2Lexical Translations20 3.3Unicode Escapes21 3.4Line Terminators24 3.5Input Elements and Tokens24 3.6White Space26 3.7Comments26 3.8Identifiers28 3.9Keywords30 3.10Literals32,10,104.58,155.71,189,96,346.83,251.71,451.41,FALSE,FALSE
3,7,BODY,3.10.1Integer Literals33 3.10.2Floating-Point Literals40 3.10.3Boolean Literals43 3.10.4Character Literals44 3.10.5String Literals45 3.10.6Text Blocks47 3.10.7Escape Sequences53 3.10.8The Null Literal54,10,82.58,142.84,202,126,456.83,268.84,539.41,FALSE,FALSE
3,8,BODY,3.11Separators54 3.12Operators54,10,16.58,88.21,32,96,544.83,184.21,561.41,FALSE,FALSE
3,10,BODY,4.1The Kinds of Types and Values55,10,5.58,172.92,34,96,596.83,268.92,602.41,FALSE,FALSE
4,2,BODY,4.4Type Variables70 4.5Parameterized Types72,10,16.58,130.14,44,96,195.83,226.14,212.41,FALSE,FALSE
4,3,BODY,4.5.1Type Arguments of Parameterized Types73 4.5.2Members and Constructors of Parameterized Types76,10,16.58,257.79,99,126,217.83,383.79,234.41,FALSE,FALSE
4,4,BODY,4.6Type Erasure77 4.7Reifiable Types77 4.8Raw Types79 4.9Intersection Types83 4.10Subtyping84,10,49.58,120.15,93,96,239.83,216.15,289.41,FALSE,FALSE
4,5,BODY,4.10.1Subtyping among Primitive Types84 4.10.2Subtyping among Class and Interface Types84 4.10.3Subtyping among Array Types85 4.10.4Least Upper Bound86 4.10.5Type Projections89 4.11Where Types Are Used91 4.12Variables96,10,71.58,258.92,219,96,294.83,354.92,366.41,FALSE,FALSE
4,8,BODY,5.1Kinds of Conversion112,10,5.58,134.33,25,96,467.83,230.33,473.41,FALSE,FALSE
4,9,BODY,5.1.1Identity Conversion112 5.1.2Widening Primitive Conversion113 5.1.3Narrowing Primitive Conversion114 5.1.4Widening and Narrowing Primitive Conversion117 5.1.5Widening Reference Conversion117 5.1.6Narrowing Reference Conversion118,10,60.58,247.54,233,126,478.83,373.54,539.41,FALSE,FALSE
4,10,BODY,5.1.6.1Allowed Narrowing Reference Conversion118 5.1.6.2Checked and Unchecked Narrowing Reference 5.1.6.3Narrowing Reference Conversions at Run Time121,10,38.58,256.35,151,162,544.83,418.35,583.41,FALSE,FALSE
4,11,BODY,Conversions120,10,5.58,71,14,206,566.83,277,572.41,FALSE,FALSE
4,12,BODY,5.1.7Boxing Conversion124,10,5.58,135.06,25,126,588.83,261.06,594.41,FALSE,FALSE
5,1,BODY,5.1.8Unboxing Conversion125 5.1.9Unchecked Conversion127 5.1.10Capture Conversion127 5.1.11String Conversion129 5.1.12Forbidden Conversions130,10,49.58,150.61,142,126,74.83,276.61,124.41,FALSE,FALSE
5,2,BODY,5.2Assignment Contexts130 5.3Invocation Contexts135 5.4String Contexts137 5.5Casting Contexts137 5.6Numeric Contexts143 5.7Testing Contexts147,10,60.58,136.84,142,96,129.83,232.84,190.41,FALSE,FALSE
5,4,BODY,6.1Declarations150 6.2Names and Identifiers158 6.3Scope of a Declaration160,10,27.58,142.36,75,96,225.83,238.36,253.41,FALSE,FALSE
5,6,BODY,6.3.2Scope for Pattern Variables in Statements167,10,5.58,223.92,49,126,346.83,349.92,352.41,FALSE,FALSE
5,8,BODY,6.4Shadowing and Obscuring171,10,5.58,157.1,29,96,445.83,253.1,451.41,FALSE,FALSE
5,9,BODY,6.5Determining the Meaning of a Name179,10,5.58,198.47,39,96,478.83,294.47,484.41,FALSE,FALSE
5,10,BODY,6.5.3.1Simple Package Names186 6.5.3.2Qualified Package Names186 6.5.4Meaning of PackageOrTypeNames186 6.5.4.1Simple PackageOrTypeNames186 6.5.4.2Qualified PackageOrTypeNames187 6.5.5.1Simple Type Names187,10,71.58,233.47,205,126,522.83,359.47,594.41,FALSE,FALSE
5,11,BODY,6.5.5Meaning of Type Names187,10,5.58,156.7,29,126,577.83,282.7,583.41,FALSE,FALSE
6,1,BODY,6.5.5.2Qualified Type Names188 6.5.6Meaning of Expression Names189 6.5.6.1Simple Expression Names189 6.5.6.2Qualified Expression Names193 6.5.7.1Simple Method Names196,10,60.58,215.98,167,126,74.83,341.98,135.41,FALSE,FALSE
6,2,BODY,6.5.7Meaning of Method Names196,10,5.58,167.26,31,126,118.83,293.26,124.41,FALSE,FALSE
6,3,BODY,6.6Access Control197,10,5.58,112.38,20,96,140.83,208.38,146.41,FALSE,FALSE
6,6,BODY,6.7Fully Qualified Names and Canonical Names205,10,5.58,232.92,47,96,195.83,328.92,201.41,FALSE,FALSE
6,8,BODY,7.1Package Members210 7.2Host Support for Modules and Packages211 7.3Compilation Units214 7.4Package Declarations216,10,38.58,212.37,116,96,236.83,308.37,275.41,FALSE,FALSE
6,9,BODY,7.4.1Named Packages216 7.4.2Unnamed Packages217 7.4.3Package Observability and Visibility217 7.5.1Single-Type-Import Declarations219 7.5.2Type-Import-on-Demand Declarations221 7.5.3Single-Static-Import Declarations222 7.5.4Static-Import-on-Demand Declarations223 7.6Top Level Class and Interface Declarations224 7.7Module Declarations227 7.7.1Dependences230 7.7.2Exported and Opened Packages232 7.7.3Service Consumption233 7.7.4Service Provision234 7.7.5Unnamed Modules235 7.7.6Observability of a Module235,10,170.58,243.91,506,96,280.83,339.91,451.41,FALSE,FALSE
6,10,BODY,7.5Import Declarations218,10,5.58,131.26,25,96,313.83,227.26,319.41,FALSE,FALSE
6,12,BODY,8.1Class Declarations239,10,5.58,125.71,24,96,486.83,221.71,492.41,FALSE,FALSE
6,13,BODY,8.1.1Class Modifiers239,10,5.58,120.61,23,126,497.83,246.61,503.41,FALSE,FALSE
6,15,BODY,8.1.2Generic Classes and Type Parameters243 8.1.3Inner Classes and Enclosing Instances246 8.1.4Superclasses and Subclasses250 8.1.5Superinterfaces253 8.1.6Permitted Direct Subclasses256,10,49.58,209.75,185,126,552.83,335.75,602.41,FALSE,FALSE
7,1,BODY,8.1.7Class Body and Member Declarations258,10,5.58,209.2,42,126,74.83,335.2,80.41,FALSE,FALSE
7,2,BODY,8.2Class Members259 8.3Field Declarations263,10,16.58,124.6,44,96,85.83,220.6,102.41,FALSE,FALSE
7,3,BODY,8.3.1Field Modifiers268,10,5.58,119.5,23,126,107.83,245.5,113.41,FALSE,FALSE
7,5,BODY,8.3.2Field Initialization274 8.3.3Restrictions on Field References in Initializers275 8.4.1Formal Parameters280 8.4.2Method Signature283 8.4.3Method Modifiers284,10,60.58,242.81,161,126,162.83,368.81,223.41,FALSE,FALSE
7,6,BODY,8.4Method Declarations278,10,5.58,135.15,25,96,184.83,231.15,190.41,FALSE,FALSE
7,8,BODY,"8.4.4Generic Methods290 8.4.5Method Result290 8.4.6Method Throws291 8.4.7Method Body293 8.4.8Inheritance, Overriding, and Hiding293 8.4.8.2Hiding (by Class Methods)298 8.4.8.1Overriding (by Instance Methods)295 8.4.8.3Requirements in Overriding and Hiding299 8.4.8.4Inheriting Methods with Override-Equivalent",10,93.58,261.92,309,126,294.83,387.92,388.41,FALSE,FALSE
7,9,BODY,Signatures303,10,5.58,63.22,13,206,393.83,269.22,399.41,FALSE,FALSE
7,10,BODY,8.4.9Overloading305 8.6Instance Initializers309 8.5Member Class and Interface Declarations308 8.7Static Initializers309 8.8Constructor Declarations310 8.8.1Formal Parameters311 8.8.2Constructor Signature312 8.8.3Constructor Modifiers312 8.8.4Generic Constructors313 8.8.5Constructor Throws314 8.8.6The Type of a Constructor314 8.8.7Constructor Body314 8.8.8Constructor Overloading319 8.8.9Default Constructor319 8.8.10Preventing Instantiation of a Class321 8.9.1Enum Constants323,10,192.58,224.77,479,96,404.83,320.77,597.41,FALSE,FALSE
7,11,BODY,8.8.7.1Explicit Constructor Invocations315,10,5.58,195.55,42,162,536.83,357.55,542.41,FALSE,FALSE
7,12,BODY,8.9Enum Classes322,10,5.58,107.39,18,96,580.83,203.39,586.41,FALSE,FALSE
8,1,BODY,8.9.2Enum Body Declarations324 8.9.3Enum Members326 8.10.1Record Components331 8.10.2Record Body Declarations333 8.10.3Record Members334 8.10.4Record Constructor Declarations338,10,71.58,188.64,177,126,74.83,314.64,146.41,FALSE,FALSE
8,2,BODY,8.10Record Classes331,10,5.58,112.38,21,96,96.83,208.38,102.41,FALSE,FALSE
8,3,BODY,8.10.4.1Normal Canonical Constructors340 8.10.4.2Compact Canonical Constructors341,10,16.58,197.77,82,162,151.83,359.77,168.41,FALSE,FALSE
8,5,BODY,9.1Interface Declarations344,10,5.58,139.57,28,96,203.83,235.57,209.41,FALSE,FALSE
8,6,BODY,9.1.1Interface Modifiers344,10,5.58,134.47,27,126,214.83,260.47,220.41,FALSE,FALSE
8,8,BODY,9.1.2Generic Interfaces and Type Parameters346 9.1.3Superinterfaces and Subinterfaces347 9.1.4Permitted Direct Subclasses and Subinterfaces348 9.1.5Interface Body and Member Declarations350,10,38.58,243.08,189,126,269.83,369.08,308.41,FALSE,FALSE
8,9,BODY,9.2Interface Members350 9.3Field (Constant) Declarations351 9.4Method Declarations354,10,38.58,169.32,85,96,313.83,265.32,352.41,FALSE,FALSE
8,10,BODY,9.3.1Initialization of Fields in Interfaces353 9.4.1Inheritance and Overriding356,10,27.58,198.09,81,126,335.83,324.09,363.41,FALSE,FALSE
8,11,BODY,9.4.1.1Overriding (by Instance Methods)357 9.4.1.2Requirements in Overriding358 9.4.1.3Inheriting Methods with Override-Equivalent,10,27.58,225.92,130,162,368.83,387.92,396.41,FALSE,FALSE
8,12,BODY,Signatures359 9.4.3Interface Method Body360 9.4.2Overloading360,10,27.58,150.31,63,126,401.83,276.31,429.41,FALSE,FALSE
8,13,BODY,9.5Member Class and Interface Declarations361 9.6Annotation Interfaces362 9.6.1Annotation Interface Elements364 9.6.2Defaults for Annotation Interface Elements367 9.6.3Repeatable Annotation Interfaces368 9.6.4Predefined Annotation Interfaces373,10,60.58,260.29,244,96,434.83,356.29,495.41,FALSE,FALSE
9,1,BODY,9.7Annotations381,10,5.58,99.89,17,96,74.83,195.89,80.41,FALSE,FALSE
9,2,BODY,9.7.1Normal Annotations382 9.7.2Marker Annotations385 9.7.3Single-Element Annotations385 9.7.4Where Annotations May Appear386 9.7.5Multiple Annotations of the Same Interface391,10,49.58,231.14,176,126,85.83,357.14,135.41,FALSE,FALSE
9,3,BODY,9.8Functional Interfaces392 9.9Function Types396,10,16.58,135.7,48,96,140.83,231.7,157.41,FALSE,FALSE
9,7,BODY,11.1The Kinds and Causes of Exceptions414 11.1.1The Kinds of Exceptions414 11.1.2The Causes of Exceptions415 11.1.3Asynchronous Exceptions416 11.2.1Exception Analysis of Expressions418 11.2.2Exception Analysis of Statements418 11.2.3Exception Checking420 11.2Compile-Time Checking of Exceptions416,10,82.58,226.71,297,96,321.83,322.71,404.41,FALSE,FALSE
9,8,BODY,11.3Run-Time Handling of an Exception422,10,5.58,197.65,40,96,409.83,293.65,415.41,FALSE,FALSE
10,1,BODY,12.4.2Detailed Initialization Procedure437,10,5.58,187.53,42,126,74.83,313.53,80.41,FALSE,FALSE
10,2,BODY,12.5Creation of New Class Instances440 12.6Finalization of Class Instances443 12.6.1Implementing Finalization445 12.6.2Interaction with the Memory Model446 12.7Unloading of Classes and Interfaces448 12.8Program Exit449,10,60.58,230.87,218,96,85.83,326.87,146.41,FALSE,FALSE
10,4,BODY,13.1The Form of a Binary452 13.2What Binary Compatibility Is and Is Not459 13.3Evolution of Packages and Modules460 13.4Evolution of Classes461,10,38.58,214.33,143,96,181.83,310.33,220.41,FALSE,FALSE
10,8,BODY,13.5Evolution of Interfaces478,10,5.58,143.2,30,96,555.83,239.2,561.41,FALSE,FALSE
11,1,BODY,13.5.4Interface Members480 13.5.5Interface Type Parameters480 13.5.6Field Declarations481 13.5.7Interface Method Declarations481 13.5.8Annotation Interfaces482,10,49.58,179.18,159,126,74.83,305.18,124.41,FALSE,FALSE
11,3,BODY,14.1Normal and Abrupt Completion of Statements484 14.2Blocks485 14.3Local Class and Interface Declarations486 14.4Local Variable Declarations488,10,38.58,236.27,144,96,159.83,332.27,198.41,FALSE,FALSE
11,4,BODY,14.4.1Local Variable Declarators and Types489 14.4.2Local Variable Declaration Statements491,10,16.58,212.24,92,126,203.83,338.24,220.41,FALSE,FALSE
11,8,BODY,14.11.1.1Exhaustive Switch Blocks508 14.11.1.2Determining which Switch Label Applies at Run,10,16.58,239.54,91,162,335.83,401.54,352.41,FALSE,FALSE
11,9,BODY,Time512,10,5.58,42.11,7,206,357.83,248.11,363.41,FALSE,FALSE
12,5,BODY,Expressions598 15.9.5.1Anonymous Constructors600,10,27.58,167.5,48,162,445.83,329.5,473.41,FALSE,FALSE
12,6,BODY,15.11Field Access Expressions609,10,5.58,153.21,32,96,533.83,249.21,539.41,FALSE,FALSE
12,7,BODY,15.12Method Invocation Expressions614,10,5.58,178.21,37,96,566.83,274.21,572.41,FALSE,FALSE
13,1,BODY,15.12.2.1Identify Potentially Applicable Methods624 15.12.2.2Phase 1: Identify Matching Arity Methods Applicable 15.12.2.3Phase 2: Identify Matching Arity Methods Applicable 15.12.2.4Phase 3: Identify Methods Applicable by Variable Arity 15.12.2.5Choosing the Most Specific Method629 15.12.2.6Method Invocation Type634,10,93.58,268.69,318,162,74.83,430.69,168.41,FALSE,FALSE
13,2,BODY,by Strict Invocation627 by Loose Invocation628 Invocation629,10,49.58,103.21,60,206,96.83,309.21,146.41,FALSE,FALSE
13,3,BODY,15.12.3Compile-Time Step 3: Is the Chosen Method Appropriate?635 15.12.4Run-Time Evaluation of Method Invocation638,10,16.58,292.26,115,126,173.83,418.26,190.41,FALSE,FALSE
13,4,BODY,"15.12.4.1Compute Target Reference (If Necessary)638 15.12.4.2Evaluate Arguments640 15.12.4.3Check Accessibility of Type and Method641 15.12.4.4Locate Method to Invoke642 15.12.4.5Create Frame, Synchronize, Transfer Control647",10,49.58,246.07,225,162,195.83,408.07,245.41,FALSE,FALSE
13,5,BODY,15.13Method Reference Expressions648,10,5.58,175.97,36,96,250.83,271.97,256.41,FALSE,FALSE
13,7,BODY,15.14Postfix Expressions662,10,5.58,130.17,27,96,294.83,226.17,300.41,FALSE,FALSE
13,8,BODY,15.15Unary Operators664,10,5.58,117.92,23,96,338.83,213.92,344.41,FALSE,FALSE
13,9,BODY,15.16Cast Expressions669 15.17Multiplicative Operators670,10,16.58,149.6,57,96,415.83,245.6,432.41,FALSE,FALSE
13,11,BODY,15.18Additive Operators675,10,5.58,127.93,26,96,470.83,223.93,476.41,FALSE,FALSE
13,12,BODY,15.19Shift Operators680 15.20Relational Operators681,10,16.58,134.04,52,96,503.83,230.04,520.41,FALSE,FALSE
13,14,BODY,15.21Equality Operators685,10,5.58,126.82,26,96,547.83,222.82,553.41,FALSE,FALSE
13,15,BODY,15.22Bitwise and Logical Operators687,10,5.58,173.48,37,96,591.83,269.48,597.41,FALSE,FALSE
14,4,BODY,15.26Assignment Operators700,10,5.58,140.71,28,96,162.83,236.71,168.41,FALSE,FALSE
14,6,BODY,15.29Constant Expressions729,10,5.58,137.39,28,96,283.83,233.39,289.41,FALSE,FALSE
14,9,BODY,16.2Definite Assignment and Statements744,10,5.58,197.38,41,96,445.83,293.38,451.41,FALSE,FALSE
15,4,BODY,"17.1Synchronization760 17.2Wait Sets and Notification760 17.2.1Wait761 17.2.2Notification763 17.2.3Interruptions763 17.2.4Interactions of Waits, Notification, and Interruption764",10,60.58,293.91,178,96,225.83,389.91,286.41,FALSE,FALSE
15,9,BODY,18.1Concepts and Notation788,10,5.58,142.66,28,96,519.83,238.66,525.41,FALSE,FALSE
15,10,BODY,18.1.1Inference Variables788 18.1.2Constraint Formulas789 18.1.3Bounds789 18.2.1Expression Compatibility Constraints791 18.2.2Type Compatibility Constraints796 18.2.3Subtyping Constraints797,10,71.58,207.57,190,126,530.83,333.57,602.41,FALSE,FALSE
15,11,BODY,18.2Reduction791,10,5.58,92.11,16,96,563.83,188.11,569.41,FALSE,FALSE
16,1,BODY,18.2.4Type Equality Constraints799 18.2.5Checked Exception Constraints800 18.3.1Complementary Pairs of Bounds803 18.3.2Bounds Involving Capture Conversion804,10,49.58,211.72,157,126,74.83,337.72,124.41,FALSE,FALSE
16,2,BODY,18.3Incorporation802,10,5.58,105.43,20,96,96.83,201.43,102.41,FALSE,FALSE
16,3,BODY,18.4Resolution804 18.5Uses of Inference807,10,16.58,121.52,42,96,129.83,217.52,146.41,FALSE,FALSE
16,4,BODY,18.5.1Invocation Applicability Inference807 18.5.2Invocation Type Inference809,10,16.58,195.3,78,126,151.83,321.3,168.41,FALSE,FALSE
16,5,BODY,18.5.2.1Poly Method Invocation Compatibility809 18.5.2.2Additional Argument Constraints811 18.5.3Functional Interface Parameterization Inference816 18.5.4More Specific Method Inference817 18.5.5Record Pattern Type Inference821,10,49.58,256.29,226,126,173.83,382.29,223.41,FALSE,FALSE
22,6,BODY,"producing the output: Hello, world.",10,24.81,94.72,35,72,451.06,166.72,475.87,FALSE,FALSE
26,6,BODY,"Apple Computer. Dylan Reference Manual. Apple Computer Inc., Cupertino, California.",10,5.58,378,83,54,392.83,432,398.41,FALSE,FALSE
26,7,BODY,09/29/95,10,5.58,82.77,19,72,403.83,154.77,409.41,FALSE,FALSE
26,8,BODY,"Bobrow, Daniel G., Linda G. DeMichiel, Richard P. Gabriel, Sonya E. Keene, Gregor Kiczales, and David A. Moon. Common Lisp Object System Specification, X3J13 Document 88-002R, June 1988; appears as Chapter 28 of Steele, Guy. Common Lisp: The Language, 2nd ed. Digital Press, 1990, ISBN 1-55558-041-6, 770-864.",10,38.58,378.01,309,54,419.83,432.01,458.41,FALSE,FALSE
26,9,BODY,"Ellis, Margaret A., and Bjarne Stroustrup. The Annotated C++ Reference Manual. Addison- Wesley, Reading, Massachusetts, 1990, reprinted with corrections October 1992, ISBN 0-201-51459-1.",10,27.58,378,186,54,468.83,432,496.41,FALSE,FALSE
26,10,BODY,"Goldberg, Adele and Robson, David. Smalltalk-80: The Language. Addison-Wesley, Reading,",10,5.58,378,87,54,506.83,432,512.41,FALSE,FALSE
26,11,BODY,"Massachusetts, 1989, ISBN 0-201-13688-0.",10,5.58,175.54,40,72,517.83,247.54,523.41,FALSE,FALSE
26,12,BODY,"Harbison, Samuel. Modula-3. Prentice Hall, Englewood Cliffs, New Jersey, 1992, ISBN",10,5.58,378,83,54,533.83,432,539.41,FALSE,FALSE
26,13,BODY,0-13-596396.,10,5.58,54.16,12,72,544.83,126.16,550.41,FALSE,FALSE
26,14,BODY,"Hoare, C. A. R. Hints on Programming Language Design. Stanford University Computer Science Department Technical Report No. CS-73-403, December 1973. Reprinted in SIGACT/SIGPLAN Symposium on Principles of Programming Languages. Association for Computing Machinery, New York, October 1973.",10,38.58,378,287,54,560.83,432,599.41,FALSE,FALSE
27,2,BODY,IEEE. IEEE Standard for Floating-Point Arithmetic. IEEE Std 754-2019 (Revision of IEEE,10,5.58,378,86,54,74.83,432,80.41,FALSE,FALSE
27,3,BODY,"754-2008). July 2019, ISBN 978-1-5044-5924-2.",10,5.58,196.93,45,72,85.83,268.93,91.41,FALSE,FALSE
27,4,BODY,"Kernighan, Brian W., and Dennis M. Ritchie. The C Programming Language, 2nd ed. Prentice",10,5.58,378,88,54,101.83,432,107.41,FALSE,FALSE
27,5,BODY,"Hall, Englewood Cliffs, New Jersey, 1988, ISBN 0-13-110362-8.",10,5.58,262.19,61,72,112.83,334.19,118.41,FALSE,FALSE
27,6,BODY,"Madsen, Ole Lehrmann, Birger Møller-Pedersen, and Kristen Nygaard. Object-Oriented Programming in the Beta Programming Language. Addison-Wesley, Reading, Massachusetts, 1993, ISBN 0-201-62430-3.",10,27.58,378,194,54,128.83,432,156.41,FALSE,FALSE
27,7,BODY,"Mitchell, James G., William Maybury, and Richard Sweet. The Mesa Programming Language,",10,5.58,378,86,54,166.83,432,172.41,FALSE,FALSE
27,8,BODY,"Version 5.0. Xerox PARC, Palo Alto, California, CSL 79-3, April 1979.",10,5.58,288.61,69,72,177.83,360.61,183.41,FALSE,FALSE
27,9,BODY,"Stroustrup, Bjarne. The C++ Programming Language, 2nd ed. Addison-Wesley, Reading,",10,5.58,378,82,54,193.83,432,199.41,FALSE,FALSE
27,10,BODY,"Massachusetts, 1991, reprinted with corrections January 1994, ISBN 0-201-53992-6.",10,5.58,339.95,81,72,204.83,411.95,210.41,FALSE,FALSE
27,11,BODY,"Unicode Consortium, The. The Unicode Standard, Version 15.1.0. South San Francisco, CA:",10,5.58,378,87,54,220.83,432,226.41,FALSE,FALSE
27,12,BODY,"The Unicode Consortium, 2023. ISBN 978-1-936213-33-7.",10,5.58,237.76,53,72,231.83,309.76,237.41,FALSE,FALSE
70,4,BODY,NullLiteral: null,10,17.75,52.57,17,90,224.13,142.57,241.88,FALSE,FALSE
401,11,BODY,It is shorthand for the normal annotation: @TypeName(value = ElementValue),10,24.81,185.4,74,72,425.06,257.4,449.87,FALSE,FALSE
509,6,BODY,EmptyStatement: ;,10,17.75,75.15,17,90,411.13,165.15,428.88,FALSE,FALSE
152,2,BODY,"•a widening reference conversion followed by an unboxing conversion, then followed by a widening primitive conversion •a boxing conversion (§5.1.7) •a boxing conversion followed by widening reference conversion •an unboxing conversion (§5.1.8) •an unboxing conversion followed by a widening primitive conversion If, after the conversions listed for an invocation context have been applied, the resulting type is a raw type (§4.8), an unchecked conversion (§5.1.9) may then be applied. A value of the null type (the null reference is the only such value) may be assigned to any reference type. It is a compile-time error if the chain of conversions contains two parameterized types that are not in the subtype relation (§4.10). The only exceptions that may arise in an invocation context are: •A ClassCastException if, after the type conversions above have been applied, the resulting value is an object which is not an instance of a subclass or subinterface of the erasure (§4.6) of the corresponding formal parameter type. •An OutOfMemoryError as a result of a boxing conversion. •A NullPointerException as a result of an unboxing conversion on a null reference. Neither strict nor loose invocation contexts include the implicit narrowing of integer constant expressions which is allowed in assignment contexts. The designers of the Java programming language felt that including these implicit narrowing conversions would add additional complexity to the rules of overload resolution (§15.12.2). Thus, the program: class Test { static int m(byte a, int b) { return a+b; } static int m(short a, short b) { return a-b; } public static void main(String[] args) { System.out.println(m(12, 2));  // compile-time error } }",9.98,474.04,360.01,1717,72,76.06,432.01,550.11,FALSE,FALSE
5,7,BODY,6.3.3Scope for Pattern Variables in case Labels171 6.4.1Shadowing175 6.4.2Obscuring178 6.5.1Syntactic Classification of a Name According to Context180 6.5.2Reclassification of Contextually Ambiguous Names184 6.5.3Meaning of Module Names and Package Names186,9.97,82.58,285.03,257,126,434.83,411.03,517.41,FALSE,FALSE
11,5,BODY,14.5Statements491 14.6The Empty Statement493 14.7Labeled Statements493 14.8Expression Statements495 14.9The if Statement496,9.97,49.58,141.83,123,96,225.83,237.83,275.41,FALSE,FALSE
183,2,BODY,"6.3.1.5Pattern Match Operator instanceof The following rule applies to an instanceof expression with a pattern operand, a instanceof p (§15.20.2): •A pattern variable is introduced by a instanceof p when true iff the pattern p contains a declaration of the pattern variable (§14.30.1). A pattern variable is not permitted to shadow another local variable (§6.4). It should be noted that there is no rule for introducing a pattern variable by a instanceof p when false.",9.97,125.12,360,468,72,76.13,432,201.25,FALSE,FALSE
12,4,BODY,"15.1Evaluation, Denotation, and Result567 15.2Forms of Expressions568 15.3Type of an Expression569 15.4Floating-point Expressions570 15.5Expressions and Run-Time Checks574 15.6Normal and Abrupt Completion of Evaluation575 15.7Evaluation Order577 15.7.1Evaluate Left-Hand Operand First577 15.7.2Evaluate Operands before Operation579 15.7.3Evaluation Respects Parentheses and Precedence580 15.7.4Argument Lists are Evaluated Left-to-Right581 15.7.5Evaluation Order for Other Expressions582 15.8.1Lexical Literals584 15.8.2Class Literals584 15.8.3this585 15.8Primary Expressions583 15.8.4Qualified this586 15.8.5Parenthesized Expressions587 15.9Class Instance Creation Expressions587 15.9.1Determining the Class being Instantiated589 15.9.2Determining Enclosing Instances591 15.9.3Choosing the Constructor and its Arguments593 15.9.4Run-Time Evaluation of Class Instance Creation 15.9.5Anonymous Class Declarations599 15.10Array Creation and Access Expressions602 15.10.1Array Creation Expressions602 15.10.2Run-Time Evaluation of Array Creation Expressions603 15.10.3Array Access Expressions606 15.10.4Run-Time Evaluation of Array Access Expressions607 15.11.1Field Access Using a Primary610 15.11.2Accessing Superclass Members using super613 15.12.1Compile-Time Step 1: Determine Type to Search616 15.12.2Compile-Time Step 2: Determine Method Signature618",9.96,401.58,298.36,1354,96,192.83,394.36,594.41,FALSE,FALSE
14,3,BODY,15.25.1Boolean Conditional Expressions698 15.25.2Numeric Conditional Expressions698 15.25.3Reference Conditional Expressions699 15.26.1Simple Assignment Operator =701 15.26.2Compound Assignment Operators707 15.27.1Lambda Parameters715 15.27.2Lambda Body719 15.27.3Type of a Lambda Expression722 15.27Lambda Expressions713 15.27.4Run-Time Evaluation of Lambda Expressions724 15.28.1The Switch Block of a switch Expression726 15.28.2Run-Time Evaluation of switch Expressions727,9.96,148.58,270.87,475,96,129.83,366.87,278.41,FALSE,FALSE
317,2,BODY,"•If the overridden or hidden method is public, then the overriding or hiding method must be public; otherwise, a compile-time error occurs. •If the overridden or hidden method is protected, then the overriding or hiding method must be protected or public; otherwise, a compile-time error occurs. •If the overridden or hidden method has package access, then the overriding or hiding method must not be private; otherwise, a compile-time error occurs. Note that a private method cannot be overridden or hidden in the technical sense of those terms. This means that a subclass can declare a method with the same signature as a private method in one of its superclasses, and there is no requirement that the return type or throws clause of such a method bear any relationship to those of the private method in the superclass.",9.96,145.06,360,821,72,76.06,432,221.12,FALSE,FALSE
13,6,BODY,15.13.1Compile-Time Declaration of a Method Reference651 15.13.2Type of a Method Reference658 15.13.3Run-Time Evaluation of Method References659 15.14.1Expression Names663 15.14.2Postfix Increment Operator ++663 15.14.3Postfix Decrement Operator --664 15.15.1Prefix Increment Operator ++666 15.15.2Prefix Decrement Operator --666 15.15.3Unary Plus Operator +667 15.15.4Unary Minus Operator -667 15.15.5Bitwise Complement Operator ~668 15.15.6Logical Complement Operator !668,9.95,148.58,259.45,474,126,261.83,385.45,410.41,FALSE,FALSE
15,5,BODY,17.3Sleep and Yield764 17.4Memory Model765 17.4.2Actions768 17.4.1Shared Variables768 17.4.3Programs and Program Order769 17.4.4Synchronization Order770 17.4.5Happens-before Order771 17.4.6Executions774 17.4.7Well-Formed Executions775 17.4.8Executions and Causality Requirements775 17.4.9Observable Behavior and Nonterminating Executions778 17.5.1Semantics of final Fields782 17.5.2Reading final Fields During Construction783 17.5.3Subsequent Modification of final Fields783 17.5.4Write-Protected Fields784,9.95,170.58,301.41,506,96,291.83,397.41,462.41,FALSE,FALSE
12,2,BODY,14.21The yield Statement552 14.22Unreachable Statements553 14.30Patterns559 14.30.1Kinds of Patterns560 14.30.2Pattern Matching563 14.30.3Properties of Patterns564,9.94,60.58,173.1,163,96,96.83,269.1,157.41,FALSE,FALSE
13,10,BODY,15.17.1Multiplication Operator *671 15.17.2Division Operator /671 15.17.3Remainder Operator %673 15.18.1String Concatenation Operator +676 15.18.2Additive Operators (+ and -) for Numeric Types678,9.94,60.58,250.96,195,126,437.83,376.96,498.41,FALSE,FALSE
4,6,BODY,"4.12.1Variables of Primitive Type96 4.12.2Variables of Reference Type97 4.12.3Kinds of Variables99 4.12.4final Variables101 4.12.5Initial Values of Variables103 4.12.6Types, Classes, and Interfaces104",9.93,60.58,177.8,200,126,371.83,303.8,432.41,FALSE,FALSE
9,5,BODY,10.1Array Types402 10.2Array Variables402 10.3Array Creation405 10.4Array Access405 10.5Array Store Exception406 10.6Array Initializers407 10.7Array Members409 10.8Class Objects for Arrays410 10.9An Array of Characters Is Not a String411,9.93,93.58,211.31,237,96,192.83,307.31,286.41,FALSE,FALSE
545,3,BODY,"S[] #a = Expression; L1: L2: ... Lm: for (int #i = 0; #i < #a.length; #i++) { {VariableModifier} T VarDeclId = #a[#i]; Statement } where: –L1 ... Lm is the (possibly empty) sequence of labels immediately preceding the enhanced for statement. –#a and #i are automatically generated identifiers that are distinct from any other identifiers (automatically generated or otherwise) that are in scope at the point where the enhanced for statement occurs. –{VariableModifier} is as given in the header of the enhanced for statement. –T is the type of the local variable as determined above. –If the declaration of a local variable in the header includes an identifier then VarDeclId is defined to be Identifier as given in the header; otherwise VarDeclId is defined to be _ (underscore). For example, this code: List<? extends Integer> l = ... for (float i : l) ...",9.93,290.98,350.01,858,82,109.12,432.01,400.11,FALSE,FALSE
9,10,BODY,"12.1Java Virtual Machine Startup427 12.1.1Load the Class Test428 12.1.2Link Test: Verify, Prepare, (Optionally) Resolve428 12.1.3Initialize Test: Execute Initializers429 12.1.4Invoke Test.main430 12.2.1The Loading Process431 12.2.2Class Loader Consistency431 12.3Linking of Classes and Interfaces432 12.2Loading of Classes and Interfaces430 12.3.1Verification of the Binary Representation432 12.3.2Preparation of a Class or Interface433 12.3.3Resolution of Symbolic References433 12.4.1When Initialization Occurs435 12.4Initialization of Classes and Interfaces434",9.92,148.58,284.15,563,96,450.83,380.15,599.41,FALSE,FALSE
385,4,BODY,"4.A is applicable to at least the same kinds of program element as AC (§9.6.4.1). Specifically, if the kinds of program element where A is applicable are denoted by the set m1, and the kinds of program element where AC is applicable are denoted by the set m2, then each kind in m2 must occur in m1, except that: •If the kind in m2 is java.lang.annotation.ElementType.ANNOTATION_TYPE, then at least one of java.lang.annotation.ElementType.ANNOTATION_TYPE or or java.lang.annotation.ElementType.TYPE java.lang.annotation.ElementType.TYPE_USE must occur in m1. •If the kind in m2 is java.lang.annotation.ElementType.TYPE, then at least one of java.lang.annotation.ElementType.TYPE or java.lang.annotation.ElementType.TYPE_USE must occur in m1. •If the kind in m2 is java.lang.annotation.ElementType.TYPE_PARAMETER, then at least one of java.lang.annotation.ElementType.TYPE_PARAMETER or java.lang.annotation.ElementType.TYPE_USE must occur in m1. This clause implements the policy that an annotation interface may be repeatable on only some of the kinds of program element where it is applicable.",9.92,251.06,360,1093,72,282.06,432,533.12,FALSE,FALSE
378,3,BODY,"AnnotationInterfaceDeclaration: {InterfaceModifier} @ interface TypeIdentifier AnnotationInterfaceBody Note that the at sign (@) and the keyword interface are distinct tokens. It is possible to separate them with whitespace, but this is discouraged as a matter of style.",9.9,50.99,335.55,270,90,158.13,425.55,209.12,FALSE,FALSE
14,10,BODY,16.2.12.1Initialization Part of for Statement750,9.88,5.58,205.31,48,162,588.83,367.31,594.41,FALSE,FALSE
15,1,BODY,16.2.12.2Incrementation Part of for Statement751,9.88,5.58,214.74,48,162,74.83,376.74,80.41,FALSE,FALSE
4,1,BODY,4.2Primitive Types and Values56 4.2.2Integer Operations57 4.2.1Integral Types and Values57 4.2.3Floating-Point Types and Values59 4.2.4Floating-Point Operations61 4.2.5The boolean Type and boolean Values63 4.3.1Objects66 4.3.2The Class Object68 4.3.3The Class String69 4.3Reference Types and Values64 4.3.4When Reference Types Are the Same69,9.87,115.58,238.91,341,96,74.83,334.91,190.41,FALSE,FALSE
14,1,BODY,"15.22.1Integer Bitwise Operators &, ^, and |688 15.22.2Boolean Logical Operators &, ^, and |689",9.87,16.58,209.51,95,126,74.83,335.51,91.41,FALSE,FALSE
11,12,BODY,14.14.1.1Initialization of for Statement523 14.14.1.2Iteration of for Statement524 14.14.1.3Abrupt Completion of for Statement525,9.86,27.58,213.65,129,162,456.83,375.65,484.41,FALSE,FALSE
14,2,BODY,15.23Conditional-And Operator &&689 15.24Conditional-Or Operator ||690 15.25Conditional Operator ? :691,9.86,27.58,169.16,103,96,96.83,265.16,124.41,FALSE,FALSE
14,8,BODY,16.1Definite Assignment and Expressions737 16.1.1Boolean Constant Expressions737 16.1.2Conditional-And Operator &&737 16.1.3Conditional-Or Operator ||738 16.1.4Logical Complement Operator !738 16.1.5Conditional Operator ? :738 16.1.6switch Expressions739 16.1.7Other Expressions of Type boolean742 16.1.8Assignment Expressions742 16.1.9Operators ++ and --742 16.1.10Other Expressions743 16.2.1Empty Statements744 16.2.2Blocks744 16.2.3Local Class and Interface Declarations746 16.2.4Local Variable Declaration Statements746 16.2.5Labeled Statements746 16.2.6Expression Statements747 16.2.7if Statements747 16.2.8assert Statements747 16.2.9switch Statements748 16.2.10while Statements749 16.2.11do Statements749 16.2.12for Statements749,9.85,258.58,242.24,735,96,324.83,338.24,583.41,FALSE,FALSE
117,2,BODY,"variable declared by a statement from being used before it has been initialized or otherwise assigned a value. A local variable declared by a pattern is created and initialized when the pattern matches (§14.30.2). The rules of scoping (§6.3) prevent the value of a local variable declared by a pattern from being used unless the pattern has matched. A local variable ceases to exist when its declaration is no longer in scope. Were it not for one exceptional situation, a local variable declared by a statement could always be regarded as being created when the statement is executed. The exceptional situation involves the switch statement (§14.11), where it is possible for control to enter a block but bypass execution of a local variable declaration statement. Because of the restrictions imposed by the rules of definite assignment (§16 (Definite Assignment)), however, the local variable declared by such a bypassed local variable declaration statement cannot be used before it has been definitely assigned a value by an assignment expression (§15.26).",9.85,175.06,342.01,1058,90,76.06,432.01,251.12,FALSE,FALSE
12,1,BODY,14.20.3.1Basic try-with-resources548 14.20.3.2Extended try-with-resources551,9.84,16.58,182.23,76,162,74.83,344.23,91.41,FALSE,FALSE
11,13,BODY,14.14.2The enhanced for statement526,9.83,5.58,170.9,36,126,489.83,296.9,495.41,FALSE,FALSE
771,6,BODY,"Let C be a class declared within the scope of V. Then: •V is definitely assigned before an enum constant (§8.9.1) or static variable initializer (§8.3.2) of C iff V is definitely assigned before the declaration of C. Note that there are no rules that would allow us to conclude that V is definitely unassigned before a static variable initializer or enum constant. We can informally conclude that V is not definitely unassigned before any static variable initializer of C, but there is no need for such a rule to be stated explicitly.",9.83,90.06,360,534,72,395.06,432,485.12,FALSE,FALSE
5,5,BODY,6.3.1Scope for Pattern Variables in Expressions164 6.3.1.1Conditional-And Operator &&164 6.3.1.2Conditional-Or Operator ||165 6.3.1.3Logical Complement Operator !166 6.3.1.4Conditional Operator ? :166 6.3.1.5Pattern Match Operator instanceof167 6.3.1.6switch Expressions167 6.3.1.7Parenthesized Expressions167 6.3.2.1Blocks168 6.3.2.2if Statements168 6.3.2.3while Statements170 6.3.2.4do Statements170 6.3.2.5for Statements170 6.3.2.6switch Statements170 6.3.2.7Labeled Statements171,9.82,170.58,247.12,483,126,258.83,373.12,429.41,FALSE,FALSE
15,2,BODY,"16.2.13break, yield, continue, return, and throw Statements751 16.2.14synchronized Statements751 16.2.15try Statements752 16.3Definite Assignment and Parameters753 16.4Definite Assignment and Array Initializers754 16.5Definite Assignment and Enum Constants754 16.6Definite Assignment and Anonymous Classes755 16.7Definite Assignment and Member Classes and Interfaces755 16.8Definite Assignment and Static Initializers755 16.9Definite Assignment, Constructors, and Instance Initializers756",9.81,104.58,313.01,488,96,85.83,409.01,190.41,FALSE,FALSE
22,3,BODY,1.2Example Programs Most of the example programs given in the text are ready to be executed and are similar in form to: class Test { public static void main(String[] args) { for (int i = 0; i < args.length; i++) System.out.print(i == 0 ? args[i] : ' ' + args[i]); System.out.println(); } },9.8,128.31,363.6,289,72,240.56,435.6,368.87,FALSE,FALSE
11,10,BODY,14.11.2The Switch Block of a switch Statement515 14.11.3Execution of a switch Statement516 14.12.1Abrupt Completion of while Statement520 14.13.1Abrupt Completion of do Statement521 14.14.1The basic for Statement523,9.79,82.58,221.51,215,126,368.83,347.51,451.41,FALSE,FALSE
385,3,BODY,"or implicitly with the @Retention annotation (§9.6.4.2). Specifically: •If the retention of AC is java.lang.annotation.RetentionPolicy.SOURCE, then the retention of A is java.lang.annotation.RetentionPolicy.SOURCE. •If the retention of AC is java.lang.annotation.RetentionPolicy.CLASS, then the retention of A is either java.lang.annotation.RetentionPolicy.CLASS or java.lang.annotation.RetentionPolicy.SOURCE. •If the retention of AC is java.lang.annotation.RetentionPolicy.RUNTIME, then the retention of A is java.lang.annotation.RetentionPolicy.SOURCE, java.lang.annotation.RetentionPolicy.CLASS, or java.lang.annotation.RetentionPolicy.RUNTIME.",9.79,180.14,342,648,90,89.06,432,269.2,FALSE,FALSE
10,7,BODY,13.4.3public Classes462 13.4.4Superclasses and Superinterfaces463 13.4.5Class Type Parameters464 13.4.6Class Body and Member Declarations465 13.4.7Access to Members and Constructors466 13.4.8Field Declarations468 13.4.9final Fields and static Constant Variables470 13.4.10static Fields471 13.4.11transient Fields471 13.4.12Method and Constructor Declarations471 13.4.13Method and Constructor Type Parameters472 13.4.14Method and Constructor Formal Parameters473 13.4.15Method Result Type474 13.4.16abstract Methods474 13.4.17final Methods475 13.4.18native Methods475 13.4.19static Methods476 13.4.20synchronized Methods476 13.4.21Method and Constructor Throws476 13.4.22Method and Constructor Body476 13.4.23Method and Constructor Overloading476 13.4.24Method Overriding477 13.4.25Static Initializers478 13.4.26Evolution of Enum Classes478 13.4.27Evolution of Record Classes478 13.5.1public Interfaces479 13.5.2sealed and non-sealed Interfaces479 13.5.3Superinterfaces480,9.78,313.58,236.39,971,126,280.83,362.39,594.41,FALSE,FALSE
15,7,BODY,17.6Word Tearing785 17.7Non-Atomic Treatment of double and long786,9.78,16.58,227.12,66,96,467.83,323.12,484.41,FALSE,FALSE
243,2,BODY,"is not found in a file under a name composed of the class or interface name plus an extension (such as .java or .jav) if either of the following is true: •The class or interface is referred to by code in other ordinary compilation units of the package in which the class or interface is declared. •The class or interface is declared public (and therefore is potentially accessible from code in other packages). This restriction implies that there must be at most one such class or interface per compilation unit. This restriction makes it easy for a Java compiler to find a named class or interface within a package. In practice, many programmers choose to put each class or interface in its own compilation unit, whether or not it is public or is referred to by code in other compilation units. For example, the source code for a public class wet.sprocket.Toad would be found in a file Toad.java in the directory wet/sprocket, and the corresponding object code would be found in the file Toad.class in the same directory.",9.77,187.06,360.02,1022,72,76.06,432.02,263.12,FALSE,FALSE
6,4,BODY,6.6.1Determining Accessibility198 6.6.2Details on protected Access203,9.74,16.58,175.43,69,126,151.83,301.43,168.41,FALSE,FALSE
11,11,BODY,14.12The while Statement519 14.13The do Statement520 14.14The for Statement522,9.74,49.58,136.15,78,96,390.83,232.15,440.41,FALSE,FALSE
13,13,BODY,"15.20.1Numerical Comparison Operators <, <=, >, and >=681 15.20.2The instanceof Operator682 15.21.1Numerical Equality Operators == and !=685 15.21.2Boolean Equality Operators == and !=686 15.21.3Reference Equality Operators == and !=687",9.74,60.58,256.49,236,126,525.83,382.49,586.41,FALSE,FALSE
181,5,BODY,"It is a compile-time error if any of the following conditions hold: •A pattern variable is both (i) introduced by a when true and (ii) introduced by b when true. •A pattern variable is both (i) introduced by a when false and (ii) introduced by b when false. These two error cases exclude the possibility of both operands of the || operator declaring a pattern variable of the same name. For example, consider the problematic expression (a instanceof String s) || (b instanceof String s). The first error case covers the entire expression evaluating to true, where (if the code were legal) exactly one declaration of a pattern variable s would be initialized depending on whether the left-hand operand or the right-hand operand evaluated to true. Since it cannot be determined at compile time which operand will evaluate to true, and therefore which declaration of s will be",9.74,152.06,360,873,72,449.2,432,601.25,FALSE,FALSE
473,14,BODY,"12.A construct emitted by a Java compiler must be marked as mandated if it corresponds to a formal parameter declared implicitly in source code (§8.8.1, §8.8.9, §8.9.3, §15.9.5.1). The following formal parameters are declared implicitly in source code: •The first formal parameter of a constructor of a non-private inner member class (§8.8.1, §8.8.9). •The first formal parameter of an anonymous constructor of an anonymous class whose superclass is an inner class (not in a static context) (§15.9.5.1).",9.74,112.06,360,503,72,486.06,432,598.12,FALSE,FALSE
45,5,BODY,"TypeIdentifier: Identifier but not permits, record, sealed, var, or yield UnqualifiedMethodIdentifier: Identifier but not yield TypeIdentifier is used in the declaration of classes, interfaces, and type parameters (§8.1, §9.1, §4.4), and when referring to types (§6.5). For example, the name of a class must be a TypeIdentifier, so it is illegal to declare a class named permits, record, sealed, var, or yield.",9.73,108.25,324,410,90,483.13,414,591.38,FALSE,FALSE
599,3,BODY,"Primary: PrimaryNoNewArray ArrayCreationExpression PrimaryNoNewArray: Literal ClassLiteral this TypeName . this ( Expression ) ClassInstanceCreationExpression FieldAccess ArrayAccess MethodInvocation MethodReference This part of the grammar of the Java programming language is unusual, in two ways. First, one might expect simple names, such as names of local variables and method parameters, to be primary expressions. For technical reasons, names are grouped together with primary expressions a little later when postfix expressions are introduced (§15.14). The technical reasons have to do with allowing left-to-right parsing of Java programs with only one-token lookahead. Consider the expressions (z[3]) and (z[]). The first is a parenthesized array access (§15.10.3) and the second is the start of a cast (§15.16). At the point that the look-ahead symbol is [, a left-to-right parse will have reduced the z to the nonterminal Name. In the context of a cast we prefer not to have to reduce the name to a Primary, but if Name were one of the alternatives for Primary, then we could not tell whether to do the reduction (that is, we could not determine whether the current situation would turn out to be a parenthesized array access or a cast) without looking ahead two tokens, to the token following the [. The grammar presented here avoids the problem by keeping Name and Primary separate and allowing either in certain other syntax rules (those for ClassInstanceCreationExpression, MethodInvocation, ArrayAccess, and PostfixExpression, though not FieldAccess because it uses an identifier directly). This strategy effectively defers the question of whether a Name should be treated as a Primary until more context can be examined. The second unusual feature avoids a potential grammatical ambiguity in the expression 'new int[3][3]' which in Java always means a single creation of a multidimensional",9.73,421.99,324.01,1905,90,171.13,414.01,593.12,FALSE,FALSE
439,4,BODY,"If no catch clause that can handle an exception can be found, then the current thread (the thread that encountered the exception) is terminated. Before termination, all finally clauses are executed and the uncaught exception is handled according to the following rules: •If the current thread has an uncaught exception handler set, then that handler is executed. •Otherwise, the method uncaughtException is invoked for the ThreadGroup that is the parent of the current thread. If the ThreadGroup and its parent ThreadGroups do not override uncaughtException, then the default handler's uncaughtException method is invoked. In situations where it is desirable to ensure that one block of code is always executed after another, even if that other block of code completes abruptly, a try statement with a finally clause (§14.20.2) may be used. If a try or catch block in a try-finally or try-catch-finally statement completes abruptly, then the finally clause is executed during propagation of the exception, even if no matching catch clause is ultimately found. If a finally clause is executed because of abrupt completion of a try block and the finally clause itself completes abruptly, then the reason for the abrupt completion of the try block is discarded and the new reason for abrupt completion is propagated from there. The exact rules for abrupt completion and for the catching of exceptions are specified in detail with the specification of each statement in §14 (Blocks, Statements, and Patterns) and for expressions in §15 (Expressions) (especially §15.6).",9.72,303.06,360.01,1565,72,195.06,432.01,498.12,FALSE,FALSE
675,2,BODY,"For each non-static member method m of U, if the function type of U has a subsignature of the signature of m, then a notional method whose method type is the function type of U is said to override m, and any compile-time error or unchecked warning specified in §8.4.8.3 may occur. For each checked exception type X listed in the throws clause of the invocation type of the compile-time declaration, X or a superclass of X must be mentioned in the throws clause of the function type of U, or a compile-time error occurs. The key idea driving the compatibility definition is that a method reference is compatible if and only if the equivalent lambda expression (x, y, z) -> exp.<T1, T2>method(x, y, z) is compatible. (This is informal, and there are issues that make it difficult or impossible to formally define the semantics in terms of such a rewrite.) These compatibility rules provide a convenient facility for converting from one functional interface to another: Task t = () -> System.out.println('hi'); Runnable r = t::invoke;",9.72,205.05,360.01,1031,72,76.06,432.01,281.11,FALSE,FALSE
11,7,BODY,14.10The assert Statement497 14.11The switch Statement500 14.11.1Switch Blocks500,9.71,27.58,145.06,81,96,302.83,241.06,330.41,FALSE,FALSE
826,4,BODY,"•The method invocation expression is compatible with T if B3 does not contain the bound false and resolution of all the inference variables in B3 succeeds (§18.4). Consider the example from the previous section: List<Number> ln = Arrays.asList(1, 2.0);",9.7,62.04,360,252,72,487.06,432,549.11,FALSE,FALSE
397,2,BODY,"It is a compile-time error if a fixed arity method or constructor declaration is annotated with the annotation @SafeVarargs. It is a compile-time error if a variable arity method declaration that is neither static nor final nor private is annotated with the annotation @SafeVarargs. Since @SafeVarargs is only applicable to static methods, final and/or private instance methods, and constructors, the annotation is not usable where method overriding occurs. Annotation inheritance only works for annotations on classes (not on methods, interfaces, or constructors), so an @SafeVarargs-style annotation cannot be passed through instance methods in classes or through interfaces.",9.68,113.06,360,677,72,76.06,432,189.12,FALSE,FALSE
70,9,BODY,Operator: (one of) =   >   <   !   ~   ?   :   -> ==  >=  <=  !=  &&  ||  ++  -- +   -   *   /   &   |   ^   %   <<   >>   >>> +=  -=  *=  /=  &=  |=  ^=  %=  <<=  >>=  >>>=,9.67,69.24,258.4,173,90,481.13,348.4,550.37,FALSE,FALSE
100,4,BODY,4.10.1Subtyping among Primitive Types The following rules define the direct supertype relation among the primitive types: •double >1 float •float >1 long •long >1 int •int >1 char •int >1 short •short >1 byte,9.67,141.11,360.01,208,72,390.09,432.01,531.2,FALSE,FALSE
185,4,BODY,"The following rules apply to a statement if (e) S else T (§14.9.2): •A pattern variable introduced by e when true is definitely matched at S. •A pattern variable introduced by e when false is definitely matched at T. •A pattern variable is introduced by if (e) S else T iff either: –It is introduced by e when true, and S can complete normally, and T cannot complete normally; or –It is introduced by e when false, and S cannot complete normally, and T can complete normally. These rules highlight the flow-like nature of scoping for pattern variables. For example, in the following statement: if (e instanceof String s) { counter += s.length(); } else { System.out.println(e);  // s not in scope }",9.67,220.05,360,698,72,186.06,432,406.11,FALSE,FALSE
460,7,BODY,"We encourage implementations to treat such objects as having a finalizer that is not overridden, and to finalize them more efficiently, as described in §12.6.1. A finalizer may be invoked explicitly, just like any other method.",9.67,40.1,342,227,72,550.1,414,590.2,FALSE,FALSE
15,6,BODY,17.5final Field Semantics780,9.64,5.58,142.27,28,96,412.83,238.27,418.41,FALSE,FALSE
46,4,BODY,Keyword: ReservedKeyword ContextualKeyword ReservedKeyword: (one of) abstract   continue   for          new         switch assert     default    if           package     synchronized boolean    do         goto         private     this break      double     implements   protected   throw byte       else       import       public      throws case       enum       instanceof   return      transient catch      extends    int          short       try char       final      interface    static      void class      finally    long         strictfp    volatile const      float      native       super       while _ (underscore) ContextualKeyword: (one of) exports      opens      requires     uses   yield module       permits    sealed       var non-sealed   provides   to           when open         record     transitive   with,9.64,325.24,328.6,828,90,239.13,418.6,564.37,FALSE,FALSE
97,2,BODY,"•At an assignment to a field: if the type of the Primary in the field access expression (§15.11) is a raw type, then a compile-time unchecked warning occurs if erasure changes the field's type. •At an invocation of a method or constructor: if the type of the class or interface to search (§15.12.1) is a raw type, then a compile-time unchecked warning occurs if erasure changes any of the formal parameter types of the method or constructor. •No compile-time unchecked warning occurs for a method call when the formal parameter types do not change under erasure (even if the return type and/or throws clause changes), for reading from a field, or for a class instance creation of a raw type. Note that the unchecked warnings above are distinct from the unchecked warnings possible from narrowing reference conversion (§5.1.6), unchecked conversion (§5.1.9), method declarations (§8.4.1, §8.4.8.3), and certain expressions (§15.12.4.2, §15.13.2, §15.27.3). The warnings here cover the case where a legacy consumer uses a generified library. For example, the library declares a generic class Foo<T extends String> that has a field f of type Vector<T>, but the consumer assigns a vector of integers to e.f where e has the raw type Foo. The legacy consumer receives a warning because it may have caused heap pollution (§4.12.2) for generified consumers of the generified library. (Note that the legacy consumer can assign a Vector<String> from the library to its own Vector variable without receiving a warning. That is, the subtyping rules (§4.10.2) of the Java programming language make it possible for a variable of a raw type to be assigned a value of any of the type's parameterized instances.) The warnings from unchecked conversion cover the dual case, where a generified consumer uses a legacy library. For example, a method of the library has the raw return type Vector, but the consumer assigns the result of the method invocation to a variable of type Vector<String>. This is unsafe, since the raw vector might have had a different element type than String, but is still permitted using unchecked conversion in order to enable interfacing with legacy code. The warning from unchecked conversion indicates that the generified consumer may experience problems from heap pollution at other points in the program.",9.63,383.06,360.01,2316,72,76.06,432.01,459.12,FALSE,FALSE
110,2,BODY,"creation expression or method invocation expression or method reference expression (§8.8.7.1, §15.9, §15.12, §15.13). •The following type contexts require that if a type is a parameterized reference type, it has only unbounded wildcard type arguments (i.e. it is a reifiable type) : –As the element type in an array creation expression (§15.10.1) –As the type that follows the instanceof relational operator (§15.20.2) •The following type contexts disallow a parameterized reference type altogether, because they involve exceptions and the type of an exception is non-generic (§6.1): –As the type of an exception that can be thrown by a method or constructor (§8.4.6, §8.8.5, §9.4) –In an exception parameter declaration (§14.20) In any type context where a type is used, it is possible to annotate the keyword denoting a primitive type or the Identifier denoting the simple name of a reference type. It is also possible to annotate an array type by writing an annotation to the left of the [ at the desired level of nesting in the array type. Annotations in these locations are called type annotations, and are specified in §9.7.4. Here are some examples: •@Foo int[] f; annotates the primitive type int •int @Foo [] f; annotates the array type int[] •int @Foo [][] f; annotates the array type int[][] •int[] @Foo [] f; annotates the array type int[] which is the component type of the array type int[][] Some of the type contexts which appear in declarations occupy the same syntactic real estate as a number of declaration contexts (§9.6.4.1): •The return type of a method (including the type of an element of an annotation interface) •The type in a field declaration of a class or interface (including an enum constant) •The type in a formal parameter declaration of a method, constructor, or lambda expression •The type in a local variable declaration •The type in an exception parameter declaration •The type in a record component declaration of a record class The fact that the same syntactic location in a program can be both a type context and a declaration context arises because the modifiers for a declaration immediately precede the type of the declared entity. §9.7.4 explains how an annotation in such a location is deemed to appear in a type context or a declaration context or both.",9.63,523.06,360.01,2299,72,76.06,432.01,599.12,FALSE,FALSE
243,4,BODY,"A 'dependence' is what is expressed by a requires directive, independent of whether a module exists with the name specified by the directive. A 'dependency' is the observable module enumerated by resolution (as described in the java.lang.module package specification) for a given requires directive. Generally, the rules of the Java programming language are more interested in dependences than dependencies. ModuleDeclaration: {Annotation} [open] module Identifier {. Identifier} { {ModuleDirective} }",9.63,96.08,324,501,90,405.1,414,501.18,FALSE,FALSE
181,3,BODY,"It is a compile-time error if any of the following conditions hold: •A pattern variable is both (i) introduced by a when true and (ii) introduced by b when true. •A pattern variable is both (i) introduced by a when false and (ii) introduced by b when false. These two error cases exclude the possibility of both operands of the && operator declaring a pattern variable of the same name. For example, consider the problematic expression (a instanceof String s) && (b instanceof String s). The first error case covers the entire expression evaluating to true, where (if the code were legal) two declarations of a pattern variable s would need to be initialized, given that both the left-hand operand and the right-hand operand evaluated to true. Since there is no way to distinguish the two variables called s in the rest of the program, the entire expression is considered erroneous. The second error case covers the opposite scenario where the entire expression evaluates to false.",9.59,172.06,360,981,72,118.06,432,290.12,FALSE,FALSE
47,7,BODY,"•For yield, when recognized as a terminal in a YieldStatement (§14.21). In other contexts, attempting to use the yield as an identifier will cause an error, because yield is neither a TypeIdentifier nor a UnqualifiedMethodIdentifier.",9.58,38.06,325.09,233,90,482.06,415.09,520.12,FALSE,FALSE
390,9,BODY,Corresponds to java.lang.annotation.ElementType.FIELD,9.57,6.14,274.86,53,90,235.06,364.86,241.2,FALSE,FALSE
819,2,BODY,"•Given a dependency α = β, every bound of α matches a bound of β, and vice versa. •Given a dependency α <: β, every lower bound of α is a lower bound of β, and every upper bound of β is an upper bound of α. The assertion that incorporation reaches a fixed point oversimplifies the matter slightly. Building on the work of Kennedy and Pierce, On Decidability of Nominal Subtyping with Variance, this property can be proven by making the argument that the set of types that may appear in the bound set is finite. The argument relies on two assumptions: •New capture variables are not generated when reducing subtyping constraints (§18.2.3). •Expansive inheritance paths are not pursued. This specification does not currently guarantee these properties (it is imprecise about the handling of wildcards when reducing subtyping constraints, and does not detect expansive inheritance paths), but may do so in a future version. (This is not a new problem: the Java subtyping algorithm is also at risk of non-termination.)",9.57,193.06,360,1014,72,76.06,432,269.12,FALSE,FALSE
389,4,BODY,Corresponds to java.lang.annotation.ElementType.MODULE,9.56,6.14,280.26,54,90,462.2,370.26,468.33,FALSE,FALSE
6,5,BODY,6.6.2.1Access to a protected Member203 6.6.2.2Access to a protected Constructor203,9.55,16.58,207.04,82,162,173.83,369.04,190.41,FALSE,FALSE
389,6,BODY,Corresponds to java.lang.annotation.ElementType.PACKAGE,9.55,6.14,285.66,55,90,500.2,375.66,506.33,FALSE,FALSE
14,5,BODY,15.28switch Expressions725,9.54,5.58,131.35,26,96,250.83,227.35,256.41,FALSE,FALSE
102,2,BODY,"•If S and T are both reference types, then S[] >1 T[] iff S >1 T. •Object >1 Object[] •Cloneable >1 Object[] •java.io.Serializable >1 Object[] •If P is a primitive type, then: –Object >1 P[] –Cloneable >1 P[] –java.io.Serializable >1 P[]",9.54,139.14,279.3,237,72,76.06,351.3,215.2,FALSE,FALSE
103,2,BODY,"•Let MEC, the minimal erased candidate set for U1, ..., Uk, be: MEC = { V | V in EC, and for all W ≠ V in EC, it is not the case that W <: V } Because we are seeking to infer more precise types, we wish to filter out any candidates that are supertypes of other candidates. This is what computing MEC accomplishes. In our running example, we had EC = { List, Collection, Object }, so MEC = { List }. The next step is to recover type arguments for the erased types in MEC.",9.54,77.06,342.01,470,72,76.06,414.01,153.12,FALSE,FALSE
11,14,BODY,14.15The break Statement530 14.16The continue Statement532 14.17The return Statement534 14.18The throw Statement535 14.19The synchronized Statement537 14.20The try statement538 14.20.1Execution of try-catch542 14.20.2Execution of try-finally and try-catch-finally543 14.20.3try-with-resources545,9.53,93.58,293.31,295,96,500.83,389.31,594.41,FALSE,FALSE
11,6,BODY,14.9.1The if-then Statement496 14.9.2The if-then-else Statement497,9.51,16.58,173.41,66,126,280.83,299.41,297.41,FALSE,FALSE
390,5,BODY,Corresponds to java.lang.annotation.ElementType.CONSTRUCTOR,9.51,6.14,307.26,59,90,146.06,397.26,152.2,FALSE,FALSE
455,8,BODY,"12.Acquire LC, label the Class object for C as erroneous, notify all waiting threads, release LC, and complete this procedure abruptly with reason E or its replacement as determined in the previous step. An implementation may optimize this procedure by eliding the lock acquisition in step 1 (and release in step 4/5) when it can determine that the initialization of the class has already completed, provided that, in terms of the memory model, all happens-before orderings that would exist if the lock were acquired, still exist when the optimization is performed. Code generators need to preserve the points of possible initialization of a class or interface, inserting an invocation of the initialization procedure described above. If this initialization procedure completes normally and the Class object is fully initialized and ready for use, then the invocation of the initialization procedure is no longer necessary and it may be",9.51,136.06,360,936,72,456.06,432,592.12,FALSE,FALSE
198,10,BODY,"for a member method or as the class type or array type to construct. The extraction of a TypeName from the identifiers of a ReferenceType in the 17 contexts above is intended to apply recursively to all sub-terms of the ReferenceType, such as its element type and any type arguments.",9.5,48.06,324,283,90,529.06,414,577.12,FALSE,FALSE
587,2,BODY,"Table 15.4-A. Correspondence with IEEE 754 operations Operator/ConversionIEEE 754 operation The numerical comparison operators <, <=, >,compareQuietLess, compareQuietLessEqual, and >= (§15.20.1)",9.5,56.28,357.75,194,72,76.09,429.75,132.37,FALSE,FALSE
356,4,BODY,"The declaration of a (non-compact) canonical constructor must satisfy all of the following conditions, or a compile-time error occurs: •Each formal parameter in the formal parameter list must have the same name and declared type as the corresponding record component. A formal parameter must be a variable arity parameter if and only if the corresponding record component is a variable arity record component. •The constructor must not be generic (§8.8.4). •The constructor must not have a throws clause. •The constructor body must not contain an explicit constructor invocation statement (§8.8.7.1). •All the other rules for constructor declarations in a normal class declaration must be satisfied (§8.8). A consequence of these rules is that the annotations on a record component can differ from the annotations on the corresponding formal parameter of an explicitly declared canonical constructor. For example, the following record declaration is valid: import java.lang.annotation.Target; import java.lang.annotation.ElementType;  @interface Foo {} @interface Bar {}  record Person(@Foo String name) { Person(@Bar String name) { this.name = name; } }",9.49,348.04,360.01,1154,72,234.2,432.01,582.24,FALSE,FALSE
759,6,BODY,"There is a piece of subtle reasoning behind the assertion that a variable V can be known to be definitely unassigned after a method invocation expression. Taken by itself, at face value and without qualification, such an assertion is not always true, because an invoked method can perform assignments. But it must be remembered that, for the purposes of the Java programming language, the concept of definite unassignment is applied only to blank final variables. If V is a blank final local variable, then only the method to which its declaration belongs can perform assignments to V. If V is a blank final field, then only a constructor or an initializer for the class containing the declaration for V can perform assignments to V; no method can perform assignments to V. Finally, explicit constructor invocations (§8.8.7.1) are handled specially (§16.9); although they are syntactically similar to expression statements containing method invocations, they are not expression statements and therefore the rules of this section do not apply to explicit constructor invocations. If an expression is a lambda expression, then the following rules apply: •V is [un]assigned after the expression iff V is [un]assigned before the expression. •V is definitely assigned before the expression or block that is the lambda body (§15.27.2) iff V is definitely assigned before the lambda expression.",9.48,191.1,360,1387,72,372.1,432,563.2,FALSE,FALSE
10,6,BODY,13.4.2.1sealed Classes461 13.4.2.2non-sealed Classes462 13.4.2.3final Classes462,9.47,27.58,146.7,80,162,247.83,308.7,275.41,FALSE,FALSE
232,6,BODY,"The package name mentioned in a package declaration must be the fully qualified name of the package (§6.7). The scope and shadowing of a package declaration is specified in §6.3 and §6.4. The rules concerning annotation modifiers for a package declaration are specified in §9.7.4 and §9.7.5. At most one annotated package declaration is permitted for a given package. The manner in which this restriction is enforced must, of necessity, vary from implementation to implementation. The following scheme is strongly recommended for file-system-based implementations: The sole annotated package declaration, if it exists, is placed in a source file called package-info.java in the directory containing the source files for the package. This file does not contain the source for a class called package-info; indeed it would be illegal for it to do so, as package-info is not a legal identifier. Typically package-info.java contains only a package declaration, preceded immediately by the annotations on the package. While the file could technically contain the source code for one or more classes with package access, it would be very bad form. It is recommended that package-info.java, if it is present, take the place of package.html for javadoc and other similar documentation generation systems. If this file is present, the documentation generation tool should look for the package documentation comment immediately preceding the (possibly annotated) package declaration in package-info.java. In this way, package-info.java becomes the sole repository for package-level annotations and documentation. If, in future, it becomes desirable to add any other package-level information, this file should prove a convenient home for this information.",9.43,283.06,360.01,1744,72,285.06,432.01,568.12,FALSE,FALSE
7,4,BODY,8.3.1.1static Fields268 8.3.1.2final Fields272 8.3.1.3transient Fields272 8.3.1.4volatile Fields272,9.42,38.58,136.23,99,162,118.83,298.23,157.41,FALSE,FALSE
7,7,BODY,8.4.3.1abstract Methods284 8.4.3.2static Methods286 8.4.3.3final Methods287 8.4.3.4native Methods288 8.4.3.5strictfp Methods288 8.4.3.6synchronized Methods288,9.42,60.58,161.54,158,162,228.83,323.54,289.41,FALSE,FALSE
8,7,BODY,9.1.1.1abstract Interfaces345 9.1.1.2strictfp Interfaces345 9.1.1.3static Interfaces345 9.1.1.4sealed and non-sealed Interfaces346,9.42,38.58,205.08,130,162,225.83,367.08,264.41,FALSE,FALSE
6,14,BODY,"8.1.1.1abstract Classes240 8.1.1.2sealed, non-sealed, and final Classes242 8.1.1.3strictfp Classes243 8.1.1.4static Classes243",9.34,38.58,227.76,126,162,508.83,389.76,547.41,FALSE,FALSE
464,2,BODY,"12.7Unloading of Classes and Interfaces An implementation of the Java programming language may unload classes. A class or interface may be unloaded if and only if its defining class loader may be reclaimed by the garbage collector as discussed in §12.6. Classes and interfaces loaded by the bootstrap loader may not be unloaded. Class unloading is an optimization that helps reduce memory use. Obviously, the semantics of a program should not depend on whether and how a system chooses to implement an optimization such as class unloading. To do otherwise would compromise the portability of programs. Consequently, whether a class or interface has been unloaded or not should be transparent to a program. However, if a class or interface C was unloaded while its defining loader was potentially reachable, then C might be reloaded. One could never ensure that this would not happen. Even if the class was not referenced by any other currently loaded class, it might be referenced by some class or interface, D, that had not yet been loaded. When D is loaded by C's defining loader, its execution might cause reloading of C. Reloading may not be transparent if, for example, the class has static variables (whose state would be lost), static initializers (which may have side effects), or native methods (which may retain static state). Furthermore, the hash value of the Class object is dependent on its identity. Therefore it is, in general, impossible to reload a class or interface in a completely transparent manner. Since we can never guarantee that unloading a class or interface whose loader is potentially reachable will not cause reloading, and reloading is never transparent, but unloading must be transparent, it follows that one must not unload a class or interface while its loader is potentially reachable. A similar line of reasoning can be used to deduce that classes and interfaces loaded by the bootstrap loader can never be unloaded. One must also argue why it is safe to unload a class C if its defining class loader can be reclaimed. If the defining loader can be reclaimed, then there can never be any live references to it (this includes references that are not live, but might be resurrected by finalizers). This, in turn, can only be true if there are can never be any live references to any of the classes defined by that loader, including C, either from their instances or from code. Class unloading is an optimization that is only significant for applications that load large numbers of classes and that stop using most of those classes after some time. A prime example of such an application is a web browser, but there are others. A characteristic of such applications is that they manage classes through explicit use of class loaders. As a result, the policy outlined above works well for them. Strictly speaking, it is not essential that the issue of class unloading be discussed by this specification, as class unloading is merely an optimization. However, the issue is very subtle, and so it is mentioned here by way of clarification.",9.31,501.56,360.01,3069,72,77.56,432.01,579.12,FALSE,FALSE
10,5,BODY,"13.4.1abstract Classes461 13.4.2sealed, non-sealed, and final Classes461",9.22,16.58,219.76,72,126,225.83,345.76,242.41,FALSE,FALSE
413,5,BODY,"the following constraints: –E is mentioned in one of the throws clauses. –For each throws clause, E is a subtype of some type named in that clause. When some return types in M are raw and others are not, the definition of a function type tries to choose the most specific type, if possible. For example, if the return types are LinkedList and LinkedList<String>, then the latter is immediately chosen as the function type's return type. When there is no most specific type, the definition compensates by finding the most substitutable return type. For example, if there is a third return type, List<?>, then it is not the case that one of the return types is a subtype of every other (as raw LinkedList is not a subtype of List<?>); instead, LinkedList<String> is chosen as the function type's return type because it is return-type-substitutable for both LinkedList and List<?>. The goal driving the definition of a function type's thrown exception types is to support the invariant that a method with the resulting throws clause could override each abstract method of the functional interface. Per §8.4.6, this means the function type cannot throw 'more' exceptions than any single method in the set M, so we look for as many exception types as possible that are 'covered' by every method's throws clause.",9.21,208.06,342.01,1306,90,204.06,432.01,412.12,FALSE,FALSE
156,2,BODY,Table 5.5-B. Casting to reference types To → From ↓ byte------- short------- char------- int------- long------- float------- double------- boolean------- Byte------- Short------- Character------- Integer------- Long------- Float------- Double------- Boolean------- Object,9.1,398.13,304.95,271,72,76.09,376.95,474.22,FALSE,FALSE
155,2,BODY,"Table 5.5-A. Casting to primitive types To → From ↓ byte short char int long float double boolean------- ηηηηηη≈ Byte ηηηηη≈ω Short-- ηηηη≈ωω - Character-- ηηη≈ωωω Integer--- ηη≈ωωωω Long---- η≈ηωωωω Float----- ≈ωωηωωωω Double------- - Boolean------- - ⊗ Object - ⊗⊗,ω - ⊗⊗,ω⊗,ω - ⊗⊗,ω⊗,ω⊗,ω - ⊗⊗,ω⊗,ω⊗,ω⊗,ω ≈ ⊗⊗,ω⊗,ω⊗,ω⊗,ω ⊗⊗,ω⊗,ω⊗,ω⊗,ω⊗,ω",9.05,398.13,342.78,340,72,76.09,414.78,474.22,FALSE,FALSE
18,0,BODY,1.1Organization of the Specification,9,4.95,157.32,36,36,40.15,193.32,45.1,FALSE,TRUE
18,1,BODY,INTRODUCTION,9,4.95,65.5,12,366.5,40.15,432,45.1,FALSE,TRUE
19,0,BODY,INTRODUCTION,9,4.95,65.5,12,72,40.15,137.5,45.1,FALSE,TRUE
19,1,BODY,Organization of the Specification1.1,9,4.95,157.32,36,310.68,40.15,468,45.1,FALSE,TRUE
20,0,BODY,1.1Organization of the Specification,9,4.95,157.32,36,36,40.15,193.32,45.1,FALSE,TRUE
20,1,BODY,INTRODUCTION,9,4.95,65.5,12,366.5,40.15,432,45.1,FALSE,TRUE
21,0,BODY,INTRODUCTION,9,4.95,65.5,12,72,40.15,137.5,45.1,FALSE,TRUE
21,1,BODY,Organization of the Specification1.1,9,4.95,157.32,36,310.68,40.15,468,45.1,FALSE,TRUE
22,0,BODY,1.2Example Programs,9,4.95,106.43,19,36,40.15,142.43,45.1,FALSE,TRUE
22,1,BODY,INTRODUCTION,9,4.95,65.5,12,366.5,40.15,432,45.1,FALSE,TRUE
22,5,BODY,"javac Test.java java Test Hello, world.",9,14.75,124.2,39,90,419.12,214.2,433.87,FALSE,FALSE
23,0,BODY,INTRODUCTION,9,4.95,65.5,12,72,40.15,137.5,45.1,FALSE,TRUE
23,1,BODY,Relationship to Predefined Classes and Interfaces1.4,9,4.95,217.87,52,250.13,40.15,468,45.1,FALSE,TRUE
23,3,BODY,"This is non-normative text. It provides intuition, rationale, advice, examples, etc.",9,5.02,290.97,84,90,157.1,380.97,162.12,FALSE,FALSE
24,0,BODY,1.5Preview Features,9,4.95,100.44,19,36,40.15,136.44,45.1,FALSE,TRUE
24,1,BODY,INTRODUCTION,9,4.95,65.5,12,366.5,40.15,432,45.1,FALSE,TRUE
25,0,BODY,INTRODUCTION,9,4.95,65.5,12,72,40.15,137.5,45.1,FALSE,TRUE
25,1,BODY,Preview Features1.5,9,4.95,100.44,19,367.56,40.15,468,45.1,FALSE,TRUE
25,3,BODY,"When preview features are enabled, Java compilers are strongly encouraged to give a non-suppressible warning for every source code reference to a preview language feature. Details of this warning are beyond the scope of this specification, but the intent should be to alert programmers to the possibility of code being affected by future changes to preview language features.",9,45.02,314,375,100,176.1,414,221.12,FALSE,FALSE
26,0,BODY,1.6Feedback,9,4.95,70.98,11,36,40.15,106.98,45.1,FALSE,TRUE
26,1,BODY,INTRODUCTION,9,4.95,65.5,12,366.5,40.15,432,45.1,FALSE,TRUE
27,0,BODY,INTRODUCTION,9,4.95,65.5,12,72,40.15,137.5,45.1,FALSE,TRUE
27,1,BODY,References1.7,9,4.95,75.48,13,392.52,40.15,468,45.1,FALSE,TRUE
30,0,BODY,2.3The Syntactic Grammar,9,4.95,123.86,24,36,40.15,159.86,45.1,FALSE,TRUE
30,1,BODY,GRAMMARS,9,4.95,47.99,8,384.01,40.15,432,45.1,FALSE,TRUE
30,6,BODY,"For example, the syntactic production:",9,5.02,138.74,38,90,413.1,228.74,418.12,FALSE,FALSE
30,10,BODY,"For example, the syntactic production:",9,5.02,138.74,38,90,547.1,228.74,552.12,FALSE,FALSE
30,11,BODY,"ArgumentList: Argument {, Argument}",9,14.95,94.94,35,108,569.15,202.94,584.1,FALSE,TRUE
31,0,BODY,GRAMMARS,9,4.95,47.99,8,72,40.15,119.99,45.1,FALSE,TRUE
31,1,BODY,Grammar Notation2.4,9,4.95,106,19,362,40.15,468,45.1,FALSE,TRUE
31,2,BODY,"states that an ArgumentList consists of an Argument, followed by zero or more occurrences of a comma and an Argument. The result is that an ArgumentList may contain any positive number of arguments.",9,25.02,324.01,198,90,74.1,414.01,99.12,FALSE,FALSE
31,4,BODY,This means that:,9,5.02,59.5,16,90,180.1,149.5,185.12,FALSE,FALSE
31,6,BODY,is a convenient abbreviation for:,9,5.02,116.48,33,90,234.1,206.48,239.12,FALSE,FALSE
31,8,BODY,"As another example, it means that:",9,5.02,124.98,34,90,298.1,214.98,303.12,FALSE,FALSE
31,10,BODY,is a convenient abbreviation for:,9,5.02,116.48,33,90,352.1,206.48,357.12,FALSE,FALSE
31,12,BODY,which in turn is an abbreviation for:,9,5.02,129.48,37,90,416.1,219.48,421.12,FALSE,FALSE
31,14,BODY,which in turn is an abbreviation for:,9,5.02,129.48,37,90,500.1,219.48,505.12,FALSE,FALSE
32,0,BODY,2.4Grammar Notation,9,4.95,106,19,36,40.15,142,45.1,FALSE,TRUE
32,1,BODY,GRAMMARS,9,4.95,47.99,8,384.01,40.15,432,45.1,FALSE,TRUE
32,3,BODY,so the nonterminal BasicForStatement actually has eight alternative right-hand sides.,9,5.02,305.96,85,90,176.1,395.96,181.12,FALSE,FALSE
32,5,BODY,"For example, the syntactic grammar contains this production:",9,5.02,220.98,60,90,236.1,310.98,241.12,FALSE,FALSE
32,6,BODY,NormalClassDeclaration: {ClassModifier} class TypeIdentifier [TypeParameters] [ClassExtends] [ClassImplements] [ClassPermits] ClassBody,9,24.95,246.51,135,108,258.15,354.51,283.1,FALSE,TRUE
32,7,BODY,which defines one right-hand side for the nonterminal NormalClassDeclaration.,9,5.02,289.22,77,90,300.1,379.22,305.12,FALSE,FALSE
32,9,BODY,"For example, the lexical grammar contains the production:",9,5.02,210.97,57,90,360.1,300.97,365.12,FALSE,FALSE
32,10,BODY,ZeroToThree: (one of) 0 1 2 3,9,24.75,50.5,29,108,382.15,158.5,406.9,FALSE,TRUE
32,11,BODY,which is merely a convenient abbreviation for:,9,5.02,167.97,46,90,424.1,257.97,429.12,FALSE,FALSE
32,14,BODY,"Thus, the production: BooleanLiteral: (one of) true false",9,47,78.85,57,90,543.1,168.85,590.1,FALSE,FALSE
33,0,BODY,GRAMMARS,9,4.95,47.99,8,72,40.15,119.99,45.1,FALSE,TRUE
33,1,BODY,Grammar Notation2.4,9,4.95,106,19,362,40.15,468,45.1,FALSE,TRUE
33,2,BODY,is shorthand for:,9,5.02,58.99,17,90,74.1,148.99,79.12,FALSE,FALSE
33,5,BODY,For example: Identifier: IdentifierChars but not a ReservedKeyword or BooleanLiteral or NullLiteral,9,47.18,251.49,99,90,186.1,341.49,233.28,FALSE,TRUE
33,7,BODY,For example:,9,5.02,47.74,12,90,285.31,137.74,290.33,FALSE,FALSE
33,8,BODY,RawInputCharacter: any Unicode character,9,15.02,90.96,40,108,307.37,198.96,322.39,FALSE,FALSE
36,0,BODY,3.2Lexical Translations,9,4.95,110.86,23,36,40.15,146.86,45.1,FALSE,TRUE
36,1,BODY,LEXICAL STRUCTURE,9,4.95,88.36,17,343.64,40.15,432,45.1,FALSE,TRUE
36,5,BODY,ASCII (ANSI X3.4) is the American Standard Code for Information Interchange. The first 128 characters of the Unicode UTF-16 encoding are the ASCII characters.,9,15.02,324,158,90,308.1,414,323.12,FALSE,FALSE
37,0,BODY,LEXICAL STRUCTURE,9,4.95,88.39,17,72,40.15,160.39,45.1,FALSE,TRUE
37,1,BODY,Unicode Escapes3.3,9,4.95,98.87,18,369.13,40.15,468,45.1,FALSE,TRUE
38,0,BODY,3.3Unicode Escapes,9,4.95,98.87,18,36,40.15,134.87,45.1,FALSE,TRUE
38,1,BODY,LEXICAL STRUCTURE,9,4.95,88.39,17,343.6,40.15,432,45.1,FALSE,TRUE
39,0,BODY,LEXICAL STRUCTURE,9,4.95,88.39,17,72,40.15,160.39,45.1,FALSE,TRUE
39,1,BODY,Unicode Escapes3.3,9,4.95,98.87,18,369.13,40.15,468,45.1,FALSE,TRUE
40,0,BODY,3.4Line Terminators,9,4.95,99.39,19,36,40.15,135.39,45.1,FALSE,TRUE
40,1,BODY,LEXICAL STRUCTURE,9,4.95,88.39,17,343.61,40.15,432,45.1,FALSE,TRUE
41,0,BODY,LEXICAL STRUCTURE,9,4.95,88.28,17,72,40.15,160.28,45.1,FALSE,TRUE
41,1,BODY,Input Elements and Tokens3.5,9,4.95,135.3,28,332.7,40.15,468,45.1,FALSE,TRUE
42,0,BODY,3.6White Space,9,4.95,81.43,14,36,40.15,117.43,45.1,FALSE,TRUE
42,1,BODY,LEXICAL STRUCTURE,9,4.95,88.45,17,343.55,40.15,432,45.1,FALSE,TRUE
43,0,BODY,LEXICAL STRUCTURE,9,4.95,88.48,17,72,40.15,160.48,45.1,FALSE,TRUE
43,1,BODY,Comments3.7,9,4.95,74,11,394,40.15,468,45.1,FALSE,TRUE
44,0,BODY,3.8Identifiers,9,4.95,73,14,36,40.15,109,45.1,FALSE,TRUE
44,1,BODY,LEXICAL STRUCTURE,9,4.95,88.48,17,343.52,40.15,432,45.1,FALSE,TRUE
45,0,BODY,LEXICAL STRUCTURE,9,4.95,88.48,17,72,40.15,160.48,45.1,FALSE,TRUE
45,1,BODY,Identifiers3.8,9,4.95,73,14,395,40.15,468,45.1,FALSE,TRUE
46,0,BODY,3.9Keywords,9,4.95,72,11,36,40.15,108,45.1,FALSE,TRUE
46,1,BODY,LEXICAL STRUCTURE,9,4.95,88.48,17,343.52,40.15,432,45.1,FALSE,TRUE
47,0,BODY,LEXICAL STRUCTURE,9,4.95,88.48,17,72,40.15,160.48,45.1,FALSE,TRUE
47,1,BODY,Keywords3.9,9,4.95,72,11,396,40.15,468,45.1,FALSE,TRUE
48,0,BODY,3.10Literals,9,4.95,64.01,12,36,40.15,100.01,45.1,FALSE,TRUE
48,1,BODY,LEXICAL STRUCTURE,9,4.95,88.51,17,343.49,40.15,432,45.1,FALSE,TRUE
49,0,BODY,LEXICAL STRUCTURE,9,4.95,88.51,17,72,40.15,160.51,45.1,FALSE,TRUE
49,1,BODY,Literals3.10,9,4.95,64.01,12,403.99,40.15,468,45.1,FALSE,TRUE
50,0,BODY,3.10Literals,9,4.95,64.01,12,36,40.15,100.01,45.1,FALSE,TRUE
50,1,BODY,LEXICAL STRUCTURE,9,4.95,88.51,17,343.49,40.15,432,45.1,FALSE,TRUE
51,0,BODY,LEXICAL STRUCTURE,9,4.95,88.51,17,72,40.15,160.51,45.1,FALSE,TRUE
51,1,BODY,Literals3.10,9,4.95,64.01,12,403.99,40.15,468,45.1,FALSE,TRUE
52,0,BODY,3.10Literals,9,4.95,64.01,12,36,40.15,100.01,45.1,FALSE,TRUE
52,1,BODY,LEXICAL STRUCTURE,9,4.95,88.51,17,343.49,40.15,432,45.1,FALSE,TRUE
52,4,BODY,The HexDigit production above comes from §3.3.,9,5.02,179.47,46,90,407.1,269.47,412.12,FALSE,FALSE
53,0,BODY,LEXICAL STRUCTURE,9,4.95,88.51,17,72,40.15,160.51,45.1,FALSE,TRUE
53,1,BODY,Literals3.10,9,4.95,64.01,12,403.99,40.15,468,45.1,FALSE,TRUE
54,0,BODY,3.10Literals,9,4.95,64.01,12,36,40.15,100.01,45.1,FALSE,TRUE
54,1,BODY,LEXICAL STRUCTURE,9,4.95,88.51,17,343.49,40.15,432,45.1,FALSE,TRUE
55,0,BODY,LEXICAL STRUCTURE,9,4.95,88.51,17,72,40.15,160.51,45.1,FALSE,TRUE
55,1,BODY,Literals3.10,9,4.95,64.01,12,403.99,40.15,468,45.1,FALSE,TRUE
56,0,BODY,3.10Literals,9,4.95,64.01,12,36,40.15,100.01,45.1,FALSE,TRUE
56,1,BODY,LEXICAL STRUCTURE,9,4.95,88.51,17,343.49,40.15,432,45.1,FALSE,TRUE
57,0,BODY,LEXICAL STRUCTURE,9,4.95,88.51,17,72,40.15,160.51,45.1,FALSE,TRUE
57,1,BODY,Literals3.10,9,4.95,64.01,12,403.99,40.15,468,45.1,FALSE,TRUE
58,0,BODY,3.10Literals,9,4.95,64.01,12,36,40.15,100.01,45.1,FALSE,TRUE
58,1,BODY,LEXICAL STRUCTURE,9,4.95,88.51,17,343.49,40.15,432,45.1,FALSE,TRUE
59,0,BODY,LEXICAL STRUCTURE,9,4.95,88.51,17,72,40.15,160.51,45.1,FALSE,TRUE
59,1,BODY,Literals3.10,9,4.95,64.01,12,403.99,40.15,468,45.1,FALSE,TRUE
60,0,BODY,3.10Literals,9,4.95,64.01,12,36,40.15,100.01,45.1,FALSE,TRUE
60,1,BODY,LEXICAL STRUCTURE,9,4.95,88.51,17,343.49,40.15,432,45.1,FALSE,TRUE
60,6,BODY,"The characters CR and LF are never an InputCharacter; each is recognized as constituting a LineTerminator, so may not appear in a character literal, even in the escape sequence \ LineTerminator.",9,25.02,324,194,90,372.23,414,397.25,FALSE,FALSE
61,0,BODY,LEXICAL STRUCTURE,9,4.95,88.51,17,72,40.15,160.51,45.1,FALSE,TRUE
61,1,BODY,Literals3.10,9,4.95,64.01,12,403.99,40.15,468,45.1,FALSE,TRUE
61,6,BODY,"The characters CR and LF are never an InputCharacter; each is recognized as constituting a LineTerminator, so may not appear in a string literal, even in the escape sequence \ LineTerminator.",9,25.02,324,191,90,525.23,414,550.25,FALSE,FALSE
62,0,BODY,3.10Literals,9,4.95,64.01,12,36,40.15,100.01,45.1,FALSE,TRUE
62,1,BODY,LEXICAL STRUCTURE,9,4.95,88.51,17,343.49,40.15,432,45.1,FALSE,TRUE
62,5,BODY,Example 3.10.5-1. String Literals,9,5.19,127,33,90,378.62,217,383.81,TRUE,FALSE
62,6,BODY,The program consisting of the compilation unit (§7.3):,9,5.02,196.49,54,90,402.1,286.49,407.12,FALSE,FALSE
63,0,BODY,LEXICAL STRUCTURE,9,4.95,88.51,17,72,40.15,160.51,45.1,FALSE,TRUE
63,1,BODY,Literals3.10,9,4.95,64.01,12,403.99,40.15,468,45.1,FALSE,TRUE
63,2,BODY,produces the output:,9,5.02,73.49,20,90,74.1,163.49,79.12,FALSE,FALSE
64,0,BODY,3.10Literals,9,4.95,64.01,12,36,40.15,100.01,45.1,FALSE,TRUE
64,1,BODY,LEXICAL STRUCTURE,9,4.95,88.51,17,343.49,40.15,432,45.1,FALSE,TRUE
64,2,BODY,"WhiteSpace: the ASCII SP character, also known as 'space' the ASCII HT character, also known as 'horizontal tab' the ASCII FF character, also known as 'form feed' LineTerminator LineTerminator: the ASCII LF character, also known as 'newline' the ASCII CR character, also known as 'return' the ASCII CR character followed by the ASCII LF character InputCharacter: UnicodeInputCharacter but not CR or LF UnicodeInputCharacter: UnicodeEscape RawInputCharacter UnicodeEscape: \ UnicodeMarker HexDigit HexDigit HexDigit HexDigit RawInputCharacter: any Unicode character",9,220.78,228.7,564,108,74.15,336.7,294.93,FALSE,TRUE
64,4,BODY,Example 3.10.6-1. Text Blocks,9,5.19,116,29,90,472.62,206,477.81,TRUE,FALSE
64,5,BODY,"When multi-line strings are desired, a text block is usually more readable than a concatenation of string literals. For example, compare these alternative representations of a snippet of HTML:",9,25.02,324,192,90,496.1,414,521.12,FALSE,FALSE
65,0,BODY,LEXICAL STRUCTURE,9,4.95,88.51,17,72,40.15,160.51,45.1,FALSE,TRUE
65,1,BODY,Literals3.10,9,4.95,64.01,12,403.99,40.15,468,45.1,FALSE,TRUE
65,3,BODY,The following are examples of text blocks:,9,5.02,154.48,42,90,146.1,244.48,151.12,FALSE,FALSE
66,0,BODY,3.10Literals,9,4.95,64.01,12,36,40.15,100.01,45.1,FALSE,TRUE
66,1,BODY,LEXICAL STRUCTURE,9,4.95,88.51,17,343.49,40.15,432,45.1,FALSE,TRUE
66,3,BODY,Example 3.10.6-2. Escape sequences in text blocks,9,5.19,191.25,49,90,114.62,281.25,119.81,TRUE,FALSE
66,8,BODY,The error can be avoided by escaping the final double quote character in the content:,9,5.02,304.92,85,90,496.1,394.92,501.12,FALSE,FALSE
67,0,BODY,LEXICAL STRUCTURE,9,4.95,88.51,17,72,40.15,160.51,45.1,FALSE,TRUE
67,1,BODY,Literals3.10,9,4.95,64.01,12,403.99,40.15,468,45.1,FALSE,TRUE
67,3,BODY,"If a text block is intended to denote another text block, then it is recommended to escape the first double quote character of the embedded opening and closing delimiters:",9,15.02,324,171,90,116.1,414,131.12,FALSE,FALSE
67,12,BODY,Example 3.10.6-3. Order of transformations on text block content,9,5.19,251.23,64,90,554.62,341.23,559.81,TRUE,FALSE
68,0,BODY,3.10Literals,9,4.95,64.01,12,36,40.15,100.01,45.1,FALSE,TRUE
68,1,BODY,LEXICAL STRUCTURE,9,4.95,88.51,17,343.49,40.15,432,45.1,FALSE,TRUE
69,0,BODY,LEXICAL STRUCTURE,9,4.95,88.51,17,72,40.15,160.51,45.1,FALSE,TRUE
69,1,BODY,Literals3.10,9,4.95,64.01,12,403.99,40.15,468,45.1,FALSE,TRUE
70,0,BODY,3.11Separators,9,4.95,75.5,14,36,40.15,111.5,45.1,FALSE,TRUE
70,1,BODY,LEXICAL STRUCTURE,9,4.95,88.47,17,343.53,40.15,432,45.1,FALSE,TRUE
72,0,BODY,4.2Primitive Types and Values,9,4.95,136.34,29,36,40.15,172.34,45.1,FALSE,TRUE
72,1,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,133.85,28,298.15,40.15,432,45.1,FALSE,TRUE
73,0,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,133.85,28,72,40.15,205.85,45.1,FALSE,TRUE
73,1,BODY,Primitive Types and Values4.2,9,4.95,136.35,29,331.65,40.15,468,45.1,FALSE,TRUE
74,0,BODY,4.2Primitive Types and Values,9,4.95,136.34,29,36,40.15,172.34,45.1,FALSE,TRUE
74,1,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,133.85,28,298.15,40.15,432,45.1,FALSE,TRUE
75,0,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,133.85,28,72,40.15,205.85,45.1,FALSE,TRUE
75,1,BODY,Primitive Types and Values4.2,9,4.95,136.35,29,331.65,40.15,468,45.1,FALSE,TRUE
75,3,BODY,This program produces the output:,9,5.02,124.49,33,90,136.1,214.49,141.12,FALSE,FALSE
75,7,BODY,"In Java SE 15 and later, the Java programming language uses the 2019 version of the IEEE 754 Standard. Prior to Java SE 15, the Java programming language used the 1985 version of the IEEE 754 Standard, where the binary32 format was known as the single format and the binary64 format was known as the double format.",9,35.02,324.01,314,90,331.1,414.01,366.12,FALSE,FALSE
76,0,BODY,4.2Primitive Types and Values,9,4.95,136.34,29,36,40.15,172.34,45.1,FALSE,TRUE
76,1,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,133.85,28,298.15,40.15,432,45.1,FALSE,TRUE
76,6,BODY,24 8 +127 -126,9,56.02,18.58,14,194,261.85,212.58,317.87,FALSE,FALSE
76,7,BODY,53 11 +1023 -1022,9,56.02,23.08,17,314,261.85,337.08,317.87,FALSE,FALSE
77,0,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,133.85,28,72,40.15,205.85,45.1,FALSE,TRUE
77,1,BODY,Primitive Types and Values4.2,9,4.95,136.35,29,331.65,40.15,468,45.1,FALSE,TRUE
78,0,BODY,4.2Primitive Types and Values,9,4.95,136.34,29,36,40.15,172.34,45.1,FALSE,TRUE
78,1,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,133.85,28,298.15,40.15,432,45.1,FALSE,TRUE
79,0,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,133.85,28,72,40.15,205.85,45.1,FALSE,TRUE
79,1,BODY,Primitive Types and Values4.2,9,4.95,136.35,29,331.65,40.15,468,45.1,FALSE,TRUE
79,3,BODY,This program produces the output:,9,5.02,124.49,33,90,296.1,214.49,301.12,FALSE,FALSE
80,0,BODY,4.3Reference Types and Values,9,4.95,138.81,29,36,40.15,174.81,45.1,FALSE,TRUE
80,1,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,133.83,28,298.17,40.15,432,45.1,FALSE,TRUE
81,0,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,133.83,28,72,40.15,205.83,45.1,FALSE,TRUE
81,1,BODY,Reference Types and Values4.3,9,4.95,138.81,29,329.19,40.15,468,45.1,FALSE,TRUE
82,0,BODY,4.3Reference Types and Values,9,4.95,138.81,29,36,40.15,174.81,45.1,FALSE,TRUE
82,1,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,133.83,28,298.17,40.15,432,45.1,FALSE,TRUE
82,4,BODY,Example 4.3.1-1. Object Creation,9,5.19,128.48,32,90,268.62,218.48,273.81,TRUE,FALSE
83,0,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,133.83,28,72,40.15,205.83,45.1,FALSE,TRUE
83,1,BODY,Reference Types and Values4.3,9,4.95,138.81,29,329.19,40.15,468,45.1,FALSE,TRUE
83,3,BODY,This program produces the output:,9,5.02,124.49,33,90,176.1,214.49,181.12,FALSE,FALSE
83,6,BODY,Example 4.3.1-2. Primitive and Reference Identity,9,5.19,192.47,49,90,548.62,282.47,553.81,TRUE,FALSE
84,0,BODY,4.3Reference Types and Values,9,4.95,138.81,29,36,40.15,174.81,45.1,FALSE,TRUE
84,1,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,133.83,28,298.17,40.15,432,45.1,FALSE,TRUE
84,3,BODY,This program produces the output:,9,5.02,124.49,33,90,216.1,214.49,221.12,FALSE,FALSE
85,0,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,133.83,28,72,40.15,205.83,45.1,FALSE,TRUE
85,1,BODY,Reference Types and Values4.3,9,4.95,138.81,29,329.19,40.15,468,45.1,FALSE,TRUE
86,0,BODY,4.4Type Variables,9,4.95,91.26,17,36,40.15,127.26,45.1,FALSE,TRUE
86,1,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.29,28,297.71,40.15,432,45.1,FALSE,TRUE
87,0,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.29,28,72,40.15,206.29,45.1,FALSE,TRUE
87,1,BODY,Type Variables4.4,9,4.95,91.26,17,376.74,40.15,468,45.1,FALSE,TRUE
87,3,BODY,Example 4.4-1. Members of a Type Variable,9,5.19,169.98,41,90,258.62,259.98,263.81,TRUE,FALSE
88,0,BODY,4.5Parameterized Types,9,4.95,112.68,22,36,40.15,148.68,45.1,FALSE,TRUE
88,1,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.08,28,297.92,40.15,432,45.1,FALSE,TRUE
89,0,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.08,28,72,40.15,206.08,45.1,FALSE,TRUE
89,1,BODY,Parameterized Types4.5,9,4.95,112.68,22,355.32,40.15,468,45.1,FALSE,TRUE
89,6,BODY,? extends B,9,4.75,59.4,11,90,558.12,149.4,562.87,FALSE,FALSE
90,0,BODY,4.5Parameterized Types,9,4.95,112.68,22,36,40.15,148.68,45.1,FALSE,TRUE
90,1,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.08,28,297.92,40.15,432,45.1,FALSE,TRUE
90,3,BODY,? super B,9,4.75,48.6,9,90,122.12,138.6,126.87,FALSE,FALSE
91,0,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.08,28,72,40.15,206.08,45.1,FALSE,TRUE
91,1,BODY,Parameterized Types4.5,9,4.95,112.68,22,355.32,40.15,468,45.1,FALSE,TRUE
91,6,BODY,Example 4.5.1-2. Bounded Wildcards,9,5.19,143.02,34,90,498.62,233.02,503.81,TRUE,FALSE
92,0,BODY,4.5Parameterized Types,9,4.95,112.68,22,36,40.15,148.68,45.1,FALSE,TRUE
92,1,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.08,28,297.92,40.15,432,45.1,FALSE,TRUE
92,2,BODY,"This version is sufficiently flexible, but note that the type parameter is used only once in the signature. This reflects the fact that the type parameter is not being used to express any kind of interdependency between the type(s) of the argument(s), the return type and/or throws type. In the absence of such interdependency, generic methods are considered bad style, and wildcards are preferred.",9,45.02,324.01,398,90,74.1,414.01,119.12,FALSE,FALSE
93,0,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.34,28,72,40.15,206.34,45.1,FALSE,TRUE
93,1,BODY,Type Erasure4.6,9,4.95,85.28,15,382.72,40.15,468,45.1,FALSE,TRUE
94,0,BODY,4.7Reifiable Types,9,4.95,92.25,18,36,40.15,128.25,45.1,FALSE,TRUE
94,1,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.28,28,297.72,40.15,432,45.1,FALSE,TRUE
95,0,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.43,28,72,40.15,206.43,45.1,FALSE,TRUE
95,1,BODY,Raw Types4.8,9,4.95,75.81,12,392.19,40.15,468,45.1,FALSE,TRUE
95,2,BODY,"The price of migration compatibility is that a full and sound reification of the generic type system is not possible, at least while the migration is taking place.",9,15.02,324.01,163,90,74.1,414.01,89.12,FALSE,FALSE
96,0,BODY,4.8Raw Types,9,4.95,75.81,12,36,40.15,111.81,45.1,FALSE,TRUE
96,1,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.43,28,297.56,40.15,432,45.1,FALSE,TRUE
96,6,BODY,"This is the opposite of the case discussed above. There is no practical justification for this half-baked type. In legacy code, no type arguments are used. In non-legacy code, we should use the generic types correctly and pass all the required type arguments.",9,25.02,324.01,259,90,451.1,414.01,476.12,FALSE,FALSE
97,0,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.43,28,72,40.15,206.43,45.1,FALSE,TRUE
97,1,BODY,Raw Types4.8,9,4.95,75.81,12,392.19,40.15,468,45.1,FALSE,TRUE
98,0,BODY,4.8Raw Types,9,4.95,75.81,12,36,40.15,111.81,45.1,FALSE,TRUE
98,1,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.43,28,297.56,40.15,432,45.1,FALSE,TRUE
98,3,BODY,Example 4.8-2. Raw Types and Inheritance,9,5.19,165.75,40,90,127.62,255.75,132.81,TRUE,FALSE
99,0,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.18,28,72,40.15,206.18,45.1,FALSE,TRUE
99,1,BODY,Intersection Types4.9,9,4.95,102.72,21,365.28,40.15,468,45.1,FALSE,TRUE
99,5,BODY,"It is worth dwelling upon the distinction between intersection types and the bounds of type variables. Every type variable bound induces an intersection type. This intersection type is often trivial, consisting of a single type. The form of a bound is restricted (only the first element may be a class or type variable, and only one type variable may appear in the",9,35.02,324.01,364,90,560.1,414.01,595.12,FALSE,FALSE
100,0,BODY,4.10Subtyping,9,4.95,72,13,36,40.15,108,45.1,FALSE,TRUE
100,1,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.47,28,297.53,40.15,432,45.1,FALSE,TRUE
100,2,BODY,"bound) to preclude certain awkward situations coming into existence. However, capture conversion can lead to the creation of type variables whose bounds are more general, such as array types).",9,25.02,324.01,192,90,74.1,414.01,99.12,FALSE,FALSE
101,0,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.47,28,72,40.15,206.47,45.1,FALSE,TRUE
101,1,BODY,Subtyping4.10,9,4.95,72,13,396,40.15,468,45.1,FALSE,TRUE
102,0,BODY,4.10Subtyping,9,4.95,72,13,36,40.15,108,45.1,FALSE,TRUE
102,1,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.47,28,297.53,40.15,432,45.1,FALSE,TRUE
103,0,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.47,28,72,40.15,206.47,45.1,FALSE,TRUE
103,1,BODY,Subtyping4.10,9,4.95,72,13,396,40.15,468,45.1,FALSE,TRUE
104,0,BODY,4.10Subtyping,9,4.95,72,13,36,40.15,108,45.1,FALSE,TRUE
104,1,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.47,28,297.53,40.15,432,45.1,FALSE,TRUE
104,2,BODY,"on pairs of parameterized types, which in turn relies on the notion of least containing type argument (lcta). lcta() is defined for all possible cases.",9,15.02,313.99,151,100,74.1,413.99,89.12,FALSE,FALSE
105,0,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.47,28,72,40.15,206.47,45.1,FALSE,TRUE
105,1,BODY,Subtyping4.10,9,4.95,72,13,396,40.15,468,45.1,FALSE,TRUE
105,3,BODY,The possibility of an infinite type stems from the recursive calls to lub(). Readers familiar with recursive types should note that an infinite type is not the same as a recursive type.,9,15.02,323.99,185,90,157.1,413.99,172.12,FALSE,FALSE
106,0,BODY,4.10Subtyping,9,4.95,72,13,36,40.15,108,45.1,FALSE,TRUE
106,1,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.47,28,297.53,40.15,432,45.1,FALSE,TRUE
107,0,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.01,28,72,40.15,206.01,45.1,FALSE,TRUE
107,1,BODY,Where Types Are Used4.11,9,4.95,119.99,24,348.01,40.15,468,45.1,FALSE,TRUE
108,0,BODY,4.11Where Types Are Used,9,4.95,119.99,24,36,40.15,155.99,45.1,FALSE,TRUE
108,1,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.01,28,297.99,40.15,432,45.1,FALSE,TRUE
109,0,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.01,28,72,40.15,206.01,45.1,FALSE,TRUE
109,1,BODY,Where Types Are Used4.11,9,4.95,119.99,24,348.01,40.15,468,45.1,FALSE,TRUE
110,0,BODY,4.11Where Types Are Used,9,4.95,119.99,24,36,40.15,155.99,45.1,FALSE,TRUE
110,1,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.01,28,297.99,40.15,432,45.1,FALSE,TRUE
111,0,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.01,28,72,40.15,206.01,45.1,FALSE,TRUE
111,1,BODY,Where Types Are Used4.11,9,4.95,119.99,24,348.01,40.15,468,45.1,FALSE,TRUE
111,2,BODY,Example 4.11-1. Usage of a Type,9,5.19,125.24,31,90,75.62,215.24,80.81,TRUE,FALSE
112,0,BODY,4.12Variables,9,4.95,71,13,36,40.15,107,45.1,FALSE,TRUE
112,1,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.48,28,297.52,40.15,432,45.1,FALSE,TRUE
113,0,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.48,28,72,40.15,206.48,45.1,FALSE,TRUE
113,1,BODY,Variables4.12,9,4.95,71,13,397,40.15,468,45.1,FALSE,TRUE
113,3,BODY,"Note that a variable is not guaranteed to always refer to a subtype of its declared type, but only to subclasses or subinterfaces of the declared type. This is due to the possibility of heap pollution discussed below.",9,25.02,324,217,90,165.1,414,190.12,FALSE,FALSE
114,0,BODY,4.12Variables,9,4.95,71,13,36,40.15,107,45.1,FALSE,TRUE
114,1,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.48,28,297.52,40.15,432,45.1,FALSE,TRUE
115,0,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.48,28,72,40.15,206.48,45.1,FALSE,TRUE
115,1,BODY,Variables4.12,9,4.95,71,13,397,40.15,468,45.1,FALSE,TRUE
115,2,BODY,"if a compile-time unchecked warning actually occurred. It is possible to run a program where some of the binaries were produced by a compiler for an older version of the Java programming language, or from sources that explicitly suppressed unchecked warnings. This practice is unhealthy at best. Conversely, it is possible that despite executing code that could (and perhaps did) give rise to a compile-time unchecked warning, no heap pollution takes place. Indeed, good programming practice requires that the programmer satisfy herself that despite any unchecked warning, the code is correct and heap pollution will not occur.",9,87.02,324,627,90,74.1,414,161.12,FALSE,FALSE
116,0,BODY,4.12Variables,9,4.95,71,13,36,40.15,107,45.1,FALSE,TRUE
116,1,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.48,28,297.52,40.15,432,45.1,FALSE,TRUE
117,0,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.48,28,72,40.15,206.48,45.1,FALSE,TRUE
117,1,BODY,Variables4.12,9,4.95,71,13,397,40.15,468,45.1,FALSE,TRUE
117,3,BODY,Example 4.12.3-1. Different Kinds of Variables,9,5.19,179.99,46,90,265.62,269.99,270.81,TRUE,FALSE
118,0,BODY,4.12Variables,9,4.95,71,13,36,40.15,107,45.1,FALSE,TRUE
118,1,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.48,28,297.52,40.15,432,45.1,FALSE,TRUE
118,3,BODY,Example 4.12.4-1. Final Variables,9,5.19,130.01,33,90,241.62,220.01,246.81,TRUE,FALSE
119,0,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.48,28,72,40.15,206.48,45.1,FALSE,TRUE
119,1,BODY,Variables4.12,9,4.95,71,13,397,40.15,468,45.1,FALSE,TRUE
120,0,BODY,4.12Variables,9,4.95,71,13,36,40.15,107,45.1,FALSE,TRUE
120,1,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.48,28,297.52,40.15,432,45.1,FALSE,TRUE
120,4,BODY,This program prints:,9,5.02,74,20,90,415.1,164,420.12,FALSE,FALSE
121,0,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.48,28,72,40.15,206.48,45.1,FALSE,TRUE
121,1,BODY,Variables4.12,9,4.95,71,13,397,40.15,468,45.1,FALSE,TRUE
121,3,BODY,"See the paper Dynamic Class Loading in the Java Virtual Machine, by Sheng Liang and Gilad Bracha, in Proceedings of OOPSLA '98, published as ACM SIGPLAN Notices, Volume 33, Number 10, October 1998, pages 36-44, and The Java Virtual Machine Specification, Java SE 23 Edition for more details.",9,35.02,306,291,108,557.1,414,592.12,FALSE,FALSE
122,0,BODY,4.12Variables,9,4.95,71,13,36,40.15,107,45.1,FALSE,TRUE
122,1,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.48,28,297.52,40.15,432,45.1,FALSE,TRUE
122,3,BODY,"Under certain conditions, it is possible that a variable of a parameterized type refers to an object that is not of that parameterized type. This situation is known as heap pollution (§4.12.2). The variable will always refer to an object that is an instance of a class that represents the parameterized type.",9,35.02,306,308,108,151.1,414,186.12,FALSE,FALSE
122,4,BODY,Example 4.12.6-1. Type of a Variable versus Class of an Object,9,5.19,241.74,62,90,206.62,331.74,211.81,TRUE,FALSE
123,0,BODY,"TYPES, VALUES, AND VARIABLES",9,4.95,134.48,28,72,40.15,206.48,45.1,FALSE,TRUE
123,1,BODY,Variables4.12,9,4.95,71,13,397,40.15,468,45.1,FALSE,TRUE
126,0,BODY,CONVERSIONS AND CONTEXTS,9,4.95,127.43,24,304.56,40.15,432,45.1,FALSE,TRUE
126,1,BODY,Example 5.0-1. Conversions at Compile Time and Run Time,9,5.19,231.51,55,90,75.62,321.51,80.81,TRUE,FALSE
127,0,BODY,CONVERSIONS AND CONTEXTS,9,4.95,127.43,24,72,40.15,199.43,45.1,FALSE,TRUE
127,2,BODY,Example 5.0-2. Conversions In Various Contexts,9,5.19,186.75,46,90,488.62,276.75,493.81,TRUE,FALSE
128,0,BODY,5.1Kinds of Conversion,9,4.95,110.95,22,36,40.15,146.95,45.1,FALSE,TRUE
128,1,BODY,CONVERSIONS AND CONTEXTS,9,4.95,126.95,24,305.04,40.15,432,45.1,FALSE,TRUE
128,3,BODY,This program produces the output:,9,5.02,124.49,33,90,346.1,214.49,351.12,FALSE,FALSE
128,7,BODY,"This may seem trivial, but it has two practical consequences. First, it is always permitted for an expression to have the desired type to begin with, thus allowing the simply stated rule that every expression is subject to conversion, if only a trivial identity conversion. Second,",9,25.02,324.01,281,90,559.1,414.01,584.12,FALSE,FALSE
129,0,BODY,CONVERSIONS AND CONTEXTS,9,4.95,126.95,24,72,40.15,198.95,45.1,FALSE,TRUE
129,1,BODY,Kinds of Conversion5.1,9,4.95,110.95,22,357.05,40.15,468,45.1,FALSE,TRUE
129,2,BODY,it implies that it is permitted for a program to include redundant cast operators for the sake of clarity.,9,15.02,324,106,90,74.1,414,89.12,FALSE,FALSE
130,0,BODY,5.1Kinds of Conversion,9,4.95,110.95,22,36,40.15,146.95,45.1,FALSE,TRUE
130,1,BODY,CONVERSIONS AND CONTEXTS,9,4.95,126.95,24,305.04,40.15,432,45.1,FALSE,TRUE
130,3,BODY,Example 5.1.2-1. Widening Primitive Conversion,9,5.19,188.25,46,90,155.62,278.25,160.81,TRUE,FALSE
130,5,BODY,This program prints:,9,5.02,74,20,90,257.1,164,262.12,FALSE,FALSE
131,0,BODY,CONVERSIONS AND CONTEXTS,9,4.95,126.95,24,72,40.15,198.95,45.1,FALSE,TRUE
131,1,BODY,Kinds of Conversion5.1,9,4.95,110.95,22,357.05,40.15,468,45.1,FALSE,TRUE
132,0,BODY,5.1Kinds of Conversion,9,4.95,110.95,22,36,40.15,146.95,45.1,FALSE,TRUE
132,1,BODY,CONVERSIONS AND CONTEXTS,9,4.95,126.95,24,305.04,40.15,432,45.1,FALSE,TRUE
132,3,BODY,Example 5.1.3-1. Narrowing Primitive Conversion,9,5.19,192.73,47,90,107.62,282.73,112.81,TRUE,FALSE
132,5,BODY,This program produces the output:,9,5.02,124.49,33,90,299.1,214.49,304.12,FALSE,FALSE
132,8,BODY,Example 5.1.3-2. Narrowing Primitive Conversions that lose information,9,5.19,278.98,70,90,498.62,368.98,503.81,TRUE,FALSE
133,0,BODY,CONVERSIONS AND CONTEXTS,9,4.95,126.95,24,72,40.15,198.95,45.1,FALSE,TRUE
133,1,BODY,Kinds of Conversion5.1,9,4.95,110.95,22,357.05,40.15,468,45.1,FALSE,TRUE
133,3,BODY,This program produces the output:,9,5.02,124.49,33,90,166.1,214.49,171.12,FALSE,FALSE
133,7,BODY,"The null type is not a reference type (§4.1), and so a widening reference conversion does not exist from the null type to a reference type. However, many conversion contexts explicitly allow the null type to be converted to a reference type.",9,25.02,324.01,241,90,514.1,414.01,539.12,FALSE,FALSE
134,0,BODY,5.1Kinds of Conversion,9,4.95,110.95,22,36,40.15,146.95,45.1,FALSE,TRUE
134,1,BODY,CONVERSIONS AND CONTEXTS,9,4.95,126.95,24,305.04,40.15,432,45.1,FALSE,TRUE
135,0,BODY,CONVERSIONS AND CONTEXTS,9,4.95,126.95,24,72,40.15,198.95,45.1,FALSE,TRUE
135,1,BODY,Kinds of Conversion5.1,9,4.95,110.95,22,357.05,40.15,468,45.1,FALSE,TRUE
136,0,BODY,5.1Kinds of Conversion,9,4.95,110.95,22,36,40.15,146.95,45.1,FALSE,TRUE
136,1,BODY,CONVERSIONS AND CONTEXTS,9,4.95,126.95,24,305.04,40.15,432,45.1,FALSE,TRUE
137,0,BODY,CONVERSIONS AND CONTEXTS,9,4.95,126.95,24,72,40.15,198.95,45.1,FALSE,TRUE
137,1,BODY,Kinds of Conversion5.1,9,4.95,110.95,22,357.05,40.15,468,45.1,FALSE,TRUE
138,0,BODY,5.1Kinds of Conversion,9,4.95,110.95,22,36,40.15,146.95,45.1,FALSE,TRUE
138,1,BODY,CONVERSIONS AND CONTEXTS,9,4.95,126.95,24,305.04,40.15,432,45.1,FALSE,TRUE
139,0,BODY,CONVERSIONS AND CONTEXTS,9,4.95,126.95,24,72,40.15,198.95,45.1,FALSE,TRUE
139,1,BODY,Kinds of Conversion5.1,9,4.95,110.95,22,357.05,40.15,468,45.1,FALSE,TRUE
140,0,BODY,5.1Kinds of Conversion,9,4.95,110.95,22,36,40.15,146.95,45.1,FALSE,TRUE
140,1,BODY,CONVERSIONS AND CONTEXTS,9,4.95,126.95,24,305.04,40.15,432,45.1,FALSE,TRUE
140,3,BODY,"This rule is necessary because the conditional operator (§15.25) applies boxing conversion to the types of its operands, and uses the result in further calculations.",9,15.02,314,165,100,317.1,414,332.12,FALSE,FALSE
141,0,BODY,CONVERSIONS AND CONTEXTS,9,4.95,126.95,24,72,40.15,198.95,45.1,FALSE,TRUE
141,1,BODY,Kinds of Conversion5.1,9,4.95,110.95,22,357.05,40.15,468,45.1,FALSE,TRUE
142,0,BODY,5.1Kinds of Conversion,9,4.95,110.95,22,36,40.15,146.95,45.1,FALSE,TRUE
142,1,BODY,CONVERSIONS AND CONTEXTS,9,4.95,126.95,24,305.04,40.15,432,45.1,FALSE,TRUE
143,0,BODY,CONVERSIONS AND CONTEXTS,9,4.95,126.95,24,72,40.15,198.95,45.1,FALSE,TRUE
143,1,BODY,Kinds of Conversion5.1,9,4.95,110.95,22,357.05,40.15,468,45.1,FALSE,TRUE
144,0,BODY,5.1Kinds of Conversion,9,4.95,110.95,22,36,40.15,146.95,45.1,FALSE,TRUE
144,1,BODY,CONVERSIONS AND CONTEXTS,9,4.95,126.95,24,305.04,40.15,432,45.1,FALSE,TRUE
145,0,BODY,CONVERSIONS AND CONTEXTS,9,4.95,126.95,24,72,40.15,198.95,45.1,FALSE,TRUE
145,1,BODY,Kinds of Conversion5.1,9,4.95,110.95,22,357.05,40.15,468,45.1,FALSE,TRUE
146,0,BODY,5.2Assignment Contexts,9,4.95,111.72,22,36,40.15,147.72,45.1,FALSE,TRUE
146,1,BODY,CONVERSIONS AND CONTEXTS,9,4.95,126.95,24,305.05,40.15,432,45.1,FALSE,TRUE
147,0,BODY,CONVERSIONS AND CONTEXTS,9,4.95,126.95,24,72,40.15,198.95,45.1,FALSE,TRUE
147,1,BODY,Assignment Contexts5.2,9,4.95,111.72,22,356.28,40.15,468,45.1,FALSE,TRUE
148,0,BODY,5.2Assignment Contexts,9,4.95,111.72,22,36,40.15,147.72,45.1,FALSE,TRUE
148,1,BODY,CONVERSIONS AND CONTEXTS,9,4.95,126.95,24,305.05,40.15,432,45.1,FALSE,TRUE
148,3,BODY,"This circumstance can only arise as a result of heap pollution (§4.12.2). In practice, implementations need only perform casts when accessing a field or method of an object of parameterized type when the erased type of the field, or the erased return type of the method, differ from its unerased type.",9,35.02,314,301,100,202.1,414,237.12,FALSE,FALSE
148,5,BODY,Example 5.2-1. Assignment for Primitive Types,9,5.19,181.74,45,90,340.62,271.74,345.81,TRUE,FALSE
148,7,BODY,This program produces the output:,9,5.02,124.49,33,90,502.1,214.49,507.12,FALSE,FALSE
148,9,BODY,"The following program, however, produces compile-time errors:",9,5.02,232.45,61,90,566.1,322.45,571.12,FALSE,FALSE
149,0,BODY,CONVERSIONS AND CONTEXTS,9,4.95,126.95,24,72,40.15,198.95,45.1,FALSE,TRUE
149,1,BODY,Assignment Contexts5.2,9,4.95,111.72,22,356.28,40.15,468,45.1,FALSE,TRUE
149,4,BODY,Example 5.2-2. Assignment for Reference Types,9,5.19,184.22,45,90,159.62,274.22,164.81,TRUE,FALSE
150,0,BODY,5.2Assignment Contexts,9,4.95,111.72,22,36,40.15,147.72,45.1,FALSE,TRUE
150,1,BODY,CONVERSIONS AND CONTEXTS,9,4.95,126.95,24,305.05,40.15,432,45.1,FALSE,TRUE
150,2,BODY,"The following test program illustrates assignment conversions on reference values, but fails to compile, as described in its comments. This example should be compared to the preceding one.",9,25.02,324.01,188,90,74.1,414.01,99.12,FALSE,FALSE
150,4,BODY,Example 5.2-3. Assignment for Array Types,9,5.19,169.24,41,90,386.62,259.24,391.81,TRUE,FALSE
150,6,BODY,In this example:,9,5.02,58,16,90,598.1,148,603.12,FALSE,FALSE
151,0,BODY,CONVERSIONS AND CONTEXTS,9,4.95,126.97,24,72,40.15,198.97,45.1,FALSE,TRUE
151,1,BODY,Invocation Contexts5.3,9,4.95,108.72,22,359.28,40.15,468,45.1,FALSE,TRUE
152,0,BODY,5.3Invocation Contexts,9,4.95,108.72,22,36,40.15,144.72,45.1,FALSE,TRUE
152,1,BODY,CONVERSIONS AND CONTEXTS,9,4.95,126.97,24,305.03,40.15,432,45.1,FALSE,TRUE
153,0,BODY,CONVERSIONS AND CONTEXTS,9,4.95,127.07,24,72,40.15,199.07,45.1,FALSE,TRUE
153,1,BODY,String Contexts5.4,9,4.95,92.29,18,375.71,40.15,468,45.1,FALSE,TRUE
154,0,BODY,5.5Casting Contexts,9,4.95,98.27,19,36,40.15,134.27,45.1,FALSE,TRUE
154,1,BODY,CONVERSIONS AND CONTEXTS,9,4.95,127.03,24,304.96,40.15,432,45.1,FALSE,TRUE
155,0,BODY,CONVERSIONS AND CONTEXTS,9,4.95,127.04,24,72,40.15,199.04,45.1,FALSE,TRUE
155,1,BODY,Casting Contexts5.5,9,4.95,98.27,19,369.73,40.15,468,45.1,FALSE,TRUE
155,3,BODY,byteshortcharintlongfloatdoubleboolean,9,4.75,303.48,38,127.72,96.87,431.21,101.62,FALSE,FALSE
155,4,BODY,- - - - - - -,9,128.78,3,13,410.81,138.94,413.8,267.73,FALSE,FALSE
155,5,BODY,"⊗ ⇓,⊗⇓,⊗⇓,⊗⇓,⊗⇓,⊗⇓,⊗⇓,⊗⇓,⊗",9,26.49,288.37,26,131.23,451.79,419.6,478.28,FALSE,FALSE
156,0,BODY,5.5Casting Contexts,9,4.95,98.27,19,36,40.15,134.27,45.1,FALSE,TRUE
156,1,BODY,CONVERSIONS AND CONTEXTS,9,4.95,127.03,24,304.96,40.15,432,45.1,FALSE,TRUE
156,3,BODY,ByteShortCharacterIntegerLongFloatDoubleBooleanObject,9,4.75,313.36,53,115.86,96.87,429.22,101.62,FALSE,FALSE
156,4,BODY,⊕,9,5.86,6.91,1,123.2,141.89,130.11,147.75,FALSE,FALSE
156,5,BODY,"⊕,⇑ ⊕,⇑ ⊕,⇑ ⊕,⇑ ⊕,⇑ ⊕⊕,⇑ ⊕⊕,⇑ ⊕⊕,⇑ ⇑ ⇑ ⇑ ⇑ ⇑ ⇑ ≈⇑ ≈⇑ ⇓⇓⇓⇓⇓⇓⇓⇓≈",9,336.4,296.37,62,123.94,141.89,420.32,478.28,FALSE,FALSE
156,6,BODY,⊕,9,5.86,6.91,1,153.36,162.51,160.27,168.38,FALSE,FALSE
156,7,BODY,⊕,9,5.86,6.91,1,193.88,183.14,200.79,189,FALSE,FALSE
156,8,BODY,⊕,9,5.86,6.91,1,238.17,203.77,245.09,209.63,FALSE,FALSE
156,9,BODY,⊕,9,5.86,6.91,1,272.1,224.39,279.01,230.26,FALSE,FALSE
156,10,BODY,≈,9,5.86,4.94,1,124.19,307.4,129.13,313.27,FALSE,FALSE
156,11,BODY,≈,9,5.86,4.94,1,154.34,328.03,159.28,333.89,FALSE,FALSE
156,12,BODY,≈,9,5.86,4.94,1,194.87,348.66,199.81,354.52,FALSE,FALSE
156,13,BODY,≈,9,5.86,4.94,1,239.16,369.28,244.1,375.15,FALSE,FALSE
156,14,BODY,≈,9,5.86,4.94,1,273.09,389.91,278.03,395.77,FALSE,FALSE
156,15,BODY,≈,9,5.86,4.94,1,301.36,410.54,306.3,416.4,FALSE,FALSE
157,0,BODY,CONVERSIONS AND CONTEXTS,9,4.95,127.04,24,72,40.15,199.04,45.1,FALSE,TRUE
157,1,BODY,Casting Contexts5.5,9,4.95,98.27,19,369.73,40.15,468,45.1,FALSE,TRUE
157,2,BODY,Example 5.5-1. Casting for Reference Types,9,5.19,168.72,42,90,75.62,258.72,80.81,TRUE,FALSE
158,0,BODY,5.5Casting Contexts,9,4.95,98.27,19,36,40.15,134.27,45.1,FALSE,TRUE
158,1,BODY,CONVERSIONS AND CONTEXTS,9,4.95,127.03,24,304.96,40.15,432,45.1,FALSE,TRUE
158,2,BODY,Example 5.5-2. Casting for Array Types,9,5.19,153.74,38,90,75.62,243.74,80.81,TRUE,FALSE
158,4,BODY,This program compiles without errors and produces the output:,9,5.02,227.47,61,90,397.1,317.47,402.12,FALSE,FALSE
159,0,BODY,CONVERSIONS AND CONTEXTS,9,4.95,127.01,24,72,40.15,199.01,45.1,FALSE,TRUE
159,1,BODY,Numeric Contexts5.6,9,4.95,101.25,19,366.75,40.15,468,45.1,FALSE,TRUE
159,2,BODY,Example 5.5-3. Casting Incompatible Types at Run Time,9,5.19,218.26,53,90,75.62,308.26,80.81,TRUE,FALSE
159,4,BODY,"This program uses casts to compile, but it throws exceptions at run time, because the types are incompatible.",9,15.02,324.01,109,90,327.1,414.01,342.12,FALSE,FALSE
160,0,BODY,5.6Numeric Contexts,9,4.95,101.25,19,36,40.15,137.25,45.1,FALSE,TRUE
160,1,BODY,CONVERSIONS AND CONTEXTS,9,4.95,127.01,24,304.98,40.15,432,45.1,FALSE,TRUE
161,0,BODY,CONVERSIONS AND CONTEXTS,9,4.95,127.01,24,72,40.15,199.01,45.1,FALSE,TRUE
161,1,BODY,Numeric Contexts5.6,9,4.95,101.25,19,366.75,40.15,468,45.1,FALSE,TRUE
162,0,BODY,5.6Numeric Contexts,9,4.95,101.25,19,36,40.15,137.25,45.1,FALSE,TRUE
162,1,BODY,CONVERSIONS AND CONTEXTS,9,4.95,127.01,24,304.98,40.15,432,45.1,FALSE,TRUE
162,4,BODY,Example 5.6-1. Unary Numeric Promotion,9,5.19,162.98,38,90,236.62,252.98,241.81,TRUE,FALSE
162,6,BODY,This program produces the output:,9,5.02,124.49,33,90,438.1,214.49,443.12,FALSE,FALSE
162,8,BODY,Example 5.6-2. Binary Numeric Promotion,9,5.19,164.99,39,90,498.62,254.99,503.81,TRUE,FALSE
163,0,BODY,CONVERSIONS AND CONTEXTS,9,4.95,127.04,24,72,40.15,199.04,45.1,FALSE,TRUE
163,1,BODY,Testing Contexts5.7,9,4.95,96.77,19,371.23,40.15,468,45.1,FALSE,TRUE
163,3,BODY,This program produces the output:,9,5.02,124.49,33,90,196.1,214.49,201.12,FALSE,FALSE
164,0,BODY,5.7Testing Contexts,9,4.95,96.77,19,36,40.15,132.77,45.1,FALSE,TRUE
164,1,BODY,CONVERSIONS AND CONTEXTS,9,4.95,127.04,24,304.95,40.15,432,45.1,FALSE,TRUE
166,0,BODY,6.1Declarations,9,4.95,83,15,36,40.15,119,45.1,FALSE,TRUE
166,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
167,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
167,1,BODY,Declarations6.1,9,4.95,83,15,385,40.15,468,45.1,FALSE,TRUE
168,0,BODY,6.1Declarations,9,4.95,83,15,36,40.15,119,45.1,FALSE,TRUE
168,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
169,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
169,1,BODY,Declarations6.1,9,4.95,83,15,385,40.15,468,45.1,FALSE,TRUE
169,3,BODY,expression (§15.12),9,5.02,71.49,19,108,228.1,179.49,233.12,FALSE,FALSE
169,5,BODY,"statement (§15.14.1, §14.20.3)",9,5.02,110.24,30,108,270.1,218.24,275.12,FALSE,FALSE
170,0,BODY,6.1Declarations,9,4.95,83,15,36,40.15,119,45.1,FALSE,TRUE
170,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
170,3,BODY,Example 6.1-1. Unique Package Names,9,5.19,149.99,35,90,323.62,239.99,328.81,TRUE,FALSE
171,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
171,1,BODY,Declarations6.1,9,4.95,83,15,385,40.15,468,45.1,FALSE,TRUE
171,2,BODY,"does not correspond to one of its exported packages, then its name should still start with the reversed form of an Internet domain with which its author is associated.",9,15.02,323.99,167,90,74.1,413.99,89.12,FALSE,FALSE
171,3,BODY,Example 6.1-2. Unique Module Names,9,5.19,147.5,34,90,107.62,237.5,112.81,TRUE,FALSE
171,6,BODY,Example 6.1-3. Descriptive Class Names,9,5.19,153.98,38,90,348.62,243.98,353.81,TRUE,FALSE
172,0,BODY,6.1Declarations,9,4.95,83,15,36,40.15,119,45.1,FALSE,TRUE
172,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
172,3,BODY,Example 6.1-4. Conventional Type Variable Names,9,5.19,196.75,47,90,169.62,286.75,174.81,TRUE,FALSE
173,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
173,1,BODY,Declarations6.1,9,4.95,83,15,385,40.15,468,45.1,FALSE,TRUE
174,0,BODY,6.2Names and Identifiers,9,4.95,117.04,24,36,40.15,153.04,45.1,FALSE,TRUE
174,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
175,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
175,1,BODY,Names and Identifiers6.2,9,4.95,117.04,24,350.96,40.15,468,45.1,FALSE,TRUE
176,0,BODY,6.3Scope of a Declaration,9,4.95,121.5,25,36,40.15,157.5,45.1,FALSE,TRUE
176,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
177,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
177,1,BODY,Scope of a Declaration6.3,9,4.95,121.51,25,346.49,40.15,468,45.1,FALSE,TRUE
178,0,BODY,6.3Scope of a Declaration,9,4.95,121.5,25,36,40.15,157.5,45.1,FALSE,TRUE
178,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
178,5,BODY,Example 6.3-1. Scope of Class Declarations,9,5.19,165.24,42,90,407.62,255.24,412.81,TRUE,FALSE
179,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
179,1,BODY,Scope of a Declaration6.3,9,4.95,121.51,25,346.49,40.15,468,45.1,FALSE,TRUE
179,2,BODY,Example 6.3-2. Scope of Local Variable Declarations,9,5.19,201.99,51,90,75.62,291.99,80.81,TRUE,FALSE
179,5,BODY,The following program does compile:,9,5.02,136.49,35,90,233.1,226.49,238.12,FALSE,FALSE
179,11,BODY,This program produces the output:,9,5.02,124.49,33,90,515.1,214.49,520.12,FALSE,FALSE
180,0,BODY,6.3Scope of a Declaration,9,4.95,121.5,25,36,40.15,157.5,45.1,FALSE,TRUE
180,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
180,3,BODY,It will be seen that the scope of a pattern variable declaration is a flow-dependent concept similar to definite assignment (§16 (Definite Assignment)). The rules defined in the rest of this section deliberately have a similar form to the rules of definite assignment.,9,25.02,324,268,90,170.1,414,195.12,FALSE,FALSE
181,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
181,1,BODY,Scope of a Declaration6.3,9,4.95,121.51,25,346.49,40.15,468,45.1,FALSE,TRUE
182,0,BODY,6.3Scope of a Declaration,9,4.95,121.5,25,36,40.15,157.5,45.1,FALSE,TRUE
182,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
183,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
183,1,BODY,Scope of a Declaration6.3,9,4.95,121.51,25,346.49,40.15,468,45.1,FALSE,TRUE
184,0,BODY,6.3Scope of a Declaration,9,4.95,121.5,25,36,40.15,157.5,45.1,FALSE,TRUE
184,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
185,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
185,1,BODY,Scope of a Declaration6.3,9,4.95,121.51,25,346.49,40.15,468,45.1,FALSE,TRUE
186,0,BODY,6.3Scope of a Declaration,9,4.95,121.5,25,36,40.15,157.5,45.1,FALSE,TRUE
186,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
187,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
187,1,BODY,Shadowing and Obscuring6.4,9,4.95,133.44,26,334.56,40.15,468,45.1,FALSE,TRUE
188,0,BODY,6.4Shadowing and Obscuring,9,4.95,133.43,26,36,40.15,169.43,45.1,FALSE,TRUE
188,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
188,3,BODY,"For example, if the name of a formal parameter of a method could be redeclared as the name of a local variable in the method body, then the local variable would shadow the formal parameter and there would be no way to refer to the formal parameter - an undesirable outcome.",9,35.02,324,273,90,112.1,414,147.12,FALSE,FALSE
189,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
189,1,BODY,Shadowing and Obscuring6.4,9,4.95,133.44,26,334.56,40.15,468,45.1,FALSE,TRUE
189,2,BODY,Example 6.4-1. Attempted Shadowing Of A Local Variable,9,5.19,225.75,54,90,75.62,315.75,80.81,TRUE,FALSE
189,3,BODY,"Because a declaration of an identifier as a local variable of a method, constructor, or initializer block must not appear within the scope of a parameter or local variable of the same name, a compile-time error occurs for the following program:",9,25.02,324,244,90,99.1,414,124.12,FALSE,FALSE
189,5,BODY,"This restriction helps to detect some otherwise very obscure bugs. A similar restriction on shadowing of members by local variables was judged impractical, because the addition of a member in a superclass could cause subclasses to have to rename local variables. Related considerations make restrictions on shadowing of local variables by members of nested classes, or on shadowing of local variables by local variables declared within nested classes unattractive as well. Hence, the following program compiles without error:",9,77.02,324,525,90,223.1,414,300.12,FALSE,FALSE
189,9,BODY,"This program compiles without error and, when executed, produces the output:",9,5.02,284.45,76,90,583.1,374.45,588.12,FALSE,FALSE
190,0,BODY,6.4Shadowing and Obscuring,9,4.95,133.43,26,36,40.15,169.43,45.1,FALSE,TRUE
190,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
190,3,BODY,"This style is also common with pattern matching, where repeated patterns often employ the same name:",9,15.02,323.99,100,90,96.1,413.99,111.12,FALSE,FALSE
190,5,BODY,"However, pattern variables are not allowed to shadow local variables, including other pattern variables, so two compile-time errors occur for the following program:",9,15.02,324,164,90,380.1,414,395.12,FALSE,FALSE
191,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
191,1,BODY,Shadowing and Obscuring6.4,9,4.95,133.44,26,334.56,40.15,468,45.1,FALSE,TRUE
192,0,BODY,6.4Shadowing and Obscuring,9,4.95,133.43,26,36,40.15,169.43,45.1,FALSE,TRUE
192,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
192,3,BODY,Example 6.4.1-1. Shadowing of a Field Declaration by a Local Variable Declaration,9,5.19,319.5,81,90,347.62,409.5,352.81,TRUE,FALSE
192,5,BODY,This program produces the output:,9,5.02,124.49,33,90,459.1,214.49,464.12,FALSE,FALSE
193,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
193,1,BODY,Shadowing and Obscuring6.4,9,4.95,133.44,26,334.56,40.15,468,45.1,FALSE,TRUE
193,4,BODY,"Here, the constructor takes parameters having the same names as the fields to be initialized. This is simpler than having to invent different names for the parameters and is not too confusing in this stylized context. In general, however, it is considered poor style to have local variables with the same names as fields.",9,35.02,324.01,321,90,372.1,414.01,407.12,FALSE,FALSE
193,5,BODY,Example 6.4.1-2. Shadowing of a Type Declaration by Another Type Declaration,9,5.19,309.25,76,90,425.62,399.25,430.81,TRUE,FALSE
193,7,BODY,The program compiles and prints:,9,5.02,121.99,32,90,577.1,211.99,582.12,FALSE,FALSE
194,0,BODY,6.4Shadowing and Obscuring,9,4.95,133.43,26,36,40.15,169.43,45.1,FALSE,TRUE
194,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
195,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
195,1,BODY,Determining the Meaning of a Name6.5,9,4.95,171.21,36,296.79,40.15,468,45.1,FALSE,TRUE
195,2,BODY,"•If a field name obscures a type name, then a fully qualified name for the type can be used unless the type name denotes a local class or interface (§14.3). •Field names cannot obscure method names. •If a field name is shadowed by a declaration of a parameter or local variable, then the name of the parameter or local variable can be changed without affecting other code. Obscuring involving constant names is rare: •Constant names normally have no lowercase letters, so they will not normally obscure names of packages or types, nor will they normally shadow fields, whose names typically contain at least one lowercase letter. •Constant names cannot obscure method names, because they are distinguished syntactically.",9,147.02,324.01,720,90,74.1,414.01,221.12,FALSE,FALSE
196,0,BODY,6.5Determining the Meaning of a Name,9,4.95,171.21,36,36,40.15,207.21,45.1,FALSE,TRUE
196,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
197,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
197,1,BODY,Determining the Meaning of a Name6.5,9,4.95,171.21,36,296.79,40.15,468,45.1,FALSE,TRUE
198,0,BODY,6.5Determining the Meaning of a Name,9,4.95,171.21,36,36,40.15,207.21,45.1,FALSE,TRUE
198,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
199,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
199,1,BODY,Determining the Meaning of a Name6.5,9,4.95,171.21,36,296.79,40.15,468,45.1,FALSE,TRUE
200,0,BODY,6.5Determining the Meaning of a Name,9,4.95,171.21,36,36,40.15,207.21,45.1,FALSE,TRUE
200,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
201,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
201,1,BODY,Determining the Meaning of a Name6.5,9,4.95,171.21,36,296.79,40.15,468,45.1,FALSE,TRUE
201,3,BODY,Example 6.5.2-1. Reclassification of Contextually Ambiguous Names,9,5.19,262.24,65,90,313.62,352.24,318.81,TRUE,FALSE
201,4,BODY,Consider the following contrived 'library code':,9,5.02,174.57,48,90,337.1,264.57,342.12,FALSE,FALSE
201,6,BODY,and then consider this example code in another package:,9,5.02,203.45,55,90,401.1,293.45,406.12,FALSE,FALSE
202,0,BODY,6.5Determining the Meaning of a Name,9,4.95,171.21,36,36,40.15,207.21,45.1,FALSE,TRUE
202,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
203,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
203,1,BODY,Determining the Meaning of a Name6.5,9,4.95,171.21,36,296.79,40.15,468,45.1,FALSE,TRUE
204,0,BODY,6.5Determining the Meaning of a Name,9,4.95,171.21,36,36,40.15,207.21,45.1,FALSE,TRUE
204,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
204,4,BODY,Example 6.5.5.1-1. References to Type Parameters,9,5.19,193.2,48,90,142.62,283.2,147.81,TRUE,FALSE
205,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
205,1,BODY,Determining the Meaning of a Name6.5,9,4.95,171.21,36,296.79,40.15,468,45.1,FALSE,TRUE
205,3,BODY,Example 6.5.5.2-1. Qualified Type Names,9,5.19,159,39,90,136.49,249,141.68,TRUE,FALSE
205,5,BODY,This program produced the following output the first time it was run:,9,5.02,248.73,69,90,237.96,338.73,242.99,FALSE,FALSE
206,0,BODY,6.5Determining the Meaning of a Name,9,4.95,171.21,36,36,40.15,207.21,45.1,FALSE,TRUE
206,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
207,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
207,1,BODY,Determining the Meaning of a Name6.5,9,4.95,171.21,36,296.79,40.15,468,45.1,FALSE,TRUE
207,2,BODY,"That is, if the expression name appears 'on the right hand side', its type is subject to capture conversion. If the expression name is a variable that appears 'on the left hand side', its type is not subject to capture conversion.",9,25.02,324.02,230,90,74.1,414.02,99.12,FALSE,FALSE
207,3,BODY,Example 6.5.6.1-1. Simple Expression Names,9,5.19,172.5,42,90,117.62,262.5,122.81,TRUE,FALSE
207,7,BODY,Example 6.5.6.1-2. References to Instance Variables,9,5.19,198.72,51,90,338.62,288.72,343.81,TRUE,FALSE
208,0,BODY,6.5Determining the Meaning of a Name,9,4.95,171.21,36,36,40.15,207.21,45.1,FALSE,TRUE
208,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
208,4,BODY,Example 6.5.6.1-3. References to Local Variables and Formal Parameters,9,5.19,281.95,70,90,199.62,371.95,204.81,TRUE,FALSE
209,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
209,1,BODY,Determining the Meaning of a Name6.5,9,4.95,171.21,36,296.79,40.15,468,45.1,FALSE,TRUE
210,0,BODY,6.5Determining the Meaning of a Name,9,4.95,171.21,36,36,40.15,207.21,45.1,FALSE,TRUE
210,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
211,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
211,1,BODY,Determining the Meaning of a Name6.5,9,4.95,171.21,36,296.79,40.15,468,45.1,FALSE,TRUE
211,3,BODY,Example 6.5.6.2-1. Qualified Expression Names,9,5.19,182.01,45,90,155.62,272.01,160.81,TRUE,FALSE
211,6,BODY,Example 6.5.6.2-2. Qualifying an Expression with a Type Name,9,5.19,243.02,60,90,350.62,333.02,355.81,TRUE,FALSE
211,7,BODY,"Note that expression names may be qualified by type names, but not by types in general. A consequence is that it is not possible to access a class variable through a parameterized type. For example, given the code:",9,25.02,323.99,214,90,374.1,413.99,399.12,FALSE,FALSE
211,9,BODY,the following assignment is illegal:,9,5.02,126.5,36,90,458.1,216.5,463.12,FALSE,FALSE
211,11,BODY,"Instead, one writes:",9,5.02,70.24,20,90,502.1,160.24,507.12,FALSE,FALSE
212,0,BODY,6.5Determining the Meaning of a Name,9,4.95,171.21,36,36,40.15,207.21,45.1,FALSE,TRUE
212,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
212,3,BODY,Example 6.5.7.1-1. Simple Method Names,9,5.19,159.99,38,90,258.62,249.99,263.81,TRUE,FALSE
212,4,BODY,The following program demonstrates the role of scoping when determining which method to invoke.,9,15.02,324.01,95,90,282.1,414.01,297.12,FALSE,FALSE
213,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
213,1,BODY,Access Control6.6,9,4.95,91.6,17,376.4,40.15,468,45.1,FALSE,TRUE
214,0,BODY,6.6Access Control,9,4.95,91.6,17,36,40.15,127.6,45.1,FALSE,TRUE
214,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
214,2,BODY,"In addition, many statements and expressions allow the use of types that are not expressed exclusively with type names. For example, a class declaration may use a parameterized type (§4.5) to denote the superclass type. Because a parameterized type is not a qualified type name, it is necessary for the class declaration to explicitly perform access control for the denoted superclass. Consequently, of the statements and expressions that provide contexts in §6.5.1 to classify a TypeName, most perform their own access control checks. Beyond access to members of a package, class, interface, or type parameter, there is the matter of access to constructors of a class. Access control must be checked when a constructor is invoked explicitly or implicitly. Consequently, access control is checked by an explicit constructor invocation statement (§8.8.7.1) and by a class instance creation expression (§15.9.3). Such checks are necessary because §6.5.1 has no mention of explicit constructor invocation statements (as they refer to constructors indirectly, rather than via names) and is unaware of the distinction between the class denoted by an unqualified class instance creation expression and a constructor of that class. Also, constructors do not have qualified names, so we cannot rely on access control being checked during classification of qualified type names. Accessibility affects inheritance of class members (§8.2), including hiding and method overriding (§8.4.8.1).",9,199.02,324.01,1479,90,74.1,414.01,273.12,FALSE,FALSE
215,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
215,1,BODY,Access Control6.6,9,4.95,91.6,17,376.4,40.15,468,45.1,FALSE,TRUE
215,4,BODY,Example 6.6-1. Access Control,9,5.19,117.23,29,90,468.62,207.23,473.81,TRUE,FALSE
215,5,BODY,Consider the two compilation units:,9,5.02,129.01,35,90,492.1,219.01,497.12,FALSE,FALSE
215,7,BODY,and:,9,5.02,15.5,4,90,546.1,105.5,551.12,FALSE,FALSE
216,0,BODY,6.6Access Control,9,4.95,91.6,17,36,40.15,127.6,45.1,FALSE,TRUE
216,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
217,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
217,1,BODY,Access Control6.6,9,4.95,91.6,17,376.4,40.15,468,45.1,FALSE,TRUE
217,4,BODY,"or by using a single-type-import declaration (§7.5.1) that mentions the fully qualified name, so that the simple name may be used thereafter:",9,15.02,324,141,90,250.1,414,265.12,FALSE,FALSE
217,7,BODY,"Example 6.6-4. Access to Fields, Methods, and Constructors with Package Access",9,5.19,310.97,78,90,407.62,400.97,412.81,TRUE,FALSE
218,0,BODY,6.6Access Control,9,4.95,91.6,17,36,40.15,127.6,45.1,FALSE,TRUE
218,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
219,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
219,1,BODY,Access Control6.6,9,4.95,91.6,17,376.4,40.15,468,45.1,FALSE,TRUE
220,0,BODY,6.6Access Control,9,4.95,91.6,17,36,40.15,127.6,45.1,FALSE,TRUE
220,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
221,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
221,1,BODY,Fully Qualified Names and Canonical Names6.7,9,4.95,202.71,44,265.29,40.15,468,45.1,FALSE,TRUE
222,0,BODY,6.7Fully Qualified Names and Canonical Names,9,4.95,202.71,44,36,40.15,238.71,45.1,FALSE,TRUE
222,1,BODY,NAMES,9,4.95,29,5,403,40.15,432,45.1,FALSE,TRUE
222,3,BODY,Example 6.7-1. Fully Qualified Names,9,5.19,146.01,36,90,410.62,236.01,415.81,TRUE,FALSE
223,0,BODY,NAMES,9,4.95,29,5,72,40.15,101,45.1,FALSE,TRUE
223,1,BODY,Fully Qualified Names and Canonical Names6.7,9,4.95,202.71,44,265.29,40.15,468,45.1,FALSE,TRUE
223,4,BODY,Example 6.7-2. Fully Qualified Names v. Canonical Name,9,5.19,221,54,90,149.62,311,154.81,TRUE,FALSE
223,5,BODY,The difference between a fully qualified name and a canonical name can be seen in code such as:,9,15.02,324,95,90,173.1,414,188.12,FALSE,FALSE
226,0,BODY,7.1Package Members,9,4.95,103.27,18,36,40.15,139.27,45.1,FALSE,TRUE
226,1,BODY,PACKAGES AND MODULES,9,4.95,110.59,20,321.4,40.15,432,45.1,FALSE,TRUE
227,0,BODY,PACKAGES AND MODULES,9,4.95,110.08,20,72,40.15,182.08,45.1,FALSE,TRUE
227,1,BODY,Host Support for Modules and Packages7.2,9,4.95,183.7,40,284.3,40.15,468,45.1,FALSE,TRUE
228,0,BODY,7.2Host Support for Modules and Packages,9,4.95,183.7,40,36,40.15,219.7,45.1,FALSE,TRUE
228,1,BODY,PACKAGES AND MODULES,9,4.95,110.08,20,321.92,40.15,432,45.1,FALSE,TRUE
228,3,BODY,"For example, a system that uses a database to store packages may not enforce a maximum of one public class or interface per compilation unit.",9,15.02,324,141,90,170.1,414,185.12,FALSE,FALSE
229,0,BODY,PACKAGES AND MODULES,9,4.95,110.08,20,72,40.15,182.08,45.1,FALSE,TRUE
229,1,BODY,Host Support for Modules and Packages7.2,9,4.95,183.7,40,284.3,40.15,468,45.1,FALSE,TRUE
230,0,BODY,7.3Compilation Units,9,4.95,103.31,20,36,40.15,139.31,45.1,FALSE,TRUE
230,1,BODY,PACKAGES AND MODULES,9,4.95,110.59,20,321.4,40.15,432,45.1,FALSE,TRUE
231,0,BODY,PACKAGES AND MODULES,9,4.95,110.59,20,72,40.15,182.59,45.1,FALSE,TRUE
231,1,BODY,Compilation Units7.3,9,4.95,103.31,20,364.69,40.15,468,45.1,FALSE,TRUE
232,0,BODY,7.4Package Declarations,9,4.95,116.74,23,36,40.15,152.74,45.1,FALSE,TRUE
232,1,BODY,PACKAGES AND MODULES,9,4.95,110.51,20,321.49,40.15,432,45.1,FALSE,TRUE
233,0,BODY,PACKAGES AND MODULES,9,4.95,110.51,20,72,40.15,182.51,45.1,FALSE,TRUE
233,1,BODY,Package Declarations7.4,9,4.95,116.74,23,351.26,40.15,468,45.1,FALSE,TRUE
233,3,BODY,Example 7.4.2-1. Unnamed Package,9,5.19,138,32,90,295.62,228,300.81,TRUE,FALSE
233,4,BODY,The compilation unit:,9,5.02,78,21,90,319.1,168,324.12,FALSE,FALSE
233,6,BODY,"defines a very simple compilation unit as part of an unnamed package. In implementations of the Java SE Platform that use a hierarchical file system for storing packages, one typical strategy is to associate an unnamed package with each directory; only one unnamed package is observable at a time, namely the one that is associated with the 'current working directory'. The precise meaning of 'current working directory' depends on the host system.",9,67.02,324,448,90,413.1,414,480.12,FALSE,FALSE
234,0,BODY,7.5Import Declarations,9,4.95,110.27,22,36,40.15,146.27,45.1,FALSE,TRUE
234,1,BODY,PACKAGES AND MODULES,9,4.95,110.55,20,321.45,40.15,432,45.1,FALSE,TRUE
234,4,BODY,"Package visibility is meant to imply that a package is observable in a useful way to a given module. It is generally not useful to know that package P is observable merely because a subpackage P.Q is observable. For example, suppose P.Q is observable (in module M1) and P.R is observable (in module M2); then, P is observable, but where? In M1, or M2, or both? The question is redundant; during compilation of module N that requires only M1, it matters that P.Q is observable, but it does not matter that P is observable.",9,55.02,324.01,521,90,184.1,414.01,239.12,FALSE,FALSE
235,0,BODY,PACKAGES AND MODULES,9,4.95,110.55,20,72,40.15,182.55,45.1,FALSE,TRUE
235,1,BODY,Import Declarations7.5,9,4.95,110.27,22,357.73,40.15,468,45.1,FALSE,TRUE
236,0,BODY,7.5Import Declarations,9,4.95,110.27,22,36,40.15,146.27,45.1,FALSE,TRUE
236,1,BODY,PACKAGES AND MODULES,9,4.95,110.55,20,321.45,40.15,432,45.1,FALSE,TRUE
236,5,BODY,Example 7.5.1-2. Duplicate Class Declarations,9,5.19,176.74,45,90,419.62,266.74,424.81,TRUE,FALSE
236,6,BODY,This program:,9,5.02,51.25,13,90,443.1,141.25,448.12,FALSE,FALSE
237,0,BODY,PACKAGES AND MODULES,9,4.95,110.55,20,72,40.15,182.55,45.1,FALSE,TRUE
237,1,BODY,Import Declarations7.5,9,4.95,110.27,22,357.73,40.15,468,45.1,FALSE,TRUE
237,2,BODY,Example 7.5.1-3. No Import of a Subpackage,9,5.19,172.25,42,90,75.62,262.25,80.81,TRUE,FALSE
237,5,BODY,Example 7.5.1-4. Importing a Type Name that is also a Package Name,9,5.19,267.98,66,90,206.62,357.98,211.81,TRUE,FALSE
238,0,BODY,7.5Import Declarations,9,4.95,110.27,22,36,40.15,146.27,45.1,FALSE,TRUE
238,1,BODY,PACKAGES AND MODULES,9,4.95,110.55,20,321.45,40.15,432,45.1,FALSE,TRUE
238,3,BODY,Example 7.5.2-1. Type-Import-on-Demand,9,5.19,164.24,38,90,354.62,254.24,359.81,TRUE,FALSE
239,0,BODY,PACKAGES AND MODULES,9,4.95,110.55,20,72,40.15,182.55,45.1,FALSE,TRUE
239,1,BODY,Import Declarations7.5,9,4.95,110.27,22,357.73,40.15,468,45.1,FALSE,TRUE
240,0,BODY,7.6Top Level Class and Interface DeclarationsPACKAGES AND MODULES,9,4.95,396,65,36,40.15,432,45.1,FALSE,TRUE
241,0,BODY,PACKAGES AND MODULESTop Level Class and Interface Declarations7.6,9,4.95,396,65,72,40.15,468,45.1,FALSE,TRUE
241,3,BODY,Example 7.6-1. Conflicting Top Level Class and Interface Declarations,9,5.19,270.99,69,90,300.62,360.99,305.81,TRUE,FALSE
242,0,BODY,7.6Top Level Class and Interface DeclarationsPACKAGES AND MODULES,9,4.95,396,65,36,40.15,432,45.1,FALSE,TRUE
242,1,BODY,Example 7.6-2. Scope of Top Level Classes and Interfaces,9,5.19,220.49,56,90,75.62,310.49,80.81,TRUE,FALSE
243,0,BODY,PACKAGES AND MODULES,9,4.95,110.53,20,72,40.15,182.53,45.1,FALSE,TRUE
243,1,BODY,Module Declarations7.7,9,4.95,113.26,22,354.74,40.15,468,45.1,FALSE,TRUE
244,0,BODY,7.7Module Declarations,9,4.95,113.26,22,36,40.15,149.26,45.1,FALSE,TRUE
244,1,BODY,PACKAGES AND MODULES,9,4.95,110.53,20,321.47,40.15,432,45.1,FALSE,TRUE
245,0,BODY,PACKAGES AND MODULES,9,4.95,110.53,20,72,40.15,182.53,45.1,FALSE,TRUE
245,1,BODY,Module Declarations7.7,9,4.95,113.26,22,354.74,40.15,468,45.1,FALSE,TRUE
246,0,BODY,7.7Module Declarations,9,4.95,113.26,22,36,40.15,149.26,45.1,FALSE,TRUE
246,1,BODY,PACKAGES AND MODULES,9,4.95,110.53,20,321.47,40.15,432,45.1,FALSE,TRUE
247,0,BODY,PACKAGES AND MODULES,9,4.95,110.53,20,72,40.15,182.53,45.1,FALSE,TRUE
247,1,BODY,Module Declarations7.7,9,4.95,113.26,22,354.74,40.15,468,45.1,FALSE,TRUE
247,5,BODY,Suppose there are four module declarations as follows:,9,5.02,197.71,54,90,261.1,287.71,266.12,FALSE,FALSE
248,0,BODY,7.7Module Declarations,9,4.95,113.26,22,36,40.15,149.26,45.1,FALSE,TRUE
248,1,BODY,PACKAGES AND MODULES,9,4.95,110.53,20,321.47,40.15,432,45.1,FALSE,TRUE
248,2,BODY,"The modules may be compiled as follows, assuming that the current directory has one subdirectory per module, named after the module it contains:",9,15.02,323.99,144,90,74.1,413.99,89.12,FALSE,FALSE
249,0,BODY,PACKAGES AND MODULES,9,4.95,110.53,20,72,40.15,182.53,45.1,FALSE,TRUE
249,1,BODY,Module Declarations7.7,9,4.95,113.26,22,354.74,40.15,468,45.1,FALSE,TRUE
250,0,BODY,7.7Module Declarations,9,4.95,113.26,22,36,40.15,149.26,45.1,FALSE,TRUE
250,1,BODY,PACKAGES AND MODULES,9,4.95,110.53,20,321.47,40.15,432,45.1,FALSE,TRUE
251,0,BODY,PACKAGES AND MODULES,9,4.95,110.53,20,72,40.15,182.53,45.1,FALSE,TRUE
251,1,BODY,Module Declarations7.7,9,4.95,113.26,22,354.74,40.15,468,45.1,FALSE,TRUE
252,0,BODY,7.7Module Declarations,9,4.95,113.26,22,36,40.15,149.26,45.1,FALSE,TRUE
252,1,BODY,PACKAGES AND MODULES,9,4.95,110.53,20,321.47,40.15,432,45.1,FALSE,TRUE
254,0,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
255,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
255,1,BODY,Class Declarations8.1,9,4.95,106.04,21,361.96,40.15,468,45.1,FALSE,TRUE
256,0,BODY,8.1Class Declarations,9,4.95,106.04,21,36,40.15,142.04,45.1,FALSE,TRUE
256,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
256,3,BODY,"If two or more (distinct) class modifiers appear in a class declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for ClassModifier.",9,25.02,324,215,90,272.1,414,297.12,FALSE,FALSE
257,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
257,1,BODY,Class Declarations8.1,9,4.95,106.04,21,361.96,40.15,468,45.1,FALSE,TRUE
257,3,BODY,Example 8.1.1.1-1. Abstract Class Declaration,9,5.19,176.48,45,90,136.62,266.48,141.81,TRUE,FALSE
257,10,BODY,Example 8.1.1.1-2. Abstract Class Declaration that Prohibits Subclasses,9,5.19,274.74,71,90,521.62,364.74,526.81,TRUE,FALSE
258,0,BODY,8.1Class Declarations,9,4.95,106.04,21,36,40.15,142.04,45.1,FALSE,TRUE
258,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
259,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
259,1,BODY,Class Declarations8.1,9,4.95,106.04,21,361.96,40.15,468,45.1,FALSE,TRUE
260,0,BODY,8.1Class Declarations,9,4.95,106.04,21,36,40.15,142.04,45.1,FALSE,TRUE
260,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
260,3,BODY,TypeParameter: {TypeParameterModifier} TypeIdentifier [TypeBound] TypeParameterModifier: Annotation TypeBound: extends TypeVariable extends ClassOrInterfaceType {AdditionalBound} AdditionalBound: & InterfaceType,9,111.95,208.18,211,108,134.15,316.18,246.1,FALSE,TRUE
261,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
261,1,BODY,Class Declarations8.1,9,4.95,106.04,21,361.96,40.15,468,45.1,FALSE,TRUE
261,2,BODY,This restriction is needed since the catch mechanism of the Java Virtual Machine works only with non-generic classes.,9,15.02,323.99,117,90,74.1,413.99,89.12,FALSE,FALSE
261,3,BODY,Example 8.1.2-1. Mutually Recursive Type Variable Bounds,9,5.19,230.76,56,90,107.62,320.76,112.81,TRUE,FALSE
261,5,BODY,Example 8.1.2-2. Nested Generic Classes,9,5.19,155.23,39,90,228.62,245.23,233.81,TRUE,FALSE
262,0,BODY,8.1Class Declarations,9,4.95,106.04,21,36,40.15,142.04,45.1,FALSE,TRUE
262,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
262,5,BODY,Example 8.1.3-1. Inner Class Declarations and Static Members,9,5.19,240.98,60,90,537.62,330.98,542.81,TRUE,FALSE
263,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
263,1,BODY,Class Declarations8.1,9,4.95,106.04,21,361.96,40.15,468,45.1,FALSE,TRUE
263,5,BODY,Note that a construct which appears in a constructor declaration or an instance initializer does not occur in a static context.,9,15.02,323.99,127,90,585.1,413.99,600.12,FALSE,FALSE
264,0,BODY,8.1Class Declarations,9,4.95,106.04,21,36,40.15,142.04,45.1,FALSE,TRUE
264,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
264,4,BODY,"If an inner class is a local class or an anonymous class, it may be declared in a static context, and in that case is not considered an inner class of any enclosing class or interface.",9,15.02,324.01,184,90,411.1,414.01,426.12,FALSE,FALSE
265,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
265,1,BODY,Class Declarations8.1,9,4.95,106.04,21,361.96,40.15,468,45.1,FALSE,TRUE
265,3,BODY,Similar rules on variable use apply in the body of a lambda expression (§15.27.2).,9,5.02,295.46,82,90,440.1,385.46,445.12,FALSE,FALSE
265,5,BODY,Example 8.1.3-2. Inner Class Declarations,9,5.19,161.24,41,90,498.62,251.24,503.81,TRUE,FALSE
266,0,BODY,8.1Class Declarations,9,4.95,106.04,21,36,40.15,142.04,45.1,FALSE,TRUE
266,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
267,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
267,1,BODY,Class Declarations8.1,9,4.95,106.04,21,361.96,40.15,468,45.1,FALSE,TRUE
268,0,BODY,8.1Class Declarations,9,4.95,106.04,21,36,40.15,142.04,45.1,FALSE,TRUE
268,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
268,3,BODY,Example 8.1.4-1. Direct Superclasses and Subclasses,9,5.19,200.5,51,90,107.62,290.5,112.81,TRUE,FALSE
268,6,BODY,Example 8.1.4-2. Superclasses and Subclasses,9,5.19,174.27,44,90,294.62,264.27,299.81,TRUE,FALSE
269,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
269,1,BODY,Class Declarations8.1,9,4.95,106.04,21,361.96,40.15,468,45.1,FALSE,TRUE
269,3,BODY,Example 8.1.4-3. Class Depends on Itself,9,5.19,155.5,40,90,136.12,245.5,141.31,TRUE,FALSE
269,9,BODY,Example 8.1.5-1. Illegal Superinterfaces,9,5.19,152.99,40,90,526.62,242.99,531.81,TRUE,FALSE
270,0,BODY,8.1Class Declarations,9,4.95,106.04,21,36,40.15,142.04,45.1,FALSE,TRUE
270,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
270,3,BODY,This requirement was introduced in order to support translation by type erasure (§4.6).,9,5.02,311.45,87,90,400.1,401.45,405.12,FALSE,FALSE
271,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
271,1,BODY,Class Declarations8.1,9,4.95,106.04,21,361.96,40.15,468,45.1,FALSE,TRUE
271,4,BODY,Example 8.1.5-3. Illegal Multiple Inheritance of an Interface,9,5.19,230.98,61,90,285.62,320.98,290.81,TRUE,FALSE
271,8,BODY,Example 8.1.5-4. Implementing Methods of a Superinterface,9,5.19,231.73,57,90,528.62,321.73,533.81,TRUE,FALSE
272,0,BODY,8.1Class Declarations,9,4.95,106.04,21,36,40.15,142.04,45.1,FALSE,TRUE
272,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
273,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
273,1,BODY,Class Declarations8.1,9,4.95,106.04,21,361.96,40.15,468,45.1,FALSE,TRUE
274,0,BODY,8.1Class Declarations,9,4.95,106.04,21,36,40.15,142.04,45.1,FALSE,TRUE
274,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
274,3,BODY,"That is, the permitted direct subclasses are inferred as the classes in the same compilation unit that specify C as their direct superclass. The requirement for a canonical name means that no local classes or anonymous classes will be considered.",9,25.02,314,246,100,125.1,414,150.12,FALSE,FALSE
275,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
275,1,BODY,Class Members8.2,9,4.95,92.57,16,375.43,40.15,468,45.1,FALSE,TRUE
275,5,BODY,Example 8.2-1. Use of Class Members,9,5.19,144.73,35,90,578.62,234.73,583.81,TRUE,FALSE
276,0,BODY,8.2Class Members,9,4.95,92.57,16,36,40.15,128.57,45.1,FALSE,TRUE
276,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
276,6,BODY,Example 8.2-2. Inheritance of Class Members with Package Access,9,5.19,256.46,63,90,459.62,346.46,464.81,TRUE,FALSE
276,9,BODY,and:,9,5.02,15.5,4,90,567.1,105.5,572.12,FALSE,FALSE
277,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
277,1,BODY,Class Members8.2,9,4.95,92.57,16,375.43,40.15,468,45.1,FALSE,TRUE
277,3,BODY,"and a third compilation unit, in another package, is:",9,5.02,185.48,53,90,146.1,275.48,151.12,FALSE,FALSE
278,0,BODY,8.2Class Members,9,4.95,92.57,16,36,40.15,128.57,45.1,FALSE,TRUE
278,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
278,2,BODY,"Therefore, this test program, in another package, can be compiled successfully:",9,5.02,285.18,79,90,74.1,375.18,79.12,FALSE,FALSE
278,7,BODY,Example 8.2-5. Accessing Members of Inaccessible Classes,9,5.19,223.97,56,90,384.62,313.97,389.81,TRUE,FALSE
278,10,BODY,and another compilation unit of another package:,9,5.02,176.97,48,90,594.1,266.97,599.12,FALSE,FALSE
279,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
279,1,BODY,Field Declarations8.3,9,4.95,105.04,21,362.96,40.15,468,45.1,FALSE,TRUE
280,0,BODY,8.3Field Declarations,9,4.95,105.03,21,36,40.15,141.03,45.1,FALSE,TRUE
280,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
281,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
281,1,BODY,Field Declarations8.3,9,4.95,105.04,21,362.96,40.15,468,45.1,FALSE,TRUE
281,3,BODY,Dims: {Annotation} [ ] {{Annotation} [ ]},9,14.95,144.46,41,108,197.15,252.46,212.1,FALSE,TRUE
281,7,BODY,"In this respect, hiding of fields is similar to hiding of methods.",9,5.02,224.75,66,90,562.1,314.75,567.12,FALSE,FALSE
282,0,BODY,8.3Field Declarations,9,4.95,105.03,21,36,40.15,141.03,45.1,FALSE,TRUE
282,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
282,3,BODY,Example 8.3-1. Multiply Inherited Fields,9,5.19,156.51,40,90,316.62,246.51,321.81,TRUE,FALSE
283,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
283,1,BODY,Field Declarations8.3,9,4.95,105.04,21,362.96,40.15,468,45.1,FALSE,TRUE
283,3,BODY,It compiles and prints:,9,5.02,80.75,23,90,166.1,170.75,171.12,FALSE,FALSE
283,8,BODY,Example 8.3-2. Re-inheritance of Fields,9,5.19,151.49,39,90,407.62,241.49,412.81,TRUE,FALSE
284,0,BODY,8.3Field Declarations,9,4.95,105.03,21,36,40.15,141.03,45.1,FALSE,TRUE
284,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
284,6,BODY,"If two or more (distinct) field modifiers appear in a field declaration, it is customary, though not required, that they appear in the order consistent with that shown above in the production for FieldModifier.",9,25.02,324.01,210,90,303.1,414.01,328.12,FALSE,FALSE
285,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
285,1,BODY,Field Declarations8.3,9,4.95,105.04,21,362.96,40.15,468,45.1,FALSE,TRUE
285,4,BODY,This program prints:,9,5.02,74,20,90,297.1,164,302.12,FALSE,FALSE
285,8,BODY,is true. Further evidence is that the incrementation:,9,5.02,183.47,53,90,475.1,273.47,480.12,FALSE,FALSE
285,11,BODY,Example 8.3.1.1-2. Hiding of Class Variables,9,5.19,171.26,44,90,552.62,261.26,557.81,TRUE,FALSE
286,0,BODY,8.3Field Declarations,9,4.95,105.03,21,36,40.15,141.03,45.1,FALSE,TRUE
286,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
286,3,BODY,This program produces the output:,9,5.02,124.49,33,90,176.1,214.49,181.12,FALSE,FALSE
286,9,BODY,Example 8.3.1.1-3. Hiding of Instance Variables,9,5.19,183.26,47,90,468.62,273.26,473.81,TRUE,FALSE
287,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
287,1,BODY,Field Declarations8.3,9,4.95,105.04,21,362.96,40.15,468,45.1,FALSE,TRUE
287,3,BODY,This program produces the output:,9,5.02,124.49,33,90,106.1,214.49,111.12,FALSE,FALSE
288,0,BODY,8.3Field Declarations,9,4.95,105.03,21,36,40.15,141.03,45.1,FALSE,TRUE
288,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
289,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
289,1,BODY,Field Declarations8.3,9,4.95,105.04,21,362.96,40.15,468,45.1,FALSE,TRUE
290,0,BODY,8.3Field Declarations,9,4.95,105.03,21,36,40.15,141.03,45.1,FALSE,TRUE
290,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
290,6,BODY,"Variable initializers are also used in local variable declaration statements (§14.4), where the initializer is evaluated and the assignment performed each time the local variable declaration statement is executed.",9,25.02,324,213,90,541.1,414,566.12,FALSE,FALSE
291,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
291,1,BODY,Field Declarations8.3,9,4.95,105.04,21,362.96,40.15,468,45.1,FALSE,TRUE
291,2,BODY,Example 8.3.2-1. Field Initialization,9,5.19,137.51,37,90,75.62,227.51,80.81,TRUE,FALSE
291,4,BODY,This program produces the output:,9,5.02,124.49,33,90,197.1,214.49,202.12,FALSE,FALSE
291,7,BODY,Example 8.3.2-2. Forward Reference to a Class Variable,9,5.19,215.96,54,90,264.62,305.96,269.81,TRUE,FALSE
292,0,BODY,8.3Field Declarations,9,4.95,105.03,21,36,40.15,141.03,45.1,FALSE,TRUE
292,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
292,3,BODY,Example 8.3.3-1. Restrictions on Field References,9,5.19,189.97,49,90,228.62,279.97,233.81,TRUE,FALSE
292,4,BODY,A compile-time error occurs for this program:,9,5.02,165.47,45,90,252.1,255.47,257.12,FALSE,FALSE
292,6,BODY,whereas the following program compiles without error:,9,5.02,199.47,53,90,336.1,289.47,341.12,FALSE,FALSE
292,10,BODY,and:,9,5.02,15.5,4,90,546.1,105.5,551.12,FALSE,FALSE
293,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
293,1,BODY,Field Declarations8.3,9,4.95,105.04,21,362.96,40.15,468,45.1,FALSE,TRUE
293,3,BODY,"result in compile-time errors. Accesses by methods are not checked in this way, so:",9,5.02,299.7,83,90,96.1,389.7,101.12,FALSE,FALSE
293,5,BODY,produces the output:,9,5.02,73.49,20,90,230.1,163.49,235.12,FALSE,FALSE
294,0,BODY,8.4Method Declarations,9,4.95,113.5,22,36,40.15,149.5,45.1,FALSE,TRUE
294,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
295,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
295,1,BODY,Method Declarations8.4,9,4.95,113.5,22,354.5,40.15,468,45.1,FALSE,TRUE
295,3,BODY,Dims: {Annotation} [ ] {{Annotation} [ ]},9,14.95,144.46,41,108,134.15,252.46,149.1,FALSE,TRUE
296,0,BODY,8.4Method Declarations,9,4.95,113.5,22,36,40.15,149.5,45.1,FALSE,TRUE
296,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
296,5,BODY,The following productions from §8.3 and §4.3 are shown here for convenience:,9,5.02,286.19,76,90,494.1,376.19,499.12,FALSE,FALSE
296,6,BODY,VariableDeclaratorId: Identifier [Dims] _ Dims: {Annotation} [ ] {{Annotation} [ ]},9,53.95,144.46,83,108,516.15,252.46,570.1,FALSE,TRUE
297,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
297,1,BODY,Method Declarations8.4,9,4.95,113.5,22,354.5,40.15,468,45.1,FALSE,TRUE
298,0,BODY,8.4Method Declarations,9,4.95,113.5,22,36,40.15,149.5,45.1,FALSE,TRUE
298,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
299,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
299,1,BODY,Method Declarations8.4,9,4.95,113.5,22,354.5,40.15,468,45.1,FALSE,TRUE
299,3,BODY,B's constructor and instance method show that the type of the receiver parameter may be denoted with a qualified TypeName like any other type; but that the name of the receiver parameter in an inner class's constructor must use the simple name of the enclosing class.,9,25.02,324,267,90,96.1,414,121.12,FALSE,FALSE
299,5,BODY,Example 8.4.2-1. Override-Equivalent Signatures,9,5.19,189.5,47,90,360.62,279.5,365.81,TRUE,FALSE
300,0,BODY,8.4Method Declarations,9,4.95,113.5,22,36,40.15,149.5,45.1,FALSE,TRUE
300,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
300,9,BODY,"If two or more (distinct) method modifiers appear in a method declaration, it is customary, though not required, that they appear in the order consistent with that shown above in the production for MethodModifier.",9,25.02,324.01,213,90,486.1,414.01,511.12,FALSE,FALSE
301,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
301,1,BODY,Method Declarations8.4,9,4.95,113.5,22,354.5,40.15,468,45.1,FALSE,TRUE
301,3,BODY,"This can provide a place to put a documentation comment, to refine the return type, or to declare that the set of checked exceptions that can be thrown by that method, when it is implemented by its subclasses, is to be more limited.",9,25.02,324,232,90,189.1,414,214.12,FALSE,FALSE
301,5,BODY,Example 8.4.3.1-1. Abstract/Abstract Method Overriding,9,5.19,219.98,54,90,280.62,309.98,285.81,TRUE,FALSE
301,8,BODY,Example 8.4.3.1-2. Abstract/Non-Abstract Overriding,9,5.19,206.73,51,90,495.62,296.73,500.81,TRUE,FALSE
302,0,BODY,8.4Method Declarations,9,4.95,113.5,22,36,40.15,149.5,45.1,FALSE,TRUE
302,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
303,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
303,1,BODY,Method Declarations8.4,9,4.95,113.5,22,354.5,40.15,468,45.1,FALSE,TRUE
304,0,BODY,8.4Method Declarations,9,4.95,113.5,22,36,40.15,149.5,45.1,FALSE,TRUE
304,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
305,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
305,1,BODY,Method Declarations8.4,9,4.95,113.5,22,354.5,40.15,468,45.1,FALSE,TRUE
306,0,BODY,8.4Method Declarations,9,4.95,113.5,22,36,40.15,149.5,45.1,FALSE,TRUE
306,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
307,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
307,1,BODY,Method Declarations8.4,9,4.95,113.5,22,354.5,40.15,468,45.1,FALSE,TRUE
308,0,BODY,8.4Method Declarations,9,4.95,113.5,22,36,40.15,149.5,45.1,FALSE,TRUE
308,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
308,5,BODY,Example 8.4.6-1. Type Variables as Thrown Exception Types,9,5.19,234.51,57,90,317.62,324.51,322.81,TRUE,FALSE
309,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
309,1,BODY,Method Declarations8.4,9,4.95,113.5,22,354.5,40.15,468,45.1,FALSE,TRUE
310,0,BODY,8.4Method Declarations,9,4.95,113.5,22,36,40.15,149.5,45.1,FALSE,TRUE
310,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
310,5,BODY,Example 8.4.8-1. Inheritance,9,5.19,110.74,28,90,420.62,200.74,425.81,TRUE,FALSE
311,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
311,1,BODY,Method Declarations8.4,9,4.95,113.5,22,354.5,40.15,468,45.1,FALSE,TRUE
312,0,BODY,8.4Method Declarations,9,4.95,113.5,22,36,40.15,149.5,45.1,FALSE,TRUE
312,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
312,5,BODY,"In this respect, overriding of methods differs from hiding of fields.",9,5.02,239.97,69,90,402.1,329.97,407.12,FALSE,FALSE
312,7,BODY,Example 8.4.8.1-1. Overriding,9,5.19,116,29,90,488.62,206,493.81,TRUE,FALSE
313,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
313,1,BODY,Method Declarations8.4,9,4.95,113.5,22,354.5,40.15,468,45.1,FALSE,TRUE
313,4,BODY,Example 8.4.8.1-2. Overriding,9,5.19,116,29,90,179.62,206,184.81,TRUE,FALSE
313,5,BODY,"Overriding makes it easy for subclasses to extend the behavior of an existing class, as shown in this example:",9,15.02,324,110,90,203.1,414,218.12,FALSE,FALSE
314,0,BODY,8.4Method Declarations,9,4.95,113.5,22,36,40.15,149.5,45.1,FALSE,TRUE
314,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
314,2,BODY,This program produces the output:,9,5.02,124.49,33,90,74.1,214.49,79.12,FALSE,FALSE
315,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
315,1,BODY,Method Declarations8.4,9,4.95,113.5,22,354.5,40.15,468,45.1,FALSE,TRUE
315,3,BODY,"In this respect, hiding of methods is similar to hiding of fields.",9,5.02,224.75,66,90,125.1,314.75,130.12,FALSE,FALSE
315,4,BODY,Example 8.4.8.2-1. Invocation of Hidden Class Methods,9,5.19,213.01,53,90,148.62,303.01,153.81,TRUE,FALSE
315,7,BODY,produces the output:,9,5.02,73.49,20,90,366.1,163.49,371.12,FALSE,FALSE
315,11,BODY,This rule allows for covariant return types - refining the return type of a method when overriding it.,9,15.02,323.99,102,90,525.23,413.99,540.25,FALSE,FALSE
316,0,BODY,8.4Method Declarations,9,4.95,113.5,22,36,40.15,149.5,45.1,FALSE,TRUE
316,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
316,3,BODY,"In this respect, overriding of methods differs from hiding of fields (§8.3), for it is permissible for a field to hide a field of another type.",9,15.02,324,143,90,125.1,414,140.12,FALSE,FALSE
317,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
317,1,BODY,Method Declarations8.4,9,4.95,113.5,22,354.5,40.15,468,45.1,FALSE,TRUE
317,3,BODY,Example 8.4.8.3-1. Covariant Return Types,9,5.19,166.99,41,90,239.62,256.99,244.81,TRUE,FALSE
317,4,BODY,The following declarations are legal in the Java programming language from Java SE 5.0 onwards:,9,15.02,323.99,95,90,263.1,413.99,278.12,FALSE,FALSE
317,6,BODY,The relaxed rule for overriding also allows one to relax the conditions on abstract classes implementing interfaces.,9,15.02,323.99,116,90,407.1,413.99,422.12,FALSE,FALSE
317,7,BODY,Example 8.4.8.3-2. Unchecked Warning from Return Type,9,5.19,224.99,53,90,440.62,314.99,445.81,TRUE,FALSE
317,8,BODY,Consider:,9,5.02,35,9,90,464.1,125,469.12,FALSE,FALSE
318,0,BODY,8.4Method Declarations,9,4.95,113.5,22,36,40.15,149.5,45.1,FALSE,TRUE
318,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
319,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
319,1,BODY,Method Declarations8.4,9,4.95,113.5,22,354.5,40.15,468,45.1,FALSE,TRUE
319,2,BODY,Example 8.4.8.3-4. Erasure Affects Overriding,9,5.19,178.48,45,90,75.62,268.48,80.81,TRUE,FALSE
319,3,BODY,A class cannot have two member methods with the same name and type erasure:,9,5.02,289.69,75,90,99.1,379.69,104.12,FALSE,FALSE
320,0,BODY,8.4Method Declarations,9,4.95,113.5,22,36,40.15,149.5,45.1,FALSE,TRUE
320,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
320,5,BODY,Example 8.4.8.4-1. Inheritance of override-equivalent methods,9,5.19,239.73,61,90,426.62,329.73,431.81,TRUE,FALSE
321,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
321,1,BODY,Method Declarations8.4,9,4.95,113.5,22,354.5,40.15,468,45.1,FALSE,TRUE
321,3,BODY,Example 8.4.9-1. Overloading,9,5.19,114.26,28,90,291.62,204.26,296.81,TRUE,FALSE
321,6,BODY,"Example 8.4.9-2. Overloading, Overriding, and Hiding",9,5.19,209.53,52,90,498.62,299.53,503.81,TRUE,FALSE
322,0,BODY,8.4Method Declarations,9,4.95,113.5,22,36,40.15,149.5,45.1,FALSE,TRUE
322,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
323,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
323,1,BODY,Method Declarations8.4,9,4.95,113.5,22,354.5,40.15,468,45.1,FALSE,TRUE
323,5,BODY,The output from this program is:,9,5.02,117.75,32,90,362.1,207.75,367.12,FALSE,FALSE
324,0,BODY,8.5Member Class and Interface Declarations,9,4.95,190.03,42,36,40.15,226.03,45.1,FALSE,TRUE
324,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
324,4,BODY,"In this respect, hiding of member class and interfaces is similar to hiding of fields (§8.3).",9,5.02,319.96,93,90,527.1,409.96,532.12,FALSE,FALSE
325,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
325,1,BODY,Instance Initializers8.6,9,4.95,108.52,24,359.48,40.15,468,45.1,FALSE,TRUE
326,0,BODY,8.8Constructor Declarations,9,4.95,129.46,27,36,40.15,165.46,45.1,FALSE,TRUE
326,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
327,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
327,1,BODY,Constructor Declarations8.8,9,4.95,129.46,27,338.54,40.15,468,45.1,FALSE,TRUE
327,3,BODY,Example 8.8-1. Constructor Declarations,9,5.19,157.23,39,90,245.62,247.23,250.81,TRUE,FALSE
327,7,BODY,"2.In a class instance creation expression for an inner local class or an anonymous class (not in a static context), §15.9.2 specifies the immediately enclosing instance of",9,15.02,324,171,90,588.1,414,603.12,FALSE,FALSE
328,0,BODY,8.8Constructor Declarations,9,4.95,129.46,27,36,40.15,165.46,45.1,FALSE,TRUE
328,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
328,2,BODY,the local/anonymous class. The local/anonymous class is necessarily emitted by the same compiler as the class instance creation expression. That compiler can represent the immediately enclosing instance how ever it wishes. There is no need for the Java programming language to implicitly declare a parameter in the local/anonymous class's constructor.,9,45.02,306.01,351,108,74.1,414.01,119.12,FALSE,FALSE
328,3,BODY,"3.In a class instance creation expression for an anonymous class, and where the anonymous class's superclass is an inner class (not in a static context), §15.9.2 specifies the anonymous class's immediately enclosing instance with respect to the superclass. This instance must be transmitted from the anonymous class to its superclass, where it will serve as the immediately enclosing instance. Since the superclass may have been emitted by a compiler which is different than the compiler of the class instance creation expression, it is necessary to transmit the instance in a standard way, by passing it as the first argument to the superclass's constructor. Note that the anonymous class itself is necessarily emitted by the same compiler as the class instance creation expression, so it would be possible for the compiler to transmit the immediately enclosing instance with respect to the superclass to the anonymous class how ever it wishes, before the anonymous class passes the instance to the superclass's constructor. However, for consistency, the Java programming language deems in §15.9.5.1 that, in some circumstances, an anonymous class's constructor implicitly declares an initial parameter for the immediately enclosing instance with respect to the superclass.",9,145.02,324.01,1274,90,130.1,414.01,275.12,FALSE,FALSE
329,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
329,1,BODY,Constructor Declarations8.8,9,4.95,129.46,27,338.54,40.15,468,45.1,FALSE,TRUE
330,0,BODY,8.8Constructor Declarations,9,4.95,129.46,27,36,40.15,165.46,45.1,FALSE,TRUE
330,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
330,8,BODY,Example 8.8.7-1. Constructor Bodies,9,5.19,140.99,35,90,548.62,230.99,553.81,TRUE,FALSE
331,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
331,1,BODY,Constructor Declarations8.8,9,4.95,129.46,27,338.54,40.15,468,45.1,FALSE,TRUE
331,6,BODY,"TypeArguments: < TypeArgumentList > ArgumentList: Expression {, Expression}",9,43.95,107.09,75,108,363.28,215.09,407.23,FALSE,TRUE
332,0,BODY,8.8Constructor Declarations,9,4.95,129.46,27,36,40.15,165.46,45.1,FALSE,TRUE
332,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
333,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
333,1,BODY,Constructor Declarations8.8,9,4.95,129.46,27,338.54,40.15,468,45.1,FALSE,TRUE
334,0,BODY,8.8Constructor Declarations,9,4.95,129.46,27,36,40.15,165.46,45.1,FALSE,TRUE
334,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
334,3,BODY,Example 8.8.7.1-1. Restrictions on Explicit Constructor Invocation Statements,9,5.19,300.23,77,90,129.62,390.23,134.81,TRUE,FALSE
334,7,BODY,Example 8.8.7.1-2. Qualified Superclass Constructor Invocation,9,5.19,244.76,62,90,380.62,334.76,385.81,TRUE,FALSE
335,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
335,1,BODY,Constructor Declarations8.8,9,4.95,129.46,27,338.54,40.15,468,45.1,FALSE,TRUE
335,4,BODY,This program produces the output:,9,5.02,124.49,33,90,348.1,214.49,353.12,FALSE,FALSE
336,0,BODY,8.8Constructor Declarations,9,4.95,129.46,27,36,40.15,165.46,45.1,FALSE,TRUE
336,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
336,3,BODY,Example 8.8.9-1. Default Constructors,9,5.19,147.48,37,90,317.62,237.48,322.81,TRUE,FALSE
336,4,BODY,The declaration:,9,5.02,58.73,16,90,341.1,148.73,346.12,FALSE,FALSE
336,8,BODY,Example 8.8.9-2. Accessibility of Constructors v. Classes,9,5.19,215.98,57,90,502.62,305.98,507.81,TRUE,FALSE
336,9,BODY,"The rule that the default constructor of a class has the same accessibility as the class itself is simple and intuitive. Note, however, that this does not imply that the constructor is accessible whenever the class is accessible. Consider:",9,25.02,324,239,90,526.1,414,551.12,FALSE,FALSE
337,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
337,1,BODY,Constructor Declarations8.8,9,4.95,129.46,27,338.54,40.15,468,45.1,FALSE,TRUE
337,5,BODY,Example 8.8.10-1. Preventing Instantiation via Constructor Accessibility,9,5.19,277.74,72,90,356.62,367.74,361.81,TRUE,FALSE
338,0,BODY,8.9Enum Classes,9,4.95,87.59,15,36,40.15,123.59,45.1,FALSE,TRUE
338,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
338,7,BODY,"In addition to the compile-time error, three further mechanisms ensure that no instances of an enum class exist beyond those defined by its enum constants:",9,15.02,324.01,155,90,570.1,414.01,585.12,FALSE,FALSE
339,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
339,1,BODY,Enum Classes8.9,9,4.95,87.6,15,380.4,40.15,468,45.1,FALSE,TRUE
339,5,BODY,"ArgumentList: Expression {, Expression}",9,14.95,107.09,39,108,374.15,215.09,389.1,FALSE,TRUE
340,0,BODY,8.9Enum Classes,9,4.95,87.59,15,36,40.15,123.59,45.1,FALSE,TRUE
340,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
340,6,BODY,ClassBodyDeclaration: ClassMemberDeclaration InstanceInitializer StaticInitializer ConstructorDeclaration ClassMemberDeclaration: FieldDeclaration MethodDeclaration ClassDeclaration InterfaceDeclaration ;,9,113.75,103.49,204,108,346.15,211.49,459.9,FALSE,TRUE
341,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
341,1,BODY,Enum Classes8.9,9,4.95,87.6,15,380.4,40.15,468,45.1,FALSE,TRUE
341,5,BODY,Example 8.9.2-1. Enum Body Declarations,9,5.19,162.76,39,90,367.62,252.76,372.81,TRUE,FALSE
341,8,BODY,Example 8.9.2-2. Restriction On Enum Constant Self-Reference,9,5.19,244.22,60,90,512.62,334.22,517.81,TRUE,FALSE
342,0,BODY,8.9Enum Classes,9,4.95,87.59,15,36,40.15,123.59,45.1,FALSE,TRUE
342,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
342,4,BODY,"The refactored version is clearly correct, as static initialization occurs top to bottom.",9,5.02,303.44,89,90,350.1,393.44,355.12,FALSE,FALSE
343,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
343,1,BODY,Enum Classes8.9,9,4.95,87.6,15,380.4,40.15,468,45.1,FALSE,TRUE
343,5,BODY,This program produces the output:,9,5.02,124.49,33,90,312.1,214.49,317.12,FALSE,FALSE
343,7,BODY,Example 8.9.3-2. Switching Over Enum Constants,9,5.19,192.51,46,90,382.62,282.51,387.81,TRUE,FALSE
344,0,BODY,8.9Enum Classes,9,4.95,87.59,15,36,40.15,123.59,45.1,FALSE,TRUE
344,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
344,3,BODY,This program produces the output:,9,5.02,124.49,33,90,146.1,214.49,151.12,FALSE,FALSE
344,5,BODY,Example 8.9.3-3. Enum Constants with Class Bodies,9,5.19,200.27,49,90,218.62,290.27,223.81,TRUE,FALSE
345,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
345,1,BODY,Enum Classes8.9,9,4.95,87.6,15,380.4,40.15,468,45.1,FALSE,TRUE
345,3,BODY,Example 8.9.3-4. Multiple Enum Classes,9,5.19,155.26,38,90,117.62,245.26,122.81,TRUE,FALSE
345,4,BODY,"In the following program, a playing card class is built atop two simple enums.",9,5.02,280.73,78,90,141.1,370.73,146.12,FALSE,FALSE
346,0,BODY,8.9Enum Classes,9,4.95,87.59,15,36,40.15,123.59,45.1,FALSE,TRUE
346,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
346,5,BODY,The program produces the output:,9,5.02,122.48,32,90,460.1,212.48,465.12,FALSE,FALSE
347,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
347,1,BODY,Record Classes8.10,9,4.95,92.57,18,375.43,40.15,468,45.1,FALSE,TRUE
348,0,BODY,8.10Record Classes,9,4.95,92.57,18,36,40.15,128.57,45.1,FALSE,TRUE
348,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
348,5,BODY,"Annotations on a record component are available via reflection if their annotation interfaces are applicable in the record component context (§9.6.4.1). Independently, annotations on a record component are propagated to the declarations of members and constructors of the record class if their annotation interfaces are applicable in other contexts (§8.10.3, §8.10.4).",9,35.02,324.01,368,90,450.1,414.01,485.12,FALSE,FALSE
349,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
349,1,BODY,Record Classes8.10,9,4.95,92.57,18,375.43,40.15,468,45.1,FALSE,TRUE
350,0,BODY,8.10Record Classes,9,4.95,92.57,18,36,40.15,128.57,45.1,FALSE,TRUE
350,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
350,2,BODY,ClassBodyDeclaration: ClassMemberDeclaration InstanceInitializer StaticInitializer ConstructorDeclaration ClassMemberDeclaration: FieldDeclaration MethodDeclaration ClassDeclaration InterfaceDeclaration ;,9,113.75,103.49,204,108,74.15,211.49,187.9,FALSE,TRUE
351,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
351,1,BODY,Record Classes8.10,9,4.95,92.57,18,375.43,40.15,468,45.1,FALSE,TRUE
352,0,BODY,8.10Record Classes,9,4.95,92.57,18,36,40.15,128.57,45.1,FALSE,TRUE
352,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
353,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
353,1,BODY,Record Classes8.10,9,4.95,92.57,18,375.43,40.15,468,45.1,FALSE,TRUE
354,0,BODY,8.10Record Classes,9,4.95,92.57,18,36,40.15,128.57,45.1,FALSE,TRUE
354,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
354,6,BODY,"Given the signature of a normal constructor that qualifies as canonical, and the signature derived for a compact constructor, the rules of constructor signatures (§8.8.2) mean it is a compile-time error if a record declaration has both a normal constructor that qualifies as canonical and a compact constructor.",9,35.02,324,311,90,447.1,414,482.12,FALSE,FALSE
355,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
355,1,BODY,Record Classes8.10,9,4.95,92.57,18,375.43,40.15,468,45.1,FALSE,TRUE
356,0,BODY,8.10Record Classes,9,4.95,92.57,18,36,40.15,128.57,45.1,FALSE,TRUE
356,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
356,3,BODY,"As a canonical constructor has a signature that is override-equivalent to the derived constructor signature of the record class, there can be only one canonical constructor declared explicitly in the record class.",9,25.02,324,213,90,190.23,414,215.25,FALSE,FALSE
357,0,BODY,CLASSES,9,4.95,35.51,7,72,40.15,107.51,45.1,FALSE,TRUE
357,1,BODY,Record Classes8.10,9,4.95,92.57,18,375.43,40.15,468,45.1,FALSE,TRUE
357,4,BODY,ConstructorModifier: (one of) Annotation public protected private SimpleTypeName: TypeIdentifier ConstructorBody: { [ExplicitConstructorInvocation] [BlockStatements] },9,82.95,211.04,167,108,217.28,319.04,300.23,FALSE,TRUE
358,0,BODY,8.10Record Classes,9,4.95,92.57,18,36,40.15,128.57,45.1,FALSE,TRUE
358,1,BODY,CLASSES,9,4.95,35.5,7,396.49,40.15,432,45.1,FALSE,TRUE
360,0,BODY,9.1Interface Declarations,9,4.95,118.43,25,36,40.15,154.43,45.1,FALSE,TRUE
360,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
361,0,BODY,INTERFACES,9,4.95,52,10,72,40.15,124,45.1,FALSE,TRUE
361,1,BODY,Interface Declarations9.1,9,4.95,118.43,25,349.57,40.15,468,45.1,FALSE,TRUE
361,3,BODY,"If two or more (distinct) interface modifiers appear in an interface declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for InterfaceModifier.",9,25.02,323.99,228,90,259.1,413.99,284.12,FALSE,FALSE
361,5,BODY,This modifier is obsolete and should not be used in new code.,9,5.02,222.48,61,90,348.23,312.48,353.25,FALSE,FALSE
362,0,BODY,9.1Interface Declarations,9,4.95,118.43,25,36,40.15,154.43,45.1,FALSE,TRUE
362,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
362,3,BODY,It is useful to recall that a class is said to be a direct subclass of its direct superinterfaces (§8.1.5).,9,15.02,324,107,90,145.23,414,160.25,FALSE,FALSE
362,6,BODY,The following productions from §8.1.2 and §4.4 are shown here for convenience:,9,5.02,292.94,78,90,409.23,382.94,414.25,FALSE,FALSE
362,7,BODY,"TypeParameters: < TypeParameterList > TypeParameterList: TypeParameter {, TypeParameter} TypeParameter: {TypeParameterModifier} TypeIdentifier [TypeBound] TypeParameterModifier: Annotation TypeBound: extends TypeVariable extends ClassOrInterfaceType {AdditionalBound} AdditionalBound: & InterfaceType",9,169.95,208.18,300,108,431.28,316.18,601.23,FALSE,TRUE
363,0,BODY,INTERFACES,9,4.95,52,10,72,40.15,124,45.1,FALSE,TRUE
363,1,BODY,Interface Declarations9.1,9,4.95,118.43,25,349.57,40.15,468,45.1,FALSE,TRUE
363,5,BODY,"InterfaceTypeList: InterfaceType {, InterfaceType}",9,14.95,127.07,50,108,494.15,235.07,509.1,FALSE,TRUE
364,0,BODY,9.1Interface Declarations,9,4.95,118.43,25,36,40.15,154.43,45.1,FALSE,TRUE
364,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
365,0,BODY,INTERFACES,9,4.95,52,10,72,40.15,124,45.1,FALSE,TRUE
365,1,BODY,Interface Declarations9.1,9,4.95,118.43,25,349.57,40.15,468,45.1,FALSE,TRUE
366,0,BODY,9.2Interface Members,9,4.95,104.96,20,36,40.15,140.96,45.1,FALSE,TRUE
366,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
366,3,BODY,"That is, the permitted direct subclasses and subinterfaces are inferred as the classes and interfaces in the same compilation unit that specify I as a direct superinterface. The requirement for a canonical name means that no local classes, local interfaces, or anonymous classes will be considered.",9,35.02,324,298,90,112.1,414,147.12,FALSE,FALSE
367,0,BODY,INTERFACES,9,4.95,52,10,72,40.15,124,45.1,FALSE,TRUE
367,1,BODY,Field (Constant) Declarations9.3,9,4.95,146.2,32,321.8,40.15,468,45.1,FALSE,TRUE
367,4,BODY,"VariableDeclaratorList: VariableDeclarator {, VariableDeclarator} VariableDeclarator: VariableDeclaratorId [= VariableInitializer] VariableDeclaratorId: Identifier [Dims] _",9,82.75,172.9,172,108,499.15,280.9,581.9,FALSE,TRUE
368,0,BODY,9.3Field (Constant) Declarations,9,4.95,146.2,32,36,40.15,182.2,45.1,FALSE,TRUE
368,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
368,2,BODY,Dims: {Annotation} [ ] {{Annotation} [ ]} VariableInitializer: Expression ArrayInitializer,9,53.95,144.46,90,108,74.15,252.46,128.1,FALSE,TRUE
368,4,BODY,"If two or more (distinct) field modifiers appear in a field declaration, it is customary, though not required, that they appear in the order consistent with that shown above in the production for ConstantModifier.",9,25.02,324.01,213,90,257.1,414.01,282.12,FALSE,FALSE
369,0,BODY,INTERFACES,9,4.95,52,10,72,40.15,124,45.1,FALSE,TRUE
369,1,BODY,Field (Constant) Declarations9.3,9,4.95,146.2,32,321.8,40.15,468,45.1,FALSE,TRUE
369,3,BODY,Example 9.3-1. Ambiguous Inherited Fields,9,5.19,167.01,41,90,133.62,257.01,138.81,TRUE,FALSE
369,4,BODY,"If two fields with the same name are inherited by an interface because, for example, two of its direct superinterfaces declare fields with that name, then a single ambiguous member results. Any use of this ambiguous member will result in a compile-time error. In the program:",9,35.02,324.01,275,90,157.1,414.01,192.12,FALSE,FALSE
369,7,BODY,Example 9.3-2. Multiply Inherited Fields,9,5.19,156.51,40,90,426.62,246.51,431.81,TRUE,FALSE
370,0,BODY,9.4Method Declarations,9,4.95,113.45,22,36,40.15,149.45,45.1,FALSE,TRUE
370,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
370,3,BODY,Example 9.3.1-1. Forward Reference to a Field,9,5.19,179.22,45,90,290.62,269.22,295.81,TRUE,FALSE
370,7,BODY,MethodHeader: Result MethodDeclarator [Throws] TypeParameters {Annotation} Result MethodDeclarator [Throws],9,24.95,249.7,107,108,575.15,357.7,600.1,FALSE,TRUE
371,0,BODY,INTERFACES,9,4.95,52,10,72,40.15,124,45.1,FALSE,TRUE
371,1,BODY,Method Declarations9.4,9,4.95,113.45,22,354.55,40.15,468,45.1,FALSE,TRUE
371,2,BODY,"Result: UnannType void MethodDeclarator: Identifier ( [ReceiverParameter ,] [FormalParameterList] ) [Dims] MethodBody: Block ;",9,92.75,262.18,126,108,74.15,370.18,166.9,FALSE,TRUE
372,0,BODY,9.4Method Declarations,9,4.95,113.45,22,36,40.15,149.45,45.1,FALSE,TRUE
372,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
373,0,BODY,INTERFACES,9,4.95,52,10,72,40.15,124,45.1,FALSE,TRUE
373,1,BODY,Method Declarations9.4,9,4.95,113.45,22,354.55,40.15,468,45.1,FALSE,TRUE
374,0,BODY,9.4Method Declarations,9,4.95,113.45,22,36,40.15,149.45,45.1,FALSE,TRUE
374,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
375,0,BODY,INTERFACES,9,4.95,52,10,72,40.15,124,45.1,FALSE,TRUE
375,1,BODY,Method Declarations9.4,9,4.95,113.45,22,354.55,40.15,468,45.1,FALSE,TRUE
376,0,BODY,9.4Method Declarations,9,4.95,113.45,22,36,40.15,149.45,45.1,FALSE,TRUE
376,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
376,2,BODY,"class hierarchies, to minimize class-interface clashes by simply giving priority to concrete methods.",9,15.02,323.99,101,90,74.1,413.99,89.12,FALSE,FALSE
377,0,BODY,INTERFACES,9,4.95,52,10,72,40.15,124,45.1,FALSE,TRUE
377,1,BODY,Member Class and Interface Declarations9.5,9,4.95,189.82,42,278.18,40.15,468,45.1,FALSE,TRUE
378,0,BODY,9.6Annotation Interfaces,9,4.95,114.95,24,36,40.15,150.95,45.1,FALSE,TRUE
378,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
378,5,BODY,"For example, annotation interface declarations have the same rules for scope as normal interface declarations.",9,15.02,324,110,90,277.1,414,292.12,FALSE,FALSE
378,7,BODY,"An annotation interface declaration is not permitted syntactically to appear within a block, by virtue of the LocalClassOrInterfaceDeclaration production in §14.3.",9,15.02,324.01,163,90,379.1,414.01,394.12,FALSE,FALSE
379,0,BODY,INTERFACES,9,4.95,52,10,72,40.15,124,45.1,FALSE,TRUE
379,1,BODY,Annotation Interfaces9.6,9,4.95,114.95,24,353.05,40.15,468,45.1,FALSE,TRUE
379,4,BODY,"Unlike a normal interface declaration, an annotation interface declaration cannot declare any type variables, by virtue of the AnnotationTypeDeclaration production.",9,15.02,324,164,90,279.1,414,294.12,FALSE,FALSE
379,8,BODY,"Because these methods do not define elements of the annotation interface, it is illegal to use them in annotations conforming to the annotation interface (§9.7). Without this rule, we could not ensure that elements were of the types representable in annotations, or that accessor methods for them would be available.",9,35.02,324,316,90,517.1,414,552.12,FALSE,FALSE
380,0,BODY,9.6Annotation Interfaces,9,4.95,114.95,24,36,40.15,150.95,45.1,FALSE,TRUE
380,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
380,5,BODY,The following production from §4.3 is shown here for convenience:,9,5.02,244.46,65,90,398.1,334.46,403.12,FALSE,FALSE
380,6,BODY,Dims: {Annotation} [ ] {{Annotation} [ ]},9,14.95,144.46,41,108,420.15,252.46,435.1,FALSE,TRUE
381,0,BODY,INTERFACES,9,4.95,52,10,72,40.15,124,45.1,FALSE,TRUE
381,1,BODY,Annotation Interfaces9.6,9,4.95,114.95,24,353.05,40.15,468,45.1,FALSE,TRUE
382,0,BODY,9.6Annotation Interfaces,9,4.95,114.95,24,36,40.15,150.95,45.1,FALSE,TRUE
382,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
382,2,BODY,Example 9.6.1-1. Annotation Interface Declaration,9,5.19,194.23,49,90,75.62,284.23,80.81,TRUE,FALSE
382,4,BODY,Example 9.6.1-2. Marker Annotation Interface Declaration,9,5.19,226.47,56,90,241.12,316.47,246.31,TRUE,FALSE
382,5,BODY,The following annotation interface declaration defines a marker annotation interface:,9,5.02,306.17,85,90,264.6,396.17,269.62,FALSE,FALSE
382,7,BODY,Example 9.6.1-3. Single-Element Annotation Interface Declarations,9,5.19,258.48,65,90,356.62,348.48,361.81,TRUE,FALSE
382,10,BODY,The following annotation interface declaration defines a single-element annotation interface whose sole element has an array type:,9,15.02,323.99,130,90,484.1,413.99,499.12,FALSE,FALSE
383,0,BODY,INTERFACES,9,4.95,52,10,72,40.15,124,45.1,FALSE,TRUE
383,1,BODY,Annotation Interfaces9.6,9,4.95,114.95,24,353.05,40.15,468,45.1,FALSE,TRUE
383,3,BODY,The following annotation interface declaration contains an element whose type is an annotation interface type:,9,15.02,323.99,110,90,146.1,413.99,161.12,FALSE,FALSE
383,5,BODY,"The grammar for annotation interface declarations permits other member declarations besides method declarations. For example, one might choose to declare a nested enum class for use by an element of the annotation interface:",9,25.02,324,224,90,340.1,414,365.12,FALSE,FALSE
384,0,BODY,9.6Annotation Interfaces,9,4.95,114.95,24,36,40.15,150.95,45.1,FALSE,TRUE
384,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
384,2,BODY,"ElementValue: ConditionalExpression ElementValueArrayInitializer Annotation ElementValueArrayInitializer: { [ElementValueList] [,] } ElementValueList: ElementValue {, ElementValue}",9,92.95,128.08,180,108,74.15,236.08,167.1,FALSE,TRUE
384,3,BODY,Note that an annotation interface element which is specified to have a default value is not a default method (§9.4). The declaration of an annotation interface cannot declare default methods (§9.6.1).,9,25.02,324,200,90,184.1,414,209.12,FALSE,FALSE
384,5,BODY,Example 9.6.2-1. Annotation Interface Declaration With Default Values,9,5.19,274.98,69,90,333.62,364.98,338.81,TRUE,FALSE
385,0,BODY,INTERFACES,9,4.95,52,10,72,40.15,124,45.1,FALSE,TRUE
385,1,BODY,Annotation Interfaces9.6,9,4.95,114.95,24,353.05,40.15,468,45.1,FALSE,TRUE
386,0,BODY,9.6Annotation Interfaces,9,4.95,114.95,24,36,40.15,150.95,45.1,FALSE,TRUE
386,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
386,5,BODY,Example 9.6.3-1. Ill-formed Containing Annotation Interface,9,5.19,233.99,59,90,203.62,323.99,208.81,TRUE,FALSE
386,6,BODY,Consider the following declarations:,9,5.02,131.24,36,90,227.1,221.24,232.12,FALSE,FALSE
386,10,BODY,"Allowing more than one containing annotation interface to be specified would cause an undesirable choice at compile time, when multiple annotations of the repeatable annotation interface are logically replaced with a container annotation (§9.7.5).",9,25.02,324,247,90,411.1,414,436.12,FALSE,FALSE
387,0,BODY,INTERFACES,9,4.95,52,10,72,40.15,124,45.1,FALSE,TRUE
387,1,BODY,Annotation Interfaces9.6,9,4.95,114.95,24,353.05,40.15,468,45.1,FALSE,TRUE
387,2,BODY,"cannot specify each other as their containing annotation interface, because cyclic annotation interface declarations are illegal.",9,15.02,324,129,90,74.1,414,89.12,FALSE,FALSE
387,4,BODY,Example 9.6.3-2. Restricting Where Annotations May Repeat,9,5.19,235.22,57,90,181.62,325.22,186.81,TRUE,FALSE
387,8,BODY,while the following interface declaration is illegal:,9,5.02,181.97,53,90,473.1,271.97,478.12,FALSE,FALSE
388,0,BODY,9.6Annotation Interfaces,9,4.95,114.95,24,36,40.15,150.95,45.1,FALSE,TRUE
388,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
388,3,BODY,Example 9.6.3-3. A Repeatable Containing Annotation Interface,9,5.19,246.24,61,90,327.62,336.24,332.81,TRUE,FALSE
388,4,BODY,The following declarations are legal:,9,5.02,132.47,37,90,351.1,222.47,356.12,FALSE,FALSE
388,6,BODY,"Thus, an annotation whose interface is a containing annotation interface may itself be repeated:",9,15.02,324,96,90,525.1,414,540.12,FALSE,FALSE
389,0,BODY,INTERFACES,9,4.95,52,10,72,40.15,124,45.1,FALSE,TRUE
389,1,BODY,Annotation Interfaces9.6,9,4.95,114.95,24,353.05,40.15,468,45.1,FALSE,TRUE
390,0,BODY,9.6Annotation Interfaces,9,4.95,114.95,24,36,40.15,150.95,45.1,FALSE,TRUE
390,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
391,0,BODY,INTERFACES,9,4.95,52,10,72,40.15,124,45.1,FALSE,TRUE
391,1,BODY,Annotation Interfaces9.6,9,4.95,114.95,24,353.05,40.15,468,45.1,FALSE,TRUE
392,0,BODY,9.6Annotation Interfaces,9,4.95,114.95,24,36,40.15,150.95,45.1,FALSE,TRUE
392,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
393,0,BODY,INTERFACES,9,4.95,52,10,72,40.15,124,45.1,FALSE,TRUE
393,1,BODY,Annotation Interfaces9.6,9,4.95,114.95,24,353.05,40.15,468,45.1,FALSE,TRUE
394,0,BODY,9.6Annotation Interfaces,9,4.95,114.95,24,36,40.15,150.95,45.1,FALSE,TRUE
394,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
395,0,BODY,INTERFACES,9,4.95,52,10,72,40.15,124,45.1,FALSE,TRUE
395,1,BODY,Annotation Interfaces9.6,9,4.95,114.95,24,353.05,40.15,468,45.1,FALSE,TRUE
396,0,BODY,9.6Annotation Interfaces,9,4.95,114.95,24,36,40.15,150.95,45.1,FALSE,TRUE
396,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
397,0,BODY,INTERFACES,9,4.95,52,10,72,40.15,124,45.1,FALSE,TRUE
397,1,BODY,Annotations9.7,9,4.95,79.51,14,388.49,40.15,468,45.1,FALSE,TRUE
398,0,BODY,9.7Annotations,9,4.95,79.51,14,36,40.15,115.51,45.1,FALSE,TRUE
398,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
399,0,BODY,INTERFACES,9,4.95,52,10,72,40.15,124,45.1,FALSE,TRUE
399,1,BODY,Annotations9.7,9,4.95,79.51,14,388.49,40.15,468,45.1,FALSE,TRUE
399,3,BODY,"An ElementValueArrayInitializer is similar to a normal array initializer (§10.6), except that an ElementValueArrayInitializer may syntactically contain annotations as well as expressions and nested initializers. However, nested initializers are not semantically legal in an ElementValueArrayInitializer because they are never commensurate with array-typed elements in annotation interface declarations (nested array types not permitted).",9,55.02,304,437,110,420.1,414,475.12,FALSE,FALSE
400,0,BODY,9.7Annotations,9,4.95,79.51,14,36,40.15,115.51,45.1,FALSE,TRUE
400,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
400,4,BODY,"It is customary, though not required, that element-value pairs in an annotation are presented in the same order as the corresponding elements in the annotation interface declaration.",9,15.02,324,182,90,219.1,414,234.12,FALSE,FALSE
400,7,BODY,Example 9.7.1-1. Normal Annotations,9,5.19,145,35,90,377.62,235,382.81,TRUE,FALSE
400,8,BODY,Here is an example of a normal annotation using the annotation interface from §9.6.1:,9,5.02,309.2,85,90,401.1,399.2,406.12,FALSE,FALSE
401,0,BODY,INTERFACES,9,4.95,52,10,72,40.15,124,45.1,FALSE,TRUE
401,1,BODY,Annotations9.7,9,4.95,79.51,14,388.49,40.15,468,45.1,FALSE,TRUE
401,5,BODY,@TypeName(),9,4.75,59.4,11,90,191.12,149.4,195.87,FALSE,TRUE
401,7,BODY,Example 9.7.2-1. Marker Annotations,9,5.19,145.49,35,90,253.62,235.49,258.81,TRUE,FALSE
401,13,BODY,Example 9.7.3-1. Single-Element Annotations,9,5.19,174.01,43,90,520.62,264.01,525.81,TRUE,FALSE
401,14,BODY,The following annotations all use the single-element annotation interfaces from §9.6.1. Here is an example of a single-element annotation:,9,27.02,313.21,138,90,544.1,403.21,571.12,FALSE,FALSE
402,0,BODY,9.7Annotations,9,4.95,79.51,14,36,40.15,115.51,45.1,FALSE,TRUE
402,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
402,2,BODY,Here is an example of an array-valued single-element annotation:,9,5.02,235.44,64,90,74.1,325.44,79.12,FALSE,FALSE
402,4,BODY,Here is an example of a single-element array-valued single-element annotation: (note that the curly braces are omitted),9,15.02,324,119,90,128.1,414,143.12,FALSE,FALSE
402,8,BODY,Here is an example of a single-element annotation that contains a normal annotation:,9,5.02,305.45,84,90,316.1,395.45,321.12,FALSE,FALSE
402,10,BODY,Here is an example of a single-element annotation that uses an enum class defined inside the annotation interface declaration:,9,15.02,323.99,126,90,370.1,413.99,385.12,FALSE,FALSE
403,0,BODY,INTERFACES,9,4.95,52,10,72,40.15,124,45.1,FALSE,TRUE
403,1,BODY,Annotations9.7,9,4.95,79.51,14,388.49,40.15,468,45.1,FALSE,TRUE
403,5,BODY,"It is customary, though not required, to write declaration annotations before all other modifiers, and type annotations immediately before the type to which they apply.",9,15.02,324,168,90,306.1,414,321.12,FALSE,FALSE
404,0,BODY,9.7Annotations,9,4.95,79.51,14,36,40.15,115.51,45.1,FALSE,TRUE
404,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
405,0,BODY,INTERFACES,9,4.95,52,10,72,40.15,124,45.1,FALSE,TRUE
405,1,BODY,Annotations9.7,9,4.95,79.51,14,388.49,40.15,468,45.1,FALSE,TRUE
406,0,BODY,9.7Annotations,9,4.95,79.51,14,36,40.15,115.51,45.1,FALSE,TRUE
406,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
407,0,BODY,INTERFACES,9,4.95,52,10,72,40.15,124,45.1,FALSE,TRUE
407,1,BODY,Annotations9.7,9,4.95,79.51,14,388.49,40.15,468,45.1,FALSE,TRUE
407,4,BODY,"It is customary, though not required, for multiple annotations of the same interface to appear consecutively.",9,15.02,324,109,90,300.1,414,315.12,FALSE,FALSE
408,0,BODY,9.8Functional Interfaces,9,4.95,114.45,24,36,40.15,150.45,45.1,FALSE,TRUE
408,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
409,0,BODY,INTERFACES,9,4.95,52,10,72,40.15,124,45.1,FALSE,TRUE
409,1,BODY,Functional Interfaces9.8,9,4.95,114.45,24,353.55,40.15,468,45.1,FALSE,TRUE
409,4,BODY,Example 9.8-1. Functional Interfaces,9,5.19,141.74,36,90,270.62,231.74,275.81,TRUE,FALSE
409,5,BODY,A simple example of a functional interface is:,9,5.02,164.72,46,90,294.1,254.72,299.12,FALSE,FALSE
410,0,BODY,9.8Functional Interfaces,9,4.95,114.45,24,36,40.15,150.45,45.1,FALSE,TRUE
410,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
410,4,BODY,Example 9.8-2. Functional Interfaces and Erasure,9,5.19,191.74,48,90,179.62,281.74,184.81,TRUE,FALSE
411,0,BODY,INTERFACES,9,4.95,52,10,72,40.15,124,45.1,FALSE,TRUE
411,1,BODY,Functional Interfaces9.8,9,4.95,114.45,24,353.55,40.15,468,45.1,FALSE,TRUE
411,5,BODY,"Finally, the following examples demonstrate the same rules as above, but with generic methods:",9,15.02,323.99,94,90,260.1,413.99,275.12,FALSE,FALSE
411,7,BODY,Example 9.8-3. Generic Functional Interfaces,9,5.19,174.48,44,90,435.62,264.48,440.81,TRUE,FALSE
412,0,BODY,9.9Function Types,9,4.95,92.52,17,36,40.15,128.52,45.1,FALSE,TRUE
412,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
413,0,BODY,INTERFACES,9,4.95,52,10,72,40.15,124,45.1,FALSE,TRUE
413,1,BODY,Function Types9.9,9,4.95,92.52,17,375.48,40.15,468,45.1,FALSE,TRUE
414,0,BODY,9.9Function Types,9,4.95,92.52,17,36,40.15,128.52,45.1,FALSE,TRUE
414,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
414,4,BODY,Example 9.9-1. Function Types,9,5.19,119.26,29,90,356.62,209.26,361.81,TRUE,FALSE
414,5,BODY,Given the following interfaces:,9,5.02,112.23,31,90,380.1,202.23,385.12,FALSE,FALSE
414,7,BODY,the function type of:,9,5.02,73.24,21,90,444.1,163.24,449.12,FALSE,FALSE
414,9,BODY,is:,9,5.02,8.5,3,90,488.1,98.5,493.12,FALSE,FALSE
414,11,BODY,while the function type of:,9,5.02,95.49,27,90,532.1,185.49,537.12,FALSE,FALSE
414,13,BODY,is:,9,5.02,8.5,3,90,576.1,98.5,581.12,FALSE,FALSE
415,0,BODY,INTERFACES,9,4.95,52,10,72,40.15,124,45.1,FALSE,TRUE
415,1,BODY,Function Types9.9,9,4.95,92.52,17,375.48,40.15,468,45.1,FALSE,TRUE
415,2,BODY,Given the following interfaces:,9,5.02,112.23,31,90,74.1,202.23,79.12,FALSE,FALSE
415,4,BODY,the function type of:,9,5.02,73.24,21,90,218.1,163.24,223.12,FALSE,FALSE
415,6,BODY,is:,9,5.02,8.5,3,90,262.1,98.5,267.12,FALSE,FALSE
415,8,BODY,while the function type of:,9,5.02,95.49,27,90,316.1,185.49,321.12,FALSE,FALSE
415,10,BODY,is:,9,5.02,8.5,3,90,360.1,98.5,365.12,FALSE,FALSE
416,0,BODY,9.9Function Types,9,4.95,92.52,17,36,40.15,128.52,45.1,FALSE,TRUE
416,1,BODY,INTERFACES,9,4.95,52,10,380,40.15,432,45.1,FALSE,TRUE
416,2,BODY,Example 9.9-2. Generic Function Types,9,5.19,152,37,90,75.62,242,80.81,TRUE,FALSE
416,7,BODY,"A generic function type for a functional interface may be implemented by a method reference expression (§15.13), but not by a lambda expression (§15.27) as there is no syntax for generic lambda expressions.",9,25.02,324,206,90,257.1,414,282.12,FALSE,FALSE
418,0,BODY,10.1Array Types,9,4.95,81.12,15,36,40.15,117.12,45.1,FALSE,TRUE
418,1,BODY,ARRAYS,9,4.95,31.5,6,400.5,40.15,432,45.1,FALSE,TRUE
419,0,BODY,ARRAYS,9,4.95,31.5,6,72,40.15,103.5,45.1,FALSE,TRUE
419,1,BODY,Array Variables10.2,9,4.95,95.08,19,372.92,40.15,468,45.1,FALSE,TRUE
419,3,BODY,The declarations above do not create array objects. The following are examples of declarations of array variables that do create array objects:,9,15.02,323.99,143,90,136.1,413.99,151.12,FALSE,FALSE
419,6,BODY,Example 10.2-2. Array Variables and Array Types,9,5.19,194.49,47,90,574.62,284.49,579.81,TRUE,FALSE
419,7,BODY,The local variable declaration statement:,9,5.02,146.47,41,90,598.1,236.47,603.12,FALSE,FALSE
420,0,BODY,10.2Array Variables,9,4.95,95.08,19,36,40.15,131.08,45.1,FALSE,TRUE
420,1,BODY,ARRAYS,9,4.95,31.5,6,400.5,40.15,432,45.1,FALSE,TRUE
420,3,BODY,is equivalent to:,9,5.02,57.5,17,90,96.1,147.5,101.12,FALSE,FALSE
420,5,BODY,"because the array type of each local variable is unchanged. Similarly, the local variable declaration statement:",9,15.02,323.99,112,90,140.1,413.99,155.12,FALSE,FALSE
420,7,BODY,is equivalent to the series of declaration statements:,9,5.02,185.72,54,90,194.1,275.72,199.12,FALSE,FALSE
420,10,BODY,is equivalent to the series of declarations:,9,5.02,148.98,44,90,322.1,238.98,327.12,FALSE,FALSE
420,12,BODY,"Because of how array types are formed, the following parameter declarations have the same array type:",9,15.02,324,101,90,386.1,414,401.12,FALSE,FALSE
420,14,BODY,"And perhaps surprisingly, the following field declarations have the same array type:",9,5.02,302.45,84,90,450.1,392.45,455.12,FALSE,FALSE
421,0,BODY,ARRAYS,9,4.95,31.5,6,72,40.15,103.5,45.1,FALSE,TRUE
421,1,BODY,Array Creation10.3,9,4.95,92.09,18,375.91,40.15,468,45.1,FALSE,TRUE
421,5,BODY,Example 10.4-1. Array Access,9,5.19,115.23,28,90,412.62,205.23,417.81,TRUE,FALSE
421,7,BODY,This program produces the output:,9,5.02,124.49,33,90,534.1,214.49,539.12,FALSE,FALSE
422,0,BODY,10.5Array Store Exception,9,4.95,118,25,36,40.15,154,45.1,FALSE,TRUE
422,1,BODY,ARRAYS,9,4.95,31.5,6,400.5,40.15,432,45.1,FALSE,TRUE
422,6,BODY,"If the component type of an array were not reifiable (§4.7), the Java Virtual Machine could not perform the store check described in the preceding paragraph. This is why an array creation expression with a non-reifiable element type is forbidden (§15.10.1). One may declare a variable of an array type whose element type is non-reifiable, but assignment of the result of an array creation expression to the variable will necessarily cause an unchecked warning (§5.1.9).",9,55.02,324.01,469,90,375.1,414.01,430.12,FALSE,FALSE
423,0,BODY,ARRAYS,9,4.95,31.5,6,72,40.15,103.5,45.1,FALSE,TRUE
423,1,BODY,Array Initializers10.6,9,4.95,99.07,22,368.93,40.15,468,45.1,FALSE,TRUE
423,2,BODY,This program produces the output:,9,5.02,124.49,33,90,74.1,214.49,79.12,FALSE,FALSE
423,7,BODY,VariableInitializer: Expression ArrayInitializer,9,24.95,70,48,108,501.15,178,526.1,FALSE,TRUE
424,0,BODY,10.6Array Initializers,9,4.95,99.07,22,36,40.15,135.07,45.1,FALSE,TRUE
424,1,BODY,ARRAYS,9,4.95,31.5,6,400.5,40.15,432,45.1,FALSE,TRUE
424,3,BODY,Example 10.6-1. Array Initializers,9,5.19,131.24,34,90,402.62,221.24,407.81,TRUE,FALSE
424,5,BODY,This program produces the output:,9,5.02,124.49,33,90,534.1,214.49,539.12,FALSE,FALSE
425,0,BODY,ARRAYS,9,4.95,31.5,6,72,40.15,103.5,45.1,FALSE,TRUE
425,1,BODY,Array Members10.7,9,4.95,93.57,17,374.43,40.15,468,45.1,FALSE,TRUE
425,5,BODY,"class A<T> implements Cloneable, java.io.Serializable { public final int length = X; public T[] clone() { try { return (T[])super.clone(); } catch (CloneNotSupportedException e) { throw new InternalError(e.getMessage()); } } } Note that the cast to T[] in the code above would generate an unchecked warning (§5.1.9) if arrays were really implemented this way.",9,126.99,324,359,90,320.12,414,447.12,FALSE,FALSE
425,6,BODY,Example 10.7-1. Arrays Are Cloneable,9,5.19,148.48,36,90,465.62,238.48,470.81,TRUE,FALSE
425,8,BODY,This program produces the output:,9,5.02,124.49,33,90,587.1,214.49,592.12,FALSE,FALSE
426,1,BODY,ARRAYS,9,4.95,31.5,6,400.5,40.15,432,45.1,FALSE,TRUE
426,4,BODY,Example 10.7-2. Shared Subarrays After A Clone,9,5.19,189.99,46,90,129.62,279.99,134.81,TRUE,FALSE
426,5,BODY,The fact that subarrays are shared when a multidimensional array is cloned is shown by this program:,9,15.02,324,100,90,153.1,414,168.12,FALSE,FALSE
426,7,BODY,This program produces the output:,9,5.02,124.49,33,90,277.1,214.49,282.12,FALSE,FALSE
427,0,BODY,ARRAYS,9,4.95,31.5,6,72,40.15,103.5,45.1,FALSE,TRUE
427,3,BODY,This program produces the output:,9,5.02,124.49,33,90,96.1,214.49,101.12,FALSE,FALSE
427,8,BODY,This program produces the output:,9,5.02,124.49,33,90,315.1,214.49,320.12,FALSE,FALSE
430,0,BODY,11.1The Kinds and Causes of Exceptions,9,4.95,170.35,38,36,40.15,206.35,45.1,FALSE,TRUE
430,1,BODY,EXCEPTIONS,9,4.95,53,10,379,40.15,432,45.1,FALSE,TRUE
431,0,BODY,EXCEPTIONS,9,4.95,53,10,72,40.15,125,45.1,FALSE,TRUE
431,1,BODY,The Kinds and Causes of Exceptions11.1,9,4.95,170.35,38,297.65,40.15,468,45.1,FALSE,TRUE
432,0,BODY,11.2Compile-Time Checking of Exceptions,9,4.95,176.24,39,36,40.15,212.24,45.1,FALSE,TRUE
432,1,BODY,EXCEPTIONS,9,4.95,53,10,379,40.15,432,45.1,FALSE,TRUE
432,5,BODY,"Asynchronous exceptions are rare, but proper understanding of their semantics is necessary if high-quality machine code is to be generated. The delay noted above is permitted to allow optimized code to detect and throw these exceptions at points where it is practical to handle them while obeying the semantics of the Java programming language. A simple implementation might poll for asynchronous exceptions at the point of each control transfer instruction. Since a program has a finite size, this provides a bound on the total delay in detecting an asynchronous exception. Since no asynchronous exception will occur between control transfers, the code generator has some flexibility to reorder computation between control transfers for greater performance. The paper Polling Efficiently on Stock Hardware by Marc Feeley, Proc. 1993 Conference on Functional Programming and Computer Architecture, Copenhagen, Denmark, pp. 179-187, is recommended as further reading.",9,127.02,324.01,966,90,337.1,414.01,464.12,FALSE,FALSE
433,0,BODY,EXCEPTIONS,9,4.95,53,10,72,40.15,125,45.1,FALSE,TRUE
433,1,BODY,Compile-Time Checking of Exceptions11.2,9,4.95,176.24,39,291.76,40.15,468,45.1,FALSE,TRUE
434,0,BODY,11.2Compile-Time Checking of Exceptions,9,4.95,176.24,39,36,40.15,212.24,45.1,FALSE,TRUE
434,1,BODY,EXCEPTIONS,9,4.95,53,10,379,40.15,432,45.1,FALSE,TRUE
434,3,BODY,"Note that a method reference expression (§15.13) of the form Primary :: [TypeArguments] Identifier can throw an exception class if the Primary subexpression can throw an exception class. In contrast, a lambda expression can throw nothing, and has no immediate subexpressions on which to perform exception analysis. It is the body of a lambda expression, containing expressions and statements, that can throw exception classes.",9,45.02,324,426,90,471.1,414,516.12,FALSE,FALSE
435,0,BODY,EXCEPTIONS,9,4.95,53,10,72,40.15,125,45.1,FALSE,TRUE
435,1,BODY,Compile-Time Checking of Exceptions11.2,9,4.95,176.24,39,291.76,40.15,468,45.1,FALSE,TRUE
436,0,BODY,11.2Compile-Time Checking of Exceptions,9,4.95,176.24,39,36,40.15,212.24,45.1,FALSE,TRUE
436,1,BODY,EXCEPTIONS,9,4.95,53,10,379,40.15,432,45.1,FALSE,TRUE
436,6,BODY,Example 11.2.3-1. Catching Checked Exceptions,9,5.19,185.75,45,90,568.62,275.75,573.81,TRUE,FALSE
437,0,BODY,EXCEPTIONS,9,4.95,53,10,72,40.15,125,45.1,FALSE,TRUE
437,1,BODY,Compile-Time Checking of Exceptions11.2,9,4.95,176.24,39,291.76,40.15,468,45.1,FALSE,TRUE
438,0,BODY,11.3Run-Time Handling of an Exception,9,4.95,168.59,37,36,40.15,204.59,45.1,FALSE,TRUE
438,1,BODY,EXCEPTIONS,9,4.95,53,10,379,40.15,432,45.1,FALSE,TRUE
439,0,BODY,EXCEPTIONS,9,4.95,53,10,72,40.15,125,45.1,FALSE,TRUE
439,1,BODY,Run-Time Handling of an Exception11.3,9,4.95,168.59,37,299.41,40.15,468,45.1,FALSE,TRUE
439,3,BODY,"If optimized code has speculatively executed some of the expressions or statements which follow the point at which the exception occurs, such code must be prepared to hide this speculative execution from the user-visible state of the program.",9,25.02,324.01,242,90,151.1,414.01,176.12,FALSE,FALSE
439,5,BODY,Example 11.3-1. Throwing and Catching Exceptions,9,5.19,200.27,48,90,516.62,290.27,521.81,TRUE,FALSE
440,0,BODY,11.3Run-Time Handling of an Exception,9,4.95,168.59,37,36,40.15,204.59,45.1,FALSE,TRUE
440,1,BODY,EXCEPTIONS,9,4.95,53,10,379,40.15,432,45.1,FALSE,TRUE
440,3,BODY,"If we execute the program, passing it the arguments:",9,5.02,188.71,52,90,476.1,278.71,481.12,FALSE,FALSE
440,5,BODY,it produces the output:,9,5.02,80.75,23,90,520.1,170.75,525.12,FALSE,FALSE
441,0,BODY,EXCEPTIONS,9,4.95,53,10,72,40.15,125,45.1,FALSE,TRUE
441,1,BODY,Run-Time Handling of an Exception11.3,9,4.95,168.59,37,299.41,40.15,468,45.1,FALSE,TRUE
444,0,BODY,12.1Java Virtual Machine Startup,9,4.95,145.08,32,36,40.15,181.08,45.1,FALSE,TRUE
444,1,BODY,EXECUTION,9,4.95,49.5,9,382.5,40.15,432,45.1,FALSE,TRUE
445,0,BODY,EXECUTION,9,4.95,49.5,9,72,40.15,121.5,45.1,FALSE,TRUE
445,1,BODY,Java Virtual Machine Startup12.1,9,4.95,145.08,32,322.92,40.15,468,45.1,FALSE,TRUE
446,0,BODY,12.2Loading of Classes and Interfaces,9,4.95,161.24,37,36,40.15,197.24,45.1,FALSE,TRUE
446,1,BODY,EXECUTION,9,4.95,49.5,9,382.5,40.15,432,45.1,FALSE,TRUE
446,4,BODY,public static void main(String[] args) public static void main(String... args),9,24.75,210.6,78,90,342.12,300.6,366.87,FALSE,FALSE
447,0,BODY,EXECUTION,9,4.95,49.5,9,72,40.15,121.5,45.1,FALSE,TRUE
447,1,BODY,Loading of Classes and Interfaces12.2,9,4.95,161.24,37,306.76,40.15,468,45.1,FALSE,TRUE
448,0,BODY,12.3Linking of Classes and Interfaces,9,4.95,158.77,37,36,40.15,194.77,45.1,FALSE,TRUE
448,1,BODY,EXECUTION,9,4.95,49.5,9,382.5,40.15,432,45.1,FALSE,TRUE
449,0,BODY,EXECUTION,9,4.95,49.5,9,72,40.15,121.5,45.1,FALSE,TRUE
449,1,BODY,Linking of Classes and Interfaces12.3,9,4.95,158.77,37,309.23,40.15,468,45.1,FALSE,TRUE
449,4,BODY,Implementations of the Java Virtual Machine may precompute additional data structures at preparation time in order to make later operations on a class or interface more efficient. One particularly useful data structure is a 'method table' or other data structure that allows any method to be invoked on instances of a class without requiring a search of superclasses at invocation time.,9,45.02,324.01,386,90,307.1,414.01,352.12,FALSE,FALSE
450,0,BODY,12.4Initialization of Classes and Interfaces,9,4.95,177.54,44,36,40.15,213.54,45.1,FALSE,TRUE
450,1,BODY,EXECUTION,9,4.95,49.5,9,382.5,40.15,432,45.1,FALSE,TRUE
450,7,BODY,"This can occur, for example, if a field declaration was deleted from a class after another class that refers to the field was compiled (§13.4.8).",9,15.02,314.01,145,100,348.1,414.01,363.12,FALSE,FALSE
450,9,BODY,"This can occur, for example, if a method declaration was deleted from a class after another class that refers to the method was compiled (§13.4.12).",9,15.02,313.99,148,100,425.1,413.99,440.12,FALSE,FALSE
451,0,BODY,EXECUTION,9,4.95,49.5,9,72,40.15,121.5,45.1,FALSE,TRUE
451,1,BODY,Initialization of Classes and Interfaces12.4,9,4.95,177.54,44,290.46,40.15,468,45.1,FALSE,TRUE
451,4,BODY,"Note that a compiler may generate synthetic default methods in an interface, that is, default methods that are neither explicitly nor implicitly declared (§13.1). Such methods will trigger the interface's initialization despite the source code giving no indication that the interface should be initialized.",9,35.02,324.01,306,90,421.1,414.01,456.12,FALSE,FALSE
452,0,BODY,12.4Initialization of Classes and Interfaces,9,4.95,177.54,44,36,40.15,213.54,45.1,FALSE,TRUE
452,1,BODY,EXECUTION,9,4.95,49.5,9,382.5,40.15,432,45.1,FALSE,TRUE
452,3,BODY,Example 12.4.1-1. Superclasses Are Initialized Before Subclasses,9,5.19,247.74,64,90,165.62,337.74,170.81,TRUE,FALSE
452,5,BODY,This program produces the output:,9,5.02,124.49,33,90,357.1,214.49,362.12,FALSE,FALSE
452,10,BODY,This program prints only:,9,5.02,92.25,25,90,576.1,182.25,581.12,FALSE,FALSE
453,0,BODY,EXECUTION,9,4.95,49.5,9,72,40.15,121.5,45.1,FALSE,TRUE
453,1,BODY,Initialization of Classes and Interfaces12.4,9,4.95,177.54,44,290.46,40.15,468,45.1,FALSE,TRUE
453,3,BODY,Example 12.4.1-3. Interface Initialization Does Not Initialize Superinterfaces,9,5.19,293.47,78,90,107.62,383.47,112.81,TRUE,FALSE
453,5,BODY,This program produces the output:,9,5.02,124.49,33,90,329.1,214.49,334.12,FALSE,FALSE
454,0,BODY,12.4Initialization of Classes and Interfaces,9,4.95,177.54,44,36,40.15,213.54,45.1,FALSE,TRUE
454,1,BODY,EXECUTION,9,4.95,49.5,9,382.5,40.15,432,45.1,FALSE,TRUE
455,0,BODY,EXECUTION,9,4.95,49.5,9,72,40.15,121.5,45.1,FALSE,TRUE
455,1,BODY,Initialization of Classes and Interfaces12.4,9,4.95,177.54,44,290.46,40.15,468,45.1,FALSE,TRUE
456,0,BODY,12.5Creation of New Class Instances,9,4.95,156.31,35,36,40.15,192.31,45.1,FALSE,TRUE
456,1,BODY,EXECUTION,9,4.95,49.5,9,382.5,40.15,432,45.1,FALSE,TRUE
456,2,BODY,"eliminated from the code - for example, by patching it out or otherwise regenerating the code. Compile-time analysis may, in some cases, be able to eliminate many of the checks that a class or interface has been initialized from the generated code, if an initialization order for a group of related classes and interfaces can be determined. Such analysis must, however, fully account for concurrency and for the fact that initialization code is unrestricted.",9,67.02,324.01,458,90,74.1,414.01,141.12,FALSE,FALSE
457,0,BODY,EXECUTION,9,4.95,49.5,9,72,40.15,121.5,45.1,FALSE,TRUE
457,1,BODY,Creation of New Class Instances12.5,9,4.95,156.31,35,311.69,40.15,468,45.1,FALSE,TRUE
457,8,BODY,Example 12.5-1. Evaluation of Instance Creation,9,5.19,186.75,47,90,558.62,276.75,563.81,TRUE,FALSE
458,0,BODY,12.5Creation of New Class Instances,9,4.95,156.31,35,36,40.15,192.31,45.1,FALSE,TRUE
458,1,BODY,EXECUTION,9,4.95,49.5,9,382.5,40.15,432,45.1,FALSE,TRUE
458,10,BODY,Example 12.5-2. Dynamic Dispatch During Instance Creation,9,5.19,235.49,57,90,577.62,325.49,582.81,TRUE,FALSE
459,0,BODY,EXECUTION,9,4.95,49.5,9,72,40.15,121.5,45.1,FALSE,TRUE
459,1,BODY,Finalization of Class Instances12.6,9,4.95,149.56,35,318.44,40.15,468,45.1,FALSE,TRUE
459,3,BODY,This program produces the output:,9,5.02,124.49,33,90,206.1,214.49,211.12,FALSE,FALSE
459,7,BODY,"As of Java SE 23, the Java SE Platform Specification allows finalization of class instances to be disabled in an implementation of the Java SE Platform, in anticipation of the removal of finalization from a future release of the Java SE Platform.",9,25.02,324.01,246,90,390.1,414.01,415.12,FALSE,FALSE
460,0,BODY,12.6Finalization of Class Instances,9,4.95,149.55,35,36,40.15,185.55,45.1,FALSE,TRUE
460,1,BODY,EXECUTION,9,4.95,49.5,9,382.5,40.15,432,45.1,FALSE,TRUE
460,4,BODY,"As an example, if a circularly linked group of unfinalized objects becomes unreachable (or finalizer-reachable), then all the objects may become finalizable together. Eventually, the finalizers for these objects may be invoked, in any order, or even concurrently using multiple threads. If the automatic storage manager later finds that the objects are unreachable, then their storage can be reclaimed. It is straightforward to implement a class that will cause a set of finalizer-like methods to be invoked in a specified order for a set of objects when all the objects become unreachable. Defining such a class is left as an exercise for the reader.",9,87.02,324.01,651,90,164.1,414.01,251.12,FALSE,FALSE
461,0,BODY,EXECUTION,9,4.95,49.5,9,72,40.15,121.5,45.1,FALSE,TRUE
461,1,BODY,Finalization of Class Instances12.6,9,4.95,149.56,35,318.44,40.15,468,45.1,FALSE,TRUE
462,0,BODY,12.6Finalization of Class Instances,9,4.95,149.55,35,36,40.15,185.55,45.1,FALSE,TRUE
462,1,BODY,EXECUTION,9,4.95,49.5,9,382.5,40.15,432,45.1,FALSE,TRUE
463,0,BODY,EXECUTION,9,4.95,49.5,9,72,40.15,121.5,45.1,FALSE,TRUE
463,1,BODY,Finalization of Class Instances12.6,9,4.95,149.56,35,318.44,40.15,468,45.1,FALSE,TRUE
464,0,BODY,12.7Unloading of Classes and Interfaces,9,4.95,169.63,39,36,40.15,205.63,45.1,FALSE,TRUE
464,1,BODY,EXECUTION,9,4.95,49.5,9,382.5,40.15,432,45.1,FALSE,TRUE
465,0,BODY,EXECUTION,9,4.95,49.5,9,72,40.15,121.5,45.1,FALSE,TRUE
465,1,BODY,Program Exit12.8,9,4.95,86.05,16,381.95,40.15,468,45.1,FALSE,TRUE
466,0,BODY,12.8Program Exit,9,4.95,86.05,16,36,40.15,122.05,45.1,FALSE,TRUE
466,1,BODY,EXECUTION,9,4.95,49.5,9,382.5,40.15,432,45.1,FALSE,TRUE
468,0,BODY,13.1The Form of a Binary,9,4.95,116.67,24,36,40.15,152.67,45.1,FALSE,TRUE
468,1,BODY,BINARY COMPATIBILITY,9,4.95,98.8,20,333.2,40.15,432,45.1,FALSE,TRUE
469,0,BODY,BINARY COMPATIBILITY,9,4.95,98.8,20,72,40.15,170.8,45.1,FALSE,TRUE
469,1,BODY,The Form of a Binary13.1,9,4.95,116.68,24,351.32,40.15,468,45.1,FALSE,TRUE
470,0,BODY,13.1The Form of a Binary,9,4.95,116.67,24,36,40.15,152.67,45.1,FALSE,TRUE
470,1,BODY,BINARY COMPATIBILITY,9,4.95,98.8,20,333.2,40.15,432,45.1,FALSE,TRUE
471,0,BODY,BINARY COMPATIBILITY,9,4.95,98.8,20,72,40.15,170.8,45.1,FALSE,TRUE
471,1,BODY,The Form of a Binary13.1,9,4.95,116.68,24,351.32,40.15,468,45.1,FALSE,TRUE
472,0,BODY,13.1The Form of a Binary,9,4.95,116.67,24,36,40.15,152.67,45.1,FALSE,TRUE
472,1,BODY,BINARY COMPATIBILITY,9,4.95,98.8,20,333.2,40.15,432,45.1,FALSE,TRUE
473,0,BODY,BINARY COMPATIBILITY,9,4.95,98.8,20,72,40.15,170.8,45.1,FALSE,TRUE
473,1,BODY,The Form of a Binary13.1,9,4.95,116.68,24,351.32,40.15,468,45.1,FALSE,TRUE
474,0,BODY,13.1The Form of a Binary,9,4.95,116.67,24,36,40.15,152.67,45.1,FALSE,TRUE
474,1,BODY,BINARY COMPATIBILITY,9,4.95,98.8,20,333.2,40.15,432,45.1,FALSE,TRUE
475,0,BODY,BINARY COMPATIBILITY,9,4.95,98.58,20,72,40.15,170.58,45.1,FALSE,TRUE
475,1,BODY,What Binary Compatibility Is and Is Not13.2,9,4.95,183.98,43,284.02,40.15,468,45.1,FALSE,TRUE
475,4,BODY,"If the Java programming language had been designed so that the particular method to be executed was chosen at run time, then such an ambiguity might be detected at run time. Such a rule would imply that adding an additional overloaded method so as to make ambiguity possible at a call site could break compatibility with an unknown number of pre-existing binaries. See §13.4.23 for more discussion.",9,45.02,324.01,398,90,437.1,414.01,482.12,FALSE,FALSE
476,0,BODY,13.3Evolution of Packages and Modules,9,4.95,167.51,37,36,40.15,203.51,45.1,FALSE,TRUE
476,1,BODY,BINARY COMPATIBILITY,9,4.95,98.63,20,333.36,40.15,432,45.1,FALSE,TRUE
477,0,BODY,BINARY COMPATIBILITY,9,4.95,98.82,20,72,40.15,170.82,45.1,FALSE,TRUE
477,1,BODY,Evolution of Classes13.4,9,4.95,111.13,24,356.87,40.15,468,45.1,FALSE,TRUE
478,0,BODY,13.4Evolution of Classes,9,4.95,111.13,24,36,40.15,147.13,45.1,FALSE,TRUE
478,1,BODY,BINARY COMPATIBILITY,9,4.95,98.81,20,333.18,40.15,432,45.1,FALSE,TRUE
479,0,BODY,BINARY COMPATIBILITY,9,4.95,98.82,20,72,40.15,170.82,45.1,FALSE,TRUE
479,1,BODY,Evolution of Classes13.4,9,4.95,111.13,24,356.87,40.15,468,45.1,FALSE,TRUE
479,4,BODY,"For example, it is binary compatible to replace a raw supertype of a class with a parameterization of the class or interface named by the raw type.",9,15.02,324,147,90,275.1,414,290.12,FALSE,FALSE
479,6,BODY,Example 13.4.4-1. Changing A Superclass,9,5.19,160.26,39,90,374.62,250.26,379.81,TRUE,FALSE
479,7,BODY,Suppose that the following test program:,9,5.02,146.74,40,90,398.1,236.74,403.12,FALSE,FALSE
479,9,BODY,"is compiled and executed, producing the output:",9,5.02,173.23,47,90,532.1,263.23,537.12,FALSE,FALSE
480,0,BODY,13.4Evolution of Classes,9,4.95,111.13,24,36,40.15,147.13,45.1,FALSE,TRUE
480,1,BODY,BINARY COMPATIBILITY,9,4.95,98.81,20,333.18,40.15,432,45.1,FALSE,TRUE
480,4,BODY,"This demonstrates that without the verifier, the Java type system could be defeated by linking inconsistent binary files, even though each was produced by a correct Java compiler. The lesson is that an implementation that lacks a verifier or fails to use it will not maintain type safety and is, therefore, not a valid implementation.",9,47.02,324.01,334,90,190.1,414.01,237.12,FALSE,FALSE
480,5,BODY,Example 13.4.4-2. Introducing a Superclass,9,5.19,166.76,42,90,255.62,256.76,260.81,TRUE,FALSE
481,0,BODY,BINARY COMPATIBILITY,9,4.95,98.82,20,72,40.15,170.82,45.1,FALSE,TRUE
481,1,BODY,Evolution of Classes13.4,9,4.95,111.13,24,356.87,40.15,468,45.1,FALSE,TRUE
481,4,BODY,Example 13.4.6-1. Changing A Class Body,9,5.19,162.02,39,90,305.62,252.02,310.81,TRUE,FALSE
481,6,BODY,This program produces the output:,9,5.02,124.49,33,90,447.1,214.49,452.12,FALSE,FALSE
481,12,BODY,as expected.,9,5.02,43.98,12,90,589.1,133.98,594.12,FALSE,FALSE
482,0,BODY,13.4Evolution of Classes,9,4.95,111.13,24,36,40.15,147.13,45.1,FALSE,TRUE
482,1,BODY,BINARY COMPATIBILITY,9,4.95,98.81,20,333.18,40.15,432,45.1,FALSE,TRUE
482,3,BODY,Example 13.4.6-2. Changing A Superclass,9,5.19,160.26,39,90,175.62,250.26,180.81,TRUE,FALSE
482,5,BODY,This program produces the output:,9,5.02,124.49,33,90,327.1,214.49,332.12,FALSE,FALSE
482,11,BODY,as you might expect.,9,5.02,74.49,20,90,489.1,164.49,494.12,FALSE,FALSE
483,0,BODY,BINARY COMPATIBILITY,9,4.95,98.82,20,72,40.15,170.82,45.1,FALSE,TRUE
483,1,BODY,Evolution of Classes13.4,9,4.95,111.13,24,356.87,40.15,468,45.1,FALSE,TRUE
483,3,BODY,Example 13.4.7-1. Changing Accessibility,9,5.19,158.51,40,90,168.62,248.51,173.81,TRUE,FALSE
483,6,BODY,used by the program:,9,5.02,76.24,20,90,296.1,166.24,301.12,FALSE,FALSE
484,0,BODY,13.4Evolution of Classes,9,4.95,111.13,24,36,40.15,147.13,45.1,FALSE,TRUE
484,1,BODY,BINARY COMPATIBILITY,9,4.95,98.81,20,333.18,40.15,432,45.1,FALSE,TRUE
484,3,BODY,Example 13.4.8-1. Adding A Field Declaration,9,5.19,177,44,90,346.62,267,351.81,TRUE,FALSE
484,5,BODY,This program produces the output:,9,5.02,124.49,33,90,448.1,214.49,453.12,FALSE,FALSE
485,0,BODY,BINARY COMPATIBILITY,9,4.95,98.82,20,72,40.15,170.82,45.1,FALSE,TRUE
485,1,BODY,Evolution of Classes13.4,9,4.95,111.13,24,356.87,40.15,468,45.1,FALSE,TRUE
485,4,BODY,"is compiled and executed, it produces the output:",9,5.02,176.48,49,90,260.1,266.48,265.12,FALSE,FALSE
486,0,BODY,13.4Evolution of Classes,9,4.95,111.13,24,36,40.15,147.13,45.1,FALSE,TRUE
486,1,BODY,BINARY COMPATIBILITY,9,4.95,98.81,20,333.18,40.15,432,45.1,FALSE,TRUE
486,6,BODY,This program produces the output:,9,5.02,124.49,33,90,365.1,214.49,370.12,FALSE,FALSE
487,0,BODY,BINARY COMPATIBILITY,9,4.95,98.82,20,72,40.15,170.82,45.1,FALSE,TRUE
487,1,BODY,Evolution of Classes13.4,9,4.95,111.13,24,356.87,40.15,468,45.1,FALSE,TRUE
488,0,BODY,13.4Evolution of Classes,9,4.95,111.13,24,36,40.15,147.13,45.1,FALSE,TRUE
488,1,BODY,BINARY COMPATIBILITY,9,4.95,98.81,20,333.18,40.15,432,45.1,FALSE,TRUE
489,0,BODY,BINARY COMPATIBILITY,9,4.95,98.82,20,72,40.15,170.82,45.1,FALSE,TRUE
489,1,BODY,Evolution of Classes13.4,9,4.95,111.13,24,356.87,40.15,468,45.1,FALSE,TRUE
490,0,BODY,13.4Evolution of Classes,9,4.95,111.13,24,36,40.15,147.13,45.1,FALSE,TRUE
490,1,BODY,BINARY COMPATIBILITY,9,4.95,98.81,20,333.18,40.15,432,45.1,FALSE,TRUE
490,6,BODY,This program produces the output:,9,5.02,124.49,33,90,451.1,214.49,456.12,FALSE,FALSE
491,0,BODY,BINARY COMPATIBILITY,9,4.95,98.82,20,72,40.15,170.82,45.1,FALSE,TRUE
491,1,BODY,Evolution of Classes13.4,9,4.95,111.13,24,356.87,40.15,468,45.1,FALSE,TRUE
491,5,BODY,This program produces the output:,9,5.02,124.49,33,90,301.1,214.49,306.12,FALSE,FALSE
492,0,BODY,13.4Evolution of Classes,9,4.95,111.13,24,36,40.15,147.13,45.1,FALSE,TRUE
492,1,BODY,BINARY COMPATIBILITY,9,4.95,98.81,20,333.18,40.15,432,45.1,FALSE,TRUE
493,0,BODY,BINARY COMPATIBILITY,9,4.95,98.82,20,72,40.15,170.82,45.1,FALSE,TRUE
493,1,BODY,Evolution of Classes13.4,9,4.95,111.13,24,356.87,40.15,468,45.1,FALSE,TRUE
493,3,BODY,Example 13.4.23-1. Adding An Overloaded Method,9,5.19,197.01,46,90,139.62,287.01,144.81,TRUE,FALSE
493,5,BODY,This program produces the output:,9,5.02,124.49,33,90,271.1,214.49,276.12,FALSE,FALSE
493,13,BODY,as might have been naively expected in the previous case.,9,5.02,207.95,57,90,487.1,297.95,492.12,FALSE,FALSE
494,0,BODY,13.5Evolution of Interfaces,9,4.95,119.56,27,36,40.15,155.56,45.1,FALSE,TRUE
494,1,BODY,BINARY COMPATIBILITY,9,4.95,98.79,20,333.21,40.15,432,45.1,FALSE,TRUE
495,0,BODY,BINARY COMPATIBILITY,9,4.95,98.79,20,72,40.15,170.79,45.1,FALSE,TRUE
495,1,BODY,Evolution of Interfaces13.5,9,4.95,119.57,27,348.43,40.15,468,45.1,FALSE,TRUE
496,0,BODY,13.5Evolution of Interfaces,9,4.95,119.56,27,36,40.15,155.56,45.1,FALSE,TRUE
496,1,BODY,BINARY COMPATIBILITY,9,4.95,98.79,20,333.21,40.15,432,45.1,FALSE,TRUE
496,4,BODY,Example 13.5.4-1. Deleting An Interface Member,9,5.19,188.96,46,90,322.62,278.96,327.81,TRUE,FALSE
496,6,BODY,This program produces the output:,9,5.02,124.49,33,90,434.1,214.49,439.12,FALSE,FALSE
497,0,BODY,BINARY COMPATIBILITY,9,4.95,98.79,20,72,40.15,170.79,45.1,FALSE,TRUE
497,1,BODY,Evolution of Interfaces13.5,9,4.95,119.57,27,348.43,40.15,468,45.1,FALSE,TRUE
497,4,BODY,Example 13.5.7-1. Adding A Default Method,9,5.19,171,41,90,414.62,261,419.81,TRUE,FALSE
497,6,BODY,This program produces the output:,9,5.02,124.49,33,90,576.1,214.49,581.12,FALSE,FALSE
498,0,BODY,13.5Evolution of Interfaces,9,4.95,119.56,27,36,40.15,155.56,45.1,FALSE,TRUE
498,1,BODY,BINARY COMPATIBILITY,9,4.95,98.79,20,333.21,40.15,432,45.1,FALSE,TRUE
500,0,BODY,"14.1Normal and Abrupt Completion of StatementsBLOCKS, STATEMENTS, AND PATTERNS",9,4.95,396,78,36,40.15,432,45.1,FALSE,TRUE
501,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.85,32,72,40.15,232.85,45.1,FALSE,TRUE
501,1,BODY,Blocks14.2,9,4.95,59.99,10,408.01,40.15,468,45.1,FALSE,TRUE
502,0,BODY,"14.3Local Class and Interface DeclarationsBLOCKS, STATEMENTS, AND PATTERNS",9,4.95,396,74,36,40.15,432,45.1,FALSE,TRUE
502,3,BODY,ClassDeclaration: NormalClassDeclaration EnumDeclaration RecordDeclaration NormalClassDeclaration: {ClassModifier} class TypeIdentifier [TypeParameters] [ClassExtends] [ClassImplements] [ClassPermits] ClassBody,9,73.95,246.51,210,108,248.15,354.51,322.1,FALSE,TRUE
502,4,BODY,EnumDeclaration: {ClassModifier} enum TypeIdentifier [ClassImplements] EnumBody NormalInterfaceDeclaration: {InterfaceModifier} interface TypeIdentifier [TypeParameters] [InterfaceExtends] [InterfacePermits] InterfaceBody,9,53.95,258.29,221,108,336.15,366.29,390.1,FALSE,TRUE
503,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNSLocal Class and Interface Declarations14.3",9,4.95,396,74,72,40.15,468,45.1,FALSE,TRUE
503,2,BODY,Example 14.3-1. Local Class Declarations,9,5.19,158.99,40,90,196.62,248.99,201.81,TRUE,FALSE
503,3,BODY,Here is an example that illustrates several aspects of the rules given above:,9,5.02,269.44,77,90,220.1,359.44,225.12,FALSE,FALSE
504,0,BODY,"14.4Local Variable DeclarationsBLOCKS, STATEMENTS, AND PATTERNS",9,4.95,396,63,36,40.15,432,45.1,FALSE,TRUE
504,4,BODY,"See §8.3 for UnannType. The following productions from §4.3, §8.3, and §8.4.1 are shown here for convenience: VariableModifier: Annotation final VariableDeclaratorList: VariableDeclarator {, VariableDeclarator} VariableDeclarator: VariableDeclaratorId [= VariableInitializer] VariableDeclaratorId: Identifier [Dims] _ Dims: {Annotation} [ ] {{Annotation} [ ]} VariableInitializer: Expression ArrayInitializer",9,222,324,408,90,279.1,414,501.1,FALSE,TRUE
505,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNSLocal Variable Declarations14.4",9,4.95,396,63,72,40.15,468,45.1,FALSE,TRUE
506,0,BODY,"14.4Local Variable DeclarationsBLOCKS, STATEMENTS, AND PATTERNS",9,4.95,396,63,36,40.15,432,45.1,FALSE,TRUE
506,2,BODY,"Because the initializer is treated as if it did not appear in an assignment context, an error occurs if it is a lambda expression (§15.27) or a method reference expression (§15.13).",9,15.02,314.01,181,100,298.1,414.01,313.12,FALSE,FALSE
507,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.71,32,72,40.15,232.71,45.1,FALSE,TRUE
507,1,BODY,Statements14.5,9,4.95,75,14,393,40.15,468,45.1,FALSE,TRUE
507,2,BODY,"While it would be possible to allow the type of the variable to mention capture variables, by projecting them away we enforce an attractive invariant that the scope of a capture variable is never larger than the statement containing the expression whose type is captured. Informally, capture variables cannot 'leak' into subsequent statements.",9,35.02,324.01,343,90,74.1,414.01,109.12,FALSE,FALSE
507,6,BODY,"If a declarator does not have an initializer, then every reference to the variable must be preceded by execution of an assignment to the variable, or a compile-time error occurs by the rules of §16 (Definite Assignment).",9,25.02,324,220,90,343.1,414,368.12,FALSE,FALSE
508,0,BODY,14.5Statements,9,4.95,75,14,36,40.15,111,45.1,FALSE,TRUE
508,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.71,32,271.29,40.15,432,45.1,FALSE,TRUE
508,2,BODY,if (door.isOpen()) if (resident.isVisible()) resident.greet('Hello!'); else door.bell.ring();  // A 'dangling else',9,34.75,237.6,115,90,74.12,327.6,108.87,FALSE,FALSE
509,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.34,32,72,40.15,232.34,45.1,FALSE,TRUE
509,1,BODY,The Empty Statement14.6,9,4.95,113.21,23,354.79,40.15,468,45.1,FALSE,TRUE
509,2,BODY,The following productions from §14.9 are shown here for convenience:,9,5.02,257.45,68,90,74.1,347.45,79.12,FALSE,FALSE
509,3,BODY,IfThenStatement: if ( Expression ) Statement IfThenElseStatement: if ( Expression ) StatementNoShortIf else Statement IfThenElseStatementNoShortIf: if ( Expression ) StatementNoShortIf else StatementNoShortIf,9,72.95,248.7,208,108,96.15,356.7,169.1,FALSE,TRUE
510,0,BODY,14.7Labeled Statements,9,4.95,106.62,22,36,40.15,142.62,45.1,FALSE,TRUE
510,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.41,32,271.59,40.15,432,45.1,FALSE,TRUE
510,3,BODY,Example 14.7-1. Labels and Identifiers,9,5.19,148.51,38,90,352.62,238.51,357.81,TRUE,FALSE
511,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.3,32,72,40.15,232.3,45.1,FALSE,TRUE
511,1,BODY,Expression Statements14.8,9,4.95,117.59,25,350.41,40.15,468,45.1,FALSE,TRUE
512,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.48,32,271.52,40.15,432,45.1,FALSE,TRUE
513,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.31,32,72,40.15,232.31,45.1,FALSE,TRUE
514,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.31,32,271.69,40.15,432,45.1,FALSE,TRUE
515,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.31,32,72,40.15,232.31,45.1,FALSE,TRUE
516,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.31,32,271.69,40.15,432,45.1,FALSE,TRUE
517,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.31,32,72,40.15,232.31,45.1,FALSE,TRUE
518,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.31,32,271.69,40.15,432,45.1,FALSE,TRUE
519,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.31,32,72,40.15,232.31,45.1,FALSE,TRUE
520,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.31,32,271.69,40.15,432,45.1,FALSE,TRUE
521,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.31,32,72,40.15,232.31,45.1,FALSE,TRUE
522,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.31,32,271.69,40.15,432,45.1,FALSE,TRUE
523,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.31,32,72,40.15,232.31,45.1,FALSE,TRUE
524,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.31,32,271.69,40.15,432,45.1,FALSE,TRUE
525,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.31,32,72,40.15,232.31,45.1,FALSE,TRUE
526,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.31,32,271.69,40.15,432,45.1,FALSE,TRUE
527,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.31,32,72,40.15,232.31,45.1,FALSE,TRUE
528,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.31,32,271.69,40.15,432,45.1,FALSE,TRUE
529,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.31,32,72,40.15,232.31,45.1,FALSE,TRUE
530,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.31,32,271.69,40.15,432,45.1,FALSE,TRUE
530,5,BODY,"Fortunately, this trick does not seem to be widely known or used. Moreover, it is less needed nowadays; this sort of code transformation is properly in the province of state-of-the-art optimizing compilers.",9,25.02,324.01,206,90,529.1,414.01,554.12,FALSE,FALSE
531,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.31,32,72,40.15,232.31,45.1,FALSE,TRUE
532,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.31,32,271.69,40.15,432,45.1,FALSE,TRUE
533,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.31,32,72,40.15,232.31,45.1,FALSE,TRUE
534,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.31,32,271.69,40.15,432,45.1,FALSE,TRUE
534,7,BODY,This program prints:,9,5.02,74,20,90,554.1,164,559.12,FALSE,FALSE
535,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.35,32,72,40.15,232.35,45.1,FALSE,TRUE
536,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.48,32,271.52,40.15,432,45.1,FALSE,TRUE
537,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.48,32,72,40.15,232.48,45.1,FALSE,TRUE
538,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.43,32,271.56,40.15,431.99,45.1,FALSE,TRUE
539,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.43,32,72,40.15,232.43,45.1,FALSE,TRUE
540,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.43,32,271.56,40.15,431.99,45.1,FALSE,TRUE
541,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.43,32,72,40.15,232.43,45.1,FALSE,TRUE
542,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.43,32,271.56,40.15,431.99,45.1,FALSE,TRUE
542,5,BODY,"The following productions from §4.3, §8.3, §8.4.1, and §14.4 are shown here for convenience:",9,15.02,324,92,90,220.1,414,235.12,FALSE,FALSE
542,6,BODY,"LocalVariableDeclaration: {VariableModifier} LocalVariableType VariableDeclaratorList VariableModifier: Annotation final LocalVariableType: UnannType var VariableDeclaratorList: VariableDeclarator {, VariableDeclarator} VariableDeclarator: VariableDeclaratorId [= VariableInitializer] VariableDeclaratorId: Identifier [Dims] _ Dims: {Annotation} [ ] {{Annotation} [ ]}",9,218.95,239.2,368,108,252.15,347.2,471.1,FALSE,TRUE
543,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.43,32,72,40.15,232.43,45.1,FALSE,TRUE
544,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.43,32,271.56,40.15,431.99,45.1,FALSE,TRUE
545,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.43,32,72,40.15,232.43,45.1,FALSE,TRUE
546,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.35,32,271.65,40.15,432,45.1,FALSE,TRUE
547,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.35,32,72,40.15,232.35,45.1,FALSE,TRUE
548,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.22,32,271.77,40.15,432,45.1,FALSE,TRUE
549,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.22,32,72,40.15,232.22,45.1,FALSE,TRUE
550,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.31,32,271.69,40.15,432,45.1,FALSE,TRUE
550,3,BODY,"Which to use, if either, is largely a matter of programming style.",9,5.02,231.97,66,90,246.1,321.97,251.12,FALSE,FALSE
551,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.35,32,72,40.15,232.35,45.1,FALSE,TRUE
552,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.35,32,271.65,40.15,432,45.1,FALSE,TRUE
554,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.45,32,271.55,40.15,432,45.1,FALSE,TRUE
554,6,BODY,This program produces the output:,9,5.02,124.49,33,90,445.1,214.49,450.12,FALSE,FALSE
554,8,BODY,Note that this program would deadlock if a single thread were not permitted to lock a monitor more than once.,9,15.02,324,109,90,489.1,414,504.12,FALSE,FALSE
555,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.45,32,72,40.15,232.45,45.1,FALSE,TRUE
555,4,BODY,VariableModifier: Annotation final VariableDeclaratorId: Identifier [Dims] _ Dims: {Annotation} [ ] {{Annotation} [ ]},9,92.95,144.46,118,108,392.15,252.46,485.1,FALSE,TRUE
556,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.45,32,271.55,40.15,432,45.1,FALSE,TRUE
557,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.45,32,72,40.15,232.45,45.1,FALSE,TRUE
558,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.45,32,271.55,40.15,432,45.1,FALSE,TRUE
559,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.45,32,72,40.15,232.45,45.1,FALSE,TRUE
560,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.45,32,271.55,40.15,432,45.1,FALSE,TRUE
561,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.45,32,72,40.15,232.45,45.1,FALSE,TRUE
561,3,BODY,This program produces the output:,9,5.02,124.49,33,90,196.1,214.49,201.12,FALSE,FALSE
562,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.45,32,271.55,40.15,432,45.1,FALSE,TRUE
562,3,BODY,"LocalVariableDeclaration: {VariableModifier} LocalVariableType VariableDeclaratorList VariableModifier: Annotation final LocalVariableType: UnannType var VariableDeclaratorList: VariableDeclarator {, VariableDeclarator} VariableDeclarator: VariableDeclaratorId [= VariableInitializer] VariableDeclaratorId: Identifier [Dims] _ Dims: {Annotation} [ ] {{Annotation} [ ]} VariableInitializer: Expression ArrayInitializer See §8.3 for UnannType.",9,279.97,257.2,441,90,207.15,347.2,487.12,FALSE,TRUE
563,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.45,32,72,40.15,232.45,45.1,FALSE,TRUE
563,3,BODY,Note that a resource specification may declare more than one unnamed local variable (§6.1).,9,5.02,324,91,90,291.1,414,296.12,FALSE,FALSE
564,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.45,32,271.55,40.15,432,45.1,FALSE,TRUE
564,3,BODY,try (VariableAccess ...) Block,9,14.75,129.6,30,90,188.26,219.6,203,FALSE,FALSE
564,5,BODY,try (T #r = VariableAccess ...) { Block },9,24.75,178.2,41,90,253.26,268.2,278,FALSE,FALSE
564,7,BODY,try ({VariableModifier} R VariableDeclaratorId = Expression ...) Block,9,14.75,345.6,70,90,386.26,435.6,401,FALSE,TRUE
565,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.45,32,72,40.15,232.45,45.1,FALSE,TRUE
565,2,BODY,{ final {VariableModifierNoFinal} R Identifier = Expression; Throwable #primaryExc = null; try ResourceSpecification_tail Block catch (Throwable #t) { #primaryExc = #t; throw #t; } finally { if (Identifier != null) { if (#primaryExc != null) { try { Identifier.close(); } catch (Throwable #suppressedExc) { #primaryExc.addSuppressed(#suppressedExc); } } else { Identifier.close(); } } } },9,224.75,334.8,388,90,74.12,424.8,298.87,FALSE,FALSE
566,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.45,32,271.55,40.15,432,45.1,FALSE,TRUE
567,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.45,32,72,40.15,232.45,45.1,FALSE,TRUE
567,4,BODY,try ResourceSpecification Block [Catches] [Finally],9,34.75,135,51,90,330.26,225,365,FALSE,TRUE
567,6,BODY,try { try ResourceSpecification Block } [Catches] [Finally],9,54.75,156.6,59,90,415.26,246.6,470,FALSE,FALSE
568,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.35,32,271.65,40.15,432,45.1,FALSE,TRUE
569,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.23,32,72,40.15,232.23,45.1,FALSE,TRUE
569,1,BODY,Unreachable Statements14.22,9,4.95,124.56,27,343.44,40.15,468,45.1,FALSE,TRUE
569,7,BODY,This definition is based on the logic around 'attempts to transfer control' in §14.15.,9,5.02,301.57,86,100,539.1,401.57,544.12,FALSE,FALSE
570,0,BODY,14.22Unreachable Statements,9,4.95,124.56,27,36,40.15,160.56,45.1,FALSE,TRUE
570,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.23,32,271.76,40.15,432,45.1,FALSE,TRUE
571,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.23,32,72,40.15,232.23,45.1,FALSE,TRUE
571,1,BODY,Unreachable Statements14.22,9,4.95,124.56,27,343.44,40.15,468,45.1,FALSE,TRUE
572,0,BODY,14.22Unreachable Statements,9,4.95,124.56,27,36,40.15,160.56,45.1,FALSE,TRUE
572,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.23,32,271.76,40.15,432,45.1,FALSE,TRUE
573,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.23,32,72,40.15,232.23,45.1,FALSE,TRUE
573,1,BODY,Unreachable Statements14.22,9,4.95,124.56,27,343.44,40.15,468,45.1,FALSE,TRUE
573,4,BODY,See §15.6 for normal and abrupt completion of expressions.,9,5.02,215.47,58,110,272.1,325.47,277.12,FALSE,FALSE
574,0,BODY,14.22Unreachable Statements,9,4.95,124.56,27,36,40.15,160.56,45.1,FALSE,TRUE
574,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.23,32,271.76,40.15,432,45.1,FALSE,TRUE
574,7,BODY,Example 14.22-1. Conditional Compilation,9,5.19,164.27,40,90,519.62,254.27,524.81,TRUE,FALSE
574,8,BODY,If the example:,9,5.02,54.49,15,90,543.1,144.49,548.12,FALSE,FALSE
575,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.79,32,72,40.15,232.79,45.1,FALSE,TRUE
575,1,BODY,Patterns14.30,9,4.95,66.5,13,401.5,40.15,468,45.1,FALSE,TRUE
575,3,BODY,"is compiled and executed, it produces the output:",9,5.02,176.48,49,90,116.1,266.48,121.12,FALSE,FALSE
575,12,BODY,ensuring that this value is not a constant expression. Similar idioms exist for the other primitive types.,9,15.02,324,106,90,488.1,414,503.12,FALSE,FALSE
576,0,BODY,14.30Patterns,9,4.95,66.5,13,36,40.15,102.5,45.1,FALSE,TRUE
576,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.79,32,271.21,40.15,432,45.1,FALSE,TRUE
576,5,BODY,"The following productions from §4.3, §8.3, §8.4.1, and §14.4 are shown here for convenience:",9,15.02,324,92,90,510.1,414,525.12,FALSE,FALSE
576,6,BODY,LocalVariableDeclaration: {VariableModifier} LocalVariableType VariableDeclaratorList VariableModifier: Annotation final,9,53.75,239.2,120,108,542.15,347.2,595.9,FALSE,TRUE
577,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.79,32,72,40.15,232.79,45.1,FALSE,TRUE
577,1,BODY,Patterns14.30,9,4.95,66.5,13,401.5,40.15,468,45.1,FALSE,TRUE
577,2,BODY,"LocalVariableType: UnannType var VariableDeclaratorList: VariableDeclarator {, VariableDeclarator} VariableDeclarator: VariableDeclaratorId [= VariableInitializer] VariableDeclaratorId: Identifier [Dims] _ Dims: {Annotation} [ ] {{Annotation} [ ]}",9,150.95,172.9,247,108,74.15,280.9,225.1,FALSE,TRUE
577,3,BODY,See §8.3 for UnannType.,9,5.02,90.23,23,90,242.1,180.23,247.12,FALSE,FALSE
578,0,BODY,14.30Patterns,9,4.95,66.5,13,36,40.15,102.5,45.1,FALSE,TRUE
578,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.79,32,271.21,40.15,432,45.1,FALSE,TRUE
578,6,BODY,"Note that this compile-time property of type patterns is used in the run-time process of pattern matching (§14.30.2), so it is associated with the type pattern for use at run time.",9,15.02,323.99,180,90,291.1,413.99,306.12,FALSE,FALSE
578,8,BODY,Future versions of the Java Programming Language may lift this restriction on annotations.,9,5.02,324.01,90,90,451.1,414.01,456.12,FALSE,FALSE
579,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.79,32,72,40.15,232.79,45.1,FALSE,TRUE
579,1,BODY,Patterns14.30,9,4.95,66.5,13,401.5,40.15,468,45.1,FALSE,TRUE
580,0,BODY,14.30Patterns,9,4.95,66.5,13,36,40.15,102.5,45.1,FALSE,TRUE
580,1,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.79,32,271.21,40.15,432,45.1,FALSE,TRUE
580,3,BODY,A pattern variable declared by a pattern appearing in the component pattern list of a record pattern is initialized only if all the patterns in the list match.,9,15.02,314,159,100,260.1,414,275.12,FALSE,FALSE
581,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNS",9,4.95,160.79,32,72,40.15,232.79,45.1,FALSE,TRUE
581,1,BODY,Patterns14.30,9,4.95,66.5,13,401.5,40.15,468,45.1,FALSE,TRUE
581,3,BODY,Note that no record pattern is unconditional because the null reference does not match any record pattern.,9,15.02,324,106,90,131.1,414,146.12,FALSE,FALSE
584,0,BODY,15.2Forms of Expressions,9,4.95,115.87,24,36,40.15,151.87,45.1,FALSE,TRUE
584,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
585,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
585,1,BODY,Type of an Expression15.3,9,4.95,118.27,25,349.73,40.15,468,45.1,FALSE,TRUE
586,0,BODY,15.4Floating-point Expressions,9,4.95,134.88,30,36,40.15,170.88,45.1,FALSE,TRUE
586,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
587,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
587,1,BODY,Floating-point Expressions15.4,9,4.95,134.88,30,333.12,40.15,468,45.1,FALSE,TRUE
587,3,BODY,"compareQuietGreater, compareQuietGreaterEqual",9,18.02,98.96,45,254,127.35,352.96,145.37,FALSE,FALSE
587,4,BODY,"The numerical equality operators == and !=compareQuietEqual, compareQuietNotEqual (§15.21.1) The unary minus operator - (§15.15.4)negate The multiplicative operators * and / (§15.17.1,multiplication, division §15.17.2) The additive operators + and - (§15.18.2)addition, subtraction Widening primitive conversion from an integralconvertFromInt type (§5.1.2) Narrowing primitive conversion to an integralconvertToIntegerTowardZero type (§5.1.3) Conversion between float and doubleconvertFormat",9,159.02,341.71,491,74.25,157.35,415.96,316.37,FALSE,FALSE
588,0,BODY,15.4Floating-point Expressions,9,4.95,134.88,30,36,40.15,170.88,45.1,FALSE,TRUE
588,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
588,4,BODY,The roundTiesToEven rounding-direction attribute was known as the 'round to nearest' rounding mode in the 1985 version of the IEEE 754 Standard. The rounding policy in the Java programming language is named after this rounding mode.,9,25.02,314,232,100,556.1,414,581.12,FALSE,FALSE
589,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
589,1,BODY,Floating-point Expressions15.4,9,4.95,134.88,30,333.12,40.15,468,45.1,FALSE,TRUE
589,3,BODY,The roundTowardZero rounding-direction attribute was known as the 'round toward zero' rounding mode in the 1985 version of the IEEE 754 Standard. The rounding policy in the Java programming language is named after this rounding mode.,9,25.02,314.01,233,100,209.1,414.01,234.12,FALSE,FALSE
590,0,BODY,15.5Expressions and Run-Time Checks,9,4.95,162.83,35,36,40.15,198.83,45.1,FALSE,TRUE
590,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
591,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
591,1,BODY,Normal and Abrupt Completion of Evaluation15.6,9,4.95,203.76,46,264.24,40.15,468,45.1,FALSE,TRUE
592,0,BODY,15.6Normal and Abrupt Completion of Evaluation,9,4.95,203.76,46,36,40.15,239.76,45.1,FALSE,TRUE
592,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
593,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
593,1,BODY,Evaluation Order15.7,9,4.95,100.48,20,367.52,40.15,468,45.1,FALSE,TRUE
593,4,BODY,"It is recommended that code not rely crucially on this specification. Code is usually clearer when each expression contains at most one side effect, as its outermost operation, and when code does not depend on exactly which exception arises as a consequence of the left-to- right evaluation of expressions.",9,35.02,324.01,306,90,423.1,414.01,458.12,FALSE,FALSE
594,0,BODY,15.7Evaluation Order,9,4.95,100.48,20,36,40.15,136.48,45.1,FALSE,TRUE
594,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
594,3,BODY,Example 15.7.1-1. Left-Hand Operand Is Evaluated First,9,5.19,219.26,54,90,119.62,309.26,124.81,TRUE,FALSE
594,4,BODY,"In the following program, the * operator has a left-hand operand that contains an assignment to a variable and a right-hand operand that contains a reference to the same variable. The value produced by the reference will reflect the fact that the assignment occurred first.",9,25.02,324.01,273,90,143.1,414.01,168.12,FALSE,FALSE
594,6,BODY,This program produces the output:,9,5.02,124.49,33,90,267.1,214.49,272.12,FALSE,FALSE
594,9,BODY,Example 15.7.1-2. Implicit Left-Hand Operand In Operator Of Compound Assigment,9,5.19,329.51,78,90,334.62,419.51,339.81,TRUE,FALSE
594,12,BODY,This program produces the output:,9,5.02,124.49,33,90,512.1,214.49,517.12,FALSE,FALSE
595,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
595,1,BODY,Evaluation Order15.7,9,4.95,100.48,20,367.52,40.15,468,45.1,FALSE,TRUE
595,2,BODY,Example 15.7.1-3. Abrupt Completion of Evaluation of the Left-Hand Operand,9,5.19,304.01,74,90,75.62,394.01,80.81,TRUE,FALSE
595,4,BODY,This program produces the output:,9,5.02,124.49,33,90,247.1,214.49,252.12,FALSE,FALSE
596,0,BODY,15.7Evaluation Order,9,4.95,100.48,20,36,40.15,136.48,45.1,FALSE,TRUE
596,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
596,3,BODY,This program produces the output:,9,5.02,124.49,33,90,96.1,214.49,101.12,FALSE,FALSE
596,5,BODY,and not:,9,5.02,29.25,8,90,140.1,119.25,145.12,FALSE,FALSE
596,9,BODY,"An implementation of the Java programming language may not take advantage of algebraic identities such as the associative law to rewrite expressions into a more convenient computational order unless it can be proven that the replacement expression is equivalent in value and in its observable side effects, even in the presence of multiple threads of execution (using the thread execution model in §17 (Threads and Locks)), for all possible computational values that might be involved.",9,55.02,324,485,90,302.1,414,357.12,FALSE,FALSE
597,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
597,1,BODY,Evaluation Order15.7,9,4.95,100.48,20,367.52,40.15,468,45.1,FALSE,TRUE
597,4,BODY,because the first expression overflows and the second does not.,9,5.02,227.95,63,90,180.1,317.95,185.12,FALSE,FALSE
597,8,BODY,Example 15.7.4-1. Evaluation Order At Method Invocation,9,5.19,226.25,55,90,422.62,316.25,427.81,TRUE,FALSE
597,10,BODY,This program produces the output:,9,5.02,124.49,33,90,544.1,214.49,549.12,FALSE,FALSE
598,0,BODY,15.7Evaluation Order,9,4.95,100.48,20,36,40.15,136.48,45.1,FALSE,TRUE
598,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
598,2,BODY,Example 15.7.4-2. Abrupt Completion of Argument Expression,9,5.19,242.75,58,90,75.62,332.75,80.81,TRUE,FALSE
598,4,BODY,This program produces the output:,9,5.02,124.49,33,90,267.1,214.49,272.12,FALSE,FALSE
599,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
599,1,BODY,Primary Expressions15.8,9,4.95,112.44,23,355.56,40.15,468,45.1,FALSE,TRUE
600,0,BODY,15.8Primary Expressions,9,4.95,112.44,23,36,40.15,148.44,45.1,FALSE,TRUE
600,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
600,4,BODY,The following production from §3.10 is shown here for convenience:,9,5.02,248.96,66,90,201.1,338.96,206.12,FALSE,FALSE
600,5,BODY,Literal: IntegerLiteral FloatingPointLiteral BooleanLiteral CharacterLiteral StringLiteral TextBlock NullLiteral,9,74.95,85.01,112,108,223.15,193.01,298.1,FALSE,TRUE
601,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
601,1,BODY,Primary Expressions15.8,9,4.95,112.44,23,355.56,40.15,468,45.1,FALSE,TRUE
602,0,BODY,15.8Primary Expressions,9,4.95,112.44,23,36,40.15,148.44,45.1,FALSE,TRUE
602,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
603,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
603,1,BODY,Class Instance Creation Expressions15.9,9,4.95,170.27,39,297.73,40.15,468,45.1,FALSE,TRUE
604,0,BODY,15.9Class Instance Creation Expressions,9,4.95,170.27,39,36,40.15,206.27,45.1,FALSE,TRUE
604,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
604,5,BODY,The following production from §15.12 is shown here for convenience:,9,5.02,253.46,67,90,225.1,343.46,230.12,FALSE,FALSE
604,6,BODY,"ArgumentList: Expression {, Expression}",9,14.95,107.09,39,108,247.15,215.09,262.1,FALSE,TRUE
604,8,BODY,This rule is introduced because inference of a generic class's type arguments may influence the constraints on a generic constructor's type arguments.,9,15.02,324.01,150,90,475.1,414.01,490.12,FALSE,FALSE
605,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
605,1,BODY,Class Instance Creation Expressions15.9,9,4.95,170.27,39,297.73,40.15,468,45.1,FALSE,TRUE
606,0,BODY,15.9Class Instance Creation Expressions,9,4.95,170.27,39,36,40.15,206.27,45.1,FALSE,TRUE
606,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
607,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
607,1,BODY,Class Instance Creation Expressions15.9,9,4.95,170.27,39,297.73,40.15,468,45.1,FALSE,TRUE
608,0,BODY,15.9Class Instance Creation Expressions,9,4.95,170.27,39,36,40.15,206.27,45.1,FALSE,TRUE
608,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
609,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
609,1,BODY,Class Instance Creation Expressions15.9,9,4.95,170.27,39,297.73,40.15,468,45.1,FALSE,TRUE
610,0,BODY,15.9Class Instance Creation Expressions,9,4.95,170.27,39,36,40.15,206.27,45.1,FALSE,TRUE
610,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
611,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
611,1,BODY,Class Instance Creation Expressions15.9,9,4.95,170.27,39,297.73,40.15,468,45.1,FALSE,TRUE
612,0,BODY,15.9Class Instance Creation Expressions,9,4.95,170.27,39,36,40.15,206.27,45.1,FALSE,TRUE
612,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
613,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
613,1,BODY,Class Instance Creation Expressions15.9,9,4.95,170.27,39,297.73,40.15,468,45.1,FALSE,TRUE
613,3,BODY,"Testing for compatibility with a target type may occur multiple times before making a final determination of the class instance creation expression's target type and the return type corresponding to the chosen constructor. For example, an enclosing method invocation expression may require testing the class instance creation expression for compatibility with different methods' formal parameter types.",9,45.02,314,402,100,317.1,414,362.12,FALSE,FALSE
614,0,BODY,15.9Class Instance Creation Expressions,9,4.95,170.27,39,36,40.15,206.27,45.1,FALSE,TRUE
614,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
615,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
615,1,BODY,Class Instance Creation Expressions15.9,9,4.95,170.27,39,297.73,40.15,468,45.1,FALSE,TRUE
615,2,BODY,Example 15.9.4-1. Evaluation Order and Out-Of-Memory Detection,9,5.19,260.73,62,90,75.62,350.73,80.81,TRUE,FALSE
615,5,BODY,prints:,9,5.02,23,7,90,375.1,113,380.12,FALSE,FALSE
616,0,BODY,15.9Class Instance Creation Expressions,9,4.95,170.27,39,36,40.15,206.27,45.1,FALSE,TRUE
616,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
617,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
617,1,BODY,Class Instance Creation Expressions15.9,9,4.95,170.27,39,297.73,40.15,468,45.1,FALSE,TRUE
618,0,BODY,15.10Array Creation and Access Expressions,9,4.95,181.38,42,36,40.15,217.38,45.1,FALSE,TRUE
618,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
618,5,BODY,Dims: {Annotation} [ ] {{Annotation} [ ]},9,14.95,144.46,41,108,400.15,252.46,415.1,FALSE,TRUE
618,7,BODY,"The rules above imply that the element type in an array creation expression cannot be a parameterized type, unless all type arguments to the parameterized type are unbounded wildcards.",9,25.02,324,184,90,512.1,414,537.12,FALSE,FALSE
619,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
619,1,BODY,Array Creation and Access Expressions15.10,9,4.95,181.38,42,286.62,40.15,468,45.1,FALSE,TRUE
620,0,BODY,15.10Array Creation and Access Expressions,9,4.95,181.38,42,36,40.15,217.38,45.1,FALSE,TRUE
620,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
620,2,BODY,Example 15.10.2-1. Array Creation Evaluation,9,5.19,179.24,44,90,75.62,269.24,80.81,TRUE,FALSE
620,3,BODY,"In an array creation expression with one or more dimension expressions, each dimension expression is fully evaluated before any part of any dimension expression to its right. Thus:",9,15.02,324,180,90,99.1,414,114.12,FALSE,FALSE
620,5,BODY,prints:,9,5.02,23,7,90,223.1,113,228.12,FALSE,FALSE
620,9,BODY,prints:,9,5.02,23,7,90,483.1,113,488.12,FALSE,FALSE
620,12,BODY,Example 15.10.2-2. Multi-Dimensional Array Creation,9,5.19,209.74,51,90,550.62,299.74,555.81,TRUE,FALSE
620,13,BODY,The declaration:,9,5.02,58.73,16,90,574.1,148.73,579.12,FALSE,FALSE
621,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
621,1,BODY,Array Creation and Access Expressions15.10,9,4.95,181.38,42,286.62,40.15,468,45.1,FALSE,TRUE
621,2,BODY,is equivalent in behavior to:,9,5.02,100.49,29,90,74.1,190.49,79.12,FALSE,FALSE
621,4,BODY,and:,9,5.02,15.5,4,90,138.1,105.5,143.12,FALSE,FALSE
621,6,BODY,is equivalent to:,9,5.02,57.5,17,90,182.1,147.5,187.12,FALSE,FALSE
621,10,BODY,A triangular matrix may be created by:,9,5.02,139.97,38,90,420.1,229.97,425.12,FALSE,FALSE
622,0,BODY,15.10Array Creation and Access Expressions,9,4.95,181.38,42,36,40.15,217.38,45.1,FALSE,TRUE
622,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
622,4,BODY,This program produces the output:,9,5.02,124.49,33,90,267.1,214.49,272.12,FALSE,FALSE
622,10,BODY,"Note that the array reference expression may be a name or any primary expression that is not an array creation expression, unless the array creation expression has an array initializer (§15.10.1).",9,25.02,324.01,196,90,528.1,414.01,553.12,FALSE,FALSE
623,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
623,1,BODY,Array Creation and Access Expressions15.10,9,4.95,181.38,42,286.62,40.15,468,45.1,FALSE,TRUE
623,4,BODY,Example 15.10.4-1. Array Reference Is Evaluated First,9,5.19,210.72,53,90,450.62,300.72,455.81,TRUE,FALSE
624,0,BODY,15.10Array Creation and Access Expressions,9,4.95,181.38,42,36,40.15,217.38,45.1,FALSE,TRUE
624,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
624,5,BODY,Example 15.10.4-2. Abrupt Completion of Array Reference Evaluation,9,5.19,271.48,66,90,193.62,361.48,198.81,TRUE,FALSE
624,6,BODY,"If evaluation of the expression to the left of the brackets completes abruptly, no part of the expression within the brackets will appear to have been evaluated. Thus, the program:",9,15.02,324,180,90,217.1,414,232.12,FALSE,FALSE
624,8,BODY,prints:,9,5.02,23,7,90,391.1,113,396.12,FALSE,FALSE
625,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
625,1,BODY,Field Access Expressions15.11,9,4.95,128.77,29,339.23,40.15,468,45.1,FALSE,TRUE
625,3,BODY,prints:,9,5.02,23,7,90,126.1,113,131.12,FALSE,FALSE
625,7,BODY,always prints:,9,5.02,50.25,14,90,354.1,140.25,359.12,FALSE,FALSE
626,0,BODY,15.11Field Access Expressions,9,4.95,128.77,29,36,40.15,164.77,45.1,FALSE,TRUE
626,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
627,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
627,1,BODY,Field Access Expressions15.11,9,4.95,128.77,29,339.23,40.15,468,45.1,FALSE,TRUE
627,4,BODY,Example 15.11.1-1. Static Binding for Field Access,9,5.19,193.25,50,90,309.62,283.25,314.81,TRUE,FALSE
627,6,BODY,This program produces the output:,9,5.02,124.49,33,90,501.1,214.49,506.12,FALSE,FALSE
628,0,BODY,15.11Field Access Expressions,9,4.95,128.77,29,36,40.15,164.77,45.1,FALSE,TRUE
628,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
628,2,BODY,"This lack of dynamic lookup for field accesses allows programs to be run efficiently with straightforward implementations. The power of late binding and overriding is available, but only when instance methods are used. Consider the same example using instance methods to access the fields:",9,35.02,324.01,289,90,74.1,414.01,109.12,FALSE,FALSE
628,4,BODY,Now the output is:,9,5.02,66.75,18,90,298.1,156.75,303.12,FALSE,FALSE
628,10,BODY,"It compiles, executes, and prints:",9,5.02,118.49,34,90,583.1,208.49,588.12,FALSE,FALSE
629,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
629,1,BODY,Field Access Expressions15.11,9,4.95,128.77,29,339.23,40.15,468,45.1,FALSE,TRUE
630,0,BODY,15.12Method Invocation Expressions,9,4.95,151.13,34,36,40.15,187.13,45.1,FALSE,TRUE
630,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
630,6,BODY,This program produces the output:,9,5.02,124.49,33,90,357.1,214.49,362.12,FALSE,FALSE
631,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
631,1,BODY,Method Invocation Expressions15.12,9,4.95,151.13,34,316.87,40.15,468,45.1,FALSE,TRUE
632,0,BODY,15.12Method Invocation Expressions,9,4.95,151.13,34,36,40.15,187.13,45.1,FALSE,TRUE
632,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
632,3,BODY,This search policy is called the 'comb rule'. It effectively looks for methods in a nested class's superclass hierarchy before looking for methods in an enclosing class and its superclass hierarchy. See §6.5.7.1 for an example.,9,25.02,304,227,110,306.1,414,331.12,FALSE,FALSE
633,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
633,1,BODY,Method Invocation Expressions15.12,9,4.95,151.13,34,316.87,40.15,468,45.1,FALSE,TRUE
633,4,BODY,"To support invocation of default methods in superinterfaces, the TypeName may also refer to a direct superinterface of the current class or interface, and the target is that superinterface.",9,25.02,324,189,90,494.1,414,519.12,FALSE,FALSE
634,0,BODY,15.12Method Invocation Expressions,9,4.95,151.13,34,36,40.15,187.13,45.1,FALSE,TRUE
634,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
635,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
635,1,BODY,Method Invocation Expressions15.12,9,4.95,151.13,34,316.87,40.15,468,45.1,FALSE,TRUE
635,5,BODY,This ensures that a method is never chosen through variable arity method invocation if it is applicable through fixed arity method invocation.,9,15.02,306,142,108,333.1,414,348.12,FALSE,FALSE
635,9,BODY,"To check for applicability, the types of an invocation's arguments cannot, in general, be inputs to the analysis. This is because: •The arguments to a method invocation may be poly expressions. •Poly expressions cannot be typed in the absence of a target type.",9,53.02,323.99,260,90,539.1,413.99,592.12,FALSE,FALSE
636,0,BODY,15.12Method Invocation Expressions,9,4.95,151.13,34,36,40.15,187.13,45.1,FALSE,TRUE
636,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
636,2,BODY,"•Overload resolution has to be completed before the arguments' target types will be known. Instead, the input to the applicability check is a list of the arguments themselves. The arguments can be checked for compatibility with potential target types, even if the ultimate types of the arguments are unknown. Note that overload resolution is independent of a target type. This is for two reasons: •First, it makes the user model more accessible and less error-prone. The meaning of a method name (i.e., the declaration corresponding to the name) is too fundamental to the meaning of a program to depend on subtle contextual hints. (In contrast, other poly expressions may have different behavior depending on a target type; but the variation in behavior is always limited and essentially equivalent, while no such guarantees can be made about the behavior of an arbitrary set of methods that share a name and arity.) •Second, it allows other properties - such as whether or not the method is a poly expression (§15.12) or how to categorize a conditional expression (§15.25) - to depend on the meaning of the method name, even before a target type is known.",9,187.02,324.01,1156,90,74.1,414.01,261.12,FALSE,FALSE
636,3,BODY,Example 15.12.2-1. Method Applicability,9,5.19,157.51,39,90,279.62,247.51,284.81,TRUE,FALSE
637,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
637,1,BODY,Method Invocation Expressions15.12,9,4.95,151.13,34,316.87,40.15,468,45.1,FALSE,TRUE
637,5,BODY,Here is an example of overloading ambiguity. Consider the program:,9,5.02,248.46,66,90,332.1,338.46,337.12,FALSE,FALSE
638,0,BODY,15.12Method Invocation Expressions,9,4.95,151.13,34,36,40.15,187.13,45.1,FALSE,TRUE
638,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
638,2,BODY,"then it would be more specific than the other two, and the method invocation would no longer be ambiguous.",9,15.02,323.99,106,90,74.1,413.99,89.12,FALSE,FALSE
638,3,BODY,Example 15.12.2-2. Return Type Not Considered During Method Selection,9,5.19,285.74,69,90,107.62,375.74,112.81,TRUE,FALSE
638,6,BODY,Example 15.12.2-3. Choosing The Most Specific Method,9,5.19,214.75,52,90,352.62,304.75,357.81,TRUE,FALSE
639,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
639,1,BODY,Method Invocation Expressions15.12,9,4.95,151.13,34,316.87,40.15,468,45.1,FALSE,TRUE
639,5,BODY,The output is:,9,5.02,50,14,90,420.1,140,425.12,FALSE,FALSE
640,0,BODY,15.12Method Invocation Expressions,9,4.95,151.13,34,36,40.15,187.13,45.1,FALSE,TRUE
640,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
640,9,BODY,"Ideally, source code should be recompiled whenever code that it depends on is changed. However, in an environment where different classes are maintained by different organizations, this is not always feasible. Defensive programming with careful attention to the problems of class evolution can make upgraded code much more robust. See §13 (Binary Compatibility) for a detailed discussion of binary compatibility and type evolution.",9,45.02,324.01,431,90,378.1,414.01,423.12,FALSE,FALSE
641,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
641,1,BODY,Method Invocation Expressions15.12,9,4.95,151.13,34,316.87,40.15,468,45.1,FALSE,TRUE
641,5,BODY,"This clause implies that a non-generic method may be potentially applicable to an invocation that supplies explicit type arguments. Indeed, it may turn out to be applicable. In such a case, the type arguments will simply be ignored. This rule stems from issues of compatibility and principles of substitutability. Since interfaces or superclasses may be generified independently of their subtypes, we may override a generic method with a non-generic one. However, the overriding (non- generic) method must be applicable to calls to the generic method, including calls that explicitly pass type arguments. Otherwise the subtype would not be substitutable for its generified supertype.",9,97.02,314.01,683,100,472.1,414.01,569.12,FALSE,FALSE
642,0,BODY,15.12Method Invocation Expressions,9,4.95,151.13,34,36,40.15,187.13,45.1,FALSE,TRUE
642,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
643,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
643,1,BODY,Method Invocation Expressions15.12,9,4.95,151.13,34,316.87,40.15,468,45.1,FALSE,TRUE
643,2,BODY,"argument cannot be properly typed until after overload resolution. These rules allow the form of the lambda expression to still be taken into account, discarding obviously incorrect target types that might otherwise cause ambiguity errors.",9,25.02,324.01,239,90,74.1,414.01,99.12,FALSE,FALSE
644,0,BODY,15.12Method Invocation Expressions,9,4.95,151.13,34,36,40.15,187.13,45.1,FALSE,TRUE
644,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
644,3,BODY,The meaning of an implicitly typed lambda expression or an inexact method reference expression is sufficiently vague prior to resolving a target type that arguments containing these expressions are not considered pertinent to applicability; they are simply ignored (except for their expected arity) until overload resolution is finished.,9,35.02,324,337,90,189.1,414,224.12,FALSE,FALSE
645,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
645,1,BODY,Method Invocation Expressions15.12,9,4.95,151.13,34,316.87,40.15,468,45.1,FALSE,TRUE
646,0,BODY,15.12Method Invocation Expressions,9,4.95,151.13,34,36,40.15,187.13,45.1,FALSE,TRUE
646,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
647,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
647,1,BODY,Method Invocation Expressions15.12,9,4.95,151.13,34,316.87,40.15,468,45.1,FALSE,TRUE
648,0,BODY,15.12Method Invocation Expressions,9,4.95,151.13,34,36,40.15,187.13,45.1,FALSE,TRUE
648,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
649,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
649,1,BODY,Method Invocation Expressions15.12,9,4.95,151.13,34,316.87,40.15,468,45.1,FALSE,TRUE
650,0,BODY,15.12Method Invocation Expressions,9,4.95,151.13,34,36,40.15,187.13,45.1,FALSE,TRUE
650,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
650,7,BODY,"Testing for compatibility with a target type may occur multiple times before making a final determination of the method invocation expression's target type and invocation type. For example, an enclosing method invocation expression may require testing the",9,25.02,314,255,100,562.23,414,587.25,FALSE,FALSE
651,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
651,1,BODY,Method Invocation Expressions15.12,9,4.95,151.13,34,316.87,40.15,468,45.1,FALSE,TRUE
651,2,BODY,deeper method invocation expression for compatibility with different methods' formal parameter types.,9,15.02,313.99,101,100,74.1,413.99,89.12,FALSE,FALSE
652,0,BODY,15.12Method Invocation Expressions,9,4.95,151.13,34,36,40.15,187.13,45.1,FALSE,TRUE
652,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
653,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
653,1,BODY,Method Invocation Expressions15.12,9,4.95,151.13,34,316.87,40.15,468,45.1,FALSE,TRUE
654,0,BODY,15.12Method Invocation Expressions,9,4.95,151.13,34,36,40.15,187.13,45.1,FALSE,TRUE
654,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
655,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
655,1,BODY,Method Invocation Expressions15.12,9,4.95,151.13,34,316.87,40.15,468,45.1,FALSE,TRUE
656,0,BODY,15.12Method Invocation Expressions,9,4.95,151.13,34,36,40.15,187.13,45.1,FALSE,TRUE
656,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
656,3,BODY,which prints:,9,5.02,47.25,13,90,166.1,137.25,171.12,FALSE,FALSE
656,6,BODY,Example 15.12.4.1-2. Evaluation Order During Method Invocation,9,5.19,255.51,62,90,233.62,345.51,238.81,TRUE,FALSE
656,7,BODY,"As part of an instance method invocation (§15.12), there is an expression that denotes the object to be invoked. This expression appears to be fully evaluated before any part of any argument expression to the method invocation is evaluated. So, for example, in:",9,47.02,324,261,90,257.1,414,304.12,FALSE,FALSE
657,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
657,1,BODY,Method Invocation Expressions15.12,9,4.95,151.13,34,316.87,40.15,468,45.1,FALSE,TRUE
658,0,BODY,15.12Method Invocation Expressions,9,4.95,151.13,34,36,40.15,187.13,45.1,FALSE,TRUE
658,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
659,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
659,1,BODY,Method Invocation Expressions15.12,9,4.95,151.13,34,316.87,40.15,468,45.1,FALSE,TRUE
660,0,BODY,15.12Method Invocation Expressions,9,4.95,151.13,34,36,40.15,187.13,45.1,FALSE,TRUE
660,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
660,6,BODY,"The dynamic lookup process, while described here explicitly, will often be implemented implicitly, for example as a side-effect of the construction and use of per-class method dispatch tables, or the construction of other per-class structures used for efficient dispatch.",9,25.02,324,271,90,498.1,414,523.12,FALSE,FALSE
660,7,BODY,Example 15.12.4.4-1. Overriding and Method Invocation,9,5.19,217.26,53,90,541.62,307.26,546.81,TRUE,FALSE
661,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
661,1,BODY,Method Invocation Expressions15.12,9,4.95,151.13,34,316.87,40.15,468,45.1,FALSE,TRUE
661,5,BODY,which is:,9,5.02,32.75,9,90,512.1,122.75,517.12,FALSE,FALSE
662,0,BODY,15.12Method Invocation Expressions,9,4.95,151.13,34,36,40.15,187.13,45.1,FALSE,TRUE
662,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
662,7,BODY,which produces the output:,9,5.02,97.74,26,90,569.1,187.74,574.12,FALSE,FALSE
663,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
663,1,BODY,Method Invocation Expressions15.12,9,4.95,151.13,34,316.87,40.15,468,45.1,FALSE,TRUE
664,0,BODY,15.13Method Reference Expressions,9,4.95,148.63,33,36,40.15,184.63,45.1,FALSE,TRUE
664,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
664,3,BODY,Example 15.12.4.5-1. Invoked Method Signature Has Different Erasure Than Compile- Time Method Signature,9,18.19,342,103,90,136.62,432,154.81,TRUE,FALSE
664,4,BODY,Consider the declarations:,9,5.02,93.99,26,90,173.1,183.99,178.12,FALSE,FALSE
665,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
665,1,BODY,Method Reference Expressions15.13,9,4.95,148.63,33,319.37,40.15,468,45.1,FALSE,TRUE
666,0,BODY,15.13Method Reference Expressions,9,4.95,148.63,33,36,40.15,184.63,45.1,FALSE,TRUE
666,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
666,3,BODY,"Here are some method reference expressions, first with no target reference and then with a target reference:",9,15.02,323.99,108,90,485.1,413.99,500.12,FALSE,FALSE
667,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
667,1,BODY,Method Reference Expressions15.13,9,4.95,148.63,33,319.37,40.15,468,45.1,FALSE,TRUE
668,0,BODY,15.13Method Reference Expressions,9,4.95,148.63,33,36,40.15,184.63,45.1,FALSE,TRUE
668,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
669,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
669,1,BODY,Method Reference Expressions15.13,9,4.95,148.63,33,319.37,40.15,468,45.1,FALSE,TRUE
670,0,BODY,15.13Method Reference Expressions,9,4.95,148.63,33,36,40.15,184.63,45.1,FALSE,TRUE
670,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
671,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
671,1,BODY,Method Reference Expressions15.13,9,4.95,148.63,33,319.37,40.15,468,45.1,FALSE,TRUE
672,0,BODY,15.13Method Reference Expressions,9,4.95,148.63,33,36,40.15,184.63,45.1,FALSE,TRUE
672,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
673,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
673,1,BODY,Method Reference Expressions15.13,9,4.95,148.63,33,319.37,40.15,468,45.1,FALSE,TRUE
674,0,BODY,15.13Method Reference Expressions,9,4.95,148.63,33,36,40.15,184.63,45.1,FALSE,TRUE
674,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
675,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
675,1,BODY,Method Reference Expressions15.13,9,4.95,148.63,33,319.37,40.15,468,45.1,FALSE,TRUE
676,0,BODY,15.13Method Reference Expressions,9,4.95,148.63,33,36,40.15,184.63,45.1,FALSE,TRUE
676,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
677,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
677,1,BODY,Method Reference Expressions15.13,9,4.95,148.63,33,319.37,40.15,468,45.1,FALSE,TRUE
678,0,BODY,15.14Postfix Expressions,9,4.95,107.46,24,36,40.15,143.46,45.1,FALSE,TRUE
678,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
679,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
679,1,BODY,Postfix Expressions15.14,9,4.95,107.46,24,360.54,40.15,468,45.1,FALSE,TRUE
679,8,BODY,Note that the binary numeric promotion mentioned above may include unboxing conversion (§5.1.8).,9,15.02,324,96,90,523.1,414,538.12,FALSE,FALSE
680,0,BODY,15.15Unary Operators,9,4.95,98.98,20,36,40.15,134.98,45.1,FALSE,TRUE
680,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
680,5,BODY,Note that the binary numeric promotion mentioned above may include unboxing conversion (§5.1.8).,9,15.02,324,96,90,349.1,414,364.12,FALSE,FALSE
681,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
681,1,BODY,Unary Operators15.15,9,4.95,98.98,20,369.02,40.15,468,45.1,FALSE,TRUE
681,5,BODY,CastExpression: ( PrimitiveType ) UnaryExpression ( ReferenceType {AdditionalBound} ) UnaryExpressionNotPlusMinus ( ReferenceType {AdditionalBound} ) LambdaExpression,9,34.95,266.48,166,108,441.15,374.48,476.1,FALSE,TRUE
682,0,BODY,15.15Unary Operators,9,4.95,98.98,20,36,40.15,134.98,45.1,FALSE,TRUE
682,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
682,4,BODY,Note that the binary numeric promotion mentioned above may include unboxing conversion (§5.1.8).,9,15.02,324,96,90,396.1,414,411.12,FALSE,FALSE
683,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
683,1,BODY,Unary Operators15.15,9,4.95,98.98,20,369.02,40.15,468,45.1,FALSE,TRUE
683,3,BODY,Note that the binary numeric promotion mentioned above may include unboxing conversion (§5.1.8).,9,15.02,324,96,90,203.1,414,218.12,FALSE,FALSE
684,0,BODY,15.15Unary Operators,9,4.95,98.98,20,36,40.15,134.98,45.1,FALSE,TRUE
684,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
684,3,BODY,The Java programming language has not adopted the stronger requirement from the 2019 version of the IEEE 754 Standard that negation inverts the sign bit for all inputs including NaN.,9,25.02,314.01,182,100,202.1,414.01,227.12,FALSE,FALSE
685,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
685,1,BODY,Cast Expressions15.16,9,4.95,98.99,21,369.01,40.15,468,45.1,FALSE,TRUE
685,4,BODY,AdditionalBound: & InterfaceType,9,14.95,67.64,32,108,268.15,175.64,283.1,FALSE,TRUE
685,6,BODY,"Casts can be used to explicitly 'tag' a lambda expression or a method reference expression with a particular target type. To provide an appropriate degree of flexibility, the target type may be a list of types denoting an intersection type, provided the intersection induces a functional interface (§9.8).",9,35.02,324.01,305,90,540.1,414.01,575.12,FALSE,FALSE
686,0,BODY,15.17Multiplicative Operators,9,4.95,126.4,29,36,40.15,162.4,45.1,FALSE,TRUE
686,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
686,3,BODY,"Some casts result in an error at compile time. Some casts can be proven, at compile time, always to be correct at run time. For example, it is always correct to convert a value of a class type to the type of its superclass; such a cast should require no special action at run time. Finally, some casts cannot be proven to be either always correct or always incorrect at compile time. Such casts require a test at run time. See §5.5 for details.",9,45.02,323.99,444,90,208.1,413.99,253.12,FALSE,FALSE
686,8,BODY,Note that binary numeric promotion may include unboxing conversion (§5.1.8).,9,5.02,287.47,76,90,507.1,377.47,512.12,FALSE,FALSE
687,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
687,1,BODY,Multiplicative Operators15.17,9,4.95,126.4,29,341.6,40.15,468,45.1,FALSE,TRUE
688,0,BODY,15.17Multiplicative Operators,9,4.95,126.4,29,36,40.15,162.4,45.1,FALSE,TRUE
688,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
689,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
689,1,BODY,Multiplicative Operators15.17,9,4.95,126.4,29,341.6,40.15,468,45.1,FALSE,TRUE
689,3,BODY,Example 15.17.3-1. Integer Remainder Operator,9,5.19,186.72,45,90,336.62,276.72,341.81,TRUE,FALSE
689,5,BODY,This program produces the output:,9,5.02,124.49,33,90,598.1,214.49,603.12,FALSE,FALSE
690,0,BODY,15.17Multiplicative Operators,9,4.95,126.4,29,36,40.15,162.4,45.1,FALSE,TRUE
690,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
690,4,BODY,Example 15.17.3-2. Floating-Point Remainder Operator,9,5.19,214.24,52,90,558.62,304.24,563.81,TRUE,FALSE
691,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
691,1,BODY,Additive Operators15.18,9,4.95,105.96,23,362.04,40.15,468,45.1,FALSE,TRUE
692,0,BODY,15.18Additive Operators,9,4.95,105.96,23,36,40.15,141.96,45.1,FALSE,TRUE
692,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
692,4,BODY,Example 15.18.1-1. String Concatenation,9,5.19,157.5,39,90,305.62,247.5,310.81,TRUE,FALSE
692,5,BODY,The example expression:,9,5.02,89.98,23,90,329.1,179.98,334.12,FALSE,FALSE
692,7,BODY,produces the result:,9,5.02,70.49,20,90,373.1,160.49,378.12,FALSE,FALSE
692,9,BODY,"The + operator is syntactically left-associative, no matter whether it is determined by type analysis to represent string concatenation or numeric addition. In some cases care is required to get the desired result. For example, the expression:",9,25.02,324,243,90,417.1,414,442.12,FALSE,FALSE
692,11,BODY,is always regarded as meaning:,9,5.02,112.47,30,90,481.1,202.47,486.12,FALSE,FALSE
692,13,BODY,Therefore the result of the expression:,9,5.02,137.21,39,90,525.1,227.21,530.12,FALSE,FALSE
692,15,BODY,is:,9,5.02,8.5,3,90,569.1,98.5,574.12,FALSE,FALSE
693,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
693,1,BODY,Additive Operators15.18,9,4.95,105.96,23,362.04,40.15,468,45.1,FALSE,TRUE
693,2,BODY,but the result of:,9,5.02,59.25,18,90,74.1,149.25,79.12,FALSE,FALSE
693,4,BODY,is:,9,5.02,8.5,3,90,118.1,98.5,123.12,FALSE,FALSE
693,6,BODY,Example 15.18.1-2. String Concatenation and Conditionals,9,5.19,225.52,56,90,173.62,315.52,178.81,TRUE,FALSE
694,0,BODY,15.18Additive Operators,9,4.95,105.96,23,36,40.15,141.96,45.1,FALSE,TRUE
694,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
694,5,BODY,into two pieces to avoid an inconveniently long line in the source code.,9,5.02,256.22,72,90,290.1,346.22,295.12,FALSE,FALSE
694,7,BODY,Note that binary numeric promotion may include unboxing conversion (§5.1.8).,9,5.02,287.47,76,90,429.1,377.47,434.12,FALSE,FALSE
695,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
695,1,BODY,Additive Operators15.18,9,4.95,105.96,23,362.04,40.15,468,45.1,FALSE,TRUE
696,0,BODY,15.19Shift Operators,9,4.95,92.51,20,36,40.15,128.51,45.1,FALSE,TRUE
696,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
697,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
697,1,BODY,Relational Operators15.20,9,4.95,113.45,25,354.55,40.15,468,45.1,FALSE,TRUE
698,0,BODY,15.20Relational Operators,9,4.95,113.44,25,36,40.15,149.44,45.1,FALSE,TRUE
698,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
698,3,BODY,Note that binary numeric promotion may include unboxing conversion (§5.1.8).,9,5.02,287.47,76,90,99.1,377.47,104.12,FALSE,FALSE
699,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
699,1,BODY,Relational Operators15.20,9,4.95,113.45,25,354.55,40.15,468,45.1,FALSE,TRUE
699,5,BODY,Example 15.20.2-1. The Type Comparison Operator,9,5.19,200,47,90,568.62,290,573.81,TRUE,FALSE
700,0,BODY,15.20Relational Operators,9,4.95,113.44,25,36,40.15,149.44,45.1,FALSE,TRUE
700,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
701,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
701,1,BODY,Equality Operators15.21,9,4.95,106.46,23,361.54,40.15,468,45.1,FALSE,TRUE
701,10,BODY,Note that binary numeric promotion may include unboxing conversion (§5.1.8).,9,5.02,287.47,76,90,576.1,377.47,581.12,FALSE,FALSE
702,0,BODY,15.21Equality Operators,9,4.95,106.46,23,36,40.15,142.46,45.1,FALSE,TRUE
702,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
703,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
703,1,BODY,Bitwise and Logical Operators15.22,9,4.95,148.99,34,319.01,40.15,468,45.1,FALSE,TRUE
704,0,BODY,15.22Bitwise and Logical Operators,9,4.95,148.99,34,36,40.15,184.99,45.1,FALSE,TRUE
704,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
704,9,BODY,The result of the expression:,9,5.02,102.48,29,90,582.1,192.48,587.12,FALSE,FALSE
705,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
706,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
707,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
708,1,BODY,EXPRESSIONS,9,4.95,56.49,11,376.75,40.15,433.24,45.1,FALSE,TRUE
708,3,BODY,"Note that, for a generic method, this is the type before instantiating the method's type arguments.",9,15.02,304,99,110,233.1,414,248.12,FALSE,FALSE
709,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
710,1,BODY,EXPRESSIONS,9,4.95,56.49,11,376.75,40.15,433.24,45.1,FALSE,TRUE
711,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
712,1,BODY,EXPRESSIONS,9,4.95,56.49,11,376.75,40.15,433.24,45.1,FALSE,TRUE
713,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
714,1,BODY,EXPRESSIONS,9,4.95,56.49,11,376.75,40.15,433.24,45.1,FALSE,TRUE
715,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
715,3,BODY,Note that numeric promotion may include unboxing conversion (§5.1.8).,9,5.02,262.22,69,100,125.1,362.22,130.12,FALSE,FALSE
716,0,BODY,15.26Assignment Operators,9,4.95,117.43,25,36,40.15,153.43,45.1,FALSE,TRUE
716,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
717,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
717,1,BODY,Assignment Operators15.26,9,4.95,117.43,25,350.57,40.15,468,45.1,FALSE,TRUE
718,0,BODY,15.26Assignment Operators,9,4.95,117.43,25,36,40.15,153.43,45.1,FALSE,TRUE
718,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
719,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
719,1,BODY,Assignment Operators15.26,9,4.95,117.43,25,350.57,40.15,468,45.1,FALSE,TRUE
719,6,BODY,Example 15.26.1-1. Simple Assignment To An Array Component,9,5.19,248.5,58,90,358.62,338.5,363.81,TRUE,FALSE
720,0,BODY,15.26Assignment Operators,9,4.95,117.43,25,36,40.15,153.43,45.1,FALSE,TRUE
720,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
721,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
721,1,BODY,Assignment Operators15.26,9,4.95,117.43,25,350.57,40.15,468,45.1,FALSE,TRUE
721,3,BODY,This program produces the output:,9,5.02,124.49,33,90,156.1,214.49,161.12,FALSE,FALSE
722,0,BODY,15.26Assignment Operators,9,4.95,117.43,25,36,40.15,153.43,45.1,FALSE,TRUE
722,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
723,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
723,1,BODY,Assignment Operators15.26,9,4.95,117.43,25,350.57,40.15,468,45.1,FALSE,TRUE
723,2,BODY,The most interesting case of the lot is thirteenth from the end:,9,5.02,222.23,64,90,74.1,312.23,79.12,FALSE,FALSE
724,0,BODY,15.26Assignment Operators,9,4.95,117.43,25,36,40.15,153.43,45.1,FALSE,TRUE
724,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
724,3,BODY,"For a simple assignment operator, the evaluation of the right-hand operand occurs before the checks of the array reference subexpression and the index subexpression, but for a compound assignment operator, the evaluation of the right-hand operand occurs after these checks.",9,35.02,314,273,100,389.1,414,424.12,FALSE,FALSE
725,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
725,1,BODY,Assignment Operators15.26,9,4.95,117.43,25,350.57,40.15,468,45.1,FALSE,TRUE
725,3,BODY,Therefore the run-time check that is sometimes required for the simple assignment operator is never required for a compound assignment operator.,9,15.02,304,144,110,298.1,414,313.12,FALSE,FALSE
726,0,BODY,15.26Assignment Operators,9,4.95,117.43,25,36,40.15,153.43,45.1,FALSE,TRUE
726,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
727,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
727,1,BODY,Assignment Operators15.26,9,4.95,117.43,25,350.57,40.15,468,45.1,FALSE,TRUE
728,0,BODY,15.26Assignment Operators,9,4.95,117.43,25,36,40.15,153.43,45.1,FALSE,TRUE
728,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
728,3,BODY,This program produces the output:,9,5.02,124.49,33,90,96.1,214.49,101.12,FALSE,FALSE
728,5,BODY,The most interesting cases of the lot are eleventh and twelfth from the end:,9,5.02,269.7,76,90,570.1,359.7,575.12,FALSE,FALSE
729,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
729,1,BODY,Lambda Expressions15.27,9,4.95,111.95,23,356.05,40.15,468,45.1,FALSE,TRUE
729,3,BODY,"They are the cases where a right-hand side that throws an exception actually gets to throw the exception; moreover, they are the only such cases in the lot. This demonstrates that the evaluation of the right-hand operand indeed occurs after the checks for a null array reference value and an out-of-bounds index value.",9,35.02,324,318,90,106.1,414,141.12,FALSE,FALSE
729,4,BODY,Example 15.26.2-2. Value Of Left-Hand Side Of Compound Assignment Is Saved Before Evaluation Of Right-Hand Side,9,18.19,341.99,111,90,159.62,431.99,177.81,TRUE,FALSE
729,6,BODY,This program produces the output:,9,5.02,124.49,33,90,294.1,214.49,299.12,FALSE,FALSE
729,10,BODY,behave in exactly the same manner as the statements:,9,5.02,191.96,52,90,454.1,281.96,459.12,FALSE,FALSE
730,0,BODY,15.27Lambda Expressions,9,4.95,111.94,23,36,40.15,147.94,45.1,FALSE,TRUE
730,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
730,4,BODY,"This syntax has the advantage of minimizing bracket noise around simple lambda expressions, which is especially beneficial when a lambda expression is an argument to",9,15.02,324,165,90,583.1,414,598.12,FALSE,FALSE
731,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
731,1,BODY,Lambda Expressions15.27,9,4.95,111.95,23,356.05,40.15,468,45.1,FALSE,TRUE
732,0,BODY,15.27Lambda Expressions,9,4.95,111.94,23,36,40.15,147.94,45.1,FALSE,TRUE
732,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
732,4,BODY,"The following productions from §8.4.1, §8.3, and §4.3 are shown here for convenience:",9,5.02,315.44,85,90,497.1,405.44,502.12,FALSE,FALSE
732,5,BODY,VariableArityParameter: {VariableModifier} UnannType {Annotation} ... Identifier VariableModifier: Annotation final,9,53.75,228.1,115,108,519.15,336.1,572.9,FALSE,TRUE
733,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
733,1,BODY,Lambda Expressions15.27,9,4.95,111.95,23,356.05,40.15,468,45.1,FALSE,TRUE
733,2,BODY,VariableDeclaratorId: Identifier [Dims] _ Dims: {Annotation} [ ] {{Annotation} [ ]},9,53.95,144.46,83,108,74.15,252.46,128.1,FALSE,TRUE
734,0,BODY,15.27Lambda Expressions,9,4.95,111.94,23,36,40.15,147.94,45.1,FALSE,TRUE
734,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
734,3,BODY,"If a lambda expression is implicitly typed, then its lambda body is interpreted according to the context in which it appears. Specifically, the types of expressions in the body, and the checked exceptions thrown by the body, and the type correctness of code in the body all depend on the types inferred for the formal parameters. This implies that inference of formal parameter types must occur 'before' attempting to type-check the lambda body.",9,45.02,323.99,445,90,138.1,413.99,183.12,FALSE,FALSE
735,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
735,1,BODY,Lambda Expressions15.27,9,4.95,111.95,23,356.05,40.15,468,45.1,FALSE,TRUE
736,0,BODY,15.27Lambda Expressions,9,4.95,111.94,23,36,40.15,147.94,45.1,FALSE,TRUE
736,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
736,5,BODY,"The handling of void/value-compatible and the meaning of names in the body jointly serve to minimize the dependency on a particular target type in the given context, which is useful both for implementations and for programmer comprehension. While expressions can be assigned different types during overload resolution depending on the target type, the meaning of unqualified names and the basic structure of the lambda body do not change. Note that the void/value-compatible definition is not a strictly structural property: 'can complete normally' depends on the values of constant expressions, and these may include names that reference constant variables.",9,87.02,324,658,90,226.1,414,313.12,FALSE,FALSE
737,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
737,1,BODY,Lambda Expressions15.27,9,4.95,111.95,23,356.05,40.15,468,45.1,FALSE,TRUE
738,0,BODY,15.27Lambda Expressions,9,4.95,111.94,23,36,40.15,147.94,45.1,FALSE,TRUE
738,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
739,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
739,1,BODY,Lambda Expressions15.27,9,4.95,111.95,23,356.05,40.15,468,45.1,FALSE,TRUE
740,0,BODY,15.27Lambda Expressions,9,4.95,111.94,23,36,40.15,147.94,45.1,FALSE,TRUE
740,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
741,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
741,7,BODY,SwitchBlock: { SwitchRule {SwitchRule} } { {SwitchBlockStatementGroup} {SwitchLabel :} } SwitchRule: SwitchLabel -> Expression ; SwitchLabel -> Block SwitchLabel -> ThrowStatement SwitchBlockStatementGroup: SwitchLabel : {SwitchLabel :} BlockStatements,9,102.95,197.6,252,108,474.15,305.6,577.1,FALSE,TRUE
742,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
742,2,BODY,"SwitchLabel: case CaseConstant {, CaseConstant} case null [, default] case CasePattern {, CasePattern} [Guard] default CaseConstant: ConditionalExpression CasePattern: Pattern Guard: when Expression",9,131.95,173.7,198,108,74.15,281.7,206.1,FALSE,TRUE
743,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
744,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
745,0,BODY,EXPRESSIONS,9,4.95,56.49,11,72,40.15,128.49,45.1,FALSE,TRUE
745,1,BODY,Constant Expressions15.29,9,4.95,114.94,25,353.06,40.15,468,45.1,FALSE,TRUE
746,0,BODY,15.29Constant Expressions,9,4.95,114.94,25,36,40.15,150.94,45.1,FALSE,TRUE
746,1,BODY,EXPRESSIONS,9,4.95,56.49,11,375.51,40.15,432,45.1,FALSE,TRUE
746,2,BODY,Example 15.29-1. Constant Expressions,9,5.19,151.76,37,90,75.62,241.76,80.81,TRUE,FALSE
748,0,BODY,DEFINITE ASSIGNMENT,9,4.95,97.06,19,334.94,40.15,432,45.1,FALSE,TRUE
748,2,BODY,Example 16-1. Definite Assignment Considers Structure of Statements and Expressions,9,5.19,334.49,83,90,166.62,424.49,171.81,TRUE,FALSE
748,5,BODY,because the access occurs only if the value of the expression:,9,5.02,219.94,62,90,284.1,309.94,289.12,FALSE,FALSE
749,0,BODY,DEFINITE ASSIGNMENT,9,4.95,97.06,19,72,40.15,169.06,45.1,FALSE,TRUE
749,3,BODY,Example 16-2. Definite Assignment Does Not Consider Values of Expressions,9,5.19,295.49,73,90,169.62,385.49,174.81,TRUE,FALSE
749,4,BODY,A Java compiler must produce a compile-time error for the code:,9,5.02,233.95,63,90,193.1,323.95,198.12,FALSE,FALSE
750,0,BODY,DEFINITE ASSIGNMENT,9,4.95,97.06,19,334.94,40.15,432,45.1,FALSE,TRUE
750,2,BODY,and so compiling this program must cause a compile-time error to occur.,9,5.02,261.96,71,90,96.1,351.96,101.12,FALSE,FALSE
750,3,BODY,Example 16-3. Definite Unassignment,9,5.19,144.49,35,90,119.62,234.49,124.81,TRUE,FALSE
750,7,BODY,and so compiling this program must cause a compile-time error to occur.,9,5.02,261.96,71,90,461.1,351.96,466.12,FALSE,FALSE
751,0,BODY,DEFINITE ASSIGNMENT,9,4.95,97.06,19,72,40.15,169.06,45.1,FALSE,TRUE
752,0,BODY,DEFINITE ASSIGNMENT,9,4.95,97.06,19,334.94,40.15,432,45.1,FALSE,TRUE
752,2,BODY,For example: •V is [un]assigned after an empty statement iff it is [un]assigned before the empty statement. should be understood to stand for two rules: •V is definitely assigned after an empty statement iff it is definitely assigned before the empty statement. •V is definitely unassigned after an empty statement iff it is definitely unassigned before the empty statement.,9,117.02,324,374,90,227.1,414,344.12,FALSE,FALSE
753,0,BODY,DEFINITE ASSIGNMENT,9,4.95,96.62,19,72,40.15,168.62,45.1,FALSE,TRUE
753,1,BODY,Definite Assignment and Expressions16.1,9,4.95,171.37,39,296.63,40.15,468,45.1,FALSE,TRUE
754,0,BODY,16.1Definite Assignment and Expressions,9,4.95,171.37,39,36,40.15,207.37,45.1,FALSE,TRUE
754,1,BODY,DEFINITE ASSIGNMENT,9,4.95,96.62,19,335.38,40.15,432,45.1,FALSE,TRUE
755,0,BODY,DEFINITE ASSIGNMENT,9,4.95,96.62,19,72,40.15,168.62,45.1,FALSE,TRUE
755,1,BODY,Definite Assignment and Expressions16.1,9,4.95,171.37,39,296.63,40.15,468,45.1,FALSE,TRUE
756,0,BODY,16.1Definite Assignment and Expressions,9,4.95,171.37,39,36,40.15,207.37,45.1,FALSE,TRUE
756,1,BODY,DEFINITE ASSIGNMENT,9,4.95,96.62,19,335.38,40.15,432,45.1,FALSE,TRUE
757,0,BODY,DEFINITE ASSIGNMENT,9,4.95,96.62,19,72,40.15,168.62,45.1,FALSE,TRUE
757,1,BODY,Definite Assignment and Expressions16.1,9,4.95,171.37,39,296.63,40.15,468,45.1,FALSE,TRUE
758,0,BODY,16.1Definite Assignment and Expressions,9,4.95,171.37,39,36,40.15,207.37,45.1,FALSE,TRUE
758,1,BODY,DEFINITE ASSIGNMENT,9,4.95,96.62,19,335.38,40.15,432,45.1,FALSE,TRUE
759,0,BODY,DEFINITE ASSIGNMENT,9,4.95,96.62,19,72,40.15,168.62,45.1,FALSE,TRUE
759,1,BODY,Definite Assignment and Expressions16.1,9,4.95,171.37,39,296.63,40.15,468,45.1,FALSE,TRUE
760,0,BODY,16.2Definite Assignment and Statements,9,4.95,166.91,38,36,40.15,202.91,45.1,FALSE,TRUE
760,1,BODY,DEFINITE ASSIGNMENT,9,4.95,96.63,19,335.36,40.15,432,45.1,FALSE,TRUE
760,2,BODY,"assigned to later on, so we cannot conclude that the variable will be unassigned when the body is executed.",9,15.02,313.99,107,100,74.1,413.99,89.12,FALSE,FALSE
761,0,BODY,DEFINITE ASSIGNMENT,9,4.95,96.64,19,72,40.15,168.64,45.1,FALSE,TRUE
761,1,BODY,Definite Assignment and Statements16.2,9,4.95,166.91,38,301.09,40.15,468,45.1,FALSE,TRUE
762,0,BODY,16.2Definite Assignment and Statements,9,4.95,166.91,38,36,40.15,202.91,45.1,FALSE,TRUE
762,1,BODY,DEFINITE ASSIGNMENT,9,4.95,96.63,19,335.36,40.15,432,45.1,FALSE,TRUE
763,0,BODY,DEFINITE ASSIGNMENT,9,4.95,96.64,19,72,40.15,168.64,45.1,FALSE,TRUE
763,1,BODY,Definite Assignment and Statements16.2,9,4.95,166.91,38,301.09,40.15,468,45.1,FALSE,TRUE
764,0,BODY,16.2Definite Assignment and Statements,9,4.95,166.91,38,36,40.15,202.91,45.1,FALSE,TRUE
764,1,BODY,DEFINITE ASSIGNMENT,9,4.95,96.63,19,335.36,40.15,432,45.1,FALSE,TRUE
765,0,BODY,DEFINITE ASSIGNMENT,9,4.95,96.64,19,72,40.15,168.64,45.1,FALSE,TRUE
765,1,BODY,Definite Assignment and Statements16.2,9,4.95,166.91,38,301.09,40.15,468,45.1,FALSE,TRUE
766,0,BODY,16.2Definite Assignment and Statements,9,4.95,166.91,38,36,40.15,202.91,45.1,FALSE,TRUE
766,1,BODY,DEFINITE ASSIGNMENT,9,4.95,96.63,19,335.36,40.15,432,45.1,FALSE,TRUE
767,0,BODY,DEFINITE ASSIGNMENT,9,4.95,96.64,19,72,40.15,168.64,45.1,FALSE,TRUE
767,1,BODY,Definite Assignment and Statements16.2,9,4.95,166.91,38,301.09,40.15,468,45.1,FALSE,TRUE
768,0,BODY,16.2Definite Assignment and Statements,9,4.95,166.91,38,36,40.15,202.91,45.1,FALSE,TRUE
768,1,BODY,DEFINITE ASSIGNMENT,9,4.95,96.63,19,335.36,40.15,432,45.1,FALSE,TRUE
769,0,BODY,DEFINITE ASSIGNMENT,9,4.95,96.63,19,72,40.15,168.63,45.1,FALSE,TRUE
769,1,BODY,Definite Assignment and Parameters16.3,9,4.95,169.88,38,298.12,40.15,468,45.1,FALSE,TRUE
770,0,BODY,16.4Definite Assignment and Array Initializers,9,4.95,190.26,46,36,40.15,226.26,45.1,FALSE,TRUE
770,1,BODY,DEFINITE ASSIGNMENT,9,4.95,96.56,19,335.44,40.15,432,45.1,FALSE,TRUE
771,0,BODY,DEFINITE ASSIGNMENTDefinite Assignment and Anonymous Classes16.6,9,4.95,396,64,72,40.15,468,45.1,FALSE,TRUE
772,0,BODY,"16.9Definite Assignment, Constructors, and Instance InitializersDEFINITE ASSIGNMENT",9,4.95,396,83,36,40.15,432,45.1,FALSE,TRUE
773,0,BODY,"DEFINITE ASSIGNMENTDefinite Assignment, Constructors, and Instance Initializers16.9",9,4.95,396,83,72,40.15,468,45.1,FALSE,TRUE
776,0,BODY,17.1Synchronization,9,4.95,94.5,19,36,40.15,130.5,45.1,FALSE,TRUE
776,1,BODY,THREADS AND LOCKS,9,4.95,90.79,17,341.21,40.15,432,45.1,FALSE,TRUE
777,0,BODY,THREADS AND LOCKS,9,4.95,90.54,17,72,40.15,162.54,45.1,FALSE,TRUE
777,1,BODY,Wait Sets and Notification17.2,9,4.95,132.33,30,335.67,40.15,468,45.1,FALSE,TRUE
778,0,BODY,17.2Wait Sets and Notification,9,4.95,132.32,30,36,40.15,168.32,45.1,FALSE,TRUE
778,1,BODY,THREADS AND LOCKS,9,4.95,90.54,17,341.45,40.15,432,45.1,FALSE,TRUE
779,0,BODY,THREADS AND LOCKS,9,4.95,90.54,17,72,40.15,162.54,45.1,FALSE,TRUE
779,1,BODY,Wait Sets and Notification17.2,9,4.95,132.33,30,335.67,40.15,468,45.1,FALSE,TRUE
780,0,BODY,17.3Sleep and Yield,9,4.95,93.29,19,36,40.15,129.29,45.1,FALSE,TRUE
780,1,BODY,THREADS AND LOCKS,9,4.95,90.8,17,341.2,40.15,432,45.1,FALSE,TRUE
781,0,BODY,THREADS AND LOCKS,9,4.95,90.8,17,72,40.15,162.8,45.1,FALSE,TRUE
781,1,BODY,Memory Model17.4,9,4.95,91.89,16,376.11,40.15,468,45.1,FALSE,TRUE
781,5,BODY,"This provides a great deal of freedom for the implementor to perform a myriad of code transformations, including the reordering of actions and removal of unnecessary synchronization.",9,25.02,324,182,90,318.1,414,343.12,FALSE,FALSE
781,6,BODY,Example 17.4-1. Incorrectly Synchronized Programs May Exhibit Surprising Behavior,9,5.19,333,81,90,361.62,423,366.81,TRUE,FALSE
782,0,BODY,17.4Memory Model,9,4.95,91.88,16,36,40.15,127.88,45.1,FALSE,TRUE
782,1,BODY,THREADS AND LOCKS,9,4.95,90.8,17,341.19,40.15,432,45.1,FALSE,TRUE
783,0,BODY,THREADS AND LOCKS,9,4.95,90.8,17,72,40.15,162.8,45.1,FALSE,TRUE
783,1,BODY,Memory Model17.4,9,4.95,91.89,16,376.11,40.15,468,45.1,FALSE,TRUE
784,0,BODY,17.4Memory Model,9,4.95,91.88,16,36,40.15,127.88,45.1,FALSE,TRUE
784,1,BODY,THREADS AND LOCKS,9,4.95,90.8,17,341.19,40.15,432,45.1,FALSE,TRUE
785,0,BODY,THREADS AND LOCKS,9,4.95,90.8,17,72,40.15,162.8,45.1,FALSE,TRUE
785,1,BODY,Memory Model17.4,9,4.95,91.89,16,376.11,40.15,468,45.1,FALSE,TRUE
785,3,BODY,Thread divergence actions are introduced to model how a thread may cause all other threads to stall and fail to make progress.,9,15.02,313.99,126,100,112.1,413.99,127.12,FALSE,FALSE
786,0,BODY,17.4Memory Model,9,4.95,91.88,16,36,40.15,127.88,45.1,FALSE,TRUE
786,1,BODY,THREADS AND LOCKS,9,4.95,90.8,17,341.19,40.15,432,45.1,FALSE,TRUE
787,0,BODY,THREADS AND LOCKS,9,4.95,90.8,17,72,40.15,162.8,45.1,FALSE,TRUE
787,1,BODY,Memory Model17.4,9,4.95,91.89,16,376.11,40.15,468,45.1,FALSE,TRUE
787,3,BODY,"Although it may seem a little strange to write a default value to a variable before the object containing the variable is allocated, conceptually every object is created at the start of the program with its default initialized values.",9,25.02,313.99,234,100,112.1,413.99,137.12,FALSE,FALSE
788,0,BODY,17.4Memory Model,9,4.95,91.88,16,36,40.15,127.88,45.1,FALSE,TRUE
788,1,BODY,THREADS AND LOCKS,9,4.95,90.8,17,341.19,40.15,432,45.1,FALSE,TRUE
788,2,BODY,"For example, the write of a default value to every field of an object constructed by a thread need not happen before the beginning of that thread, as long as no read ever observes that fact.",9,25.02,324,190,90,74.1,414,99.12,FALSE,FALSE
788,4,BODY,"Therefore, a data race cannot cause incorrect behavior such as returning the wrong length for an array.",9,15.02,324,103,90,487.1,414,502.12,FALSE,FALSE
789,0,BODY,THREADS AND LOCKS,9,4.95,90.8,17,72,40.15,162.8,45.1,FALSE,TRUE
789,1,BODY,Memory Model17.4,9,4.95,91.89,16,376.11,40.15,468,45.1,FALSE,TRUE
789,2,BODY,"This is an extremely strong guarantee for programmers. Programmers do not need to reason about reorderings to determine that their code contains data races. Therefore they do not need to reason about reorderings when determining whether their code is correctly synchronized. Once the determination that the code is correctly synchronized is made, the programmer does not need to worry that reorderings will affect his or her code. A program must be correctly synchronized to avoid the kinds of counterintuitive behaviors that can be observed when code is reordered. The use of correct synchronization does not ensure that the overall behavior of a program is correct. However, its use does allow a programmer to reason about the possible behaviors of a program in a simple way; the behavior of a correctly synchronized program is much less dependent on possible reorderings. Without correct synchronization, very strange, confusing and counterintuitive behaviors are possible.",9,127.02,324,976,90,74.1,414,201.12,FALSE,FALSE
789,4,BODY,Example 17.4.5-1. Happens-before Consistency,9,5.19,180.49,44,90,427.12,270.49,432.31,TRUE,FALSE
789,8,BODY,"Since there is no synchronization, each read can see either the write of the initial value or the write by the other thread. An execution order that displays this behavior is:",9,15.02,323.99,175,90,588.1,413.99,603.12,FALSE,FALSE
790,0,BODY,17.4Memory Model,9,4.95,91.88,16,36,40.15,127.88,45.1,FALSE,TRUE
790,1,BODY,THREADS AND LOCKS,9,4.95,90.8,17,341.19,40.15,432,45.1,FALSE,TRUE
790,3,BODY,Another execution order that is happens-before consistent is:,9,5.02,218.71,61,90,126.1,308.71,131.12,FALSE,FALSE
790,5,BODY,"In this execution, the reads see writes that occur later in the execution order. This may seem counterintuitive, but is allowed by happens-before consistency. Allowing reads to see later writes can sometimes produce unacceptable behaviors.",9,25.02,324,239,90,200.1,414,225.12,FALSE,FALSE
791,0,BODY,THREADS AND LOCKS,9,4.95,90.8,17,72,40.15,162.8,45.1,FALSE,TRUE
791,1,BODY,Memory Model17.4,9,4.95,91.89,16,376.11,40.15,468,45.1,FALSE,TRUE
792,0,BODY,17.4Memory Model,9,4.95,91.88,16,36,40.15,127.88,45.1,FALSE,TRUE
792,1,BODY,THREADS AND LOCKS,9,4.95,90.8,17,341.19,40.15,432,45.1,FALSE,TRUE
793,0,BODY,THREADS AND LOCKS,9,4.95,90.8,17,72,40.15,162.8,45.1,FALSE,TRUE
793,1,BODY,Memory Model17.4,9,4.95,91.89,16,376.11,40.15,468,45.1,FALSE,TRUE
793,4,BODY,Example 17.4.8-1. Happens-before Consistency Is Not Sufficient,9,5.19,245.24,62,90,224.12,335.24,229.31,TRUE,FALSE
793,5,BODY,"Happens-before consistency is a necessary, but not sufficient, set of constraints. Merely enforcing happens-before consistency would allow for unacceptable behaviors - those that violate the requirements we have established for programs. For example, happens-before consistency allows values to appear 'out of thin air'. This can be seen by a detailed examination of the trace in Table 17.4.8-A.",9,45.02,324.01,395,90,247.6,414.01,292.62,FALSE,FALSE
793,8,BODY,"The code shown in Table 17.4.8-A is correctly synchronized. This may seem surprising, since it does not perform any synchronization actions. Remember, however, that a program is correctly synchronized if, when it is executed in a sequentially consistent manner, there are no data races. If this code is executed in a sequentially consistent way, each action will occur in program order, and neither of the writes will occur. Since no writes occur, there can be no data races: the program is correctly synchronized. Since this program is correctly synchronized, the only behaviors we can allow are sequentially consistent behaviors. However, there is an execution of this program that is happens-before consistent, but not sequentially consistent:",9,97.02,324.01,746,90,392.1,414.01,489.12,FALSE,FALSE
793,10,BODY,"This result is happens-before consistent: there is no happens-before relationship that prevents it from occurring. However, it is clearly not acceptable: there is no sequentially consistent execution that would result in this behavior. The fact that we allow a read to see a write that comes later in the execution order can sometimes thus result in unacceptable behaviors.",9,45.02,324,373,90,558.1,414,603.12,FALSE,FALSE
794,0,BODY,17.4Memory Model,9,4.95,91.88,16,36,40.15,127.88,45.1,FALSE,TRUE
794,1,BODY,THREADS AND LOCKS,9,4.95,90.8,17,341.19,40.15,432,45.1,FALSE,TRUE
794,2,BODY,"Although allowing reads to see writes that come later in the execution order is sometimes undesirable, it is also sometimes necessary. As we saw above, the trace in Table 17.4.5- A requires some reads to see writes that occur later in the execution order. Since the reads come first in each thread, the very first action in the execution order must be a read. If that read cannot see a write that occurs later, then it cannot see any value other than the initial value for the variable it reads. This is clearly not reflective of all behaviors. We refer to the issue of when reads can see future writes as causality, because of issues that arise in cases like the one found in Table 17.4.8-A. In that case, the reads cause the writes to occur, and the writes cause the reads to occur. There is no 'first cause' for the actions. Our memory model therefore needs a consistent way of determining which reads can see writes early. Examples such as the one found in Table 17.4.8-A demonstrate that the specification must be careful when stating whether a read can see a write that occurs later in the execution (bearing in mind that if a read sees a write that occurs later in the execution, it represents the fact that the write is actually performed early). The memory model takes as input a given execution, and a program, and determines whether that execution is a legal execution of the program. It does this by gradually building a set of 'committed' actions that reflect which actions were executed by the program. Usually, the next action to be committed will reflect the next action that can be performed by a sequentially consistent execution. However, to reflect reads that need to see later writes, we allow some actions to be committed earlier than other actions that happen-before them. Obviously, some actions may be committed early and some may not. If, for example, one of the writes in Table 17.4.8-A were committed before the read of that variable, the read could see the write, and the 'out-of-thin-air' result could occur. Informally, we allow an action to be committed early if we know that the action can occur without assuming some data race occurs. In Table 17.4.8-A, we cannot perform either write early, because the writes cannot occur unless the reads see the result of a data race.",9,313.02,324.01,2305,90,74.1,414.01,387.12,FALSE,FALSE
795,0,BODY,THREADS AND LOCKS,9,4.95,90.8,17,72,40.15,162.8,45.1,FALSE,TRUE
795,1,BODY,Memory Model17.4,9,4.95,91.89,16,376.11,40.15,468,45.1,FALSE,TRUE
796,1,BODY,THREADS AND LOCKS,9,4.95,90.63,17,341.37,40.15,432,45.1,FALSE,TRUE
797,0,BODY,THREADS AND LOCKS,9,4.95,90.63,17,72,40.15,162.63,45.1,FALSE,TRUE
797,10,BODY,while another thread (thread 2) executes,9,5.02,144.7,40,90,554.1,234.7,559.12,FALSE,FALSE
798,1,BODY,THREADS AND LOCKS,9,4.95,90.63,17,341.37,40.15,432,45.1,FALSE,TRUE
799,0,BODY,THREADS AND LOCKS,9,4.95,90.63,17,72,40.15,162.63,45.1,FALSE,TRUE
800,1,BODY,THREADS AND LOCKS,9,4.95,90.63,17,341.37,40.15,432,45.1,FALSE,TRUE
801,0,BODY,THREADS AND LOCKS,9,4.95,90.83,17,72,40.15,162.83,45.1,FALSE,TRUE
801,1,BODY,Word Tearing17.6,9,4.95,87.42,16,380.58,40.15,468,45.1,FALSE,TRUE
801,4,BODY,Example 17.6-1. Detection of Word Tearing,9,5.19,167.73,41,90,372.62,257.73,377.81,TRUE,FALSE
802,1,BODY,THREADS AND LOCKS,9,4.95,90.15,17,341.85,40.15,432,45.1,FALSE,TRUE
802,3,BODY,This makes the point that bytes must not be overwritten by writes to adjacent bytes.,9,5.02,300.73,84,90,206.1,390.73,211.12,FALSE,FALSE
804,0,BODY,18.1Concepts and Notation,9,4.95,120.24,25,36,40.15,156.24,45.1,FALSE,TRUE
804,1,BODY,TYPE INFERENCE,9,4.95,72.37,14,359.62,40.15,432,45.1,FALSE,TRUE
804,3,BODY,"In comparison to the Java SE 7 Edition of The Java® Language Specification, important changes to inference include: •Adding support for lambda expressions and method references as method invocation arguments. •Generalizing to define inference in terms of poly expressions, which may not have well- defined types until after inference is complete. This has the notable effect of improving inference for nested generic method and diamond constructor invocations. •Describing how inference is used to handle wildcard-parameterized functional interface target types and most specific method analysis. •Clarifying the distinction between invocation applicability testing (which involves only the invocation arguments) and invocation type inference (which incorporates a target type). •Delaying resolution of all inference variables, even those with lower bounds, until invocation type inference, in order to get better results. •Improving inference behavior for interdependent (or self-dependent) variables. •Eliminating bugs and potential sources of confusion. This revision more carefully and precisely handles the distinction between specific conversion contexts and subtyping, and describes reduction by paralleling the corresponding non-inference relations. Where there are intentional departures from the non-inference relations, these are explicitly identified as such. •Laying a foundation for future evolution: enhancements to or new applications of inference will be easier to integrate into the specification.",9,270.82,324.01,1515,90,129.3,414.01,400.12,FALSE,FALSE
805,0,BODY,TYPE INFERENCE,9,4.95,72.38,14,72,40.15,144.38,45.1,FALSE,TRUE
805,1,BODY,Concepts and Notation18.1,9,4.95,120.25,25,347.75,40.15,468,45.1,FALSE,TRUE
806,0,BODY,18.1Concepts and Notation,9,4.95,120.24,25,36,40.15,156.24,45.1,FALSE,TRUE
806,1,BODY,TYPE INFERENCE,9,4.95,72.37,14,359.62,40.15,432,45.1,FALSE,TRUE
807,0,BODY,TYPE INFERENCE,9,4.95,72.53,14,72,40.15,144.53,45.1,FALSE,TRUE
807,1,BODY,Reduction18.2,9,4.95,72.5,13,395.5,40.15,468,45.1,FALSE,TRUE
808,0,BODY,18.2Reduction,9,4.95,72.49,13,36,40.15,108.49,45.1,FALSE,TRUE
808,1,BODY,TYPE INFERENCE,9,4.95,72.53,14,359.47,40.15,432,45.1,FALSE,TRUE
809,0,BODY,TYPE INFERENCE,9,4.95,72.53,14,72,40.15,144.53,45.1,FALSE,TRUE
809,1,BODY,Reduction18.2,9,4.95,72.5,13,395.5,40.15,468,45.1,FALSE,TRUE
810,0,BODY,18.2Reduction,9,4.95,72.49,13,36,40.15,108.49,45.1,FALSE,TRUE
810,1,BODY,TYPE INFERENCE,9,4.95,72.53,14,359.47,40.15,432,45.1,FALSE,TRUE
811,0,BODY,TYPE INFERENCE,9,4.95,72.53,14,72,40.15,144.53,45.1,FALSE,TRUE
811,1,BODY,Reduction18.2,9,4.95,72.5,13,395.5,40.15,468,45.1,FALSE,TRUE
811,3,BODY,"This condition never arises in practice, due to the handling of inexact method references in §18.5.1 and the substitution applied to the target type in §18.5.2.2.",9,15.02,304,162,110,382.1,414,397.12,FALSE,FALSE
812,0,BODY,18.2Reduction,9,4.95,72.49,13,36,40.15,108.49,45.1,FALSE,TRUE
812,1,BODY,TYPE INFERENCE,9,4.95,72.53,14,359.47,40.15,432,45.1,FALSE,TRUE
812,2,BODY,"with an out-of-scope type variable is nonsensical, we prefer to avoid the situation by giving up immediately whenever the possibility arises. This simplification is not completeness-preserving.",9,25.02,284.01,193,130,74.1,414.01,99.12,FALSE,FALSE
812,4,BODY,The strategy used to determine a return type for a generic referenced method follows the pattern used earlier in this section for generic method invocations. This may involve 'lifting' bounds into the outer context and inferring dependencies between the two sets of inference variables.,9,35.02,284,286,130,200.1,414,235.12,FALSE,FALSE
813,0,BODY,TYPE INFERENCE,9,4.95,72.53,14,72,40.15,144.53,45.1,FALSE,TRUE
813,1,BODY,Reduction18.2,9,4.95,72.5,13,395.5,40.15,468,45.1,FALSE,TRUE
814,0,BODY,18.2Reduction,9,4.95,72.49,13,36,40.15,108.49,45.1,FALSE,TRUE
814,1,BODY,TYPE INFERENCE,9,4.95,72.53,14,359.47,40.15,432,45.1,FALSE,TRUE
815,0,BODY,TYPE INFERENCE,9,4.95,72.53,14,72,40.15,144.53,45.1,FALSE,TRUE
815,1,BODY,Reduction18.2,9,4.95,72.5,13,395.5,40.15,468,45.1,FALSE,TRUE
815,4,BODY,"This rule does not accommodate inference variables appearing directly as elements of an intersection type (rather than nested in a parameterized type). Due to the restrictions on type parameter declarations (§4.4), such intersection types do not arise in practice.",9,25.02,314,264,100,530.1,414,555.12,FALSE,FALSE
816,0,BODY,18.2Reduction,9,4.95,72.49,13,36,40.15,108.49,45.1,FALSE,TRUE
816,1,BODY,TYPE INFERENCE,9,4.95,72.53,14,359.47,40.15,432,45.1,FALSE,TRUE
816,4,BODY,"This condition never arises in practice, due to the substitution applied to the target type in §18.5.2.2.",9,15.02,313.99,105,100,472.1,413.99,487.12,FALSE,FALSE
816,6,BODY,"This condition never arises in practice, due to the substitution applied to the target type in §18.5.2.2.",9,15.02,313.99,105,100,536.1,413.99,551.12,FALSE,FALSE
817,0,BODY,TYPE INFERENCE,9,4.95,72.53,14,72,40.15,144.53,45.1,FALSE,TRUE
817,1,BODY,Reduction18.2,9,4.95,72.5,13,395.5,40.15,468,45.1,FALSE,TRUE
818,0,BODY,18.3Incorporation,9,4.95,86.5,17,36,40.15,122.5,45.1,FALSE,TRUE
818,1,BODY,TYPE INFERENCE,9,4.95,72.48,14,359.52,40.15,432,45.1,FALSE,TRUE
819,0,BODY,TYPE INFERENCE,9,4.95,72.48,14,72,40.15,144.48,45.1,FALSE,TRUE
819,1,BODY,Incorporation18.3,9,4.95,86.5,17,381.5,40.15,468,45.1,FALSE,TRUE
820,0,BODY,18.4Resolution,9,4.95,74.5,14,36,40.15,110.5,45.1,FALSE,TRUE
820,1,BODY,TYPE INFERENCE,9,4.95,72.52,14,359.48,40.15,432,45.1,FALSE,TRUE
821,0,BODY,TYPE INFERENCE,9,4.95,72.52,14,72,40.15,144.52,45.1,FALSE,TRUE
821,1,BODY,Resolution18.4,9,4.95,74.5,14,393.5,40.15,468,45.1,FALSE,TRUE
822,0,BODY,18.4Resolution,9,4.95,74.5,14,36,40.15,110.5,45.1,FALSE,TRUE
822,1,BODY,TYPE INFERENCE,9,4.95,72.52,14,359.48,40.15,432,45.1,FALSE,TRUE
823,0,BODY,TYPE INFERENCE,9,4.95,72.44,14,72,40.15,144.44,45.1,FALSE,TRUE
823,1,BODY,Uses of Inference18.5,9,4.95,100.35,21,367.65,40.15,468,45.1,FALSE,TRUE
823,2,BODY,"The first method of instantiating an inference variable derives the instantiation from that variable's bounds. Sometimes, however, complex dependencies mean that the result is not within the variable's bounds. In that case, a different method of instantiation is performed, analogous to capture conversion (§5.1.10): fresh type variables are introduced, with bounds derived from the bounds of the inference variables. Note that the lower bounds of these 'capture' variables are computed using only proper types: this is important in order to avoid attempts to perform typing computations on uninstantiated type variables.",9,65.02,324.01,621,90,74.1,414.01,139.12,FALSE,FALSE
824,0,BODY,18.5Uses of Inference,9,4.95,100.35,21,36,40.15,136.35,45.1,FALSE,TRUE
824,1,BODY,TYPE INFERENCE,9,4.95,72.44,14,359.56,40.15,432,45.1,FALSE,TRUE
824,4,BODY,"Trivially (because of its arity), this method is neither applicable by strict invocation (§15.12.2.2) nor applicable by loose invocation (§15.12.2.3). But since there are no other candidates, in a third phase the method is checked for applicability by variable arity invocation.",9,35.02,324,278,90,440.1,414,475.12,FALSE,FALSE
825,0,BODY,TYPE INFERENCE,9,4.95,72.44,14,72,40.15,144.44,45.1,FALSE,TRUE
825,1,BODY,Uses of Inference18.5,9,4.95,100.35,21,367.65,40.15,468,45.1,FALSE,TRUE
825,5,BODY,"It is important to note that multiple 'rounds' of inference are involved in finding the type of a method invocation. This is necessary, for example, to allow a target type to influence the type of the invocation without allowing it to influence the choice of an applicable method. The first round (§18.5.1) produces a bound set and tests that a resolution exists, but does not commit to that resolution. Subsequent rounds reduce additional constraints until a final resolution step determines the 'real' type of the expression.",9,55.02,324.01,527,90,314.35,414.01,369.37,FALSE,FALSE
826,0,BODY,18.5Uses of Inference,9,4.95,100.35,21,36,40.15,136.35,45.1,FALSE,TRUE
826,1,BODY,TYPE INFERENCE,9,4.95,72.44,14,359.56,40.15,432,45.1,FALSE,TRUE
827,0,BODY,TYPE INFERENCE,9,4.95,72.44,14,72,40.15,144.44,45.1,FALSE,TRUE
827,1,BODY,Uses of Inference18.5,9,4.95,100.35,21,367.65,40.15,468,45.1,FALSE,TRUE
828,0,BODY,18.5Uses of Inference,9,4.95,100.35,21,36,40.15,136.35,45.1,FALSE,TRUE
828,1,BODY,TYPE INFERENCE,9,4.95,72.44,14,359.56,40.15,432,45.1,FALSE,TRUE
829,0,BODY,TYPE INFERENCE,9,4.95,72.44,14,72,40.15,144.44,45.1,FALSE,TRUE
829,1,BODY,Uses of Inference18.5,9,4.95,100.35,21,367.65,40.15,468,45.1,FALSE,TRUE
830,0,BODY,18.5Uses of Inference,9,4.95,100.35,21,36,40.15,136.35,45.1,FALSE,TRUE
830,1,BODY,TYPE INFERENCE,9,4.95,72.44,14,359.56,40.15,432,45.1,FALSE,TRUE
831,0,BODY,TYPE INFERENCE,9,4.95,72.44,14,72,40.15,144.44,45.1,FALSE,TRUE
831,1,BODY,Uses of Inference18.5,9,4.95,100.35,21,367.65,40.15,468,45.1,FALSE,TRUE
832,0,BODY,18.5Uses of Inference,9,4.95,100.35,21,36,40.15,136.35,45.1,FALSE,TRUE
832,1,BODY,TYPE INFERENCE,9,4.95,72.44,14,359.56,40.15,432,45.1,FALSE,TRUE
832,4,BODY,"In order to determine the function type of a wildcard-parameterized functional interface, we have to 'instantiate' the wildcard type arguments with specific types. The 'default' approach is to simply replace the wildcards with their bounds, as described in §9.8, but this",9,25.02,324,271,90,569.1,414,594.12,FALSE,FALSE
833,0,BODY,TYPE INFERENCE,9,4.95,72.44,14,72,40.15,144.44,45.1,FALSE,TRUE
833,1,BODY,Uses of Inference18.5,9,4.95,100.35,21,367.65,40.15,468,45.1,FALSE,TRUE
834,0,BODY,18.5Uses of Inference,9,4.95,100.35,21,36,40.15,136.35,45.1,FALSE,TRUE
834,1,BODY,TYPE INFERENCE,9,4.95,72.44,14,359.56,40.15,432,45.1,FALSE,TRUE
835,0,BODY,TYPE INFERENCE,9,4.95,72.44,14,72,40.15,144.44,45.1,FALSE,TRUE
835,1,BODY,Uses of Inference18.5,9,4.95,100.35,21,367.65,40.15,468,45.1,FALSE,TRUE
835,2,BODY,simplification is not completeness-preserving. (The same comment applies to the treatment of formal parameter types and return types below.),9,15.02,303.99,140,110,74.1,413.99,89.12,FALSE,FALSE
836,0,BODY,18.5Uses of Inference,9,4.95,100.35,21,36,40.15,136.35,45.1,FALSE,TRUE
836,1,BODY,TYPE INFERENCE,9,4.95,72.44,14,359.56,40.15,432,45.1,FALSE,TRUE
837,0,BODY,TYPE INFERENCE,9,4.95,72.44,14,72,40.15,144.44,45.1,FALSE,TRUE
837,1,BODY,Uses of Inference18.5,9,4.95,100.35,21,367.65,40.15,468,45.1,FALSE,TRUE
838,0,BODY,18.5Uses of Inference,9,4.95,100.35,21,36,40.15,136.35,45.1,FALSE,TRUE
838,1,BODY,TYPE INFERENCE,9,4.95,72.44,14,359.56,40.15,432,45.1,FALSE,TRUE
838,6,BODY,The following program infers a parameterization for a record pattern:,9,5.02,249.68,69,90,327.59,339.68,332.61,FALSE,FALSE
839,0,BODY,TYPE INFERENCE,9,4.95,72.44,14,72,40.15,144.44,45.1,FALSE,TRUE
839,1,BODY,Uses of Inference18.5,9,4.95,100.35,21,367.65,40.15,468,45.1,FALSE,TRUE
842,0,BODY,SYNTAX,9,4.95,31.51,6,400.49,40.15,432,45.1,FALSE,TRUE
843,0,BODY,SYNTAX,9,4.95,31.51,6,72,40.15,103.51,45.1,FALSE,TRUE
844,0,BODY,SYNTAX,9,4.95,31.51,6,400.49,40.15,432,45.1,FALSE,TRUE
845,0,BODY,SYNTAX,9,4.95,31.51,6,72,40.15,103.51,45.1,FALSE,TRUE
846,0,BODY,SYNTAX,9,4.95,31.51,6,400.49,40.15,432,45.1,FALSE,TRUE
847,0,BODY,SYNTAX,9,4.95,31.51,6,72,40.15,103.51,45.1,FALSE,TRUE
848,0,BODY,SYNTAX,9,4.95,31.51,6,400.49,40.15,432,45.1,FALSE,TRUE
849,0,BODY,SYNTAX,9,4.95,31.51,6,72,40.15,103.51,45.1,FALSE,TRUE
850,0,BODY,SYNTAX,9,4.95,31.51,6,400.49,40.15,432,45.1,FALSE,TRUE
851,0,BODY,SYNTAX,9,4.95,31.51,6,72,40.15,103.51,45.1,FALSE,TRUE
852,0,BODY,SYNTAX,9,4.95,31.51,6,400.49,40.15,432,45.1,FALSE,TRUE
853,0,BODY,SYNTAX,9,4.95,31.51,6,72,40.15,103.51,45.1,FALSE,TRUE
854,0,BODY,SYNTAX,9,4.95,31.51,6,400.49,40.15,432,45.1,FALSE,TRUE
855,0,BODY,SYNTAX,9,4.95,31.51,6,72,40.15,103.51,45.1,FALSE,TRUE
856,0,BODY,SYNTAX,9,4.95,31.51,6,400.49,40.15,432,45.1,FALSE,TRUE
857,0,BODY,SYNTAX,9,4.95,31.51,6,72,40.15,103.51,45.1,FALSE,TRUE
858,0,BODY,SYNTAX,9,4.95,31.51,6,400.49,40.15,432,45.1,FALSE,TRUE
859,0,BODY,SYNTAX,9,4.95,31.51,6,72,40.15,103.51,45.1,FALSE,TRUE
860,0,BODY,SYNTAX,9,4.95,31.51,6,400.49,40.15,432,45.1,FALSE,TRUE
861,0,BODY,SYNTAX,9,4.95,31.51,6,72,40.15,103.51,45.1,FALSE,TRUE
862,0,BODY,SYNTAX,9,4.95,31.51,6,400.49,40.15,432,45.1,FALSE,TRUE
863,0,BODY,SYNTAX,9,4.95,31.51,6,72,40.15,103.51,45.1,FALSE,TRUE
864,0,BODY,SYNTAX,9,4.95,31.51,6,400.49,40.15,432,45.1,FALSE,TRUE
865,0,BODY,SYNTAX,9,4.95,31.51,6,72,40.15,103.51,45.1,FALSE,TRUE
866,0,BODY,SYNTAX,9,4.95,31.51,6,400.49,40.15,432,45.1,FALSE,TRUE
867,0,BODY,SYNTAX,9,4.95,31.51,6,72,40.15,103.51,45.1,FALSE,TRUE
868,0,BODY,SYNTAX,9,4.95,31.51,6,400.49,40.15,432,45.1,FALSE,TRUE
869,0,BODY,SYNTAX,9,4.95,31.51,6,72,40.15,103.51,45.1,FALSE,TRUE
872,0,BODY,LIMITED LICENSE GRANT,9,4.95,105.57,21,326.43,40.15,432,45.1,FALSE,TRUE
873,0,BODY,LIMITED LICENSE GRANT,9,4.95,105.57,21,72,40.15,177.57,45.1,FALSE,TRUE
874,0,BODY,LIMITED LICENSE GRANT,9,4.95,105.57,21,326.43,40.15,432,45.1,FALSE,TRUE
875,0,BODY,LIMITED LICENSE GRANT,9,4.95,105.57,21,72,40.15,177.57,45.1,FALSE,TRUE
30,8,BODY,"states that the nonterminal IfThenStatement represents the token if, followed by a left parenthesis token, followed by an Expression, followed by a right parenthesis token, followed by a Statement.",8.99,25.02,324,197,90,467.1,414,492.12,FALSE,FALSE
42,6,BODY,"we say that the } token is to the right of the { token, even though it appears, in this two- dimensional representation, downward and to the left of the { token. This convention about the use of the words left and right allows us to speak, for example, of the right-hand operand of a binary operator or of the left-hand side of an assignment.",8.99,35.02,324.01,342,90,280.1,414.01,315.12,FALSE,FALSE
66,6,BODY,"If the program is modified to place the closing delimiter on the last line of the content, then an error occurs because the first three consecutive double quote characters on the last line are translated (§3.2) into the closing delimiter ''' and thus a stray double quote character remains:",8.99,35.02,324.01,290,90,312.1,414.01,347.12,FALSE,FALSE
68,2,BODY,"white space. For example, consider this text block that mentions the escape sequence \r (CR):",8.99,15.02,324,93,90,74.1,414,89.12,FALSE,FALSE
91,2,BODY,"2002). This work itself builds upon earlier work by Kresten Thorup and Mads Torgersen (Unifying Genericity, ECOOP 99), as well as a long tradition of work on declaration based variance that goes back to Pierre America's work on POOL (OOPSLA 89). Wildcards differ in certain details from the constructs described in the aforementioned paper, in particular in the use of capture conversion (§5.1.10) rather than the close operation described by Igarashi and Viroli. For a formal account of wildcards, see Wild FJ by Mads Torgersen, Erik Ernst and Christian Plesner Hansen, in the 12th workshop on Foundations of Object Oriented Programming (FOOL 2005).",8.99,87.02,324.01,650,90,74.1,414.01,161.12,FALSE,FALSE
94,5,BODY,"The decision not to make all generic types reifiable is one of the most crucial, and controversial design decisions involving the type system of the Java programming language. Ultimately, the most important motivation for this decision is compatibility with existing code. In a naive sense, the addition of new constructs such as generics has no implications for pre-existing code. The Java programming language, per se, is compatible with earlier versions as long as every program written in the previous versions retains its meaning in the new version. However, this notion, which may be termed language compatibility, is of purely theoretical interest. Real programs (even trivial ones, such as 'Hello World') are composed of several compilation units, some of which are provided by the Java SE Platform (such as elements of java.lang or java.util). In practice, then, the minimum requirement is platform compatibility - that any program written for the prior version of the Java SE Platform continues to function unchanged in the new version. One way to provide platform compatibility is to leave existing platform functionality unchanged, only adding new functionality. For example, rather than modify the existing Collections hierarchy in java.util, one might introduce a new library utilizing generics. The disadvantages of such a scheme is that it is extremely difficult for pre-existing clients of the Collection library to migrate to the new library. Collections are used to exchange data between independently developed modules; if a vendor decides to switch to the new, generic, library, that vendor must also distribute two versions of their code, to be compatible with their clients. Libraries that are dependent on other vendors code cannot be modified to use generics until the supplier's library is updated. If two modules are mutually dependent, the changes must be made simultaneously. Clearly, platform compatibility, as outlined above, does not provide a realistic path for adoption of a pervasive new feature such as generics. Therefore, the design of the generic type system seeks to support migration compatibility. Migration compatibility allows the evolution of existing code to take advantage of generics without imposing dependencies between independently developed software modules.",8.99,323.02,324.01,2311,90,249.1,414.01,572.12,FALSE,FALSE
99,2,BODY,"This example reveals that certain members of a raw type are not erased, namely static members whose types are parameterized, and members inherited from a non-generic supertype. Raw types are closely related to wildcards. Both are based on existential types. Raw types can be thought of as wildcards whose type rules are deliberately unsound, to accommodate interaction with legacy code. Historically, raw types preceded wildcards; they were first introduced in GJ, and described in the paper Making the future safe for the past: Adding Genericity to the Java Programming Language by Gilad Bracha, Martin Odersky, David Stoutamire, and Philip Wadler, in Proceedings of the ACM Conference on Object-Oriented Programming, Systems, Languages and Applications (OOPSLA 98), October 1998.",8.99,107.02,324.01,781,90,74.1,414.01,181.12,FALSE,FALSE
139,3,BODY,"Note that R cannot be an interface when these rules are first applied for any given conversion, but R may be an interface if the rules are applied recursively because the run-time reference value may refer to an array whose element type is an interface type.",8.99,25.02,304,258,110,233.1,414,258.12,FALSE,FALSE
163,5,BODY,"The example converts the ASCII character G to the ASCII control-G (BEL), by masking off all but the low 5 bits of the character. The 7 is the numeric value of this control character.",8.99,15.02,324,182,90,250.1,414,265.12,FALSE,FALSE
170,5,BODY,"The first component of a unique package name is always written in all-lowercase ASCII letters and should be one of the top level domain names, such as com, edu, gov, mil, net, or org, or one of the English two-letter codes identifying countries as specified in ISO Standard 3166. In some cases, the Internet domain name may not be a valid package name. Here are some suggested conventions for dealing with these situations: •If the domain name contains a hyphen, or any other special character not allowed in an identifier (§3.8), convert it into an underscore. •If any of the resulting package name components are keywords (§3.9), append an underscore to them. •If any of the resulting package name components start with a digit, or any other character that is not allowed as an initial character of an identifier, have an underscore prefixed to the component. The name of a module should correspond to the name of its principal exported package. If a module does not have such a package, or if for legacy reasons it must have a name that",8.99,193.02,324.01,1039,90,405.1,414.01,598.12,FALSE,FALSE
172,2,BODY,"If there are multiple type parameters that denote arbitrary types, one should use letters that neighbor T in the alphabet, such as S. Alternately, it is acceptable to use numeric subscripts (e.g., T1, T2) to distinguish among the different type variables. In such cases, all the variables with the same prefix should be subscripted. If a generic method appears inside a generic class, it is a good idea to avoid using the same names for the type parameters of the method and class, to avoid confusion. The same applies to nested generic classes.",8.99,77.02,324.01,545,90,74.1,414.01,151.12,FALSE,FALSE
179,7,BODY,because the local variable x is definitely assigned (§16 (Definite Assignment)) before it is used. It prints:,8.99,15.02,323.99,109,90,337.1,413.99,352.12,FALSE,FALSE
185,3,BODY,"The rule about an if-then statement introducing a pattern variable relies on the notion of 'cannot complete normally' (§14.22), which in turn relies on the concept of a constant expression (§15.29). This means that calculating the scope of a pattern variable may require determining whether a simple name, or a qualified name of the form TypeName . Identifier, refers to a constant variable. As pattern variables can never refer to a constant variable, there is no circularity.",8.99,55.02,324.01,477,90,112.1,414.01,167.12,FALSE,FALSE
185,6,BODY,"The code can even be rewritten as follows, though double use of the ! operator is not necessarily recommended:",8.99,15.02,324,110,90,570.1,414,585.12,FALSE,FALSE
188,5,BODY,"These rules allow redeclaration of a variable, local class, or local interface in nested class or interface declarations that occur in the scope of the variable, local class, or local interface; such nested class or interface declarations may be local class or interface declarations (§14.3) or anonymous class declarations (§15.9.5). Thus, the declaration of a formal parameter, local variable, local class, or local interface may be shadowed in a class or interface declaration nested within a method, constructor, or lambda expression; and the declaration of an exception parameter may be shadowed in a class or interface declaration nested within the Block of the catch clause. There are two design alternatives for handling name clashes created by lambda parameters and other variables declared in lambda expressions. One is to mimic class declarations: like local classes, lambda expressions introduce a new 'level' for names, and all variable names outside the expression can be redeclared. Another is a 'local' strategy: like catch clauses, for loops, and blocks, lambda expressions operate at the same 'level' as the enclosing context, and local variables outside the expression cannot be shadowed. The above rules use the local strategy; there is no special dispensation that allows a variable declared in a lambda expression to shadow a variable declared in an enclosing method.",8.99,167.02,324.01,1389,90,389.1,414.01,556.12,FALSE,FALSE
194,5,BODY,"The naming conventions of §6.1 help reduce obscuring, but if it does occur, here are some notes about what you can do to avoid it. When package names occur in expressions: •If a package name is obscured by a field declaration, then import declarations (§7.5) can usually be used to make available the type names declared in that package. •If a package name is obscured by a declaration of a parameter or local variable, then the name of the parameter or local variable can be changed without affecting other code. The first component of a package name is normally not easily mistaken for a type name, as a type name normally begins with a single uppercase letter. (The Java programming language does not actually rely on case distinctions to determine whether a name is a package name or a type name.) Obscuring involving class and interface type names is rare. Names of fields, parameters, and local variables normally do not obscure type names because they conventionally begin with a lowercase letter whereas type names conventionally begin with an uppercase letter. Method names cannot obscure or be obscured by other names (§6.5.7). Obscuring involving field names is rare; however: •If a field name obscures a package name, then an import declaration (§7.5) can usually be used to make available the type names declared in that package.",8.99,265.02,324.01,1342,90,336.1,414.01,601.12,FALSE,FALSE
200,2,BODY,"The effect of syntactic classification is to restrict certain kinds of entities to certain parts of expressions: •The name of a field, parameter, or local variable may be used as an expression (§15.14.1). •The name of a method may appear in an expression only as part of a method invocation expression (§15.12). •The name of a class or interface may appear in an expression only as part of a class literal (§15.8.2), a qualified this expression (§15.8.4), a class instance creation expression (§15.9), an array creation expression (§15.10.1), a cast expression (§15.16), an instanceof expression (§15.20.2), an enum constant (§8.9), or as part of a qualified name for a field or method. •The name of a package may appear in an expression only as part of a qualified name for a class or interface.",8.99,145.02,324,796,90,74.1,414,219.12,FALSE,FALSE
201,10,BODY,is initially classified as an AmbiguousName. These are then reclassified: •The simple name org is reclassified as a PackageName (since there is no variable or type named org in scope).,8.99,37.02,324,184,90,559.1,414,596.12,FALSE,FALSE
211,13,BODY,"This does not restrict the Java programming language in any meaningful way. Type parameters may not be used in the types of static variables, and so the type arguments of a parameterized type can never influence the type of a static variable. Therefore, no expressive power is lost. The type name Foo appears to be a raw type, but it is not; rather, it is the name of the non-generic type Foo whose static member is to be accessed (§6.1). Since there is no use of a raw type, there are no unchecked warnings.",8.99,55.02,324,508,90,546.1,414,601.12,FALSE,FALSE
213,4,BODY,"For example, a single-type-import declaration uses a qualified type name (§7.5.1), so the named class or interface must be accessible from the compilation unit containing the import declaration. As another example, a class declaration may use a qualified type name for a superclass type (§8.1.5), so again the named class must be accessible. Some obvious expressions are 'missing' from context classification in §6.5.1: field access on a Primary (§15.11.1), method invocation on a Primary (§15.12), method reference via a Primary (§15.13), and the instantiated class in a qualified class instance creation (§15.9). Each of these expressions uses identifiers, rather than names, for the reason given in §6.2. Consequently, access control to members (whether fields, methods, classes, or interfaces) is applied explicitly by field access expressions, method invocation expressions, method reference expressions, and qualified class instance creation expressions. (Note that access to a field may also be denoted by a qualified name occuring as a postfix expression.)",8.99,127.02,324.01,1064,90,475.1,414.01,602.12,FALSE,FALSE
229,8,BODY,"If the @ character is not a valid character in a file name for some given host file system, then some other character that is not valid in an identifier could be used instead.",8.99,15.02,323.99,175,90,554.1,413.99,569.12,FALSE,FALSE
231,4,BODY,"The readability relation is reflexive, so M reads itself, and thus all of the modular and ordinary compilation units associated with M are visible to M. The modules read by M drive the packages that are uniquely visible to M (§7.4.3), which in turn drives both the top level packages in scope and the meaning of package names for code in the modular and ordinary compilation units associated with M (§6.3, §6.5.3, §6.5.5). The rules above ensure that package and type names used in annotations in a modular compilation unit (in particular, annotations applied to the module declaration) are interpreted as if they appeared in an ordinary compilation unit associated with the module.",8.99,99.02,324.01,682,90,412.1,414.01,511.12,FALSE,FALSE
240,5,BODY,Extra ';' tokens appearing at the level of class and interface declarations in a compilation unit have no effect on the meaning of the compilation unit. Stray semicolons are permitted,8.99,15.02,324.01,183,90,581.1,414.01,596.12,FALSE,FALSE
241,1,BODY,in the Java programming language solely as a concession to C++ programmers who are used to placing ';' after a class declaration. They should not be used in new Java code.,8.99,15.02,324,171,90,74.1,414,89.12,FALSE,FALSE
251,3,BODY,"By virtue of the fact that an ordinary compilation unit associated with an unnamed module is observable, the associated unnamed module is observable. Thus, if the implementation of the Java SE Platform supports more than one unnamed module, every unnamed module is observable; and each unnamed module reads every unnamed module including itself. However, it is important to realize that the ordinary compilation units of an unnamed module are never visible to a named module (§7.3) because no requires directive can arrange for a named module to read an unnamed module. The Core Reflection API of the Java SE Platform may be used to arrange for a named module to read an unnamed module at run time.",8.99,107.02,314,698,100,332.1,414,439.12,FALSE,FALSE
264,2,BODY,"The purpose of a static context is to demarcate code that must not refer explicitly or implicitly to the current instance of the class whose declaration lexically encloses the static context. Consequently, code that occurs in a static context is restricted in the following ways: •this expressions (both unqualified and qualified) are disallowed (§15.8.3, §15.8.4). •Field accesses, method invocations, and method references may not be qualified by super (§15.11.2, §15.12.3, §15.13.1). •Unqualified references to instance variables of any lexically enclosing class or interface declaration are disallowed (§6.5.6.1). •Unqualified invocations of instance methods of any lexically enclosing class or interface declaration are disallowed (§15.12.3). •References to type parameters of any lexically enclosing class or interface declarations are disallowed (§6.5.5.1). •References to type parameters, local variables, formal parameters, and exception parameters declared by methods or constructors of any lexically enclosing class or interface declaration that is outside the immediately enclosing class or interface declaration are disallowed (§6.5.5.1, §6.5.6.1). •Declarations of local normal classes (as opposed to local enum classes) and declarations of anonymous classes both specify classes that are inner, yet when instantiated have no immediately enclosing instances (§15.9.2). •Class instance creation expressions that instantiate inner member classes must be qualified (§15.9).",8.99,269.02,324.01,1484,90,74.1,414.01,343.12,FALSE,FALSE
274,8,BODY,"If C is a nested class, there may be definitions of the same kind (variable, method, or type) and name as m in enclosing scopes. (The scopes may be blocks, classes, or packages.) In",8.99,15.02,324.01,181,90,574.1,414.01,589.12,FALSE,FALSE
275,2,BODY,"all such cases, the member m declared in or inherited by C shadows the other definitions of the same kind and name.",8.99,15.02,324,115,90,74.1,414,89.12,FALSE,FALSE
282,4,BODY,"A class may inherit two or more fields with the same name, either from its superclass and a superinterface or from two superinterfaces. A compile-time error occurs on any attempt to refer to any ambiguously inherited field by its simple name. A qualified name or a field access expression that contains the keyword super (§15.11.2) may be used to access such fields unambiguously. In the program:",8.99,45.02,324.02,396,90,340.1,414.02,385.12,FALSE,FALSE
297,3,BODY,"In the grammar for VariableArityParameter, note that the ellipsis (...) is a token unto itself (§3.11). It is possible to put whitespace between it and the type, but this is discouraged as a matter of style.",8.99,25.02,324,207,90,151.1,414,176.12,FALSE,FALSE
308,3,BODY,"Essentially, for each checked exception that can result from execution of the body of a method or constructor, a compile-time error occurs unless its exception type or a supertype of its exception type is mentioned in a throws clause in the declaration of the method or constructor. The requirement to declare checked exceptions allows a Java compiler to ensure that code for handling such error conditions has been included. Methods or constructors that fail to handle exceptional conditions thrown as checked exceptions in their bodies will normally cause compile-time errors if they lack proper exception types in their throws clauses. The Java programming language thus encourages a programming style where rare and otherwise truly exceptional conditions are documented in this way.",8.99,107.02,324.01,786,90,144.1,414.01,251.12,FALSE,FALSE
396,2,BODY,"exported or opened by the module declaration. In contrast, a module declaration that exports or opens a package to a friend module is usually not controlled by the same programmer or team that controls the friend module. Simply exporting or opening the package does not make the module declaration rely on the friend module, so there is little value in warning if the friend module is deprecated; the programmer of the module declaration would almost always wish to suppress such a warning. The only implicit declaration that can cause a deprecation warning or removal warning is a container annotation (§9.7.5). Namely, if T is a repeatable annotation interface and TC is its containing annotation interface, and TC is deprecated, then repeating the @T annotation will cause a warning. The warning is due to the implicit @TC container annotation. It is strongly discouraged to deprecate a containing annotation interface without deprecating the corresponding repeatable annotation interface.",8.99,127.02,324.01,992,90,74.1,414.01,201.12,FALSE,FALSE
400,6,BODY,"For example, it is legal to annotate the declaration of an annotation interface S with a meta- annotation of interface T, and to annotate T's own declaration with a meta-annotation of interface S. The predefined annotation interfaces (§9.6.4) contain several such circularities.",8.99,25.02,324,278,90,334.1,414,359.12,FALSE,FALSE
433,3,BODY,"Error classes are exempted because they can occur at many points in the program and recovery from them is difficult or impossible. A program declaring such exceptions would be cluttered, pointlessly. Sophisticated programs may yet wish to catch and attempt to recover from some of these conditions. Run-time exception classes are exempted because, in the judgment of the designers of the Java programming language, having to declare such exceptions would not aid significantly in establishing the correctness of programs. Many of the operations and constructs of the Java programming language can result in exceptions at run time. The information available to a Java compiler, and the level of analysis a compiler performs, are usually not sufficient to establish that such run-time exceptions cannot occur, even though this may be obvious to the programmer. Requiring such exception classes to be declared would simply be an irritation to programmers. For example, certain code might implement a circular data structure that, by construction, can never involve null references; the programmer can then be certain that a NullPointerException cannot occur, but it would be difficult for a Java compiler to prove it. The theorem-proving technology that is needed to establish such global properties of data structures is beyond the scope of this specification.",8.99,189.02,324.01,1358,90,254.1,414.01,443.12,FALSE,FALSE
436,3,BODY,"Note that no compile-time error is due if an instance variable initializer or instance initializer of an anonymous class (§15.9.5) can throw an exception class. In a named class, it is the responsibility of the programmer to propagate information about which exception classes can be thrown by initializers, by declaring a suitable throws clause on any explicit constructor declaration. This relationship between the checked exception classes thrown by a class's initializers and the checked exception classes declared by a class's constructors is assured for an anonymous class declaration, because no explicit constructor declarations are possible and a Java compiler always generates a constructor with a suitable throws clause for the anonymous class declaration based on the checked exception classes that its initializers can throw.",8.99,95.02,324.01,838,90,294.1,414.01,389.12,FALSE,FALSE
480,6,BODY,"Broadly speaking, there are various situations where a class transformation that is binary compatible for a client might not be source compatible for that client. For example, the requirement that alternatives in a multi-catch clause (§14.20) are not subclasses or superclasses of each other is only a source restriction. The following code:",8.99,47.02,324,341,90,279.1,414,326.12,FALSE,FALSE
480,8,BODY,"is legal provided that A and B do not have a subclass/superclass relationship when the code is compiled. Thereafter, it is binary compatible with respect to this client for A and B to be changed to have such a relationship. The previously compiled code will continue to execute, but since the change is not source compatible with respect to this client, the code cannot be recompiled.",8.99,45.02,324.01,384,90,405.1,414.01,450.12,FALSE,FALSE
506,7,BODY,"Note that some variables declared with var cannot be declared with an explicit type, because the type of the variable is not denotable. Upward projection is applied to the type of the initializer when determining the type of the variable. If the type of the initializer contains capture variables, this projection maps the type of the initializer to a supertype that does not contain capture variables.",8.99,57.02,324,402,90,546.1,414,603.12,FALSE,FALSE
512,2,BODY,"does not work. On the other hand, the Java programming language allows all the most useful kinds of expressions in expression statements, and it does not require a method invocation used as an expression statement to invoke a void method, so such a trick is almost never needed. If a trick is needed, either an assignment statement (§15.26) or a local variable declaration statement (§14.4) can be used instead.",8.99,45.02,324.01,411,90,74.1,414.01,119.12,FALSE,FALSE
538,9,BODY,"Because at least one digit must be generated, the do statement is an appropriate control structure.",8.99,15.02,324,99,90,463.1,414,478.12,FALSE,FALSE
569,5,BODY,even though the value of n is known at compile time and in principle it can be known at compile time that the assignment to k can never be executed.,8.99,15.02,323.99,148,90,348.1,413.99,363.12,FALSE,FALSE
594,10,BODY,"In the following program, the two assignment statements both fetch and remember the value of the left-hand operand, which is 9, before the right-hand operand of the addition operator is evaluated, at which point the variable is set to 3.",8.99,25.02,324,237,90,358.1,414,383.12,FALSE,FALSE
638,7,BODY,"The most specific method is chosen at compile time; its descriptor determines what method is actually executed at run time. If a new method is added to a class, then source code that was compiled with the old definition of the class might not use the new method, even if a recompilation would cause this method to be chosen. So, for example, consider two compilation units, one for class Point:",8.99,57.02,324.01,394,90,376.1,414.01,433.12,FALSE,FALSE
647,2,BODY,"complex in order to allow capture variables to occur in formal parameter types: first, each formal parameter type of T must be a subtype of the corresponding formal parameter type of the capture of S; second, after mapping the wildcards to their bounds (§9.9), the formal parameter types of the resulting function types are the same.",8.99,35.02,314,333,100,74.1,414,109.12,FALSE,FALSE
657,3,BODY,"The preceding paragraph is crafted to handle the interaction of parameterized types and array types that occurs in a Java Virtual Machine with erased generics. Namely, if the element type T of the variable array parameter is non-reifiable, e.g. List<String>, then special care must be taken with the array creation expression (§15.10) because the created array's element type must be reifiable. By erasing the array type of the final expression in the argument list, we are guaranteed to obtain a reifiable element type. Then, since the array creation expression appears in an invocation context (§5.3), an unchecked conversion is possible from the array type with reifiable element type to an array type with non- reifiable element type, specifically that of the variable arity parameter. A Java compiler is required to give a compile-time unchecked warning at this conversion. Oracle's reference implementation of a Java compiler identifies this unchecked warning as a more informative unchecked generic array creation.",8.99,115.02,324.01,1021,90,112.1,414.01,227.12,FALSE,FALSE
748,3,BODY,A Java compiler recognizes that k is definitely assigned before its access (as an argument of a method invocation) in the code:,8.99,15.02,324,127,90,190.1,414,205.12,FALSE,FALSE
749,6,BODY,"even though the value of n is known at compile time, and in principle it can be known at compile time that the assignment to k will always be executed (more properly, evaluated). A Java compiler must operate according to the rules laid out in this section. The rules recognize only constant expressions; in this example, the expression n > 2 is not a constant expression as defined in §15.29. As another example, a Java compiler will accept the code:",8.99,67.02,324,450,90,307.1,414,374.12,FALSE,FALSE
759,4,BODY,"This case applies to literals, names, this (both qualified and unqualified), unqualified class instance creation expressions with no arguments, array creation expressions with initializers that contain no expressions, superclass field access expressions, unqualified and type-qualified method invocation expressions with no arguments, superclass method invocation expressions with no arguments, and superclass and type-qualified method reference expressions.",8.99,55.02,314,458,100,268.1,414,323.12,FALSE,FALSE
759,7,BODY,No rule allows V to be definitely unassigned before a lambda body. This is by design: a variable that was definitely unassigned before the lambda body may end up being,8.99,15.02,313.99,167,100,580.1,413.99,595.12,FALSE,FALSE
761,3,BODY,"Note that there are no rules that would allow us to conclude that V is definitely unassigned before the block that is the body of any constructor, method, instance initializer, or static initializer declared in C. We can informally conclude that V is not definitely unassigned before the block that is the body of any constructor, method, instance initializer, or static initializer declared in C, but there is no need for such a rule to be stated explicitly.",8.99,45.02,314.01,459,100,215.1,414.01,260.12,FALSE,FALSE
762,2,BODY,"So, we can conclude that if the conditions are met by a program that causes no compile time error, then any assignments to V in B will not actually take place at run time.",8.99,15.02,324,171,90,74.1,414,89.12,FALSE,FALSE
772,5,BODY,"Note that there are no rules that would allow us to conclude that V is definitely unassigned before an instance variable initializer. We can informally conclude that V is not definitely unassigned before any instance variable initializer of C, but there is no need for such a rule to be stated explicitly.",8.99,35.02,314,305,100,328.1,414,363.12,FALSE,FALSE
782,5,BODY,"To some programmers, this behavior may seem 'broken'. However, it should be noted that this code is improperly synchronized: •there is a write in one thread, •a read of the same variable by another thread, •and the write and read are not ordered by synchronization. This situation is an example of a data race (§17.4.5). When code contains a data race, counterintuitive results are often possible. Several mechanisms can produce the reordering in Table 17.4-B. A Just-In-Time compiler in a Java Virtual Machine implementation may rearrange code, or the processor. In addition, the memory hierarchy of the architecture on which a Java Virtual Machine implementation is run may make it appear as if code is being reordered. In this chapter, we shall refer to anything that can reorder code as a compiler. Another example of surprising results can be seen in Table 17.4-C. Initially, p == q and p.x == 0. This program is also incorrectly synchronized; it writes to shared memory without enforcing any ordering between those writes.",8.99,205.02,324.01,1028,90,263.6,414.01,468.62,FALSE,FALSE
811,5,BODY,"In this case, a constraint in terms of R might lead an inference variable to be bound by an out-of-scope type variable. Since instantiating an inference variable",8.99,15.02,284.01,161,130,581.1,414.01,596.12,FALSE,FALSE
818,2,BODY,"while exceptions only influence the invocation type after overload resolution is complete (§18.5.2). This could be simplified by including exception compatibility in the definition of lambda expression compatibility (§15.27.3), but this would lead to possibly surprising cases in which exceptions that can be thrown by an explicitly typed lambda body change overload resolution. The exceptions thrown by a lambda body cannot be determined until (i) the parameter types of the lambda are known, and (ii) the target type of result expressions in the body is known. (The second requirement is to account for generic method invocations in which, for example, the same type parameter appears in the return type and the throws clause.) Hence, we require both of these, as derived from the target type T, to be proper types. One consequence is that lambda expressions returned from other lambda expressions cannot generate constraints from their thrown exceptions. These constraints can only be generated from top-level lambda expressions. Note that the handling of the case in which more than one inference variable appears in a function type's throws clause is not completeness-preserving. Either variable may, on its own, satisfy the constraint that each checked exception be declared, but we cannot be sure which one is intended. So, for predictability, we constrain them both.",8.99,201.02,324.01,1374,90,74.1,414.01,275.12,FALSE,FALSE
824,5,BODY,"The initial bound set, B, is a trivial upper bound for a single inference variable, α:",8.99,5.86,293.93,86,90,495.04,383.93,500.9,FALSE,FALSE
48,3,BODY,"character that matches JavaLetterOrDigit. In general, accidentally omitting white space in source code will cause a sequence of input characters to be tokenized as an identifier, due to the 'longest possible translation' rule (§3.2). For example, the sequence of twelve input characters p u b l i c s t a t i c is always tokenized as the identifier publicstatic, rather than as the reserved keywords public and static. If two tokens are intended, they must be separated by white space or a comment. The rule above works in tandem with the 'longest possible translation' rule to produce an intuitive result in contexts where contextual keywords may appear. For example, the sequence of eleven input characters v a r f i l e n a m e is usually tokenized as the identifier varfilename, but in a local variable declaration, the first three input characters are tentatively recognized as the contextual keyword var by the first condition of the rule above. However, it would be confusing to overlook the lack of white space in the sequence by recognizing the next eight input characters as the identifier filename. (This would mean that the sequence undergoes different tokenization in different contexts: an identifier in most contexts, but a contextual keyword and an identifier in local variable declarations.) Accordingly, the second condition prevents recognition of the contextual keyword var on the grounds that the immediately following input character f is a JavaLetterOrDigit. The sequence v a r f i l e n a m e is therefore tokenized as the identifier varfilename in a local variable declaration. As another example of the careful recognition of contextual keywords, consider the sequence of 15 input characters n o n - s e a l e d c l a s s. This sequence is usually translated to three tokens - the identifier non, the operator -, and the identifier sealedclass - but in a normal class declaration, where the first condition holds, the first ten input characters are tentatively recognized as the contextual keyword non-sealed. To avoid translating the sequence to two keyword tokens (non-sealed and class) rather than three non-keyword tokens, and to avoid rewarding the programmer for omitting white space before class, the second condition prevents recognition of the contextual keyword. The sequence n o n - s e a l e d c l a s s is therefore tokenized as three tokens in a class declaration. In the rule above, the first condition depends on details of the syntactic grammar, but a compiler for the Java programming language can implement the rule without fully parsing the input program. For example, a heuristic could be used to track the contextual state of the tokenizer, as long as the heuristic guarantees that valid uses of contextual keywords are tokenized as keywords, and valid uses of identifiers are tokenized as identifiers. Alternatively, a compiler could always tokenize a contextual keyword as an identifier, leaving it to a later phase to recognize special uses of these identifiers.",8.98,414.06,324.01,3013,90,89.06,414.01,503.12,FALSE,FALSE
72,3,BODY,"In practice, the programmer can ignore the null type and just pretend that null is merely a special literal that can be of any reference type.",8.98,15.02,324,142,90,195.1,414,210.12,FALSE,FALSE
92,4,BODY,"Here, the referent can be inserted into any queue whose element type is a supertype of the type T of the referent; T is the lower bound for the wildcard.",8.98,15.02,324,153,90,158.1,414,173.12,FALSE,FALSE
114,5,BODY,"The value of ls in the example above is always an instance of a class that provides a representation of a List. Assignment from an expression of a raw type to a variable of a parameterized type should only be used when combining legacy code which does not make use of parameterized types with more modern code that does. If no operation that requires a compile-time unchecked warning to be issued takes place, and no unsafe aliasing occurs of array variables with non-reifiable element types, then heap pollution cannot occur. Note that this does not imply that heap pollution only occurs",8.98,99.02,324.01,588,90,504.1,414.01,603.12,FALSE,FALSE
141,5,BODY,"Ideally, boxing a primitive value would always yield an identical reference. In practice, this may not be feasible using existing implementation techniques. The rule above is a pragmatic compromise, requiring that certain common values always be boxed into indistinguishable objects. The implementation may cache these, lazily or eagerly. For other values, the rule disallows any assumptions about the identity of the boxed values on the programmer's part. This allows (but does not require) sharing of some or all of these references. This ensures that in most common cases, the behavior will be the desired one, without imposing an undue performance penalty, especially on small devices. Less memory-limited implementations might, for example, cache all char and short values, as well as int and long values in the range of -32K to +32K.",8.98,107.02,324.01,839,90,349.1,414.01,456.12,FALSE,FALSE
145,4,BODY,"This is undesirable, as it exposes implementation information to the caller. Worse, the designer of an API might reason that the signature using a wildcard is what the callers of the API require, and only later realize that a type safe implementation was precluded. The call from reverse() to rev() is in fact harmless, but it cannot be justified on the basis of a general subtyping relation between List<?> and List<T>. The call is harmless, because the incoming argument is doubtless a list of some type (albeit an unknown one). If we can capture this unknown type in a type variable X, we can infer T to be X. That is the essence of capture conversion. The specification of course must cope with complications, like non-trivial (and possibly recursively defined) upper or lower bounds, the presence of multiple arguments etc. Mathematically sophisticated readers will want to relate capture conversion to established type theory. Readers unfamiliar with type theory can skip this discussion - or else study a suitable text, such as Types and Programming Languages by Benjamin Pierce, and then revisit this section. Here then is a brief summary of the relationship of capture conversion to established type theoretical notions. Wildcard types are a restricted form of existential types. Capture conversion corresponds loosely to an opening of a value of existential type. A capture conversion of an expression e can be thought of as an open of e in a scope that comprises the top level expression that encloses e. The classical open operation on existentials requires that the captured type variable must not escape the opened expression. The open that corresponds to capture conversion is always on a scope sufficiently large that the captured type variable can never be visible outside that scope. The advantage of this scheme is that there is no need for a close operation, as defined in the paper On Variance-Based Subtyping for Parametric Types by Atsushi Igarashi and Mirko Viroli, in the proceedings of the 16th European Conference on Object Oriented Programming (ECOOP 2002). For a formal account of wildcards, see Wild FJ by Mads Torgersen, Erik Ernst and Christian Plesner Hansen, in the 12th workshop on Foundations of Object Oriented Programming (FOOL 2005).",8.98,323.02,324.01,2272,90,222.1,414.01,545.12,FALSE,FALSE
152,3,BODY,"causes a compile-time error because the integer literals 12 and 2 have type int, so neither method m matches under the rules of overload resolution. A language that included implicit narrowing of integer constant expressions would need additional rules to resolve cases like this example.",8.98,35.02,324.01,288,90,568.1,414.01,603.12,FALSE,FALSE
189,7,BODY,"On the other hand, local variables with the same name may be declared in two separate blocks or for statements, neither of which contains the other:",8.98,15.02,324,148,90,449.1,414,464.12,FALSE,FALSE
216,5,BODY,"A public class member or constructor is accessible throughout the package where it is declared and from any other package, provided the package in which it is declared is observable (§7.4.3). For example, in the compilation unit:",8.98,25.02,324,229,90,305.1,414,330.12,FALSE,FALSE
219,3,BODY,"A subclass S is regarded as being responsible for the implementation of objects of class C. Depending on C's accessibility, S may be declared in the same package as C, or in different package of the same module as C, or in a package of a different module entirely.",8.98,25.02,324,264,90,206.23,414,231.25,FALSE,FALSE
227,7,BODY,"The host system is free to determine that a compilation unit which contains a module declaration is not, in fact, observable, and thus is not associated with the module declared therein. This enables a compiler to choose which directory on a modulesourcepath is 'really' the embodiment of a given module. However, if the host system determines that a compilation unit which contains a module declaration is observable, then §7.4.3 mandates that the compilation unit must be associated with the module declared therein, and not with any other module. The host system is free to determine that a compilation unit which contains a class or interface declaration is (first) observable and (second) associated with an unnamed module or an automatic module - despite no declaration of an unnamed or automatic module existing in any compilation unit, observable or otherwise.",8.98,117.02,324.01,868,90,461.1,414.01,578.12,FALSE,FALSE
241,5,BODY,"Here, the first compile-time error is caused by the duplicate declaration of the name Point as both a class and an interface in the same package. A second compile-time error is the attempt to declare the name Vector both by a class declaration and by a single-type-import declaration. Note, however, that it is not an error for the name in a class declaration to overlap with a class or interface that otherwise might be imported by a type-import-on-demand declaration (§7.5.2) in the same compilation unit. Thus, in this program:",8.98,77.02,324.01,530,90,432.1,414.01,509.12,FALSE,FALSE
250,3,BODY,"While a service provider that is specified by a provides directive must be declared in the current module, its provider method may have a return type that is declared in another module. Also, note that when a service provider declares a provider method, the service provider itself need not be a subtype of the service.",8.98,35.02,324,319,90,409.1,414,444.12,FALSE,FALSE
258,4,BODY,"Explicit and exhaustive control over a class's direct subclasses is useful when the class hierarchy is used to model the kinds of values in a domain, rather than as a mechanism for code inheritance and reuse. The direct subclasses may themselves be declared sealed in order to further control the class hierarchy.",8.98,35.02,324.01,313,90,342.23,414.01,377.25,FALSE,FALSE
283,5,BODY,"Even if two distinct inherited fields have the same type, the same value, and are both final, any reference to either field by simple name is considered ambiguous and results in a compile-time error. In the program:",8.98,25.02,323.99,215,90,210.1,413.99,235.12,FALSE,FALSE
292,8,BODY,"even though the constructor for Test2 (§8.8) refers to the field k that is declared three lines later. The restrictions above are designed to catch, at compile time, circular or otherwise malformed initializations. Thus, both:",8.98,47.02,324,226,90,430.1,414,477.12,FALSE,FALSE
293,7,BODY,"because the variable initializer for i uses the class method peek to access the value of the variable j before j has been initialized by its variable initializer, at which point it still has its default value (§4.12.5). A more elaborate example is:",8.98,47.02,324,248,90,274.1,414,321.12,FALSE,FALSE
310,4,BODY,"Note that methods are overridden or hidden on a signature-by-signature basis. If, for example, a class declares two public methods with the same name (§8.4.9), and a subclass overrides one of them, the subclass still inherits the other method.",8.98,25.02,324,243,90,377.1,414,402.12,FALSE,FALSE
312,3,BODY,"The signature of an overriding method may differ from the overridden one if a formal parameter in one of the methods has a raw type, while the corresponding parameter in the other has a parameterized type. This accommodates migration of pre-existing code to take advantage of generics. The notion of overriding includes methods that override another from some subclass of their declaring class. This can happen in two ways: •A concrete method in a generic superclass can, under certain parameterizations, have the same signature as an abstract method in that class. In this case, the concrete method is inherited and the abstract method is not (as described above). The inherited method should then be considered to override its abstract peer from C. (This scenario is complicated by package access: if C is in a different package, then mA would not have been inherited anyway, and should not be considered overridden.) •A method inherited from a class can override a superinterface method. (Happily, package access is not a concern here.)",8.98,165.02,324.01,1039,90,169.1,414.01,334.12,FALSE,FALSE
314,6,BODY,"In this respect, hiding of methods differs from hiding of fields (§8.3), for it is permissible for a static variable to hide an instance variable. Hiding is also distinct from shadowing (§6.4.1) and obscuring (§6.4.2).",8.98,25.02,324.01,218,90,574.23,414.01,599.25,FALSE,FALSE
327,6,BODY,"The rationale for why only this kind of class has an implicitly declared constructor parameter is subtle. The following explanation may be helpful: 1.In a class instance creation expression for a non-private inner member class, §15.9.2 specifies the immediately enclosing instance of the member class. The member class may have been emitted by a compiler which is different than the compiler of the class instance creation expression. Therefore, there must be a standard way for the compiler of the creation expression to pass a reference (representing the immediately enclosing instance) to the member class's constructor. Consequently, the Java programming language deems in this section that a non-private inner member class's constructor implicitly declares an initial parameter for the immediately enclosing instance. §15.9.3 specifies that the instance is passed to the constructor.",8.98,117.02,324.01,888,90,460.1,414.01,577.12,FALSE,FALSE
341,7,BODY,"Each enum constant arranges for a different value in the field value, passed in via a constructor. The field represents the value, in cents, of an American coin. Note that there are no restrictions on the parameters that may be declared by an enum class's constructor.",8.98,25.02,324,268,90,469.1,414,494.12,FALSE,FALSE
345,2,BODY,This pattern is much safer than using a switch statement because the pattern precludes the possibility of forgetting to add a behavior for a new constant (since the enum declaration would cause a compile-time error).,8.98,25.02,324.01,216,90,74.1,414.01,99.12,FALSE,FALSE
346,3,BODY,"The following program exercises the Card class. It takes two integer parameters on the command line, representing the number of hands to deal and the number of cards in each hand:",8.98,25.02,324,179,90,106.1,414,131.12,FALSE,FALSE
400,2,BODY,"Note that if T is not an array type or an annotation interface, the element value must be a ConditionalExpression (§15.25). The use of ConditionalExpression rather than a more general production like Expression is a syntactic trick to prevent assignment expressions as element values. Since an assignment expression is not a constant expression, it cannot be a commensurate element value for a primitive or String-typed element.",8.98,45.02,324,428,90,74.1,414,119.12,FALSE,FALSE
460,2,BODY,"It is important to note that many finalizer threads may be active (this is sometimes needed on large shared memory multiprocessors), and that if a large connected data structure becomes garbage, all of the finalize methods for every object in that data structure could be invoked at the same time, each finalizer invocation running in a different thread.",8.98,35.02,324.01,354,90,74.1,414.01,109.12,FALSE,FALSE
485,2,BODY,"The field h of Hyper is output by the original binary of Test. While this may seem surprising at first, it serves to reduce the number of incompatibilities that occur at run time. (In an ideal world, all source files that needed recompilation would be recompiled whenever any one of them changed, eliminating such surprises. But such a mass recompilation is often impractical or impossible, especially in the Internet. And, as was previously noted, such recompilation would sometimes require further changes to the source code.) As another example, if the program:",8.98,77.02,324.01,564,90,74.1,414.01,151.12,FALSE,FALSE
496,8,BODY,Suppose that a new version of interface I is compiled:,8.98,5.02,195.52,54,90,478.1,285.52,483.12,FALSE,FALSE
546,3,BODY,The following program combines the enhanced for statement with auto-unboxing to translate a histogram into a frequency table:,8.98,15.02,324,125,90,99.1,414,114.12,FALSE,FALSE
579,3,BODY,It can be seen that a match-all pattern is equivalent to a nested type pattern that declares an unnamed pattern variable and whose LocalVariableType is var.,8.98,15.02,324,156,90,157.1,414,172.12,FALSE,FALSE
596,7,BODY,"since no part of the division operation, including signaling of a divide-by-zero exception, may appear to occur before the invocation of loseBig completes, even though the implementation may be able to detect or infer that the division operation would certainly result in a divide-by-zero exception.",8.98,35.02,324,299,90,184.1,414,219.12,FALSE,FALSE
601,5,BODY,"The keyword this is also used in explicit constructor invocation statements (§8.8.7.1), and to denote the receiver parameter of a method or constructor (§8.4).",8.98,15.02,324,159,90,548.1,414,563.12,FALSE,FALSE
621,8,BODY,"with d, d1, d2, and d3 replaced by names that are not already locally declared. Thus, a single new expression actually creates one array of length 6, 6 arrays of length 10, 6x10 = 60 arrays of length 8, and 6x10x8 = 480 arrays of length 12. This example leaves the fifth dimension, which would be arrays containing the actual array elements (references to Age objects), initialized only to null references. These arrays can be filled in later by other code, such as:",8.98,55.02,324.01,466,90,316.1,414.01,371.12,FALSE,FALSE
663,3,BODY,"The casts to types T1 and T2 do not change the method that is invoked, because the instance method to be invoked is chosen according to the run-time class of the object referred to by this. A cast does not change the class of an object; it only checks that the class is compatible with the specified type.",8.98,35.02,324,305,90,126.1,414,161.12,FALSE,FALSE
681,4,BODY,"This portion of the grammar contains some tricks to avoid two potential syntactic ambiguities. The first potential ambiguity would arise in expressions such as (p)+q, which looks, to a C or C++ programmer, as though it could be either a cast to type p of a unary + operating on q, or a binary addition of two quantities p and q. In C and C++, the parser handles this problem by performing a limited amount of semantic analysis as it parses, so that it knows whether p is the name of a type or the name of a variable. Java takes a different approach. The result of the + operator must be numeric, and all type names involved in casts on numeric values are known keywords. Thus, if p is a keyword naming a primitive type, then (p)+q can make sense only as a cast of a unary expression. However, if p is not a keyword naming a primitive type, then (p)+q can make sense only as a binary arithmetic operation. Similar remarks apply to the - operator. The grammar splits CastExpression into multiple cases to make this distinction:",8.98,149.02,324.01,1025,90,275.1,414.01,424.12,FALSE,FALSE
681,6,BODY,"The nonterminal UnaryExpression includes all unary operators, but the nonterminal UnaryExpressionNotPlusMinus excludes uses of all unary operators that could also be binary operators, which in Java are + and -. The second potential ambiguity is that the expression (p)++ could, to a C or C++ programmer, appear to be either a postfix increment of a parenthesized expression or the beginning of a cast, for example, in (p)++q. As before, parsers for C and C++ know whether p is the name of a type or the name of a variable. But a parser using only one-token lookahead and no semantic analysis during the parse would not be able to tell, when ++ is the lookahead token, whether (p) should be considered a Primary expression or left alone for later consideration as part of a CastExpression.",8.98,107.02,324.01,788,90,493.1,414.01,600.12,FALSE,FALSE
707,6,BODY,"In fact, by the grammar of expression statements (§14.8), it is not permitted for a conditional expression to appear in any context where an invocation of a void method could appear.",8.98,15.02,324.01,182,90,407.1,414.01,422.12,FALSE,FALSE
731,3,BODY,"This could be an invocation of foo with one argument (a generic lambda cast to type x), or it could be an invocation of foo with two arguments, both the results of comparisons, the second comparing z with a lambda expression. (Strictly speaking, a lambda expression is meaningless as an operand to the relational operator >, but that is a tenuous assumption on which to build the grammar.) There is a precedent for ambiguity resolution involving casts, which essentially prohibits the use of - and + following a non-primitive cast (§15.15), but to extend that approach to generic lambdas would involve invasive changes to the grammar.",8.98,87.02,324.01,634,90,384.1,414.01,471.12,FALSE,FALSE
741,2,BODY,"•A new object need not be allocated on every evaluation. •Objects produced by different lambda expressions need not belong to different classes (if the bodies are identical, for example). •Every object produced by evaluation need not belong to the same class (captured local variables might be inlined, for example). •If an 'existing instance' is available, it need not have been created at a previous lambda evaluation (it might have been allocated during the enclosing class's initialization, for example). If the targeted functional interface type is a subtype of java.io.Serializable, the resulting object will automatically be an instance of a serializable class. Making an object derived from a lambda expression serializable can have extra run time overhead and security implications, so lambda-derived objects are not required to be serializable 'by default'.",8.98,145.02,324.01,867,90,74.1,414.01,219.12,FALSE,FALSE
753,2,BODY,"unassigned after e when true'. This leads to a circularity. In effect, V is definitely unassigned before the loop condition e only if it is unassigned after the loop as a whole! We break this vicious circle using a hypothetical analysis of the loop condition and body. For example, if we assume that V is definitely unassigned before e (regardless of whether V really is definitely unassigned before e), and can then prove that V was definitely unassigned after e then we know that e does not assign V. This is stated more formally as: Assuming V is definitely unassigned before e, V is definitely unassigned after e. Variations on the above analysis are used to define well founded definite unassignment rules for all loop statements in the Java programming language.",8.98,121.02,324,768,90,74.1,414,195.12,FALSE,FALSE
758,5,BODY,"Note that if a is V and V is not definitely assigned before a compound assignment such as a &= b, then a compile-time error will necessarily occur. The first rule for definite assignment stated above includes the disjunct 'a is V' even for compound assignment expressions, not just simple assignments, so that V will be considered to have been definitely assigned at later points in the code. Including the disjunct 'a is V' does not affect the binary decision as to whether a program is acceptable or will result in a compile-time error, but it affects how many different points in the code may be regarded as erroneous, and so in practice it can improve the quality of error reporting. A similar remark applies to the inclusion of the conjunct 'a is not V' in the first rule for definite unassignment stated above.",8.98,85.02,324.01,816,90,422.1,414.01,507.12,FALSE,FALSE
778,5,BODY,Notice that this provision necessitates the Java coding practice of using wait only within loops that terminate only when some logical condition that the thread is waiting for holds.,8.98,25.02,286,182,128,349.1,414,374.12,FALSE,FALSE
36,3,BODY,"Some APIs of the Java SE Platform, primarily in the Character class, use 32-bit integers to represent code points as individual entities. The Java SE Platform provides methods to convert between 16-bit and 32-bit representations.",8.97,25.02,324,229,90,157.1,414,182.12,FALSE,FALSE
38,3,BODY,"The \, u, and hexadecimal digits here are all ASCII characters.",8.97,5.02,226.79,63,90,112.23,316.79,117.25,FALSE,FALSE
38,5,BODY,"For example, if the most recent raw input character in the result was a backslash that arose from a Unicode escape \u005c in the raw input, then an ASCII \ character appearing next in the raw input is eligible to begin another Unicode escape.",8.97,25.02,314.01,242,100,269.23,414.01,294.25,FALSE,FALSE
66,4,BODY,"In the following program, the value of the story variable would be less readable if individual double quote characters were escaped:",8.97,15.02,324,132,90,138.1,414,153.12,FALSE,FALSE
118,4,BODY,Declaring a variable final can serve as useful documentation that its value will not change and can help avoid programming errors. In this program:,8.97,15.02,324.01,147,90,265.1,414.01,280.12,FALSE,FALSE
143,5,BODY,"Unchecked conversion is used to enable a smooth interoperation of legacy code, written before the introduction of generic types, with libraries that have undergone a conversion to use genericity (a process we call generification). In such circumstances (most notably, clients of the Collections Framework in java.util), legacy code uses raw types (e.g. Collection instead of Collection<String>). Expressions of raw types are passed as arguments to library methods that use parameterized versions of those same types as the types of their corresponding formal parameters. Such calls cannot be shown to be statically safe under the type system using generics. Rejecting such calls would invalidate large bodies of existing code, and prevent them from using newer versions of the libraries. This in turn, would discourage library vendors from taking advantage of genericity. To prevent such an unwelcome turn of events, a raw type may be converted to an arbitrary invocation of the generic type declaration to which the raw type refers. While the conversion is unsound, it is tolerated as a concession to practicality. An unchecked warning is issued in such cases.",8.97,147.02,324,1161,90,229.1,414,376.12,FALSE,FALSE
169,6,BODY,"14.In a throws clause of a method or constructor (§8.4.6, §8.8.5, §9.4) 15.In an exception parameter declaration (§14.20) The first twelve non-generic contexts correspond to the first twelve syntactic contexts for a TypeName in §6.5.1. The thirteenth non-generic context is where a qualified ExpressionName such as C.x may include a TypeName C to denote static member access. The common use of TypeName in these thirteen contexts is significant: it indicates that these contexts involve a less-than-first-class use of a type. In contrast, the fourteenth and fifteenth non-generic contexts employ ClassType, indicating that throws and catch clauses use types in a first-class way, in line with, for example, field declarations. The characterization of these two contexts as non-generic is due to the fact that an exception type cannot be parameterized (§8.1.2). Note that the ClassType production allows annotations, so it is possible to annotate the use of a type in a throws or catch clause, whereas the TypeName production disallows annotations, so it is not possible to annotate the name of a type in, for example, a single- type-import declaration. Naming Conventions The class libraries of the Java SE Platform attempt to use, whenever possible, names chosen according to the conventions presented below. These conventions help to make code more readable and avoid certain kinds of name conflicts. We recommend these conventions for use in all programs written in the Java programming language. However, these conventions should not be followed slavishly if long-held conventional usage dictates otherwise. So, for example, the sin and cos methods of the class java.lang.Math have mathematically conventional names, even though these method names flout the convention suggested here because they are short and are not verbs.",8.97,301.02,324.01,1829,90,286.1,414.01,587.12,FALSE,FALSE
170,2,BODY,"Package Names and Module Names Programmers should take steps to avoid the possibility of two published packages having the same name by choosing unique package names for packages that are widely distributed. This allows packages to be easily and automatically installed and catalogued. This section specifies a suggested convention for generating such unique package names. Implementations of the Java SE Platform are encouraged to provide automatic support for converting a set of packages from local and casual package names to the unique name format described here. If unique package names are not used, then package name conflicts may arise far from the point of creation of either of the conflicting packages. This may create a situation that is difficult or impossible for the user or programmer to resolve. The classes ClassLoader and ModuleLayer can be used to isolate packages with the same name from each other in those cases where the packages will have constrained interactions, but not in a way that is transparent to a naïve program. You form a unique package name by first having (or belonging to an organization that has) an Internet domain name, such as oracle.com. You then reverse this name, component by component, to obtain, in this example, com.oracle, and use this as a prefix for your package names, using a convention developed within your organization to further administer package names. Such a convention might specify that certain package name components be division, department, project, machine, or login names.",8.97,231.02,324.02,1542,90,74.1,414.02,305.12,FALSE,FALSE
176,2,BODY,"The occurrence of length in args.length is a name because args.length is a qualified name (§6.5.6.2) and not a field access expression (§15.11). A field access expression, as well as a method invocation expression, a method reference expression, and a qualified class instance creation expression, uses an identifier rather than a name to denote the member of interest. Thus, the occurrence of length in args[0].length() is not a name, but rather an identifier appearing in a method invocation expression. One might wonder why these kinds of expression use an identifier rather than a simple name, which is after all just an identifier. The reason is that a simple expression name is defined in terms of the lexical environment; that is, a simple expression name must be in the scope of a variable declaration (§6.5.6.1). On the other hand, field access, qualified method invocation, method references, and qualified class instance creation all refer to members whose names are not in the lexical environment. By definition, such names are bound only in the context provided by the Primary of the field access expression, method invocation expression, method reference expression, or class instance creation expression; or by the super of the field access expression, method invocation expression, or method reference expression; and so on. Thus, we denote such members with identifiers rather than simple names. To complicate things further, a field access expression is not the only way to denote a field of an object. For parsing reasons, a qualified name is used to denote a field of an in- scope variable. (The variable itself is denoted with a simple name, alluded to above.) It is necessary for access control (§6.6) to apply to both denotations of a field.",8.97,229.02,324.01,1764,90,74.1,414.01,303.12,FALSE,FALSE
206,5,BODY,"The net effect of these rules is that a local variable, formal parameter, or exception parameter can only be referenced from a nested class or interface declared within its scope if (i) the reference is not within a static context, (ii) there is a chain of inner (non-static) classes from the reference to the variable declaration, and (iii) the variable is final or effectively final. References from lambda expressions also require the variable to be final or effectively final.",8.97,55.02,324,480,90,407.1,414,462.12,FALSE,FALSE
207,5,BODY,"In this program, the names used as the left-hand-sides in the assignments to i, v, and f denote the local variable i, the field v, and the value of f (not the variable f, because f is a final variable). The example therefore produces an error at compile time because the last assignment does not have a variable as its left-hand side. If the erroneous assignment is removed, the modified code can be compiled and it will produce the output:",8.97,45.02,324,440,90,259.1,414,304.12,FALSE,FALSE
216,9,BODY,"If a class lacks the public modifier, access to the class declaration is limited to the package in which it is declared (§6.6). In the example:",8.97,15.02,324.01,143,90,526.1,414.01,541.12,FALSE,FALSE
218,8,BODY,A private class member or constructor is accessible only within the body of the top level class (§7.6) that encloses the declaration of the member or constructor. It is not inherited by subclasses. In the example:,8.97,25.02,324.01,213,90,389.1,414.01,414.12,FALSE,FALSE
247,3,BODY,"The Java SE Platform distinguishes between named modules that are explicitly declared (that is, with a module declaration) and named modules that are implicitly declared (that is, automatic modules). However, the Java programming language does not surface the distinction: requires directives refer to named modules without regard for whether they are explicitly declared or implicitly declared. While automatic modules are convenient for migration, they are unreliable in the sense that their names and exported packages may change when their authors convert them to explicitly declared modules. A Java compiler is encouraged to issue a warning if a requires directive refers to an automatic module. An especially strong warning is recommended if the transitive modifier appears in the directive.",8.97,107.02,324,797,90,112.1,414,219.12,FALSE,FALSE
273,5,BODY,"A sealed class and its direct subclasses need to refer to each other in a circular fashion, in permits and extends clauses, respectively. Therefore, in a modular codebase, they must be co-located in the same module, as classes in different modules cannot refer to each other in a circular fashion. Co-location is desirable in any case because a sealed class hierarchy should always be declared within a single maintenance domain, where the same developer or group of developers is responsible for maintaining the hierarchy. A named module typically represents a maintenance domain in a modular codebase.",8.97,65.02,324.01,603,90,342.1,414.01,407.12,FALSE,FALSE
289,9,BODY,"This allows method one and method two to be executed concurrently, but guarantees that accesses to the shared values for i and j occur exactly as many times, and in exactly the same order, as they appear to occur during execution of the program text by each thread. Therefore, the shared value for j is never greater than that for i, because each update to i must be reflected in the shared value for i before the update to j occurs. It is possible, however, that any given invocation of method two might observe a value for j that is much greater than the value observed for i, because method one might be executed many times",8.97,65.02,324,626,90,525.1,414,590.12,FALSE,FALSE
290,2,BODY,between the moment when method two fetches the value of i and the moment when method two fetches the value of j. See §17.4 for more discussion and examples.,8.97,37.02,324,156,90,74.1,414,111.12,FALSE,FALSE
290,4,BODY,"Note that static fields that are constant variables (§4.12.4) are initialized before other static fields (§12.4.2, step 6). This also applies in interfaces (§9.3.1). When such fields are referenced by simple name, they will never be observed to have their default initial values (§4.12.5).",8.97,35.02,314,289,100,303.1,414,338.12,FALSE,FALSE
328,4,BODY,"The fact that a non-private inner member class may be accessed by a different compiler than compiled it, whereas an inner local class or an anonymous class is always accessed by the same compiler that compiled it, explains why the binary name of a non-private inner member class is defined to be predictable but the binary name of an inner local class or an anonymous class is not (§13.1).",8.97,45.02,324.02,389,90,292.1,414.02,337.12,FALSE,FALSE
334,6,BODY,"then a compile-time error would occur, because the instance variable color cannot be used by a explicit constructor invocation statement.",8.97,15.02,324,137,90,347.1,414,362.12,FALSE,FALSE
344,6,BODY,"Rather than using a switch statement to 'add' behavior to an enum class from the outside, it is possible to use class bodies to attach behaviors to enum constants directly.",8.97,15.02,324,172,90,242.1,414,257.12,FALSE,FALSE
358,3,BODY,"If a record declaration has a record component named c, then the simple name c in the body of a compact constructor denotes the implicit formal parameter named c, and not the component field named c.",8.97,25.02,324,199,90,112.1,414,137.12,FALSE,FALSE
370,5,BODY,"This program causes two compile-time errors, because j is referred to in the initialization of f before j is declared, and because the initialization of k refers to k itself.",8.97,15.02,324,174,90,372.1,414,387.12,FALSE,FALSE
374,3,BODY,An overridden default method can be accessed by using a method invocation expression (§15.12) that contains the keyword super qualified by a superinterface name.,8.97,15.02,323.99,161,90,138.1,413.99,153.12,FALSE,FALSE
375,4,BODY,"Naturally, when two different default methods with matching signatures are inherited by a subinterface, there is a behavioral conflict. We actively detect this conflict and notify the programmer with an error, rather than waiting for the problem to arise when a concrete class is compiled. The error can be avoided by declaring a new method that overrides, and thus prevents the inheritance of, all conflicting methods. Similarly, when an abstract method and a default method with matching signatures are inherited by a subinterface, we produce an error. In this case, it would be possible to give priority to one or the other - perhaps we would assume that the default method provides a reasonable implementation for the abstract method. But this is risky, since other than the coincidental name and signature, we have no reason to believe that the default method behaves consistently with the abstract method's contract - the default method may not have even existed when the subinterface was originally developed. It is safer in this situation to ask the user to actively assert that the default implementation is appropriate (via an overriding declaration). In contrast, the longstanding behavior for inherited concrete methods in classes is that they override abstract methods declared in interfaces (see §8.4.8). The same argument about potential contract violation applies here, but in this case there is an inherent imbalance between classes and interfaces. We prefer, in order to preserve the independent nature of",8.97,199.02,324.01,1523,90,385.23,414.01,584.25,FALSE,FALSE
382,8,BODY,The convention that a single-element annotation interface defines an element called value is illustrated in the following annotation interface declaration:,8.97,15.02,324,155,90,380.1,414,395.12,FALSE,FALSE
382,12,BODY,The following annotation interface declaration shows a Class-typed element whose value is constrained by a bounded wildcard:,8.97,15.02,324,124,90,588.1,414,603.12,FALSE,FALSE
402,6,BODY,Here is an example of a single-element annotation with a Class-typed element whose value is constrained by a bounded wildcard.,8.97,15.02,324,126,90,192.1,414,207.12,FALSE,FALSE
453,7,BODY,"The reference to J.i is to a field that is a constant variable (§4.12.4); therefore, it does not cause I to be initialized (§13.4.9). The reference to K.j is a reference to a field actually declared in interface J that is not a constant variable; this causes initialization of the fields of interface J, but not those of its superinterface I, nor those of interface K. Despite the fact that the name K is used to refer to field j of interface J, interface K is not initialized.",8.97,89.02,324,477,90,403.1,414,492.12,FALSE,FALSE
458,5,BODY,"This constructor then invokes the Point constructor with no arguments. The Point constructor does not begin with an invocation of a constructor, so the Java compiler provides an implicit invocation of its superclass constructor of no arguments, as though it had been written:",8.97,35.02,324,275,90,270.1,414,305.12,FALSE,FALSE
533,5,BODY,Abrupt completion because of a yield statement is handled by the general rule for switch expressions (§15.28.2).,8.97,15.02,314,112,100,394.1,414,409.12,FALSE,FALSE
535,6,BODY,"If the (possibly unboxed) value of the Expression is false the first time it is evaluated, then the Statement is not executed.",8.97,15.02,314.01,126,100,554.1,414.01,569.12,FALSE,FALSE
536,4,BODY,The case of abrupt completion because of a break with a label is handled by the general rule for labeled statements (§14.7).,8.97,15.02,314,124,100,312.1,414,327.12,FALSE,FALSE
537,4,BODY,Executing a do statement always executes the contained Statement at least once.,8.97,5.02,289.04,79,90,259.1,379.04,264.12,FALSE,FALSE
538,5,BODY,The case of abrupt completion because of a break with a label is handled by the general rule for labeled statements (§14.7).,8.97,15.02,314,124,100,272.1,414,287.12,FALSE,FALSE
541,3,BODY,"If the (possibly unboxed) value of the Expression is false the first time it is evaluated, then the Statement is not executed.",8.97,15.02,314.01,126,100,125.1,414.01,140.12,FALSE,FALSE
541,9,BODY,Note that the case of abrupt completion because of a break with a label is handled by the general rule for labeled statements (§14.7).,8.97,15.02,314,134,100,568.23,414,583.25,FALSE,FALSE
556,3,BODY,"An implicitly final exception parameter is final by virtue of its declaration, while an effectively final exception parameter is (as it were) final by virtue of how it is used. An exception parameter of a multi-catch clause is implicitly declared final, so will never occur as the left-hand operand of an assignment operator, but it is not considered effectively final.",8.97,45.02,324,369,90,528.1,414,573.12,FALSE,FALSE
589,5,BODY,"Java 1.0 and 1.1 required strict evaluation of floating-point expressions. Strict evaluation means that each float operand corresponds to a value representable in the IEEE 754 binary32 format, each double operand corresponds to a value representable in the IEEE 754 binary64 format, and each floating-point operator with a corresponding IEEE 754 operation matches the IEEE 754 result for the same operands. Strict evaluation provides predictable results, but caused performance problems in the Java Virtual Machine implementations for some processor families common in the Java 1.0/1.1 era. Consequently, in Java 1.2 through Java SE 16, the Java SE Platform allowed a Java Virtual Machine implementation to have one or two value sets associated with each floating-point type. The float type was associated with the float value set and the float-extended-exponent value set, while the double type was associated with the double value set and the double-extended-exponent value set. The float value set corresponded to the values representable in the IEEE 754 binary32 format; the float-extended-exponent value set had the same number of precision bits but larger exponent range. Similarly, the double value set corresponded to the values representable in the IEEE 754 binary64 format; the double-extended-exponent value set had the same number of precision bits but larger exponent range. Allowing use of the extended-exponent value sets by default ameliorated the performance problems on some processor families. For compatibility, Java 1.2 allowed the programmer to forbid an implementation from using the extended-exponent value sets. The programmer expressed this by placing the strictfp modifier on the declaration of a class, interface, or method. strictfp constrained the floating-point semantics of any enclosed expressions to use the float value set for float expressions and the double value set for double expressions, ensuring the results of such expressions were fully predictable. Code modified by strictfp thus had the same floating-point semantics as specified in Java 1.0 and 1.1.",8.97,269.02,324.01,2096,90,309.1,414.01,578.12,FALSE,FALSE
620,11,BODY,because the embedded assignment that sets i to 1 is never executed.,8.97,5.02,245.55,67,90,527.1,335.55,532.12,FALSE,FALSE
653,3,BODY,"In the case that a superinterface overrides a method declared in a grandparent interface, this rule prevents the child interface from 'skipping' the override by simply adding the grandparent to its list of direct superinterfaces. The appropriate way to access functionality of a grandparent is through the direct superinterface, and only if that interface chooses to expose the desired behavior. (Alternately, the programmer is free to define an additional superinterface that exposes the desired behavior with a super method invocation.)",8.97,65.02,304,538,110,112.1,414,177.12,FALSE,FALSE
662,5,BODY,"An overridden instance method of a superclass may be accessed by using the keyword super to access the members of the immediate superclass, bypassing any overriding declaration in the class that contains the method invocation. When accessing an instance variable, super means the same as a cast of this (§15.11.2), but this equivalence does not hold true for method invocation. This is demonstrated by the example:",8.97,67.02,324.01,414,90,263.1,414.01,330.12,FALSE,FALSE
735,6,BODY,"The transparency of this (both explicit and implicit) in the body of a lambda expression - that is, treating it the same as in the surrounding context - allows more flexibility for implementations, and prevents the meaning of unqualified names in the body from being dependent on overload resolution. Practically speaking, it is unusual for a lambda expression to need to talk about itself (either to call itself recursively or to invoke its other methods), while it is more common to want to use names to refer to things in the enclosing class that would otherwise be shadowed (this, toString()). If it is necessary for a lambda expression to refer to itself (as if via this), a method reference or an anonymous inner class should be used instead.",8.97,97.02,324.01,748,90,291.1,414.01,388.12,FALSE,FALSE
748,7,BODY,"is true, and the value can be true only if the assignment to k is executed (more properly, evaluated). Similarly, a Java compiler will recognize that in the code:",8.97,37.02,324,162,90,328.1,414,365.12,FALSE,FALSE
749,2,BODY,"must be rejected by a Java compiler, because in this case the while statement is not guaranteed to execute its body as far as the rules of definite assignment are concerned.",8.97,15.02,324,173,90,136.1,414,151.12,FALSE,FALSE
781,7,BODY,"The semantics of the Java programming language allow compilers and microprocessors to perform optimizations that can interact with incorrectly synchronized code in ways that can produce behaviors that seem paradoxical. Here are some examples of how incorrectly synchronized programs may exhibit surprising behaviors. Consider, for example, the example program traces shown in Table 17.4-A. This program uses local variables r1 and r2 and shared variables A and B. Initially, A == B == 0.",8.97,67.02,324,487,90,385.1,414,452.12,FALSE,FALSE
783,2,BODY,One common compiler optimization involves having the value read for r2 reused for r5: they are both reads of r1.x with no intervening write. This situation is shown in Table 17.4- D.,8.97,25.02,324,182,90,74.1,414,99.12,FALSE,FALSE
797,8,BODY,final fields are designed to allow for necessary security guarantees. Consider the following program. One thread (which we shall refer to as thread 1) executes:,8.97,15.02,323.99,160,90,500.1,413.99,515.12,FALSE,FALSE
810,3,BODY,"In more complex cases, a result expression may be a poly expression - perhaps even another lambda expression - and so the inference variable might be passed through multiple constraint formulas with different target types before a bound is produced. Most of the work described in this section precedes assertions about the result expressions; its purpose is to derive the lambda expression's function type, and to check for expressions that are clearly disqualified from compatibility. We do not attempt to produce bounds on inference variables that appear in the target function type's throws clause. This is because exception containment is not part of compatibility (§15.27.3) - in particular, it must not influence method applicability (§18.5.1). However, we do get bounds on these variables later, because invocation type inference (§18.5.2.2) produces exception containment constraint formulas (§18.2.5). Note that if the target type is an inference variable, or if the target type's parameter types contain inference variables, we produce false. During invocation type inference (§18.5.2.2), extra substitutions are performed in order to instantiate these inference variables, thus avoiding this scenario. (In other words, reduction will, in practice, never be 'invoked' with a target type of one of these forms.) Finally, note that the result expressions of a lambda expression are required by §15.27.3 to be compatible in an assignment context with the target type's return type, R. If R is a proper type, such as Byte derived from Function<α,Byte>, then assignability is easy enough to test, and reduction does so above. If R is not a proper type, such as α derived from Function<String,α>, then we make the simplifying assumption above that loose invocation compatibility will be sufficient. The difference between assignment compatibility and loose invocation compatibility is that only assignment allows narrowing of constant expressions, such as Byte b = 100;. Consequently, our simplifying assumption is not completeness-preserving: given target return type α and an integer literal result expression 100, it is conceivable that α could be instantiated to Byte, but reduction will not in fact produce such a bound.",8.97,328.55,324.01,2229,90,190.1,414.01,518.65,FALSE,FALSE
813,3,BODY,"Boxing T to T' is not completeness-preserving; for example, if T were long, S might be instantiated to Integer, which is not a subtype of Long but could be unboxed and then widened to long. We avoid this problem in most cases by giving special treatment to inference-variable return types that we know are already constrained to be certain boxed primitive types; see §18.5.2.1. Similarly, the treatment of unchecked conversion sacrifices completeness in cases in which T is not a parameterized type (for example, if T is an inference variable). It is not usually clear in such situations whether the unchecked conversion is necessary or not. Since unchecked conversions introduce unchecked warnings, inference prefers to avoid them unless it is clearly necessary.",8.97,107.02,324,763,90,112.1,414,219.12,FALSE,FALSE
39,4,BODY,A Java compiler should use the \uxxxx notation as an output format to display Unicode characters when a suitable font is not available.,8.96,15.02,323.99,135,90,521.1,413.99,536.12,FALSE,FALSE
53,3,BODY,"Note that octal numerals always consist of two or more digits, as 0 alone is always considered to be a decimal numeral - not that it matters much in practice, for the numerals 0, 00, and 0x0 all represent exactly the same integer value.",8.96,25.02,324.01,236,90,362.1,414.01,387.12,FALSE,FALSE
67,13,BODY,"Interpreting escape sequences last allows programmers to use \n, \f, and \r for vertical formatting of a string without affecting the normalization of line terminators, and to use \b and \t for horizontal formatting of a string without affecting the removal of incidental",8.96,25.02,324,271,90,578.1,414,603.12,FALSE,FALSE
93,3,BODY,"In other words, it is illegal to refer to a static member declared in a generic type declaration by using a parameterized type.",8.96,15.02,324,127,90,125.1,414,140.12,FALSE,FALSE
178,3,BODY,The translation of a try-with-resources statement implies the rule above.,8.96,5.02,263.85,73,90,336.1,353.85,341.12,FALSE,FALSE
179,3,BODY,"The following program causes a compile-time error because the initialization of local variable x is within the scope of the declaration of local variable x, but the local variable x does not yet have a value and cannot be used. The field x has a value of 0 (assigned when Test1 was initialized) but is a red herring since it is shadowed (§6.4.1) by the local variable x.",8.96,45.02,324,370,90,99.1,414,144.12,FALSE,FALSE
182,2,BODY,"initialized, the entire expression is considered erroneous. The second error case covers the opposite scenario where the entire expression evaluates to false.",8.96,15.02,324.01,158,90,74.1,414.01,89.12,FALSE,FALSE
219,5,BODY,"More information about access to protected members can be found in Checking Access to Protected Members in the Java Virtual Machine by Alessandro Coglio, in the Journal of Object Technology, October 2005.",8.96,25.02,324,204,90,492.23,414,517.25,FALSE,TRUE
262,4,BODY,There are no 'inner interfaces' because every nested interface is implicitly static (§9.1.1.3).,8.96,15.02,324,95,90,504.1,414,519.12,FALSE,FALSE
283,7,BODY,"it is not astonishing that the reference to GREEN should be considered ambiguous, because class Test inherits two different declarations for GREEN with different values. The point of this example is that the reference to RED is also considered ambiguous, because two distinct declarations are inherited. The fact that the two fields named RED happen to have the same type and the same unchanging value does not affect this judgment.",8.96,45.02,324.01,432,90,344.1,414.01,389.12,FALSE,FALSE
339,2,BODY,•The final clone method in Enum ensures that enum constants can never be cloned. •Reflective instantiation of enum classes is prohibited. •Special treatment by the serialization mechanism ensures that duplicate instances are never created as a result of deserialization.,8.96,47.02,323.99,270,90,74.1,413.99,121.12,FALSE,FALSE
341,3,BODY,"In practice, a compiler is likely to mirror the Enum class by declaring String and int parameters in the default constructor of an enum class. However, these parameters are not specified as 'implicitly declared' because different compilers do not need to agree on the form of the default constructor. Only the compiler of an enum declaration knows how to instantiate the enum constants; other compilers can simply rely on the implicitly declared public static fields of the enum class (§8.9.3) without regard for how those fields were initialized.",8.96,65.02,324.01,547,90,202.1,414.01,267.12,FALSE,FALSE
341,9,BODY,"Without the rule on static field access, apparently reasonable code would fail at run time due to the initialization circularity inherent in enum classes. (A circularity exists in any class with a 'self-typed' static field.) Here is an example of the sort of code that would fail:",8.96,25.02,324.01,280,90,536.1,414.01,561.12,FALSE,FALSE
347,5,BODY,"A record declaration does not have an extends clause, so it is not possible to explicitly declare a direct superclass type, even Record. The serialization mechanism treats instances of a record class differently than ordinary serializable or externalizable objects. In particular, a record object is deserialized using the canonical constructor (§8.10.4).",8.96,57.02,324,355,90,436.1,414,493.12,FALSE,FALSE
365,5,BODY,"A sealed interface and its direct subclasses and direct subinterfaces need to refer to each other in a circular fashion, in permits, implements, and extends clauses, respectively. Therefore, in a modular codebase, they must be co-located in the same module, as classes and interfaces in different modules cannot refer to each other in a circular fashion. Co- location is desirable in any case because a sealed interface hierarchy should always be declared within a single maintenance domain, where the same developer or group of developers is responsible for maintaining the hierarchy. A named module typically represents a maintenance domain in a modular codebase.",8.96,75.02,324,665,90,397.1,414,472.12,FALSE,FALSE
416,5,BODY,the function type of G is:,8.96,5.02,88.54,26,90,213.1,178.54,218.12,FALSE,FALSE
421,9,BODY,"The program declares a variable ia that has type array of int, that is, int[]. The variable ia is initialized to reference a newly created array object, created by an array creation expression (§15.10.1). The array creation expression specifies that the array should have",8.96,25.02,324,271,90,578.1,414,603.12,FALSE,FALSE
426,3,BODY,showing that the components of the arrays referenced by ia1 and ia2 are different variables.,8.96,15.02,324,92,90,96.1,414,111.12,FALSE,FALSE
466,3,BODY,"Except for this unusual situation involving Runtime.halt, program exit depends on the termination of any shutdown hooks which were started. The rationale is as follows. When the number of non-daemon threads drops to zero or a thread invokes System.exit or Runtime.exit, it is likely that the program has no more work to do and is transitioning toward exit; however, the program may still have other threads that are performing ancillary tasks, and it would be undesirable to stop them in their tracks. Shutdown hooks let the program gracefully interrupt and bring down such threads in an application-specific manner; accordingly, the program has not yet exited if shutdown hooks are still running. Native applications can use the JNI Invocation API to create and destroy the Java Virtual Machine in such a way that a Java program, having started execution in the main method of an initial class (§12.1), exits as described in the first situation above.",8.96,117.02,324.01,952,90,157.1,414.01,274.12,FALSE,FALSE
487,6,BODY,if N need not be read-only.,8.96,5.02,95.28,27,90,290.1,185.28,295.12,FALSE,FALSE
505,3,BODY,The following code illustrates these rules restricting the use of var:,8.96,5.02,243.37,70,90,425.1,333.37,430.12,FALSE,FALSE
505,5,BODY,These restrictions help to avoid confusion about the type being represented by var.,8.96,5.02,300.11,83,90,519.1,390.11,524.12,FALSE,FALSE
506,5,BODY,The following code illustrates the typing of variables declared with var:,8.96,5.02,260.87,73,90,422.1,350.87,427.12,FALSE,FALSE
511,3,BODY,The identifier max could also have been used as the statement label; the label would not obscure the local variable max within the labeled statement.,8.96,15.02,323.99,149,90,96.1,413.99,111.12,FALSE,FALSE
587,7,BODY,"The requirement for matching sign, significand, and exponent precludes some transformations that might be allowed if floating-point behavior was less precisely specified. For example, -x cannot generally be replaced by (0.0 - x) because the sign of the result will differ if x is -0.0. Also, other possibly value-changing transformation such",8.96,35.02,324,341,90,553.1,414,588.12,FALSE,FALSE
594,8,BODY,It is not permitted for evaluation of the * operator to produce 6 instead of 9.,8.96,5.02,273.36,79,90,311.1,363.36,316.12,FALSE,FALSE
594,14,BODY,"It is not permitted for either assignment (compound for a, simple for b) to produce the result 6. See also the example in §15.26.2.",8.96,37.02,324,131,90,566.1,414,603.12,FALSE,FALSE
627,8,BODY,"The last line shows that, indeed, the field that is accessed does not depend on the run- time class of the referenced object; even if s holds a reference to an object of class T, the expression s.x refers to the x field of class S, because the type of the expression s is S. Objects of class T contain two fields named x, one for class T and one for its superclass S.",8.96,35.02,324,367,90,565.1,414,600.12,FALSE,FALSE
637,7,BODY,"This example produces an error at compile time. The problem is that there are two declarations of test that are applicable and accessible, and neither is more specific than the other. Therefore, the method invocation is ambiguous. If a third definition of test were added:",8.96,47.02,323.99,272,90,506.1,413.99,553.12,FALSE,FALSE
658,4,BODY,"This is the only place where Q is involved in checks for m, because a protected instance method may only be invoked via a qualifying class or interface that aligns with the invoker's type.",8.96,25.02,314,188,100,300.1,414,325.12,FALSE,FALSE
667,5,BODY,"It is not possible to specify a particular signature to be matched, for example, Arrays::sort(int[]). Instead, the functional interface provides argument types that are used as input to the overload resolution algorithm (§15.12.2). This should satisfy the vast majority of use cases; when the rare need arises for more precise control, a lambda expression can be used. The use of type argument syntax in the class name before a delimiter (List<String>::size) raises the parsing problem of distinguishing between < as a type argument bracket and < as a less-than operator. In theory, this is no worse than allowing type arguments in cast expressions; however, the difference is that the cast case only comes up when a ( token is encountered; with the addition of method reference expressions, the start of every expression is potentially a parameterized type.",8.96,117.02,324.01,858,90,394.1,414.01,511.12,FALSE,FALSE
682,2,BODY,"In Java, the result of the ++ operator must be numeric, and all type names involved in casts on numeric values are known keywords. Thus, if p is a keyword naming a primitive type, then (p)++ can make sense only as a cast of a prefix increment expression, and there had better be an operand such as q following the ++. However, if p is not a keyword naming a primitive type, then (p)++ can make sense only as a postfix increment of p. Similar remarks apply to the -- operator. The nonterminal UnaryExpressionNotPlusMinus therefore also excludes uses of the prefix operators ++ and --.",8.96,65.02,324,583,90,74.1,414,139.12,FALSE,FALSE
692,3,BODY,"An implementation may choose to perform conversion and concatenation in one step to avoid creating and then discarding an intermediate String object. To increase the performance of repeated string concatenation, a Java compiler may use the StringBuffer class or a similar technique to reduce the number of intermediate String objects that are created by evaluation of an expression. For primitive types, an implementation may also optimize away the creation of a wrapper object by converting directly from a primitive type to a string.",8.96,77.02,324,535,90,210.1,414,287.12,FALSE,FALSE
733,4,BODY,"Either can be used, whether the functional interface's abstract method is fixed arity or variable arity. (This is consistent with the rules for method overriding.) Since lambda expressions are never directly invoked, using int... for the formal parameter where the functional interface uses int[] can have no impact on the surrounding program. In a lambda body, a variable arity parameter is treated just like an array-typed parameter.",8.96,45.02,324,435,90,543.1,414,588.12,FALSE,FALSE
752,4,BODY,"The definite unassignment analysis of loop statements raises a special problem. Consider the statement while (e) S. In order to determine whether V is definitely unassigned within some subexpression of e, we need to determine whether V is definitely unassigned before e. One might argue, by analogy with the rule for definite assignment (§16.2.10), that V is definitely unassigned before e iff it is definitely unassigned before the while statement. However, such a rule is inadequate for our purposes. If e evaluates to true, the statement S will be executed. Later, if V is assigned by S, then in the following iteration(s) V will have already been assigned when e is evaluated. Under the rule suggested above, it would be possible to assign V multiple times, which is exactly what we have sought to avoid by introducing these rules. A revised rule would be: 'V is definitely unassigned before e iff it is definitely unassigned before the while statement and definitely unassigned after S'. However, when we formulate the rule for S, we find: 'V is definitely unassigned before S iff it is definitely",8.96,137.02,324,1102,90,451.1,414,588.12,FALSE,FALSE
781,10,BODY,"It may appear that the result r2 == 2 and r1 == 1 is impossible. Intuitively, either instruction 1 or instruction 3 should come first in an execution. If instruction 1 comes first, it should not be able to see the write at instruction 4. If instruction 3 comes first, it should not be able to see the write at instruction 2.",8.96,35.02,324.01,324,90,551.6,414.01,586.62,FALSE,FALSE
46,2,BODY,"UnqualifiedMethodIdentifier is used when a method invocation expression refers to a method by its simple name (§6.5.7.1). Since the term yield is excluded from UnqualifiedMethodIdentifier, any invocation of a method named yield must be qualified, thus distinguishing the invocation from a yield statement (§14.21).",8.95,35.02,324,314,90,74.1,414,109.12,FALSE,FALSE
47,2,BODY,"The keywords const and goto are reserved, even though they are not currently used. This may allow a Java compiler to produce better error messages if these C++ keywords incorrectly appear in programs. The keyword strictfp is obsolete and should not be used in new code. The keyword _ (underscore) may be used in certain declarations in place of an identifier (§6.1). true and false are not keywords, but rather boolean literals (§3.10.3). null is not a keyword, but rather the null literal (§3.10.8).",8.95,123.02,324,500,90,74.1,414,197.12,FALSE,FALSE
62,3,BODY,"Because Unicode escapes are processed very early, it is not correct to write '\u000a' for a string literal containing a single linefeed (LF); the Unicode escape \u000a is transformed into an actual linefeed in translation step 1 (§3.3) and the linefeed becomes a LineTerminator in step 2 (§3.4), so the string literal is not valid in step 3. Instead, one should use the escape sequence '\n'. Similarly, it is not correct to write '\u000d' for a string literal containing a single carriage return (CR). Instead, use '\r'. Finally, it is not possible to write '\u0022' for a string literal containing a double quotation mark ('). A long string literal can always be broken up into shorter pieces and written as a (possibly parenthesized) expression using the string concatenation operator + (§15.18.1).",8.95,97.02,324,800,90,158.1,414,255.12,FALSE,FALSE
69,4,BODY,"The OctalDigit production above comes from §3.10.1. Octal escapes are provided for compatibility with C, but can express only Unicode values \u0000 through \u00FF, so Unicode escapes are usually preferred.",8.95,25.02,324,205,90,490.55,414,515.57,FALSE,FALSE
96,3,BODY,"because Outer itself is raw, hence so are all its inner classes including Inner, and so it is not possible to pass any type arguments to Inner.",8.95,15.02,324,143,90,128.1,414,143.12,FALSE,FALSE
120,6,BODY,"illustrating the default initialization of npoints, which occurs when the class Point is prepared (§12.3.2), and the default initialization of x, y, and root, which occurs when a new Point is instantiated. See §12 (Execution) for a full description of all aspects of loading, linking, and initialization of classes and interfaces, plus a description of the instantiation of classes to make new class instances.",8.95,45.02,324,410,90,479.1,414,524.12,FALSE,FALSE
171,8,BODY,"Likewise, names of interface should be short and descriptive, not overly long, in mixed case with the first letter of each word capitalized. The name may be a descriptive noun or noun phrase, which is appropriate when an interface is used as if it were an abstract superclass, such as interfaces java.io.DataInput and java.io.DataOutput; or it may be an adjective describing a behavior, as for the interfaces Runnable and Cloneable. Type Variable Names Type variable names should be pithy (single character if possible) yet evocative, and should not include lower case letters. This makes it easy to distinguish type parameters from ordinary classes and interfaces. Container classes and interfaces should use the name E for their element type. Maps should use K for the type of their keys and V for the type of their values. The name X should be used for arbitrary exception types. We use T for type, whenever there is not anything more specific about the type to distinguish it. (This is often the case in generic methods.)",8.95,161.02,324.01,1025,90,430.1,414.01,591.12,FALSE,FALSE
311,2,BODY,"obviously it must be declared abstract, or else override both abstract foo methods with a concrete method. Note that it is possible for an inherited concrete method to prevent the inheritance of an abstract or default method. (The concrete method will override the abstract or default method 'from C', per §8.4.8.1 and §9.4.1.1.) Also, it is possible for one supertype method to prevent the inheritance of another supertype method if the former 'already' overrides the latter - this is the same as the rule for interfaces (§9.4.1), and prevents conflicts in which multiple default methods are inherited and one implementation is clearly meant to supersede the other.",8.95,97.02,324,666,90,74.1,414,171.12,FALSE,FALSE
315,5,BODY,"A class (static) method that is hidden can be invoked by using a reference whose type is the type of the class that actually contains the declaration of the method. In this respect, hiding of static methods is different from overriding of instance methods. The example:",8.95,25.02,324,269,90,172.1,414,197.12,FALSE,FALSE
333,4,BODY,"While it may be the case that S is a member of C due to inheritance, the zeroth lexically enclosing instance of this (that is, this itself) is never used as the immediately enclosing instance of i with respect to S.",8.95,25.02,296,215,118,304.1,414,329.12,FALSE,FALSE
335,2,BODY,"The program below achieves this by passing an instance of Outer to the constructor of ChildOfInner, which uses the instance in a qualified superclass constructor invocation statement. The rules for an explicit constructor invocation statement do not prohibit using formal parameters of the constructor that contains the statement.",8.95,35.02,324,330,90,74.1,414,109.12,FALSE,FALSE
374,5,BODY,"The prohibition against declaring one of the Object methods as a default method may be surprising. There are, after all, cases like java.util.List in which the behavior of toString and equals are precisely defined. The motivation becomes clearer, however, when some broader design decisions are understood: •First, methods inherited from a superclass are allowed to override methods inherited from superinterfaces (§8.4.8.1). So, every implementing class would automatically override an interface's toString default. This is longstanding behavior in the Java programming language. It is not something we wish to change with the design of default methods, because that would conflict with the goal of allowing interfaces to unobtrusively evolve, only providing default behavior when a class doesn't already have it through the class hierarchy. •Second, interfaces do not inherit from Object, but rather implicitly declare many of the same methods as Object (§9.2). So, there is no common ancestor for the toString declared in Object and the toString declared in an interface. At best, if both were candidates for inheritance by a class, they would conflict. Working around this problem would require awkward commingling of the class and interface inheritance trees. •Third, use cases for declaring Object methods in interfaces typically assume a linear interface hierarchy; the feature does not generalize very well to multiple inheritance scenarios.",8.95,209.02,324,1449,90,371.23,414,580.25,FALSE,FALSE
408,6,BODY,"is prohibited, even if FooContainer is repeatable with a containing annotation interface of its own. It is obtuse to repeat annotations which are themselves containers when an annotation of the underlying repeatable interface is present.",8.95,25.02,324,237,90,325.1,414,350.12,FALSE,FALSE
410,11,BODY,"Similarly, the definition of 'functional interface' respects the fact that an interface may only have methods with override-equivalent signatures if one is return-type-substitutable for all the others. Thus, in the following interface hierarchy where Z causes a compile-time error, Z is not a functional interface: (because none of its abstract members are return- type-substitutable for all other abstract members)",8.95,45.02,324,415,90,545.1,414,590.12,FALSE,FALSE
416,3,BODY,"A function type may be generic, as a functional interface's abstract method may be generic. For example, in the following interface hierarchy:",8.95,15.02,324,142,90,99.1,414,114.12,FALSE,FALSE
422,2,BODY,"101 components. The length of the array is available using the field length, as shown. The program fills the array with the integers from 0 to 100, sums these integers, and prints the result.",8.95,25.02,324,191,90,74.1,414,99.12,FALSE,FALSE
448,2,BODY,"For further discussion of these issues, see The Java Virtual Machine Specification, Java SE 23 Edition and the paper Dynamic Class Loading in the Java Virtual Machine, by Sheng Liang and Gilad Bracha, in Proceedings of OOPSLA '98, published as ACM SIGPLAN Notices, Volume 33, Number 10, October 1998, pages 36-44. A basic principle of the design of the Java programming language is that the run-time type system cannot be subverted by code written in the Java programming language, not even by implementations of such otherwise sensitive system classes as ClassLoader and SecurityManager.",8.95,65.02,324,588,90,74.1,414,139.12,FALSE,FALSE
450,3,BODY,"This can occur, for example, if a field that is originally declared public is changed to be private after another class that refers to the field has been compiled (§13.4.7); or if the package in which a public class is declared ceases to be exported by its module after another module that refers to the class has been compiled (§13.3).",8.95,35.02,314,336,100,164.1,414,199.12,FALSE,FALSE
485,7,BODY,"If the resulting binary is used with the existing binaries for Hyper and Test, then the output is still:",8.95,15.02,324,104,90,348.1,414,363.12,FALSE,FALSE
493,9,BODY,"If Super is recompiled but not Test, then running the new binary with the existing binary of Test still produces the output:",8.95,15.02,324.01,124,90,389.1,414.01,404.12,FALSE,FALSE
494,4,BODY,"As with sealed classes (§13.4.2.1), although adding an enum constant to an enum class is considered a binary compatible change, it may cause the execution of an exhaustive switch (§14.11.1) to fail if the switch encounters the new enum constant that was not known at compile time (§14.11.3, §15.28.2).",8.95,35.02,324,301,90,199.1,414,234.12,FALSE,FALSE
510,4,BODY,"The following code was taken from a version of the class String and its method indexOf, where the label was originally called test. Changing the label to have the same name as the local variable i does not obscure the label in the scope of the declaration of i. Thus, the code is valid.",8.95,35.02,324,286,90,376.1,414,411.12,FALSE,FALSE
534,5,BODY,"Fall through can be the cause of subtle bugs. If code is not to fall through case to case in this manner, then break statements can be used to indicate when control should be transferred, or switch rules can be used, as in the program:",8.95,25.02,324,235,90,230.1,414,255.12,FALSE,FALSE
557,2,BODY,"If an exception parameter is effectively final (in a uni-catch clause) or implicitly final (in a multi-catch clause), then adding an explicit final modifier to its declaration will not introduce any compile-time errors. On the other hand, if the exception parameter of a uni-catch clause is explicitly declared final, then removing the final modifier may introduce compile-time errors because the exception parameter, now considered to be effectively final, can no longer longer be referenced by anonymous and local class declarations in the body of the catch clause. If there are no compile-time errors, it is possible to further change the program so that the exception parameter is re-assigned in the body of the catch clause and thus will no longer be considered effectively final.",8.95,85.02,324.01,785,90,74.1,414.01,159.12,FALSE,FALSE
615,3,BODY,"If evaluation of a class instance creation expression finds there is insufficient memory to perform the creation operation, then an OutOfMemoryError is thrown. This check occurs before any argument expressions are evaluated. So, for example, the test program:",8.95,47.02,324,259,90,99.1,414,146.12,FALSE,FALSE
623,5,BODY,"In an array access, the expression to the left of the brackets appears to be fully evaluated before any part of the expression within the brackets is evaluated. For example, in the (admittedly monstrous) expression a[(a=b)[3]], the expression a is fully evaluated before the expression (a=b)[3]; this means that the original value of a is fetched and remembered while the expression (a=b)[3] is evaluated. This array referenced by the original value of a is then subscripted by a value that is element 3 of another array (possibly the same array) that was referenced by b and is now also referenced by a. Thus, the program:",8.95,87.02,324,623,90,474.1,414,561.12,FALSE,FALSE
628,6,BODY,"The last line shows that, indeed, the method that is accessed does depend on the run- time class of the referenced object; when s holds a reference to an object of class T, the expression s.z() refers to the z method of class T, despite the fact that the type of the expression s is S. Method z of class T overrides method z of class S.",8.95,35.02,324,336,90,362.1,414,397.12,FALSE,FALSE
658,2,BODY,"If Q is protected, it is necessarily a nested class or interface, so at compile time, its accessibility is affected by the accessibility of classes and interfaces enclosing its declaration. However, during linkage, its accessibility is not affected by the accessibility of classes and interfaces enclosing its declaration. Moreover, during linkage, a protected Q is as accessible as a public Q. These discrepancies between access control at compile time (§6.6) and access control at run time are due to limitations in the Java Virtual Machine.",8.95,55.02,324.01,543,90,74.1,414.01,129.12,FALSE,FALSE
694,3,BODY,"In the code, note the careful conditional generation of the singular 'bottle' when appropriate rather than the plural 'bottles'; note also how the string concatenation operator was used to break the long constant string:",8.95,25.02,324,220,90,226.1,414,251.12,FALSE,FALSE
740,3,BODY,"This implies that the identity of the result of evaluating a lambda expression (or, of serializing and deserializing a lambda expression) is unpredictable, and therefore identity- sensitive operations (such as reference equality (§15.21.3), object locking (§14.19), and the System.identityHashCode method) may produce different results in different implementations of the Java programming language, or even upon different lambda expression evaluations in the same implementation.",8.95,55.02,324,479,90,230.1,414,285.12,FALSE,FALSE
754,5,BODY,This is equivalent to saying that V is [un]assigned after !a iff V is [un]assigned after a.,8.95,5.02,311.21,91,100,441.1,411.21,446.12,FALSE,FALSE
802,5,BODY,"Some implementations may find it convenient to divide a single write action on a 64-bit long or double value into two write actions on adjacent 32-bit values. For efficiency's sake, this behavior is implementation-specific; an implementation of the Java Virtual Machine is free to perform writes to long and double values atomically or in two parts. Implementations of the Java Virtual Machine are encouraged to avoid splitting 64-bit values where possible. Programmers are encouraged to declare shared 64-bit values as volatile or synchronize their programs correctly to avoid possible complications.",8.95,77.02,324,601,90,391.1,414,468.12,FALSE,FALSE
8,14,BODY,9.6.4.1@Target373 9.6.4.2@Retention374 9.6.4.3@Inherited375 9.6.4.4@Override376 9.6.4.5@SuppressWarnings377 9.6.4.6@Deprecated378 9.6.4.7@SafeVarargs380 9.6.4.8@Repeatable381 9.6.4.9@FunctionalInterface381,8.94,93.58,163.4,205,162,500.83,325.4,594.41,FALSE,FALSE
31,9,BODY,BasicForStatement: for ( [ForInit] ; [Expression] ; [ForUpdate] ) Statement,8.94,14.95,224.1,75,108,320.15,332.1,335.1,FALSE,TRUE
47,6,BODY,"In other contexts, attempting to use var as an identifier will cause an error, because var is not a TypeIdentifier (§3.8).",8.94,15.02,296,122,118,454.1,414,469.12,FALSE,FALSE
68,4,BODY,"The \r escape sequences are not interpreted until after the line terminators have been normalized to LF. Using Unicode escapes to visualize LF (\u000A) and CR (\u000D), and using | to visualize the left margin, the string represented by the text block is:",8.94,25.02,324,255,90,188.1,414,213.12,FALSE,FALSE
79,5,BODY,"This example demonstrates, among other things, that gradual underflow can result in a gradual loss of precision. The results when i is 0 involve division by zero, so that z becomes positive infinity, and z * 0 is NaN, which is not equal to 1.0.",8.94,47.02,324,244,90,400.1,414,447.12,FALSE,FALSE
90,5,BODY,"The relationship of wildcards to established type theory is an interesting one, which we briefly allude to here. Wildcards are a restricted form of existential types. Given a generic type declaration G<T extends B>, G<?> is roughly analogous to Some X <: B. G<X>. Historically, wildcards are a direct descendant of the work by Atsushi Igarashi and Mirko Viroli. Readers interested in a more comprehensive discussion should refer to On Variance- Based Subtyping for Parametric Types by Atsushi Igarashi and Mirko Viroli, in the Proceedings of the 16th European Conference on Object Oriented Programming (ECOOP",8.94,76.95,324,608,90,518.1,414,595.05,FALSE,FALSE
171,5,BODY,"The first component of a package or module name must not be the identifier java. Package and module names that start with the identifier java are reserved for packages and modules of the Java SE Platform. The name of a package or module is not meant to imply where the package or module is stored on the Internet. For example, a package named edu.cmu.cs.bovik.cheese is not necessarily obtainable from the host cmu.edu or cs.cmu.edu or bovik.cs.cmu.edu. The suggested convention for generating unique package and module names is merely a way to piggyback a package and module naming convention on top of an existing, widely known unique name registry instead of having to create a separate registry for package and module names. Class and Interface Names Names of class should be descriptive nouns or noun phrases, not overly long, in mixed case with the first letter of each word capitalized.",8.94,161.02,324.01,893,90,169.1,414.01,330.12,FALSE,FALSE
179,9,BODY,"In the following program, the initializer for three can correctly refer to the variable two declared in an earlier declarator, and the method invocation in the next line can correctly refer to the variable three declared earlier in the block.",8.94,25.02,324,242,90,391.1,414,416.12,FALSE,FALSE
202,4,BODY,"This section does not mandate a compile-time error if no module with that name is observable. Instead, the requires directive in a module declaration (§7.7.1) performs its own validation of the module name, while the exports and opens directives (§7.7.2) are tolerant of non-existent module names.",8.94,35.02,324,297,90,244.1,414,279.12,FALSE,FALSE
204,2,BODY,"For example, the type name must not appear in the body of a static method declared by D, nor (if D is a local interface) in the body of a default method of D.",8.94,15.02,324,158,90,74.1,414,89.12,FALSE,FALSE
237,6,BODY,"Package names and type names are usually different under the naming conventions described in §6.1. Nevertheless, in a contrived example where there is an unconventionally named package Vector, which declares a public class whose name is Mosquito:",8.94,25.02,324.01,246,90,230.1,414.01,255.12,FALSE,FALSE
242,3,BODY,"This program defines two classes that use each other in the declarations of their class members. Because the classes Point and PointColor have all the class declarations in package points, including all those in the current compilation unit, as their scope, this program compiles correctly. That is, forward reference is not a problem.",8.94,35.02,324,335,90,227.1,414,262.12,FALSE,FALSE
263,3,BODY,"Prior to Java SE 16, an inner class could not declare static initializers, and could only declare static members that were constant variables (§4.12.4).",8.94,15.02,324,152,90,306.1,414,321.12,FALSE,FALSE
269,5,BODY,This program causes a compile-time error because class Point depends on itself.,8.94,5.02,292.94,79,90,187.6,382.94,192.62,FALSE,FALSE
278,8,BODY,"Even though a class might not be declared public, instances of the class might be available at run time to code outside the package in which it is declared by means of a public superclass or superinterface. An instance of the class can be assigned to a variable of such a public type. An invocation of a public method of the object referred to by such a variable may invoke a method of the class if it implements or overrides a method of the public superclass or superinterface. (In this situation, the method is necessarily declared public, even though it is declared in a class that is not public.) Consider the compilation unit:",8.94,87.02,324.01,631,90,408.1,414.01,495.12,FALSE,FALSE
309,5,BODY,"If an implementation is to be provided for a method declared void, but the implementation requires no executable code, the method body should be written as a block that contains no statements: '{ }'.",8.94,25.02,324,199,90,284.1,414,309.12,FALSE,FALSE
343,8,BODY,"A switch statement (§14.11) is useful for simulating the addition of a method to an enum class from outside the class. This example 'adds' a color method to the Coin class from §8.9.2, and prints a table of coins, their values, and their colors.",8.94,25.02,324,245,90,406.1,414,431.12,FALSE,FALSE
373,5,BODY,"In essence, a static method in an interface cannot hide an instance method in a superinterface type. This is similar to the rule in §8.4.8.2 whereby a static method in a class cannot hide an instance method in a superclass type or superinterface type. Note that the rule in §8.4.8.2 speaks of a class that 'declares or inherits a static method', whereas the rule above speaks only of an interface that 'declares a static method', since an interface cannot inherit a static method. Also note that the rule in §8.4.8.2 allows hiding of both instance and static methods in superclasses/superinterfaces, whereas the rule above considers only public instance methods in superinterface types. Along the same lines, a private method in an interface cannot override an instance method - whether public or private - in a superinterface type. This is similar to the rules in §8.4.8.1 and §8.4.8.3 whereby a private method in a class cannot override any instance method in a superclass type or superinterface type, because §8.4.8.1 requires the overridden method to be non-private and §8.4.8.3 requires the overriding method to provide at least as much access as the overridden method. In summary, only public methods in interfaces can be overridden, and only by public methods in subinterfaces or in implementing classes.",8.94,167.02,324.01,1311,90,278.1,414.01,445.12,FALSE,FALSE
407,7,BODY,"If this code was legal, then multiple levels of containment would be needed: first the base annotations of interface Foo would be contained by an implicitly declared container annotation of interface FooContainer, then that annotation and the explicitly declared",8.94,25.02,324,262,90,576.1,414,601.12,FALSE,FALSE
410,5,BODY,"In the following interface hierarchy, Z is a functional interface because while it inherits two abstract methods which are not members of Object, they have the same signature, so the inherited methods logically represent a single method:",8.94,25.02,324,237,90,203.1,414,228.12,FALSE,FALSE
450,5,BODY,"This can occur, for example, if a class that is originally not abstract is changed to be abstract after another class that refers to the class in question has been compiled (§13.4.1).",8.94,25.02,314,183,100,261.1,414,286.12,FALSE,FALSE
452,7,BODY,"The class One is never initialized, because it not used actively and therefore is never linked to. The class Two is initialized only after its superclass Super has been initialized.",8.94,15.02,324.01,181,90,401.1,414.01,416.12,FALSE,FALSE
462,3,BODY,"The finalizer guardian forces super.finalize to be called if a subclass overrides finalize and does not explicitly call super.finalize. If these optimizations are allowed for references that are stored on the heap, then a Java compiler can detect that the finalizerGuardian field is never read, null it out, collect the object immediately, and call the finalizer early. This runs counter to the intent: the programmer probably wanted to call the Foo finalizer when the Foo instance became unreachable. This sort of transformation is therefore not legal: the inner class object should be reachable for as long as the outer class object is reachable. Transformations of this sort may result in invocations of the finalize method occurring earlier than might be otherwise expected. In order to allow the user to prevent this, we enforce the notion that synchronization may keep the object alive. If an object's finalizer can result in synchronization on that object, then that object must be alive and considered reachable whenever a lock is held on it. Note that this does not prevent synchronization elimination: synchronization only keeps an object alive if a finalizer might synchronize on it. Since the finalizer occurs in another thread, in many cases the synchronization could not be removed anyway.",8.94,191.02,324.01,1303,90,178.1,414.01,369.12,FALSE,FALSE
483,8,BODY,then these classes compile and Test executes to produce the output:,8.94,5.02,246.16,67,90,420.1,336.16,425.12,FALSE,FALSE
531,3,BODY,"switch statements differ from switch expressions in terms of which expressions may appear to the right of an arrow (->) in the switch block, that is, which expressions may be used as switch rule expressions. In a switch statement, only a statement expression may be used as a switch rule expression, but in a switch expression, any expression may be used (§15.28.1).",8.94,45.02,314,366,100,255.1,414,300.12,FALSE,FALSE
574,6,BODY,"The idea is that it should be possible to change the value of DEBUG from false to true or from true to false and then compile the code correctly with no other changes to the program text. Conditional compilation comes with a caveat. If a set of classes that use a 'flag' variable - or more precisely, any static constant variable (§4.12.4) - are compiled and conditional code is omitted, it does not suffice later to distribute just a new version of the class or interface that contains the definition of the flag. The classes that use the flag will not see its new value, so their behavior may be surprising. In essence, a change to the value of a flag is binary compatible with pre-existing binaries (no LinkageError occurs) but not behaviorally compatible. Another reason for 'inlining' values of static constant variables is because of switch statements. They are the only kind of statement that relies on constant expressions, namely that each case label of a switch statement must be a constant expression whose value is different than every other case label. case labels are often references to static constant variables so it may not be immediately obvious that all the labels have different values. If it is proven that there are no duplicate labels at compile time, then inlining the values into the class file ensures there are no duplicate labels at run time either - a very desirable property.",8.94,189.02,324.01,1406,90,312.1,414.01,501.12,FALSE,FALSE
587,5,BODY,"The floating-point remainder operator % (§15.17.3) does not correspond to the IEEE 754 remainder operation. Some IEEE 754 operations without corresponding operators in the Java programming language are provided via methods in the Math and StrictMath classes, including the sqrt method for the IEEE 754 squareRoot operation, the fma method for the IEEE 754 fusedMultiplyAdd operation, and the IEEEremainder method for the IEEE 754 remainder operation.",8.94,77.02,324,450,90,337.1,414,414.12,FALSE,FALSE
588,2,BODY,as replacing (a * b + c) with a call to a fused multiply-accumulate library method are not allowed unless the result can be proven to be identical.,8.94,15.02,324,147,90,74.1,414,89.12,FALSE,FALSE
590,2,BODY,"In Java SE 17 and later, the Java SE Platform always requires strict evaluation of floating- point expressions. Newer members of the processor families that had performance problems implementing strict evaluation no longer have that difficulty. This specification no longer associates float and double with the four value sets described above, and the strictfp modifier no longer affects the evaluation of floating-point expressions. For compatibility, strictfp remains a keyword in Java SE 23 (§3.8) and continues to have restrictions on its use (§8.4.3, §9.4), although Java compilers are encouraged to warn the programmer about its obsolete status. Future versions of the Java programming language may redefine or remove the strictfp keyword.",8.94,85.02,324.01,745,90,74.1,414.01,159.12,FALSE,FALSE
598,6,BODY,because the assignment of 3 to id is not executed.,8.94,5.02,180.87,50,90,311.1,270.87,316.12,FALSE,FALSE
616,5,BODY,"When <> is used, the inferred type arguments may not be as anticipated by the programmer. Consequently, the supertype of the anonymous class may not be as anticipated, and methods declared in the anonymous class may not override supertype methods as intended. Treating such methods as if annotated with @Override (if they are not explicitly annotated with @Override) helps avoid silently incorrect programs.",8.94,45.02,324.01,407,90,469.1,414.01,514.12,FALSE,FALSE
625,5,BODY,"because the embedded assignment of 2 to index occurs before the check for a null array reference expression. As a related example, the program:",8.94,15.02,324,143,90,170.1,414,185.12,FALSE,FALSE
628,8,BODY,The following program demonstrates that a null reference may be used to access a class (static) variable without causing an exception:,8.94,15.02,323.99,134,90,439.1,413.99,454.12,FALSE,FALSE
662,3,BODY,"Overriding is sometimes called 'late-bound self-reference'; in this example it means that the reference to clear in the body of Point.move (which is really syntactic shorthand for this.clear) invokes a method chosen 'late' (at run time, based on the run-time class of the object referenced by this) rather than a method chosen 'early' (at compile time, based only on the type of this). This provides the programmer a powerful way of extending abstractions and is a key idea in object-oriented programming.",8.94,55.02,324.01,505,90,166.1,414.01,221.12,FALSE,FALSE
731,2,BODY,"a method, or when the body is another lambda expression. It also clearly distinguishes between its expression and statement forms, which avoids ambiguities or over-reliance on ';' tokens. When some extra bracketing is needed to visually distinguish either the full lambda expression or its body expression, parentheses are naturally supported (just as in other cases in which operator precedence is unclear). The syntax has some parsing challenges. The Java programming language has always required arbitrary lookahead to distinguish between types and expressions after a '(' token: what follows may be a cast or a parenthesized expression. This was made worse when generics reused the binary operators '<' and '>' in types. Lambda expressions introduce a new possibility: the tokens following '(' may describe a type, an expression, or a lambda parameter list. Some tokens immediately indicate a parameter list (annotations, final); in other cases there are certain patterns that must be interpreted as parameter lists (two names in a row, a ',' not nested inside of '<' and '>'); and sometimes, the decision cannot be made until a '->' is encountered after a ')'. The simplest way to think of how this might be efficiently parsed is with a state machine: each state represents a subset of possible interpretations (type, expression, or parameters), and when the machine transitions to a state in which the set is a singleton, the parser knows which case it is. This does not map very elegantly to a fixed-lookahead grammar, however. There is no special nullary form: a lambda expression with zero arguments is expressed as () -> .... The obvious special-case syntax, -> ..., does not work because it introduces an ambiguity between argument lists and casts: (x) -> .... Lambda expressions cannot declare type parameters. While it would make sense semantically to do so, the natural syntax (preceding the parameter list with a type parameter list) introduces messy ambiguities. For example, consider: foo( (x) < y , z > (w) -> v )",8.94,292.01,324.01,2031,90,74.1,414.01,366.11,FALSE,FALSE
749,8,BODY,"as far as definite assignment of k is concerned, because the rules outlined in this section allow it to tell that k is assigned no matter whether the flag is true or false. But the rules do not accept the variation:",8.94,25.02,324,215,90,483.1,414,508.12,FALSE,FALSE
751,3,BODY,"when the expression is true but not when the expression is false (because if a is false, then the assignment to k is not necessarily executed (more properly, evaluated)).",8.94,15.02,324,170,90,229.1,414,244.12,FALSE,FALSE
770,5,BODY,"This is because an enum constant is essentially a static final field (§8.3.1.1, §8.3.1.2) that is initialized with a class instance creation expression (§15.9).",8.94,15.02,324,160,90,326.1,414,341.12,FALSE,FALSE
782,2,BODY,"If some execution exhibited this behavior, then we would know that instruction 4 came before instruction 1, which came before instruction 2, which came before instruction 3, which came before instruction 4. This is, on the face of it, absurd. However, compilers are allowed to reorder the instructions in either thread, when this does not affect the execution of that thread in isolation. If instruction 1 is reordered with instruction 2, as shown in the trace in Table 17.4-B, then it is easy to see how the result r2 == 2 and r1 == 1 might occur.",8.94,77.02,324,548,90,74.1,414,151.12,FALSE,FALSE
791,11,BODY,"We use f|d to denote the function given by restricting the domain of f to d. For all x in d, f|d(x) = f(x), and for all x not in d, f|d(x) is undefined. We use p|d to represent the restriction of the partial order p to the elements in d. For all x,y in d, p(x,y) if and only if p|d(x,y). If either x or y are not in d, then it is not the case that p|d(x,y).",8.94,50.07,324,357,90,479.1,414,529.17,FALSE,FALSE
30,7,BODY,IfThenStatement: if ( Expression ) Statement,8.93,14.95,113.69,44,108,435.15,221.69,450.1,FALSE,TRUE
49,6,BODY,"The suffix L is preferred, because the letter l (ell) is often hard to distinguish from the digit 1 (one).",8.93,15.02,324.01,106,90,567.1,414.01,582.12,FALSE,FALSE
63,4,BODY,This example illustrates six points: •String literals in the same class and package represent references to the same String object (§4.3.1). •String literals in different classes in the same package represent references to the same String object. •String literals in different classes in different packages likewise represent references to the same String object. •Strings concatenated from constant expressions (§15.29) are computed at compile time and then treated as if they were literals. •Strings computed by concatenation at run time are newly created and therefore distinct. •The result of explicitly interning a computed string is the same String object as any pre-existing string literal with the same contents.,8.93,157.02,324,720,90,168.1,414,325.12,FALSE,FALSE
88,2,BODY,"If C had been declared in a different package than T, then the call to mCPackage would give rise to a compile-time error, as that member would not be accessible at the point where T is declared.",8.93,25.02,324.02,194,90,74.1,414.02,99.12,FALSE,FALSE
113,6,BODY,"gives rise to a compile-time unchecked warning, because it is not possible to ascertain, either at compile time (within the limits of the compile-time type checking rules) or at run time, whether the variable l does indeed refer to a List<String>. If the code above is executed, heap pollution arises, as the variable ls, declared to be a List<String>, refers to a value that is not in fact a List<String>. The problem cannot be identified at run time because type variables are not reified, and thus instances do not carry any information at run time regarding the type arguments used to create them.",8.93,99.02,324.01,601,90,498.1,414.01,597.12,FALSE,FALSE
169,2,BODY,"2.In a single-type-import declaration (§7.5.1) 3.To the left of the . in a single-static-import declaration (§7.5.3) 4.To the left of the . in a static-import-on-demand declaration (§7.5.4) 5.In a permits clause of a sealed class or interface declaration (§8.1.6, §9.1.4). 6.To the left of the ( in a constructor declaration (§8.8) 7.After the @ sign in an annotation (§9.7) 8.To the left of .class in a class literal (§15.8.2) 9.To the left of .this in a qualified this expression (§15.8.4) 10.To the left of .super in a qualified superclass field access expression (§15.11.2) 11.To the left of .Identifier or .super.Identifier in a qualified method invocation",8.93,149.02,324,661,90,74.1,414,223.12,FALSE,FALSE
182,4,BODY,It should be noted that there are no rules for introducing a pattern variable by a ? b : c when true or false. This is because it cannot be determined at compile time whether the operand a will evaluate to true.,8.93,25.02,324,211,90,302.36,414,327.38,FALSE,FALSE
236,8,BODY,"causes a compile-time error because of the duplicate declaration of Vector, as does:",8.93,5.02,304.97,84,90,497.1,394.97,502.12,FALSE,FALSE
247,7,BODY,where the package p exported by m.D is declared as follows:,8.93,5.02,218.15,59,90,445.1,308.15,450.12,FALSE,FALSE
291,9,BODY,"This program compiles without error; it initializes j to 1 when class Test is initialized, and initializes f to the current value of j every time an instance of class Test is created.",8.93,15.02,324,183,90,336.1,414,351.12,FALSE,FALSE
304,7,BODY,"These are the same monitors that can be used by the synchronized statement (§14.19). Thus, the code:",8.93,27.02,319.3,100,90,554.1,409.3,581.12,FALSE,FALSE
323,3,BODY,"Here, the overriding methods getX and getY in class RealPoint have the same return types as the methods of class Point that they override, so this code can be successfully compiled. Consider, then, this test program:",8.93,47.02,324,216,90,106.1,414,153.12,FALSE,FALSE
334,4,BODY,If the first constructor of ColoredPoint in the example from §8.8.7 were changed as follows:,8.93,15.02,324,92,90,153.1,414,168.12,FALSE,FALSE
335,6,BODY,"The effect is that manipulation of instance variables in the common instance of Outer is visible through references to different instances of ChildOfInner, even though such references are not aliases in the conventional sense.",8.93,25.02,324,226,90,402.1,414,427.12,FALSE,FALSE
386,14,BODY,"This is implied by the requirement on the value() method of the containing annotation interface. Specifically, if an annotation interface A specified itself (via @Repeatable) as its containing annotation interface, then the return type of A's value() method would have to be A[]; but this would cause a compile-time error since an annotation interface cannot refer to itself in its elements (§9.6.1). More generally, two annotation interfaces",8.93,45.02,324,442,90,558.1,414,603.12,FALSE,FALSE
393,6,BODY,"The use of @Override on the accessor method int x() ensures that if the record component x is modified or removed, then the corresponding accessor method must be modified or removed too.",8.93,25.02,324,186,90,348.1,414,373.12,FALSE,FALSE
394,3,BODY,"Compiler vendors are encouraged to document the strings they support for @SuppressWarnings, and to cooperate to ensure that the same strings are recognized across multiple compilers.",8.93,25.02,324,182,90,201.1,414,226.12,FALSE,FALSE
410,7,BODY,"Similarly, Z is a functional interface in the following interface hierarchy because Y.m is a subsignature of X.m and is return-type-substitutable for X.m:",8.93,15.02,324,154,90,287.1,414,302.12,FALSE,FALSE
458,7,BODY,"Therefore, the constructor for Object which takes no arguments is invoked. The class Object has no superclass, so the recursion terminates here. Next, any instance initializers and instance variable initializers of Object are invoked. Next, the body of the constructor of Object that takes no arguments is executed. No such constructor is declared in Object, so the Java compiler supplies a default one, which in this special case is:",8.93,57.02,324.01,434,90,344.1,414.01,401.12,FALSE,FALSE
465,3,BODY,"Readers are referred to the API specifications of Thread and Runtime for details of how threads obtain daemon status, and how shutdown hooks are registered.",8.93,15.02,324,156,90,144.1,414,159.12,FALSE,FALSE
474,2,BODY,"•The formal parameter name of the valueOf method which is implicitly declared in an enum class (§8.9.3). •The formal parameters of a compact constructor of a record class (§8.10.4). For reference, the following constructs are declared implicitly in source code, but are not marked as mandated because only formal parameters and modules can be so marked in a class file (JVMS §4.7.24, JVMS §4.7.25): •Default constructors of normal and enum classes (§8.8.9, §8.9.2) •Canonical constructors of record classes (§8.10.4) •Anonymous constructors (§15.9.5.1) •The values and valueOf methods of enum classes (§8.9.3) •Certain public fields of enum classes (§8.9.3) •Certain private fields and public methods of record classes (§8.10.3) •Certain public methods of interfaces (§9.2) •Container annotations (§9.7.5)",8.93,207.02,324,805,90,74.1,414,281.12,FALSE,FALSE
525,4,BODY,As the selector expression has type J<Integer> the permitted direct subclass D need not be considered as there is no possibility that the value of ji can be an instance of D.,8.93,15.02,314,174,100,523.1,414,538.12,FALSE,FALSE
532,4,BODY,"For compatibility reasons, switch statements that are not enhanced switch statements are not required to be exhaustive.",8.93,15.02,324,119,90,190.1,414,205.12,FALSE,FALSE
545,6,BODY,"The following program, which calculates the sum of an integer array, shows how enhanced for works for arrays:",8.93,15.02,324,109,90,517.1,414,532.12,FALSE,FALSE
547,5,BODY,"The task of the method loseEdges, given integers i and j, is to construct a new graph by copying a given graph but omitting the edge from node i to node j, if any, and the edge from node j to node i, if any:",8.93,25.02,324.01,207,90,297.1,414.01,322.12,FALSE,FALSE
552,2,BODY,The reference type of the Expression will always be a class type (since no interface types are assignable to Throwable) which is not parameterized (since a subclass of Throwable cannot be generic (§8.1.2)).,8.93,25.02,324,206,90,74.1,414,99.12,FALSE,FALSE
568,5,BODY,"It can be seen, then, that a yield statement always completes abruptly.",8.93,5.02,256.96,71,90,398.1,346.96,403.12,FALSE,FALSE
615,7,BODY,"because the out-of-memory condition is detected before the argument expression oldid = id is evaluated. Compare this to the treatment of array creation expressions, for which the out-of-memory condition is detected after evaluation of the dimension expressions (§15.10.2).",8.93,47.02,324,272,90,419.1,414,466.12,FALSE,FALSE
620,7,BODY,"because the first dimension is calculated as 4 before the second dimension expression sets i to 3. If evaluation of a dimension expression completes abruptly, no part of any dimension expression to its right will appear to have been evaluated. Thus:",8.93,47.02,324,249,90,267.1,414,314.12,FALSE,FALSE
624,12,BODY,"If the array reference expression produces null instead of a reference to an array, then a NullPointerException is thrown at run time, but only after all parts of the array access expression have been evaluated and only if these evaluations completed normally. Thus, the program:",8.93,35.02,324,279,90,482.1,414,517.12,FALSE,FALSE
629,5,BODY,"Thus, super.f can access the field f that is accessible in class S, even if that field is hidden by a declaration of a field f in class C.",8.93,15.02,324,138,90,528.1,414,543.12,FALSE,FALSE
638,5,BODY,"Here, the most specific declaration of method test is the one taking a parameter of type ColoredPoint. Because the result type of the method is int, a compile-time error occurs because an int cannot be converted to a String by assignment conversion. This example shows that the result types of methods do not participate in resolving overloaded methods, so that the second test method, which returns a String, is not chosen, even though it has a result type that would allow the example program to compile without error.",8.93,55.02,324.01,520,90,279.1,414.01,334.12,FALSE,FALSE
641,3,BODY,"Whether a member method is accessible at a method invocation depends on the access modifier (public, protected, no modifier (package access), or private) in the member's declaration, and on the inheritance of the member by the class or interface determined by compile-time step 1, and on where the method invocation appears.",8.93,35.02,314,324,100,176.1,414,211.12,FALSE,FALSE
664,8,BODY,"This is the method that would actually be invoked by the Java Virtual Machine in response to the call c.id(new Object()) shown above, and it will execute the cast and fail, as required.",8.93,25.02,324,185,90,459.1,414,484.12,FALSE,FALSE
731,5,BODY,"Thus, if the lambda expression has exactly one formal parameter, it may be specified by the singleton list (int x) or (x), or by eliding the parentheses altogether, as x.",8.93,15.02,323.99,170,90,580.1,413.99,595.12,FALSE,FALSE
741,6,BODY,"The body of both a switch expression and a switch statement (§14.11) is called a switch block. General rules which apply to all switch blocks, whether they appear in switch expressions or switch statements, are given in §14.11.1. The following productions from §14.11.1 are shown here for convenience:",8.93,35.02,324,301,90,422.1,414,457.12,FALSE,FALSE
748,9,BODY,"the variable k is definitely assigned by the while statement because the condition expression true never has the value false, so only the break statement can cause the while statement to complete normally, and k is definitely assigned before the break statement. On the other hand, the code:",8.93,57.02,324,291,90,484.1,414,541.12,FALSE,FALSE
750,5,BODY,"as far as definite unassignment of k is concerned, because the rules outlined in this section allow it to tell that k is assigned at most once (indeed, exactly once) no matter whether the flag is true or false. But the rules do not accept the variation:",8.93,25.02,324.01,253,90,287.1,414.01,312.12,FALSE,FALSE
751,5,BODY,"A peculiar consequence of this definition is that 'V is definitely assigned after break;' is always true! Because a break statement never completes normally, it is vacuously true that V has been assigned a value if the break statement completes normally.",8.93,25.02,324,254,90,325.1,414,350.12,FALSE,FALSE
751,7,BODY,"An even more peculiar consequence of this definition is that 'V is definitely unassigned after break;' is always true! Because a break statement never completes normally, it is vacuously true that V has not been assigned a value if the break statement completes normally. (For that matter, it is also vacuously true that the moon is made of green cheese if the break statement completes normally.)",8.93,45.02,324,397,90,418.1,414,463.12,FALSE,FALSE
783,5,BODY,"Now consider the case where the assignment to r6.x in Thread 2 happens between the first read of r1.x and the read of r3.x in Thread 1. If the compiler decides to reuse the value of r2 for the r5, then r2 and r5 will have the value 0, and r4 will have the value 3. From the perspective of the programmer, the value stored at p.x has changed from 0 to 3 and then changed back.",8.93,45.02,324,375,90,249.6,414,294.62,FALSE,FALSE
797,4,BODY,The program below illustrates how final fields compare to normal fields.,8.93,5.02,269.21,72,90,147.1,359.21,152.12,FALSE,FALSE
798,2,BODY,"String objects are intended to be immutable and string operations do not perform synchronization. While the String implementation does not have any data races, other code could have data races involving the use of String objects, and the memory model makes weak guarantees for programs that have data races. In particular, if the fields of the String class were not final, then it would be possible (although unlikely) that thread 2 could initially see the default value of 0 for the offset of the string object, allowing it to compare as equal to '/tmp'. A later operation on the String object might see the correct offset of 4, so that the String object is perceived as being '/usr'. Many security features of the Java programming language depend upon String objects being perceived as truly immutable, even if malicious code is using data races to pass String references between threads.",8.93,105.02,324,890,90,74.1,414,179.12,FALSE,FALSE
827,7,BODY,"α = Number Finally, we perform a substitution on the declared return type of asList to determine that the method invocation has type List<Number>; clearly, this is compatible with the target type. This inference strategy is different than the Java SE 7 Edition of The Java® Language Specification, which would have instantiated α based on its lower bounds (before even considering the invocation's target type), as we did in the previous section. This would result in a type error, since the resulting type is not a subtype of List<Number>. Under various special circumstances, based on the bounds appearing in B2, we eagerly resolve an inference variable that appears as the return type of the invocation. This is to avoid unfortunate situations in which the usual constraint, ‹R θ → T›, is not completeness- preserving. It is, unfortunately, possible that by eagerly resolving the variable, we are unable to make use of bounds that would be inferred later. It is also possible that, in some cases, bounds that will later be inferred from the invocation arguments (such as implicitly typed lambda expressions) would have caused a different outcome if they had been present in B2. Despite these limitations, the strategy allows for reasonable outcomes in typical use cases, and is backwards compatible with the algorithm in the Java SE 7 Edition of The Java® Language Specification.",8.93,218.96,324.01,1382,90,287.55,414.01,506.51,FALSE,FALSE
37,3,BODY,"The input characters a--b are tokenized as a, --, and b, which is not part of any grammatically correct program, even though the tokenization a, -, -, b could be part of a grammatically correct program. The tokenization a, -, -, b can be realized with the input characters a- -b (with an ASCII SP character between the two - characters). It might be supposed that the raw input \\u1234 is translated to a \ character and (following the 'longest possible' rule) a Unicode escape of the form \u1234. In fact, the leading \ character causes this raw input to be translated to seven distinct characters: \ \ u 1 2 3 4.",8.92,77.02,324,614,90,125.1,414,202.12,FALSE,FALSE
39,2,BODY,"Note that \u005cu005a cannot be written in a string literal to denote the six characters \ u 0 0 5 a. This is because the first two characters resulting from translation, \ and u, are interpreted in a string literal as an illegal escape sequence (§3.10.7). Fortunately, the rule about contiguous backslash characters helps programmers to craft raw inputs that denote Unicode escapes in a string literal. Denoting the six characters \ u 0 0 5 a in a string literal simply requires another \ to be placed adjacent to the existing \, such as '\\u005a is Z'. This works because the second \ in the raw input \\u005a is not eligible to begin a Unicode escape, so the first \ and the second \ are preserved as raw input characters, as are the next five characters u 0 0 5 a. The two \ characters are subsequently interpreted in a string literal as the escape sequence for a backslash, resulting in a string with the desired six characters \ u 0 0 5 a. Without the rule, the raw input \\u005a would be processed as a raw input character \ followed by a Unicode escape \u005a which becomes a raw input character Z; this would be unhelpful because \Z is an illegal escape sequence in a string literal. (Note that the rule translates \u005c\u005c to \\ because the translation of the first Unicode escape to a raw input character \ does not prevent the translation of the second Unicode escape to another raw input character \.) The rule also allows programmers to craft raw inputs that denote escape sequences in a string literal. For example, the raw input \\\u006e results in the three characters \ \ n because the first \ and the second \ are preserved as raw input characters, while the third \ is eligible to begin a Unicode escape and thus \u006e is translated to a raw input character n. The three characters \ \ n are subsequently interpreted in a string literal as \ n which denotes the escape sequence for a linefeed. (Note that \\\u006e may be written as \u005c \u005c\u006e because each Unicode escape \u005c is translated to a raw input character \ and so the remaining raw input \u006e is preceded by an even number of backslashes and processed as the Unicode escape for n.)",8.92,269.02,324.01,2179,90,74.1,414.01,343.12,FALSE,FALSE
87,5,BODY,"The type variable T has the same members as the intersection type C & I, which in turn has the same members as the empty class CT, defined in the same scope with equivalent supertypes. The members of an interface are always public, and therefore always inherited (unless overridden). Hence mI is a member of CT and of T. Among the members of C, all but mCPrivate are inherited by CT, and are therefore members of both CT and T.",8.92,45.02,324,427,90,550.1,414,595.12,FALSE,FALSE
91,8,BODY,"Here, the method is declared within the interface Collection<E>, and is designed to add all the elements of its incoming argument to the collection upon which it is invoked. A natural tendency would be to use Collection<E> as the type of c, but this is unnecessarily restrictive. An alternative would be to declare the method itself to be generic:",8.92,35.02,324.01,347,90,540.1,414.01,575.12,FALSE,FALSE
130,7,BODY,thus indicating that information was lost during the conversion from type int to type float because values of type float are not precise to nine significant digits.,8.92,15.02,324,164,90,301.1,414,316.12,FALSE,FALSE
136,5,BODY,"For this reason, D is not disjoint from J, and there is a narrowing reference conversion from D to J. The final clause above implies that two freely extensible interfaces (§9.1.1.4) are not disjoint.",8.92,47.02,324,199,90,403.1,414,450.12,FALSE,FALSE
169,4,BODY,12.To the left of .super:: in a method reference expression (§15.13) 13.In a qualified expression name in a postfix expression or a try-with-resources,8.92,21.02,324,150,90,244.1,414,265.12,FALSE,FALSE
205,7,BODY,"In this example, the name java.util.Date must denote a type, so we first use the procedure recursively to determine if java.util is an accessible class or interface or type parameter, or a package, which it is, and then we look to see if the class Date is accessible in this package.",8.92,35.02,324.01,283,90,281.96,414.01,316.99,FALSE,FALSE
235,3,BODY,"An import declaration makes classes, interfaces, or members available by their simple names only within the compilation unit that actually contains the import declaration. The scope of the class(es), interface(s), or member(s) introduced by an import declaration specifically does not include other compilation units in the same package, other import declarations in the current compilation unit, or a package declaration in the current compilation unit (except for the annotations of a package declaration).",8.92,55.02,324,508,90,247.1,414,302.12,FALSE,FALSE
242,7,BODY,"the fully qualified name of the class Point is vista.Point. (The package name vista is suitable for local or personal use; if the package were intended to be widely distributed, it would be better to give it a unique package name (§6.1).)",8.92,25.02,324,238,90,386.1,414,411.12,FALSE,FALSE
264,6,BODY,"It is unusual, but possible, for the immediately enclosing class or interface declaration of an inner class to be an interface. This only occurs if the class is a local or anonymous class declared in a default or static method body (§9.4).",8.92,25.02,324.01,239,90,481.1,414.01,506.12,FALSE,FALSE
266,3,BODY,"The declaration of class LocalInStaticContext occurs in a static context due to being within the static method classMethod. Instance variables of class Outer are not available within the body of a static method. In particular, instance variables of Outer are not available inside the body of LocalInStaticContext. However, local variables from the surrounding method may be referred to without error (provided they are declared final or are effectively final). Inner classes whose declarations do not occur in a static context may freely refer to the instance variables of their enclosing class declaration. An instance variable is always defined with respect to an instance. In the case of instance variables of an enclosing class declaration, the instance variable must be defined with respect to an enclosing instance of the inner class. For example, the class Local above has an enclosing instance of class Outer. As a further example:",8.92,127.02,324,939,90,146.1,414,273.12,FALSE,FALSE
276,7,BODY,Consider the example where the points package declares two compilation units:,8.92,5.02,293.75,77,90,483.1,383.75,488.12,FALSE,FALSE
289,7,BODY,"This prevents method one and method two from being executed concurrently, and furthermore guarantees that the shared values of i and j are both updated before method one returns. Therefore method two never observes a value for j greater than that for i; indeed, it always observes the same value for i and j. Another approach would be to declare i and j to be volatile:",8.92,57.02,324,369,90,369.1,414,426.12,FALSE,FALSE
305,6,BODY,"This program defines a class which is designed for concurrent use. Each instance of the class Box has an instance variable boxContents that can hold a reference to any object. You can put an object in a Box by invoking put, which returns false if the box is already full. You can get something out of a Box by invoking get, which returns a null reference if the box is empty. If put and get were not synchronized, and two threads were executing methods for the same instance of Box at the same time, then the code could misbehave. It might, for example, lose track of an object because two invocations to put occurred at the same time.",8.92,87.02,324,635,90,516.1,414,603.12,FALSE,FALSE
320,3,BODY,"This exception to the strict default-abstract and default-default conflict rules is made when an abstract method is declared in a superclass: the assertion of abstract-ness coming from the superclass hierarchy essentially trumps the default method, making the default method act as if it were abstract. However, the abstract method from a class does not override the default method(s), because interfaces are still allowed to refine the signature of the abstract method coming from the class hierarchy. Note that the exception does not apply if all override-equivalent abstract methods inherited by C were declared in interfaces.",8.92,87.02,324.01,629,90,170.1,414.01,257.12,FALSE,FALSE
343,3,BODY,Example 8.9.3-1. Iterating Over Enum Constants With An Enhanced for Loop,8.92,5.19,302.55,72,90,200.62,392.55,205.81,TRUE,FALSE
379,6,BODY,"Unlike a normal interface declaration, an annotation interface declaration cannot choose the direct superinterface type via an extends clause, by virtue of the AnnotationTypeDeclaration production. A consequence of the fact that an annotation interface declaration does not explicitly specify a superinterface type via extends is that a subinterface of an annotation interface is never itself an annotation interface, since the subinterface's declaration necessarily uses an extends clause. Similarly, java.lang.annotation.Annotation is not itself an annotation interface.",8.92,87.02,324,572,90,349.1,414,436.12,FALSE,FALSE
380,7,BODY,"By virtue of the grammar above, a method declaration in an annotation interface declaration cannot have formal parameters, type parameters, or a throws clause; and cannot be private, default, or static. Thus, an annotation interface cannot have the same variety of methods as a normal interface. Note that it is still possible for an annotation interface to inherit a default method from its implicit superinterface, java.lang.annotation.Annotation, though no such default method exists as of Java SE 23. By convention, the only modifiers that should be present on the declaration of an annotation interface element are annotations.",8.92,97.02,324.01,632,90,452.1,414.01,549.12,FALSE,FALSE
386,12,BODY,"This is implied by the requirement that if the declaration of an annotation interface A specifies a containing annotation interface of AC, then the value() method of AC has a return type involving A, specifically A[].",8.92,25.02,324,217,90,491.1,414,516.12,FALSE,FALSE
396,6,BODY,"The variable arity parameter has declared type T[], which is non-reifiable. However, the method fundamentally just reads from the input array and adds the elements to a collection, both of which are safe operations with respect to the array. Therefore, any compile-time unchecked warnings at method invocation expressions for java.util.Collections.addAll are arguably spurious and uninformative. Applying @SafeVarargs to the method declaration prevents generation of these unchecked warnings at the method invocation expressions.",8.92,65.02,324.01,529,90,501.23,414.01,566.25,FALSE,FALSE
397,4,BODY,"Note that an @Repeatable meta-annotation on the declaration of A, indicating AC, is not sufficient to make AC the containing annotation interface of A. There are numerous well- formedness rules for AC to be considered the containing annotation interface of A.",8.92,25.02,324,259,90,279.23,414,304.25,FALSE,FALSE
410,9,BODY,"The definition of functional interface respects the fact that an interface cannot have two members which are not subsignatures of each other, yet have the same erasure (§9.4.1.2). Thus, in the following three interface hierarchies where Z causes a compile-time error, Z is not a functional interface: (because none of its abstract members are subsignatures of all other abstract members)",8.92,45.02,324,387,90,361.1,414,406.12,FALSE,FALSE
437,3,BODY,"By the rules above, each alternative in a multi-catch clause (§14.20) must be able to catch some exception class thrown by the try block and uncaught by previous catch clauses. For example, the second catch clause below would cause a compile-time error because exception analysis determines that SubclassOfFoo is already caught by the first catch clause:",8.92,45.02,324,354,90,536.1,414,581.12,FALSE,FALSE
458,9,BODY,"This constructor executes without effect and returns. Next, all initializers for the instance variables of class Point are executed. As it happens, the declarations of x and y do not provide any initialization expressions, so no action is required for this step of the example. Then the body of the Point constructor is executed, setting x to 1 and y to 1. Next, the initializers for the instance variables of class ColoredPoint are executed. This step assigns the value 0xFF00FF to color. Finally, the rest of the body of the ColoredPoint constructor is executed (the part after the invocation of super); there happen to be no statements in the rest of the body, so no further action is required and initialization is complete.",8.92,119.02,324,728,90,440.1,414,559.12,FALSE,FALSE
477,6,BODY,"Note that evolving a sealed class by adding a permitted direct subclass is considered a binary compatible change because pre-existing binaries that previously linked without error (e.g., a class file that contains an exhaustive switch (§14.11.1)) will continue to link without error. A class file that contains an exhaustive switch will not fail to link if the sealed class that it switches over is expanded by the hierarchy's owner to have a new permitted direct subclass. The JVM is not required to perform exhaustiveness checks when linking a class file that contains an exhaustive switch. The execution of an exhaustive switch can fail with an error (a MatchException is thrown) if it encounters an instance of a permitted direct subclass that was not known at compile time (§14.11.3, §15.28.2). Strictly speaking, the error is not flagging a binary incompatible change of the sealed class, but more accurately a migration incompatible change of the sealed class.",8.92,127.02,324.01,967,90,463.23,414.01,590.25,FALSE,FALSE
479,11,BODY,Suppose that a new version of class Super is then compiled:,8.92,5.02,218.48,59,90,576.1,308.48,581.12,FALSE,FALSE
547,2,BODY,"It can be seen, then, that a break statement always completes abruptly. The preceding descriptions say 'attempts to transfer control' rather than just 'transfers control' because if there are any try statements (§14.20) within the break target whose try blocks or catch clauses contain the break statement, then any finally clauses of those try statements are executed, in order, innermost to outermost, before control is transferred to the break target. Abrupt completion of a finally clause can disrupt the transfer of control initiated by a break statement.",8.92,77.02,324.01,560,90,74.1,414.01,151.12,FALSE,FALSE
551,3,BODY,"It can be seen, then, that a return statement always completes abruptly. The preceding descriptions say 'attempts to transfer control' rather than just 'transfers control' because if there are any try statements (§14.20) within the method or constructor whose try blocks or catch clauses contain the return statement, then any finally clauses of those try statements will be executed, in order, innermost to outermost, before control is transferred to the invoker of the method or constructor. Abrupt completion of a finally clause can disrupt the transfer of control initiated by a return statement.",8.92,77.02,324,600,90,260.1,414,337.12,FALSE,FALSE
557,6,BODY,"where the multi-catch clause with two alternatives has been translated into two uni-catch clauses, one for each alternative. A Java compiler is neither required nor recommended to compile a multi-catch clause by duplicating code in this manner, since it is possible to represent the multi-catch clause in a class file without duplication.",8.92,35.02,324,338,90,566.1,414,601.12,FALSE,FALSE
573,6,BODY,"One might expect the if statement to be handled in the following manner: •An if-then statement can complete normally iff at least one of the following is true: –The if-then statement is reachable and the condition expression is not a constant expression whose value is true. –The then-statement can complete normally. The then-statement is reachable iff the if-then statement is reachable and the condition expression is not a constant expression whose value is false. •An if-then-else statement can complete normally iff the then-statement can complete normally or the else-statement can complete normally. The then-statement is reachable iff the if-then-else statement is reachable and the condition expression is not a constant expression whose value is false. The else-statement is reachable iff the if-then-else statement is reachable and the condition expression is not a constant expression whose value is true. This approach would be consistent with the treatment of other control structures. However, in order to allow the if statement to be used conveniently for 'conditional compilation' purposes, the actual rules differ.",8.92,239.02,324.01,1133,90,364.1,414.01,603.12,FALSE,FALSE
595,6,BODY,"That is, the left-hand operand forgetIt() of the operator / throws an exception before the right-hand operand is evaluated and its embedded assignment of 2 to j occurs.",8.92,15.02,324,168,90,301.1,414,316.12,FALSE,FALSE
596,11,BODY,"For example, !(x<y) may not be rewritten as x>=y, because these expressions have different values if either x or y is NaN or both are NaN.",8.92,15.02,324,138,90,412.1,414,427.12,FALSE,FALSE
600,2,BODY,"array, but which, without appropriate grammatical finesse, might also be interpreted as meaning the same as '(new int[3])[3]'. This ambiguity is eliminated by splitting the expected definition of Primary into Primary and PrimaryNoNewArray. (This may be compared to the splitting of Statement into Statement and StatementNoShortIf (§14.5) to avoid the 'dangling else' problem.)",8.92,57.02,324,376,90,74.1,414,131.12,FALSE,FALSE
622,6,BODY,"because the out-of-memory condition is detected after the dimension expression oldlen = len is evaluated. Compare this to class instance creation expressions (§15.9), which detect the out-of- memory condition before evaluating argument expressions (§15.9.4).",8.92,47.02,324,258,90,311.1,414,358.12,FALSE,FALSE
630,3,BODY,"Thus, T.super.f can access the field f that is accessible in class S, even if that field is hidden by a declaration of a field f in class T.",8.92,15.02,323.99,140,90,112.1,413.99,127.12,FALSE,FALSE
635,3,BODY,"This guarantees that any calls that were valid in the Java programming language before Java SE 5.0 are not considered ambiguous as the result of the introduction of variable arity methods, implicit boxing and/or unboxing. However, the declaration of a variable arity method (§8.4.1) can change the method chosen for a given method invocation expression, because a variable arity method is treated as a fixed arity method in the first phase. For example, declaring m(Object...) in a class which already declares m(Object) causes m(Object) to no longer be chosen for some invocation expressions (such as m(null)), as m(Object[]) is more specific.",8.92,75.02,306,644,108,183.1,414,258.12,FALSE,FALSE
637,3,BODY,"Here, a compile-time error occurs for the second invocation of setColor, because no applicable method can be found at compile time. The type of the literal 37 is int, and int cannot be converted to byte by invocation conversion. Assignment conversion, which is used in the initialization of the variable color, performs an implicit conversion of the constant from type int to byte, which is permitted because the value 37 is small enough to be represented in type byte; but such a conversion is not allowed for invocation conversion. If the method setColor had, however, been declared to take an int instead of a byte, then both method invocations would be correct; the first invocation would be allowed because invocation conversion does permit a widening conversion from byte to int. However, a narrowing cast would then be required in the body of setColor:",8.92,107.02,324,859,90,186.1,414,293.12,FALSE,FALSE
655,5,BODY,"When a target reference is computed and then discarded because the invocation mode is static, the reference is not examined to see whether it is null:",8.92,15.02,324,150,90,536.1,414,551.12,FALSE,FALSE
745,4,BODY,"Constant expressions are used as case labels in switch statements and switch expressions (§14.11, §15.28) and have a special significance in assignment contexts (§5.2) and the initialization of a class or interface (§12.4.2). They may also govern the ability of a while, do, or for statement to complete normally (§14.22), and the type of a conditional operator ? : with numeric operands.",8.92,45.02,324.01,388,90,544.1,414.01,589.12,FALSE,FALSE
753,5,BODY,"This is equivalent to saying that V is [un]assigned after e iff V is [un]assigned before e. Because a constant expression whose value is true never has the value false, and a constant expression whose value is false never has the value true, the first two rules are vacuously satisfied. They are helpful in analyzing expressions involving the operators && (§16.1.2), || (§16.1.3), ! (§16.1.4), and ? : (§16.1.5).",8.92,57.02,324,412,90,436.1,414,493.12,FALSE,FALSE
31,11,BODY,BasicForStatement: for ( ; [Expression] ; [ForUpdate] ) Statement for ( ForInit ; [Expression] ; [ForUpdate] ) Statement,8.91,24.95,217.09,120,108,374.15,325.09,399.1,FALSE,TRUE
91,4,BODY,"Note that using Collection<Object> as the type of the incoming parameter, c, would not be nearly as useful; the method could only be used with an argument expression that had type Collection<Object>, which would be quite rare. In contrast, the use of an unbounded wildcard allows any kind of collection to be passed as an argument. Here is an example where the element type of an array is parameterized by a wildcard:",8.91,57.02,324,417,90,391.1,414,448.12,FALSE,FALSE
126,2,BODY,"•A conversion from type Object to type Thread requires a run-time check to make sure that the run-time value is actually an instance of class Thread or one of its subclasses; if it is not, an exception is thrown. •A conversion from type Thread to type Object requires no run-time action; Thread is a subclass of Object, so any reference produced by an expression of type Thread is a valid reference value of type Object. •A conversion from type int to type long requires run-time sign-extension of a 32-bit integer value to the 64-bit long representation. No information is lost. •A conversion from type double to type long requires a non-trivial translation from a 64-bit floating-point value to the 64-bit integer representation. Depending on the actual run-time value, information may be lost.",8.91,123.02,324,796,90,99.1,414,222.12,FALSE,FALSE
193,2,BODY,"Since the scope of a class variable includes the entire body of the class (§8.2), the class variable x would normally be available throughout the entire body of the method main. In this example, however, the class variable x is shadowed within the body of the method main by the declaration of the local variable x. A local variable has as its scope the rest of the block in which it is declared (§6.3); in this case this is the rest of the body of the main method, namely its initializer '0' and the invocations of System.out.print and System.out.println. This means that: •The expression x in the invocation of print refers to (denotes) the value of the local variable x. •The invocation of println uses a qualified name (§6.6) Test.x, which uses the class type name Test to access the class variable x, because the declaration of Test.x is shadowed at this point and cannot be referred to by its simple name. The keyword this can also be used to access a shadowed field x, using the form this.x. Indeed, this idiom typically appears in constructors (§8.8):",8.91,199.02,324,1059,90,74.1,414,273.12,FALSE,FALSE
199,2,BODY,"For example, suppose a field declaration uses the type p.q.Foo[]. The brackets of the array type are ignored, and the term p.q.Foo is extracted as a dotted sequence of Identifiers to the left of the brackets in an array type, and classified as a TypeName. A later step determines which of p, q, and Foo is a type name or a package name. As another example, suppose a cast operator uses the type p.q.Foo<? extends String>. The term p.q.Foo is again extracted as a dotted sequence of Identifier terms, this time to the left of the < in a parameterized type, and classified as a TypeName. The term String is extracted as an Identifier in an extends clause of a wildcard type argument of a parameterized type, and classified as a TypeName.",8.91,97.02,324,735,90,74.1,414,171.12,FALSE,FALSE
210,3,BODY,"Note that this clause covers the use of enum constants (§8.9), since these always have a corresponding final class variable.",8.91,15.02,314,124,100,131.1,414,146.12,FALSE,FALSE
236,4,BODY,"causes the simple name Vector to be available within the class and interface declarations in a compilation unit. Thus, the simple name Vector refers to the class declaration Vector in the package java.util in all places where it is not shadowed (§6.4.1) or obscured (§6.4.2) by a declaration of a field, parameter, local variable, or nested class or interface declaration with the same name. Note that the actual declaration of java.util.Vector is generic (§8.1.2). Once imported, the name Vector can be used without qualification in a parameterized type such as Vector<String>, or as the raw type Vector. A related limitation of the import declaration is that a member class or interface declared inside a generic class or interface declaration can be imported, but its outer type is always erased.",8.91,107.02,324.01,799,90,294.1,414.01,401.12,FALSE,FALSE
238,5,BODY,"causes the simple names of all public classes and interfaces declared in the package java.util to be available within the class and interface declarations of the compilation unit. Thus, the simple name Vector refers to the class Vector of the package java.util in all places in the compilation unit where that class declaration is not shadowed (§6.4.1) or obscured (§6.4.2). The declaration might be shadowed by a single-type-import declaration of a class or interface whose simple name is Vector; by a class or interface named Vector and declared in the package to which the compilation unit belongs; or any nested classes or interfaces. The declaration might be obscured by a declaration of a field, parameter, or local variable named Vector. (It would be unusual for any of these conditions to occur.)",8.91,141.02,324,804,90,396.1,414,537.12,FALSE,FALSE
260,6,BODY,will result in the variable b holding the value true.,8.91,5.02,185.49,53,90,548.1,275.49,553.12,FALSE,FALSE
276,3,BODY,"This program causes four compile-time errors. One error occurs because ColoredPoint has no constructor declared with two int parameters, as requested by the use in main. This illustrates the fact that ColoredPoint does not inherit the constructors of its superclass Point. Another error occurs because ColoredPoint declares no constructors, and therefore a default constructor for it is implicitly declared (§8.8.9), and this default constructor is equivalent to:",8.91,89.02,324,463,90,236.1,414,325.12,FALSE,FALSE
285,6,BODY,"showing that changing the fields x, y, and useCount of p does not affect the fields of q, because these fields are instance variables in distinct objects. In this example, the class variable origin of the class Point is referenced both using the class name as a qualifier, in Point.origin, and using variables of the class type in field access expressions (§15.11), as in p.origin and q.origin. These two ways of accessing the origin class variable access the same object, evidenced by the fact that the value of the reference equality expression (§15.21.3):",8.91,65.02,324,558,90,371.1,414,436.12,FALSE,FALSE
287,7,BODY,"then the field x of class Point is no longer hidden within class Test. Within instance methods in the declaration of class Test, the simple name x now refers to the field declared within class Point. Code in class Test may still refer to that same field as super.x. The expression sample.x still refers to the field x within type Test, but that field is now an inherited field, and so refers to the field x declared in class Point. The output from this variant program is:",8.91,55.02,324,472,90,478.1,414,533.12,FALSE,FALSE
303,4,BODY,"The loop might then be subject to further optimizations. Such inlining cannot be done at compile time unless it can be guaranteed that Test and Point will always be recompiled together, so that whenever Point - and specifically its move method - changes, the code for Test.main will also be updated.",8.91,47.02,324,299,90,530.23,414,577.25,FALSE,FALSE
315,9,BODY,"because the invocation of greeting uses the type of s, namely Super, to figure out, at compile time, which class method to invoke, whereas the invocation of name uses the class of s, namely Sub, to figure out, at run time, which instance method to invoke.",8.91,25.02,324,255,90,410.1,414,435.12,FALSE,FALSE
322,5,BODY,"Here, the class Point provides methods getX and getY that return the values of its fields x and y; the class RealPoint then overrides these methods by declaring methods with the same signature. The result is two errors at compile time, one for each method, because the return types do not match; the methods in class Point return values of type int, but the wanna-be overriding methods in class RealPoint return values of type float. This program corrects the errors of the preceding program:",8.91,67.02,324.01,492,90,396.1,414.01,463.12,FALSE,FALSE
392,6,BODY,"This is perfectly legal, but class Foo inherits the equals implementation from Object, which can cause some subtle bugs.",8.91,15.02,324,120,90,243.23,414,258.25,FALSE,FALSE
411,3,BODY,"In the following example, the declarations of Foo<T,N> and Bar are legal: in each, the methods called m are not subsignatures of each other, but do have different erasures. Still, the fact that the methods in each are not subsignatures means Foo<T,N> and Bar are not functional interfaces. However, Baz is a functional interface because the methods it inherits from Foo<Integer,Integer> have the same signature and so logically represent a single method.",8.91,55.02,324.01,454,90,116.1,414.01,171.12,FALSE,FALSE
438,4,BODY,"Equivalently, a catch clause will catch any exception object that is an instanceof (§15.20.2) one of its catchable exception classes.",8.91,15.02,324,133,90,498.1,414,513.12,FALSE,FALSE
481,8,BODY,Suppose that a new version of class Super is produced:,8.91,5.02,200.72,54,90,491.1,290.72,496.12,FALSE,FALSE
482,7,BODY,Suppose that a new version of class Super is produced:,8.91,5.02,200.72,54,90,371.1,290.72,376.12,FALSE,FALSE
486,8,BODY,Suppose that a new version of class Super is produced:,8.91,5.02,200.72,54,90,409.1,290.72,414.12,FALSE,FALSE
490,8,BODY,Suppose that a new version of class Super is produced:,8.91,5.02,200.72,54,90,505.1,290.72,510.12,FALSE,FALSE
491,7,BODY,Suppose that a new version of class Super is produced:,8.91,5.02,200.72,54,90,345.1,290.72,350.12,FALSE,FALSE
493,7,BODY,Suppose that a new version of class Super is produced:,8.91,5.02,200.72,54,90,315.1,290.72,320.12,FALSE,FALSE
495,4,BODY,"As with sealed classes (§13.4.2.1), whilst adding a permitted direct subclass or subinterface of a sealed interface is considered a binary compatible change, it may cause the execution of an exhaustive switch (§14.11.1) to fail with an error (a MatchException may be thrown) if the switch encounters an instance of the new permitted direct subclass or subinterface that was not known at compile time (§14.11.3, §15.28.2).",8.91,45.02,324.01,421,90,341.1,414.01,386.12,FALSE,FALSE
521,7,BODY,"A case label with a case pattern that is unconditional for the type of the selector expression will, as the name suggests, match every value and so behave like a default label. A switch block can not have more than one switch label that acts like a default.",8.91,25.02,314,257,100,553.1,414,578.12,FALSE,FALSE
548,3,BODY,"Note the use of two statement labels, edgelist and search, and the use of break statements. This allows the code that copies a list, omitting one edge, to be shared between two separate tests, the test for an edge from node i to node j, and the test for an edge from node j to node i.",8.91,35.02,324.01,284,90,216.1,414.01,251.12,FALSE,FALSE
575,5,BODY,Suppose that a new version of class Flags is produced:,8.91,5.02,200.72,54,90,160.1,290.72,165.12,FALSE,FALSE
602,5,BODY,"Here, the class IntVector implements a method equals, which compares two vectors. If the other vector is the same vector object as the one for which the equals method was invoked, then the check can skip the length and value comparisons. The equals method implements this check by comparing the reference to the other object to this.",8.91,35.02,324,333,90,330.1,414,365.12,FALSE,FALSE
616,3,BODY,"An anonymous class being non-final is relevant in casting, in particular the narrowing reference conversion allowed for the cast operator (§5.5). On the other hand, it is not relevant to subclassing, because it is impossible to declare a subclass of an anonymous class (an anonymous class cannot be named by an extends clause) despite the anonymous class being non-final.",8.91,45.02,324,371,90,131.1,414,176.12,FALSE,FALSE
634,4,BODY,"A workaround is to introduce a private method in the lexically enclosing class declaration, that performs the interface super call.",8.91,15.02,324,131,90,340.1,414,355.12,FALSE,FALSE
636,5,BODY,"For the method invocation two(1) within class Doubler, there are two accessible methods named two, but only the second one is applicable, and so that is the one invoked at run time. For the method invocation two(3) within class Test, there are two applicable methods, but only the one in class Test is accessible, and so that is the one to be invoked at run time (the argument 3 is converted to type long). For the method invocation Doubler.two(3), the class Doubler, not class Test, is searched for methods named two; the only applicable method is not accessible, and so this method invocation causes a compile-time error. Another example is:",8.91,121.02,324.01,643,90,431.1,414.01,552.12,FALSE,FALSE
678,7,BODY,"The timing of method reference expression evaluation is more complex than that of lambda expressions (§15.27.4). When a method reference expression has an expression (rather than a type) preceding the :: separator, that subexpression is evaluated immediately. The result of evaluation is stored until the method of the corresponding functional interface type is invoked; at that point, the result is used as the target reference for the invocation. This means the expression preceding the :: separator is evaluated only when the program encounters the method reference expression, and is not re-evaluated on subsequent invocations on the functional interface type. It is interesting to contrast the treatment of null here with its treatment during method invocation. When a method invocation expression is evaluated, it is possible for the Primary that qualifies the invocation to evaluate to null but for no NullPointerException to be raised. This occurs when the invoked method is static (despite the syntax of the invocation suggesting an instance method). Since the applicable method for a method reference expression qualified by a Primary is prohibited from being static (§15.13.1), the evaluation of the method reference expression is simpler - a null Primary always raises a NullPointerException.",8.91,167.02,324.01,1304,90,344.1,414.01,511.12,FALSE,FALSE
729,8,BODY,"The value 1 of k is saved by the compound assignment operator += before its right-hand operand (k = 4) * (k + 2) is evaluated. Evaluation of this right-hand operand then assigns 4 to k, calculates the value 6 for k + 2, and then multiplies 4 by 6 to get 24. This is added to the saved value 1 to get 25, which is then stored into k by the += operator. An identical analysis applies to the case that uses a[0]. In short, the statements:",8.91,67.02,324.01,435,90,338.1,414.01,405.12,FALSE,FALSE
739,5,BODY,"Generally speaking, a lambda of the form () -> expr, where expr is a statement expression, is interpreted as either () -> { return expr; } or () -> { expr; }, depending on the target type.",8.91,25.02,324.01,188,90,547.1,414.01,572.12,FALSE,FALSE
767,5,BODY,"The notion that a variable is '[un]assigned after' a statement or expression really means 'is [un]assigned after the statement or expression completes normally'. Because a break, yield, continue, return, or throw statement never completes normally, it vacuously satisfies this notion.",8.91,35.02,314.01,284,100,462.23,414.01,497.25,FALSE,FALSE
827,2,BODY,"In order to complete type-checking of the method invocation, we must determine whether it is compatible with its target type, List<Number>. The bound set used to demonstrate applicability in the previous section, B2, was:",8.91,37.02,323.99,221,90,74.1,413.99,111.12,FALSE,FALSE
68,8,BODY,"Text blocks can be used wherever an expression of type String is allowed, such as in string concatenation (§15.18.1), in the invocation of methods on instances of String, and in annotations with String elements:",8.9,25.02,324,211,90,406.1,414,431.12,FALSE,FALSE
180,5,BODY,"The simplest example is that the pattern variable s is introduced by the expression a instanceof String s when true. In other words, if the value of the expression is true then the pattern matching must have succeeded, and thus the pattern variable must have been assigned a value. In contrast, the pattern variable t is introduced by the expression !(b instanceof Integer t) when false. This is because the pattern matching could only have succeeded if the value of the expression is false.",8.9,77.02,324,491,90,307.1,414,384.12,FALSE,FALSE
226,4,BODY,"For example, in the Java SE Platform API: •The package java has subpackages awt, applet, io, lang, net, and util, but no compilation units. •The package java.awt has a subpackage named image, as well as a number of compilation units containing declarations of classes and interfaces.",8.9,63.02,324,283,90,282.1,414,345.12,FALSE,FALSE
242,5,BODY,"In this code, the class Point is declared in a compilation unit with no package declaration, and thus Point is its fully qualified name, whereas in the code:",8.9,15.02,324,157,90,322.1,414,337.12,FALSE,FALSE
246,3,BODY,"Development tools for the Java programming language are encouraged to highlight requires transitive directives and unqualified exports directives, as these form the primary API of a module.",8.9,25.02,324,189,90,126.1,414,151.12,FALSE,FALSE
259,2,BODY,"Thus, an effect of the sealed keyword is to force all direct subclasses to explicitly declare whether they are final, sealed, or non-sealed. This avoids accidentally exposing a sealed class hierarchy to unwanted subclassing. An enum class is either implicitly final or implicitly sealed, so it can implement a sealed interface. Similarly, a record class is implicitly final, so it can also implement a sealed interface.",8.9,67.02,324,419,90,74.1,414,141.12,FALSE,FALSE
272,5,BODY,"the method getNumberOfScales in class Tuna has a name, signature, and return type that matches the method declared in interface Fish and also matches the method declared in interface Piano; it is considered to implement both. On the other hand, in a situation such as this:",8.9,47.02,324.01,273,90,242.1,414.01,289.12,FALSE,FALSE
281,5,BODY,"In this respect, hiding of fields differs from hiding of methods (§8.4.8.3), for there is no distinction drawn between static and non-static fields in field hiding whereas a distinction is drawn between static and non-static methods in method hiding.",8.9,25.02,324,250,90,469.1,414,494.12,FALSE,FALSE
291,6,BODY,because the assignments to x and y occur whenever a new Point is created.,8.9,5.02,274.53,73,90,241.1,364.53,246.12,FALSE,FALSE
318,8,BODY,"The program results in a compile-time error, because the override of method move in class CheckedPoint declares that it will throw a checked exception that the move in class Point has not declared. If this were not considered an error, an invoker of the method move on a reference of type Point could find the contract between it and Point broken if this exception were thrown. Removing the throws clause does not help:",8.9,67.02,324,419,90,409.1,414,476.12,FALSE,FALSE
369,8,BODY,"If a single field is inherited multiple times from the same interface because, for example, both this interface and one of this interface's direct superinterfaces extend the interface that declares the field, then only a single member results. This situation does not in itself cause a compile-time error. In the previous example, the fields RED, GREEN, and BLUE are inherited by interface LotsOfColors in more than one way, through interface RainbowColors and also through interface PrintColors, but the reference to field RED in interface LotsOfColors is not considered ambiguous because only one actual declaration of the field RED is involved.",8.9,87.02,324.01,647,90,450.1,414.01,537.12,FALSE,FALSE
412,3,BODY,"In special circumstances, it is useful to treat an intersection type as a functional interface type. Typically, this will look like an intersection of a functional interface type with one or more marker interface types, such as Runnable & java.io.Serializable. Such an intersection can be used in casts (§15.16) that force a lambda expression to conform to a certain type. If one of the interface types in the intersection is java.io.Serializable, special run-time support for serialization is triggered (§15.27.4).",8.9,55.02,324,515,90,201.1,414,256.12,FALSE,FALSE
439,6,BODY,"The following program declares an exception class TestException. The main method of class Test invokes the thrower method four times, causing exceptions to be thrown three of the four times. The try statement in method main catches each exception that the thrower throws. Whether the invocation of thrower completes normally or abruptly, a message is printed describing what happened.",8.9,45.02,324,384,90,540.1,414,585.12,FALSE,FALSE
484,7,BODY,Suppose a new version of class Super is produced:,8.9,5.02,184.97,49,90,492.1,274.97,497.12,FALSE,FALSE
503,5,BODY,"The first statement of method foo creates an instance of the member class Global.Cyclic rather than an instance of the local class Cyclic, because the statement appears prior to the scope of the local class declaration. The fact that the scope of a local class declaration encompasses its whole declaration (not only its body) means that the definition of the local class Cyclic is indeed cyclic because it extends itself rather than Global.Cyclic. Consequently, the declaration of the local class Cyclic is rejected at compile time. Since local class names cannot be redeclared within the same method (or constructor or initializer, as the case may be), the second and third declarations of Local result in compile- time errors. However, Local can be redeclared in the context of another, more deeply nested, class such as AnotherLocal.",8.9,129.02,324.01,837,90,474.1,414.01,603.12,FALSE,FALSE
506,4,BODY,Example 14.4.1-1. Type of Local Variables Declared With var,8.9,5.19,237.02,59,90,398.62,327.02,403.81,TRUE,FALSE
516,2,BODY,"be free of side effects. Evaluating such a boolean expression should not affect any state that is visible after the evaluation is complete. It is not illegal for a boolean expression contained in an assertion to have a side effect, but it is generally inappropriate, as it could cause program behavior to vary depending on whether assertions were enabled or disabled. In light of this, assertions should not be used for argument checking in public methods. Argument checking is typically part of the contract of a method, and this contract must be upheld whether assertions are enabled or disabled. A secondary problem with using assertions for argument checking is that erroneous arguments should result in an appropriate run-time exception (such as IllegalArgumentException, ArrayIndexOutOfBoundsException, or NullPointerException). An assertion failure will not throw an appropriate exception. Again, it is not illegal to use assertions for argument checking on public methods, but it is generally inappropriate. It is intended that AssertionError never be caught, but it is possible to do so, thus the rules for try statements should treat assertions appearing in a try block similarly to the current treatment of throw statements.",8.9,169.02,324,1235,90,74.1,414,243.12,FALSE,FALSE
534,3,BODY,"contains a switch block in which the code for each case falls through into the code for the next case. As a result, the program prints:",8.9,15.02,324,135,90,156.1,414,171.12,FALSE,FALSE
561,5,BODY,"The NullPointerException (which is a kind of RuntimeException) that is thrown by method blowUp is not caught by the try statement in main, because a NullPointerException is not assignable to a variable of type BlewIt. This causes the finally clause to execute, after which the thread executing main, which is the only thread of the test program, terminates because of an uncaught exception, which typically results in printing the exception name and a simple backtrace. However, a backtrace is not required by this specification. The problem with mandating a backtrace is that an exception can be created at one point in the program and thrown at a later one. It is prohibitively expensive to store a stack trace in an exception unless it is actually thrown (in which case the trace may be generated while unwinding the stack). Hence we do not mandate a back trace in every exception.",8.9,117.02,324.01,884,90,270.1,414.01,387.12,FALSE,FALSE
597,6,BODY,"For example a+b+c, where a, b, and c are local variables (this simplifying assumption avoids issues involving multiple threads and volatile variables), will always produce the same answer whether evaluated as (a+b)+c or a+(b+c); if the expression b+c occurs nearby in the code, a smart Java compiler may be able to use this common subexpression.",8.9,35.02,324,345,90,240.1,414,275.12,FALSE,FALSE
624,10,BODY,because the embedded assignment of 2 to index never occurs.,8.9,5.02,226.25,59,90,435.1,316.25,440.12,FALSE,FALSE
640,7,BODY,"With forethought about such problems, the maintainer of the points package could fix the ColoredPoint class to work with both newly compiled and old code, by adding defensive code to the old adopt method for the sake of old code that still invokes it on ColoredPoint arguments:",8.9,35.02,324.01,277,90,264.1,414.01,299.12,FALSE,FALSE
659,3,BODY,"Note that for invocation mode interface, R necessarily implements Q; for invocation mode virtual, R is necessarily either Q or a subclass of Q. If the target object is an array, then R is a 'class' representing an array type.",8.9,25.02,304,225,110,499.1,414,524.12,FALSE,FALSE
693,8,BODY,the method printSong will print a version of a children's song. Popular values for stuff include 'pop' and 'beer'; the most popular value for n is 100. Here is the output that results from running the program:,8.9,25.02,324,209,90,491.1,414,516.12,FALSE,FALSE
700,3,BODY,"This program results in two compile-time errors. The cast (Point)e is incorrect because no instance of Element or any of its possible subclasses (none are shown here) could possibly be an instance of any subclass of Point. The instanceof expression is incorrect for exactly the same reason. If, on the other hand, the class Point were a subclass of Element (an admittedly strange notion in this example):",8.9,45.02,324.01,404,90,186.1,414.01,231.12,FALSE,FALSE
700,5,BODY,"then the cast would be possible, though it would require a run-time check, and the instanceof expression would then be sensible and valid. The cast (Point)e would never raise an exception because it would not be executed if the value of e could not correctly be cast to type Point. Prior to Java SE 16, the ReferenceType operand of a type comparison operator was required to be reifiable (§4.7). This prevented the use of a parameterized type unless all its type arguments were wildcards. The requirement was lifted in Java SE 16 to allow more parameterized types to be used. For example, in the following program, it is legal to test whether the method parameter x, with static type List<Integer>, has a more 'refined' parameterized type ArrayList<Integer> at run time:",8.9,107.02,324,770,90,270.1,414,377.12,FALSE,FALSE
781,3,BODY,"The compiler is free to read the field this.done just once, and reuse the cached value in each execution of the loop. This would mean that the loop would never terminate, even if another thread changed the value of this.done.",8.9,25.02,323.99,225,90,106.1,413.99,131.12,FALSE,FALSE
789,5,BODY,"For the trace in Table 17.4.5-A, initially A == B == 0. The trace can observe r2 == 0 and r1 == 0 and still be happens-before consistent, since there are execution orders that allow each read to see the appropriate write.",8.9,25.02,324,221,90,450.6,414,475.62,FALSE,FALSE
833,3,BODY,"The lambda expression is a Predicate<Number>, which is a subtype of Predicate<? super Integer> but not Predicate<Integer>. The analysis in this section is used to infer that Number is an appropriate choice for the type argument to Predicate. That said, the analysis here, while described in terms of general type inference, is intentionally quite simple. The only constraints are equality constraints, which means that reduction amounts to simple pattern matching. A more powerful strategy might also infer constraints from the body of the lambda expression. But, given possible interactions with inference for surrounding and/or nested generic method invocations, this would introduce a lot of extra complexity.",8.9,97.02,324,712,90,128.1,414,225.12,FALSE,FALSE
833,5,BODY,"Note that no substitution is applied to S1, ..., Sk; even if m1 is generic, the type parameters of m1 are treated as type variables, not inference variables.",8.9,15.02,324,157,90,488.1,414,503.12,FALSE,FALSE
38,9,BODY,"For example, the raw input \u005cu005a results in the six characters \ u 0 0 5 a, because 005c is the Unicode value for a backslash. It does not result in the character Z, which is Unicode value 005a, because the backslash that resulted from processing the Unicode escape \u005c is not interpreted as the start of a further Unicode escape.",8.89,35.02,324,339,90,556.23,414,591.25,FALSE,FALSE
41,4,BODY,"For example, the input characters - and = can form the operator token -= (§3.12) only if there is no intervening white space or comment. As another example, the ten input characters staticvoid form a single identifier token while the eleven input characters static void (with an ASCII SP character between c and v) form a pair of keyword tokens, static and void, separated by white space.",8.89,45.02,324,388,90,270.23,414,315.25,FALSE,FALSE
44,6,BODY,"The 'Java letters' include uppercase and lowercase ASCII Latin letters A-Z (\u0041- \u005a), and a-z (\u0061-\u007a), and, for historical reasons, the ASCII dollar sign ($, or \u0024) and underscore (_, or \u005f). The dollar sign should be used only in mechanically generated source code or, rarely, to access pre-existing names on legacy systems. The underscore may be used in identifiers formed of two or more characters, but it cannot be used as a one-character identifier due to being a keyword. The 'Java digits' include the ASCII digits 0-9 (\u0030-\u0039).",8.89,77.02,324,564,90,428.63,414,505.65,FALSE,FALSE
58,4,BODY,The details of proper input conversion from a Unicode string representation of a floating- point number to the internal IEEE 754 binary floating-point representation are described for the methods valueOf of class Float and class Double of the package java.lang.,8.89,25.02,323.99,261,90,357.1,413.99,382.12,FALSE,FALSE
74,3,BODY,See §4.2.5 for an idiom to convert integer expressions to boolean.,8.89,5.02,241.82,66,90,369.1,331.82,374.12,FALSE,FALSE
103,4,BODY,"In our running example, the only generic element of MEC is List, and Relevant(List) = { List<String>, List<Object> }. We will now seek to find a type argument for List that contains (§4.5.1) both String and Object. This is done by means of the least containing parameterization (lcp) operation defined below. The first line defines lcp() on a set, such as Relevant(List), as an operation on a list consisting of the elements of the set. The next line defines the operation on such a list as a pairwise reduction on the elements of the list. The third line is the definition of lcp()",8.89,77.02,314.01,582,100,227.1,414.01,304.12,FALSE,FALSE
114,3,BODY,"Heap pollution occurs at (1) because a component in the stringLists array that should refer to a List<String> now refers to a List<Integer>. There is no way to detect this pollution in the presence of both a universal supertype (Object[]) and a non-reifiable type (the declared type of the formal parameter, List<String>[]). No unchecked warning is justified at (1); nevertheless, at run time, a ClassCastException will occur at (2). A compile-time unchecked warning will be given at any invocation of the method above because an invocation is considered by the Java programming language's static type system to create an array whose element type, List<String>, is non-reifiable (§15.12.4.2). If and only if the body of the method was type-safe with respect to the variable arity parameter, then the programmer could use the SafeVarargs annotation to silence warnings at invocations (§9.6.4.7). Since the body of the method as written above causes heap pollution, it would be completely inappropriate to use the annotation to disable warnings for callers. Finally, note that the stringLists array could be aliased through variables of types other than Object[], and heap pollution could still occur. For example, the type of the array variable could be java.util.Collection[] - a raw element type - and the body of the method above would compile without warnings or errors and still cause heap pollution. And if the Java SE Platform defined, say, Sequence as a non-generic supertype of List<T>, then using Sequence as the type of array would also cause heap pollution.",8.89,199.02,324.01,1568,90,250.1,414.01,449.12,FALSE,FALSE
132,7,BODY,"The results for char, int, and long are unsurprising, producing the minimum and maximum representable values of the type. The results for byte and short lose information about the sign and magnitude of the numeric values and also lose precision. The results can be understood by examining the low order bits of the minimum and maximum int. The minimum int is, in hexadecimal, 0x80000000, and the maximum int is 0x7fffffff. This explains the short results, which are the low 16 bits of these values, namely, 0x0000 and 0xffff; it explains the char results, which also are the low 16 bits of these values, namely, '\u0000' and '\uffff'; and it explains the byte results, which are the low 8 bits of these values, namely, 0x00 and 0xff.",8.89,97.02,324,733,90,383.1,414,480.12,FALSE,FALSE
137,4,BODY,"These terms refer to the compatibility of the types involved in the conversion when viewed as raw types. If the conversion is conceptually an 'upcast', then the conversion is completely unchecked; no run time test is needed because the conversion is legal in the non-generic type system of the Java Virtual Machine. Conversely, if the conversion is conceptually a 'downcast', then the conversion is partially unchecked; even in the non- generic type system of the Java Virtual Machine, a run time check is needed to test the compatibility of the (raw) types involved in the conversion. Using types from the java.util package as an example, a conversion from ArrayList<String> to Collection<T> is completely unchecked, because the (raw) type ArrayList is a subtype of the (raw) type Collection in the Java Virtual Machine. Conversely, a conversion from Collection<T> to ArrayList<String> is partially unchecked, because the (raw) type Collection is not a subtype of the (raw) type ArrayList in the Java Virtual Machine.",8.89,137.02,324,1018,90,435.23,414,572.25,FALSE,FALSE
157,4,BODY,"Here, the first compile-time error occurs because the class types Long and Point are unrelated (that is, they are not the same, and neither is a subclass of the other), so a cast between them will always fail. The second compile-time error occurs because a variable of type EndPoint can never reference a value that implements the interface Colorable. This is because EndPoint is a final type, and a variable of a final type always holds a value of the same run-time type as its compile-time type. Therefore, the run-time type of variable e must be exactly the type EndPoint, and type EndPoint does not implement Colorable.",8.89,87.02,324,623,90,377.1,414,464.12,FALSE,FALSE
168,3,BODY,"The declaration of a generic class or interface (class C<T> ... or interface C<T> ...) introduces both a class named C and a family of types: the raw type C, the parameterized type C<Foo>, the parameterized type C<Bar>, etc. When a reference to C occurs where genericity is unimportant, identified below as one of the non-generic contexts, the reference to C denotes the class or interface C. In other contexts, the reference to C denotes a type, or part of a type, introduced by C. The 15 non-generic contexts are as follows: 1.In a uses or provides directive in a module declaration (§7.7.1)",8.89,111.02,324.01,593,90,482.1,414.01,593.12,FALSE,FALSE
220,4,BODY,"Consider this example, where the points package declares:",8.89,5.02,217.25,57,90,280.1,307.25,285.12,FALSE,FALSE
220,8,BODY,"A compile-time error occurs in the method delta here: it cannot access the protected members x and y of its parameter p, because while Point3d (the class in which the references to fields x and y occur) is a subclass of Point (the class in which x and y are declared), it is not involved in the implementation of a Point (the type of the parameter p).",8.89,35.02,324,351,90,568.1,414,603.12,FALSE,FALSE
237,9,BODY,the single-type-import declaration importing class Vector from package java.util does not prevent the package name Vector from appearing and being correctly recognized in subsequent import declarations. The example compiles and produces the output:,8.89,25.02,324,248,90,428.1,414,453.12,FALSE,FALSE
272,7,BODY,"it is impossible to declare a method named getNumberOfScales whose signature and return type are compatible with those of both the methods declared in interface Fish and in interface StringBass, because a class cannot have multiple methods with the same signature and different primitive return types (§8.4). Therefore, it is impossible for a single class to implement both interface Fish and interface StringBass (§8.4.8).",8.89,45.02,324,423,90,388.1,414,433.12,FALSE,FALSE
282,6,BODY,"the class Test inherits two fields named v, one from its superclass SuperTest and one from its superinterface Frob. This in itself is permitted, but a compile-time error occurs because of the use of the simple name v in method printV: it cannot be determined which v is intended. The following variation uses the field access expression super.v to refer to the field named v declared in class SuperTest and uses the qualified name Frob.v to refer to the field named v declared in interface Frob:",8.89,77.02,324.01,495,90,494.1,414.01,571.12,FALSE,FALSE
289,5,BODY,"then method two could occasionally print a value for j that is greater than the value of i, because the example includes no synchronization and, under the rules explained in §17.4, the shared values of i and j might be updated out of order. One way to prevent this out-or-order behavior would be to declare methods one and two to be synchronized (§8.4.3.6):",8.89,57.02,324,357,90,213.1,414,270.12,FALSE,FALSE
324,2,BODY,"The last two lines of output show that the method invocations p.getX() and rp.getX() each invoke the getX method declared in class RealPoint. Indeed, there is no way to invoke the getX method of class Point for an instance of class RealPoint from outside the body of RealPoint, no matter what the type of the variable we may use to hold the reference to the object. Thus, we see that fields and methods behave differently: hiding is different from overriding.",8.89,55.02,324,459,90,74.1,414,129.12,FALSE,FALSE
338,5,BODY,"An enum declaration does not have an extends clause, so it is not possible to explicitly declare a direct superclass type, even Enum<E>.",8.89,15.02,324,136,90,500.1,414,515.12,FALSE,FALSE
354,3,BODY,"then, assuming r1 is not the null reference, it is always the case that the expression r1.equals(r2) will evaluate to true. Explicitly declared accessor methods and equals methods should respect this invariant. It is not generally possible for a compiler to check whether explicitly declared methods respect the invariant. The following record declaration is bad style because its accessor methods clip the x and y components and therefore prevent p3 from being equals to p1:",8.89,55.02,324.01,475,90,96.1,414.01,151.12,FALSE,FALSE
375,2,BODY,"•Fourth, the Object methods are so fundamental that it seems dangerous to allow an arbitrary superinterface to silently add a default method that changes their behavior. An interface is free, however, to define another method that provides behavior useful for classes that override the Object methods. For example, the java.util.List interface could declare an elementString method that produces the string described by the contract of toString; implementors of toString in classes could then delegate to this method.",8.89,67.02,324.01,517,90,74.1,414.01,141.12,FALSE,FALSE
395,3,BODY,"Terminal deprecation is sufficiently urgent that the use of a terminally deprecated element will cause a removal warning even if the using element is itself deprecated, since there is no guarantee that both elements will be removed at the same time. To dismiss the warning but continue using the element, the programmer must manually acknowledge the risk via an @SuppressWarnings annotation.",8.89,45.02,324,391,90,368.1,414,413.12,FALSE,FALSE
426,9,BODY,showing that the int[] array that is ia[0] and the int[] array that is ja[0] are the same array.,8.89,15.02,324,96,90,321.1,414,336.12,FALSE,FALSE
427,10,BODY,"While ia and ib refer to different arrays, the result of the comparison of the Class objects demonstrates that all arrays whose components are of type int are instances of the same array type (namely int[]).",8.89,25.02,324,207,90,369.1,414,394.12,FALSE,FALSE
431,3,BODY,"Programs can use the pre-existing exception classes of the Java SE Platform API in throw statements, or define additional exception classes as subclasses of Throwable or of any of its subclasses, as appropriate. To take advantage of compile-time checking for exception handlers (§11.2), it is typical to define most new exception classes as checked exception classes, that is, as subclasses of Exception that are not subclasses of RuntimeException. The class Error is a separate subclass of Throwable, distinct from Exception in the class hierarchy, to allow programs to use the idiom '} catch (Exception e) {' (§11.2.3) to catch all exceptions from which recovery may be possible without catching errors from which recovery is typically not possible. Note that a subclass of Throwable cannot be generic (§8.1.2).",8.89,119.02,324,813,90,138.1,414,257.12,FALSE,FALSE
453,2,BODY,because the class Sub is never initialized; the reference to Sub.taxi is a reference to a field actually declared in class Super and does not trigger initialization of the class Sub.,8.89,15.02,324,182,90,74.1,414,89.12,FALSE,FALSE
484,9,BODY,"Then, recompiling Hyper and Super, and executing the resulting new binaries with the old binary of Test produces the output:",8.89,15.02,324,124,90,566.1,414,581.12,FALSE,FALSE
546,2,BODY,Example 14.14-2. Enhanced for And Unboxing Conversion,8.89,5.19,227.31,53,90,75.62,317.31,80.81,TRUE,FALSE
549,5,BODY,"In the Graph class in §14.15, one of the break statements is used to finish execution of the entire body of the outermost for loop. This break can be replaced by a continue if the for loop itself is labeled:",8.89,25.02,324,207,90,350.1,414,375.12,FALSE,FALSE
575,9,BODY,"because DEBUG is a static constant variable, so its value could have been used in compiling Test without making a reference to the class Flags. This behavior would also occur if Flags was an interface, as in the modified example:",8.89,37.02,323.99,229,90,258.1,413.99,295.12,FALSE,FALSE
625,9,BODY,"A NullPointerException never occurs, because the index expression must be completely evaluated before any further part of the array access occurs, and that includes the check as to whether the value of the array reference expression is null.",8.89,25.02,324,241,90,398.1,414,423.12,FALSE,FALSE
673,3,BODY,"For convenience, when the name of a generic type is used to refer to an instance method (where the receiver becomes the first parameter), the target type is used to determine the type arguments. This facilitates usage like Pair::first in place of Pair<String,Integer>::first. Similarly, a method reference like Pair::new is treated like a 'diamond' instance creation (new Pair<>()). Because the 'diamond' is implicit, this form does not instantiate a raw type; in fact, there is no way to express a reference to the constructor of a raw type.",8.89,65.02,324,542,90,146.1,414,211.12,FALSE,FALSE
806,3,BODY,"Examples of bound sets: •{ α = String } contains a single bound, instantiating α as String. •{ Integer <: α, Double <: α, α <: Object } describes two proper lower bounds and one proper upper bound for α. •{ α <: Iterable<?>, β <: Object, α <: List<β> } describes a proper upper bound for each of α and β, along with a dependency between them. •{ } contains no bounds nor dependencies, and can be referred to as true. •{ false } expresses the fact that no satisfactory instantiation exists.",8.89,111.02,324,489,90,452.1,414,563.12,FALSE,FALSE
827,5,BODY,"This compatibility constraint produces an equality bound for α, which is included in the new bound set, B3:",8.89,15.71,324,107,90,204.29,414,220,FALSE,FALSE
118,6,BODY,"the class Point declares a final class variable origin. The origin variable holds a reference to an object that is an instance of class Point whose coordinates are (0, 0). The value of the variable Point.origin can never change, so it always refers to the same Point object, the one created by its initializer. However, an operation on this Point object might change its state - for example, modifying its useCount or even, misleadingly, its x or y coordinate.",8.88,55.02,324,460,90,369.1,414,424.12,FALSE,FALSE
204,6,BODY,"The class type parameter T is in scope throughout the declaration of class Box; however, using the name T in the declaration of static method empty is illegal. Similarly, the method type parameter U is in scope throughout the declaration of method make; however, using the name U in the declaration of the (implicitly static) local interface Checker is illegal.",8.88,57.02,324,361,90,424.1,414,481.12,FALSE,FALSE
208,3,BODY,"The fields a and b are in scope throughout the body of class Test. However, using the name b in the static context of the concat2 method, or in the declaration of the nested class Matcher that is not an inner class of Test, is illegal.",8.88,25.02,324,235,90,156.1,414,181.12,FALSE,FALSE
209,3,BODY,"The formal parameter args is in scope throughout the body of method main. args is effectively final, so the name args can be used in the instance method checkWhitespace of local class Checker. However, using the name args in the static context of the checkFlag method of local class Checker is illegal. The local variable first is in scope for the remainder of the body of method main. first is also effectively final. However, the anonymous class declared in checkFirst is not an inner class of Checker, so using the name first in the anonymous class body is illegal. (A lambda expression in the body of checkFirst would similarly be unable to refer to first, because the lambda expression would occur in a static context.) The local variable c is in scope for the last few lines of the body of method main, and is declared final, so the name c can be used in the body of the lambda expression. The local variable i is in scope throughout the for loop. However, i is not effectively final, so using the name i in the body of the lambda expression is illegal.",8.88,161.02,324,1059,90,116.1,414,277.12,FALSE,FALSE
211,5,BODY,"This program encounters two compile-time errors, because the int variable i has no members, and because nPoints is not a method of class Point.",8.88,15.02,324,143,90,317.1,414,332.12,FALSE,FALSE
218,10,BODY,"the private members ID, masterID, and setMasterID may be used only within the body of class Point. They may not be accessed by qualified names, field access expressions, or method invocation expressions outside the body of the declaration of Point. See §8.8.10 for an example that uses a private constructor.",8.88,47.02,324.01,308,90,513.1,414.01,560.12,FALSE,FALSE
277,5,BODY,"Here both classes in the points package compile. The class Point3d inherits the fields x and y of class Point, because it is in the same package as Point. The class Point4d, which is in a different package, does not inherit the fields x and y of class Point or the field z of class Point3d, and so fails to compile. A better way to write the third compilation unit would be:",8.88,57.02,324,374,90,250.1,414,307.12,FALSE,FALSE
286,7,BODY,"then the field x of class Point is no longer hidden within class Test; instead, the simple name x now refers to the field Point.x. Code in class Test may still refer to that same field as super.x. Therefore, the output from this variant program is:",8.88,25.02,324,248,90,404.1,414,429.12,FALSE,FALSE
320,7,BODY,"C inherits two methods from its direct superclass type A<String>: the method m(String) marked at 1, and (due to C's parameterization of A) the method m(String) marked at 2. These methods have the same signature, so are override-equivalent with each other.",8.88,25.02,324,255,90,564.1,414,589.12,FALSE,FALSE
322,3,BODY,"Here, the class RealPoint hides the declarations of the int instance variables x and y of class Point with its own float instance variables x and y, and overrides the method move of class Point with its own move method. It also overloads the name move with another method with a different signature (§8.4.2). In this example, the members of the class RealPoint include the instance variable color inherited from the class Point, the float instance variables x and y declared in RealPoint, and the two move methods declared in RealPoint. Which of these overloaded move methods of class RealPoint will be chosen for any particular method invocation will be determined at compile time by the overloading resolution procedure described in §15.12. This following program is an extended variation of the preceding program:",8.88,141.02,324,816,90,96.1,414,237.12,FALSE,FALSE
323,7,BODY,"The first line of output illustrates the fact that an instance of RealPoint actually contains the two integer fields declared in class Point; it is just that their names are hidden from code that occurs within the declaration of class RealPoint (and those of any subclasses it might have). When a reference to an instance of class RealPoint in a variable of type Point is used to access the field x, the integer field x declared in class Point is accessed. The fact that its value is zero indicates that the method invocation p.move(1, -1) did not invoke the method move of class Point; instead, it invoked the overriding method move of class RealPoint. The second line of output shows that the field access rp.x refers to the field x declared in class RealPoint. This field is of type float, and this second line of output accordingly displays floating-point values. Incidentally, this also illustrates the fact that the method name show is overloaded; the types of the arguments in the method invocation dictate which of the two definitions will be invoked.",8.88,137.02,324,1059,90,436.1,414,573.12,FALSE,FALSE
329,3,BODY,"If two or more (distinct) method modifiers appear in a method declaration, it is customary, though not required, that they appear in the order consistent with that shown above in the production for MethodModifier. Unlike methods, a constructor cannot be abstract, static, final, native, strictfp, or synchronized: •A constructor is not inherited, so there is no need to declare it final. •An abstract constructor could never be implemented. •A constructor is always invoked with respect to an object, so it makes no sense for a constructor to be static. •There is no practical need for a constructor to be synchronized, because it would lock the object under construction, which is normally not made available to other threads until all constructors for the object have completed their work. •The lack of native constructors is an arbitrary language design choice that makes it easy for an implementation of the Java Virtual Machine to verify that superclass constructors are always properly invoked during object creation. •The inability to declare a constructor as strictfp (in contrast to a method (§8.4.3)) is an intentional language design choice that stemmed from the (now obsolete) ability to declare a class as strictfp.",8.88,229.02,324.01,1228,90,112.1,414.01,341.12,FALSE,FALSE
337,7,BODY,"Here, the class ClassOnly cannot be instantiated, while in the following code:",8.88,5.02,284.91,78,90,428.1,374.91,433.12,FALSE,FALSE
349,2,BODY,"ways. First, every record class provides implementations of hashCode and toString that return representations of a record object as a whole; they cannot serve as accessor methods (§8.10.3) for record components called hashCode or toString, and there would be no way to access such record components from outside the record class. Similarly, some record classes may provide implementations of clone and (regrettably) finalize, so a record component called clone or finalize could not be accessed via an accessor method. Finally, the getClass, notify, notifyAll, and wait methods in Object are final, so record components with the same names could not have accessor methods. (The accessor methods would have the same signatures as the final methods, and would thus attempt, unsuccessfully, to override them.)",8.88,95.02,324.01,806,90,74.1,414.01,169.12,FALSE,FALSE
351,3,BODY,"The restrictions on record component names (§8.10.1) mean that no implicitly declared accessor method has a signature that is override-equivalent with a non-private method of class Object. An explicit method declaration that takes one of the restricted names, such as public void wait() {...}, is not an accessor method, since wait is never a record component name. Annotations that appear on a record component are not propagated to an explicitly declared accessor method for that record component. In some situations, the programmer may need to duplicate a record component's annotations on an explicitly declared accessor method, but this is not generally necessary. Annotations that are propagated to an implicitly declared accessor method must result in a legally annotated method. For example, in the following record declaration, the implicitly declared accessor method x() would be annotated with @SafeVarargs, but such an annotation is illegal on a fixed arity method (§9.6.4.7): record BadRecord(@SafeVarargs int x) {}  // Error",8.88,170.01,324,1038,90,297.1,414,467.11,FALSE,FALSE
369,6,BODY,"the interface LotsOfColors inherits two fields named YELLOW. This is all right as long as the interface does not contain any reference by simple name to the field YELLOW. (Such a reference could occur within a variable initializer for a field.) Even if interface PrintColors were to give the value 3 to YELLOW rather than the value 8, a reference to field YELLOW within interface LotsOfColors would still be considered ambiguous.",8.88,67.02,324.01,429,90,341.1,414.01,408.12,FALSE,FALSE
387,10,BODY,"More broadly, if Foo is a repeatable annotation interface and FooContainer is its containing annotation interface, then: •If Foo has no @Target meta-annotation and FooContainer has no @Target meta- annotation, then @Foo may be repeated on any program element which supports annotations.",8.88,57.02,324,286,90,527.1,414,584.12,FALSE,FALSE
405,3,BODY,"The intuition behind the second clause is that if Outer.this is legal in a nested class enclosed by Outer, then Outer may be annotated because it represents the type of some",8.88,15.02,324,173,90,584.1,414,599.12,FALSE,FALSE
411,8,BODY,"Functional interfaces can be generic, such as java.util.function.Predicate<T>. Such a functional interface may be parameterized in a way that produces distinct abstract methods - that is, multiple methods that cannot be legally overridden with a single declaration. For example:",8.88,35.02,324,278,90,459.1,414,494.12,FALSE,FALSE
427,5,BODY,where the string '[I' is the run-time type signature for the Class object 'array with component type int'.,8.88,15.02,324,106,90,170.1,414,185.12,FALSE,FALSE
482,9,BODY,"Then, if Super and Hyper are recompiled but not Test, then running the new binaries with the existing binary of Test produces the output:",8.88,15.02,324,137,90,435.1,414,450.12,FALSE,FALSE
493,11,BODY,"However, if Test is then recompiled, using this new Super, the output is then:",8.88,5.02,285.18,78,90,443.1,375.18,448.12,FALSE,FALSE
498,2,BODY,Suppose that a default method is added to Cowboy:,8.88,5.02,183.79,49,90,74.1,273.79,79.12,FALSE,FALSE
505,2,BODY,Example 14.4-1. Local Variables Declared With var,8.88,5.19,198.77,49,90,401.62,288.77,406.81,TRUE,FALSE
525,2,BODY,"•The type T names an abstract sealed class or sealed interface C and for every permitted direct subclass or subinterface D of C, one of the following two conditions holds: 1.There is no type that both names D and is a subtype of T, or 2.There is a type U that both names D and is a subtype of T, and P covers U. A default label is permitted, but not required, in the case where the switch block exhausts all the permitted direct subclasses and subinterfaces of an abstract sealed class or sealed interface. For example: sealed interface I permits A, B, C {} final class A   implements I {} final class B   implements I {} record C(int j) implements I {}  // Implicitly final static int testExhaustive1(I i) { return switch(i) { case A a -> 0; case B b -> 1; case C c -> 2;           // No default required! }; }",8.88,243.05,360,811,72,76.06,432,319.11,FALSE,FALSE
538,6,BODY,Example 14.13-1. The do Statement,8.88,5.19,135.85,33,90,315.62,225.85,320.81,TRUE,FALSE
575,7,BODY,"If Flags is recompiled but not Test, then running the new binary with the existing binary of Test produces the output:",8.88,15.02,324.01,118,90,204.1,414.01,219.12,FALSE,FALSE
640,5,BODY,"because the old binary file for Test still has the descriptor 'one parameter, whose type is Point; void' associated with the method call cp.adopt(cp2). If the source code for Test is recompiled, the Java compiler will then discover that there are now two applicable adopt methods, and that the signature for the more specific one is 'one parameter, whose type is ColoredPoint; void'; running the program will then produce the desired output:",8.88,45.02,324.01,441,90,180.1,414.01,225.12,FALSE,FALSE
705,1,BODY,Conditional-And Operator &&15.23,8.88,4.95,144.54,32,323.46,40.15,468,45.1,FALSE,TRUE
800,5,BODY,"One place where use of a final-field-safe context would be appropriate is in an executor or thread pool. By executing each Runnable in a separate final-field-safe context, the executor could guarantee that incorrect access by one Runnable to a object o will not remove final field guarantees for other Runnables handled by the same executor.",8.88,35.02,324,341,90,451.1,414,486.12,FALSE,FALSE
172,5,BODY,"When type parameters do not fall conveniently into one of the categories mentioned, names should be chosen to be as meaningful as possible within the confines of a single letter. The names mentioned above (E, K, V, X, T) should not be used for type parameters that do not fall into the designated categories. Method Names Method names should be verbs or verb phrases, in mixed case, with the first letter lowercase and the first letter of any subsequent words capitalized. Here are some additional specific conventions for method names: •Methods to get and set an attribute that might be thought of as a variable V should be named getV and setV. An example is the methods getPriority and setPriority of class Thread. •A method that returns the length of something should be named length, as in class String. •A method that tests a boolean condition V about an object should be named isV. An example is the method isInterrupted of class Thread. •A method that converts its object to a particular format F should be named toF. Examples are the method toString of class Object and the methods toLocaleString and toGMTString of class java.util.Date. Whenever possible and appropriate, basing the names of methods in a new class on names in an existing class that is similar, especially a class from the Java SE Platform API, will make it easier to use. Field Names Names of fields that are not final should be in mixed case with a lowercase first letter and the first letters of subsequent words capitalized. Note that well-designed classes have",8.87,325.02,324.01,1541,90,261.1,414.01,586.12,FALSE,FALSE
212,6,BODY,"For the invocation f1(0), only one method named f1 is in scope. It is the method Test.f1(int), whose declaration is in scope throughout the body of Test including the anonymous class declaration. §15.12.1 chooses to search in class Test since the anonymous class declaration has no member named f1. Eventually, Test.f1(int) is resolved. For the invocation f2(0), two methods named f2 are in scope. First, the declaration of the method Super.f2(String) is in scope throughout the anonymous class declaration.",8.87,67.02,324,507,90,536.1,414,603.12,FALSE,FALSE
213,2,BODY,"Second, the declaration of the method Test.f2(int) is in scope throughout the body of Test including the anonymous class declaration. (Note that neither declaration shadows the other, because at the point where each is declared, the other is not in scope.) §15.12.1 chooses to search in class Super because it has a member named f2. However, Super.f2(String) is not applicable to f2(0), so a compile-time error occurs. Note that class Test is not searched. For the invocation f3(0), three methods named f3 are in scope. First and second, the declarations of the methods Super.f3(String) and Super.f3(int,int) are in scope throughout the anonymous class declaration. Third, the declaration of the method Test.f3(int) is in scope throughout the body of Test including the anonymous class declaration. §15.12.1 chooses to search in class Super because it has a member named f3. However, Super.f3(String) and Super.f3(int,int) are not applicable to f3(0), so a compile-time error occurs. Note that class Test is not searched. Choosing to search a nested class's superclass hierarchy before the lexically enclosing scope is called the 'comb rule' (§15.12.1).",8.87,169.02,324.01,1153,90,74.1,414.01,243.12,FALSE,FALSE
229,3,BODY,"where each of the .java files contains the source for a compilation unit (§7.3) that contains the definition of a class or interface whose binary compiled form is contained in the corresponding .class file. Under this simple organization of packages, an implementation of the Java SE Platform would transform a package name into a pathname by concatenating the components of the package name, placing a file name separator (directory indicator) between adjacent components. For example, if this simple organization were used on an operating system where the file name separator is /, the package name: jag.scrabble.board",8.87,130.01,324,620,90,168.1,414,298.11,FALSE,FALSE
236,10,BODY,where myVector is a package containing the compilation unit:,8.87,5.02,226.37,60,90,551.1,316.37,556.12,FALSE,FALSE
257,9,BODY,would be correct. Instantiation of a SimplePoint causes the default constructor and field initializers for x and y of Point to be executed.,8.87,15.02,324,139,90,488.1,414,503.12,FALSE,FALSE
287,5,BODY,"because the declaration of x in class Test hides the definition of x in class Point, so class Test does not inherit the field x from its superclass Point. It must be noted, however, that while the field x of class Point is not inherited by class Test, it is nevertheless implemented by instances of class Test. In other words, every instance of class Test contains two fields, one of type int and one of type double. Both fields bear the name x, but within the declaration of class Test, the simple name x always refers to the field declared within class Test. Code in instance methods of class Test may refer to the instance variable x of class Point as super.x. Code that uses a field access expression to access field x will access the field named x in the class indicated by the type of reference expression. Thus, the expression sample.x accesses a double value, the instance variable declared in class Test, because the type of the variable sample is Test, but the expression ((Point)sample).x accesses an int value, the instance variable declared in class Point, because of the cast to type Point. If the declaration of x is deleted from class Test, as in the program:",8.87,159.02,324,1175,90,160.1,414,319.12,FALSE,FALSE
288,6,BODY,"were saved to persistent storage by a system service, then only the fields x and y would be saved. This specification does not specify details of such services; see the specification of java.io.Serializable for an example of such a service.",8.87,25.02,324,240,90,378.36,414,403.38,FALSE,FALSE
331,3,BODY,"Here, the first constructor of ColoredPoint invokes the second, providing an additional argument; the second constructor of ColoredPoint invokes the constructor of its superclass Point, passing along the coordinates.",8.87,25.02,324,216,90,196.1,414,221.12,FALSE,FALSE
458,3,BODY,"Here, a new instance of ColoredPoint is created. First, space is allocated for the new ColoredPoint, to hold the fields x, y, and color. All these fields are then initialized to their default values (in this case, 0 for each field). Next, the ColoredPoint constructor with no arguments is first invoked. Since ColoredPoint declares no constructors, a default constructor of the following form is implicitly declared:",8.87,45.02,324,416,90,186.1,414,231.12,FALSE,FALSE
481,10,BODY,"Then, recompiling Super and executing this new binary with the original binaries for Test and Hyper produces the output:",8.87,15.02,324,120,90,535.1,414,550.12,FALSE,FALSE
519,3,BODY,"Switch blocks are not designed to work with the types boolean, long, float, and double. The selector expression of a switch statement or switch expression can not have one of these types.",8.87,25.02,324,187,90,406.1,414,431.12,FALSE,FALSE
553,2,BODY,"By convention, user-declared throwable types should usually be declared to be subclasses of class Exception, which is a subclass of class Throwable (§11.1.1).",8.87,15.02,323.99,158,90,306.1,413.99,321.12,FALSE,FALSE
639,7,BODY,"The programmer who coded class Test has expected to see the word green, because the actual argument, a ColoredPoint, has a color field, and color would seem to be a 'relevant field'. (Of course, the documentation for the package points ought to have been much more precise!) Notice, by the way, that the most specific method (indeed, the only applicable method) for the method invocation of adopt has a signature that indicates a method of one parameter, and the parameter is of type Point. This signature becomes part of the binary representation of class Test produced by the Java compiler and is used by the method invocation at run time. Suppose the programmer reported this software error and the maintainer of the points package decided, after due deliberation, to correct it by adding a method to class ColoredPoint:",8.87,139.02,324.01,823,90,464.1,414.01,603.12,FALSE,FALSE
701,7,BODY,"However, this fact is essentially never useful. For example, a==b==c parses as (a==b)==c. The result type of a==b is always boolean, and c must therefore be of type boolean or a compile-time error occurs. Thus, a==b==c does not test to see whether a, b, and c are all equal.",8.87,35.02,324,274,90,266.1,414,301.12,FALSE,FALSE
706,0,BODY,15.24Conditional-Or Operator ||,8.87,4.95,140.07,31,36,40.15,176.07,45.1,FALSE,TRUE
31,13,BODY,BasicForStatement: for ( ; ; [ForUpdate] ) Statement for ( ; Expression ; [ForUpdate] ) Statement for ( ForInit ; ; [ForUpdate] ) Statement for ( ForInit ; Expression ; [ForUpdate] ) Statement,8.86,44.95,210.09,192,108,438.15,318.09,483.1,FALSE,TRUE
38,7,BODY,"For example, the raw input '\\u2122=\u2122' results in the eleven characters ' \ \ u 2 1 2 2 = ™ ' because while the second ASCII \ character in the raw input is not eligible to begin a Unicode escape, the third ASCII \ character is eligible, and \u2122 is the Unicode encoding of the character ™.",8.86,35.02,314.01,297,100,408.23,414.01,443.25,FALSE,FALSE
84,5,BODY,"because v1.val and v2.val reference the same instance variable (§4.12.3) in the one Value object created by the only new expression, while i1 and i2 are different variables.",8.86,15.02,324,173,90,270.1,414,285.12,FALSE,FALSE
111,4,BODY,"In this example, types are used in declarations of the following: •Fields, which are the class variables and instance variables of classes (§8.3), and constants of interfaces (§9.3); here the field divisor in the class MiscMath is declared to be of type int •Method parameters (§8.4.1); here the parameter l of the method ratio is declared to be of type long •Method results (§8.4); here the result of the method ratio is declared to be of type float, and the result of the method gausser is declared to be of type double •Constructor parameters (§8.8.1); here the parameter of the constructor for MiscMath is declared to be of type int •Local variables (§14.4, §14.14); the local variables r and val of the method gausser are declared to be of types Random and double[] (array of double)",8.86,151.02,324,788,90,427.1,414,578.12,FALSE,FALSE
147,6,BODY,"The first three elements of the chain are related by widening reference conversion, while the last entry is derived from its predecessor by unchecked conversion. However, this is not a valid assignment conversion, because the chain contains two parameterized types, Comparable<Integer> and Comparable<String>, that are not subtypes.",8.86,35.02,324,332,90,552.1,414,587.12,FALSE,FALSE
173,3,BODY,"Local Variable and Parameter Names Local variable and parameter names should be short, yet meaningful. They are often short sequences of lowercase letters that are not words, such as: •Acronyms, that is the first letter of a series of words, as in cp for a variable holding a reference to a ColoredPoint •Abbreviations, as in buf holding a pointer to a buffer of some kind •Mnemonic terms, organized in some way to aid memory and understanding, typically by using a set of local variables with conventional names patterned after the names of parameters to widely used classes. For example: –in and out, whenever some kind of input and output are involved, patterned after the fields of System –off and len, whenever an offset and length are involved, patterned after the parameters to the read and write methods of the interfaces DataInput and DataOutput of java.io",8.86,189.02,324,865,90,402.1,414,591.12,FALSE,FALSE
216,3,BODY,"which declare two class types in the package points: •The class type PointVec is not public and not part of the public interface of the package points, but rather can be used only by other classes in the package. •The class type Point is declared public and is available to other packages. It is part of the public interface of the package points. •The methods move, getX, and getY of the class Point are declared public and so are available to any code that uses an object of type Point. •The fields x and y are declared protected and are accessible outside the package points only in subclasses of class Point, and only when they are fields of objects that are being implemented by the code that is accessing them. See §6.6.2 for an example of how the protected access modifier limits access.",8.86,147.02,324.01,794,90,116.1,414.01,263.12,FALSE,FALSE
221,2,BODY,"The method delta3d can access the protected members of its parameter q, because the class Point3d is a subclass of Point and is involved in the implementation of a Point3d. The method delta could try to cast (§5.5, §15.16) its parameter to be a Point3d, but this cast would fail, causing an exception, if the class of p at run time were not Point3d. A compile-time error also occurs in the method warp: it cannot access the protected member z of its parameter a, because while the class Point (the class in which the reference to field z occurs) is involved in the implementation of a Point3d (the type of the parameter a), it is not a subclass of Point3d (the class in which z is declared).",8.86,99.02,324.01,691,90,74.1,414.01,173.12,FALSE,FALSE
276,5,BODY,"which invokes the constructor, with no arguments, for the direct superclass of the class ColoredPoint. The error is that the constructor for Point that takes no arguments is private, and therefore is not accessible outside the class Point, even through a superclass constructor invocation (§8.8.7). Two more errors occur because the method reset of class Point is private, and therefore is not inherited by class ColoredPoint. The method invocations in method clear of class ColoredPoint and in method main of class Test are therefore not correct.",8.86,77.02,324,547,90,364.1,414,441.12,FALSE,FALSE
277,7,BODY,"using the move method of the superclass Point3d to process dx, dy, and dz. If Point4d is written in this way, it will compile without errors.",8.86,15.02,324,141,90,406.1,414,421.12,FALSE,FALSE
289,3,BODY,"If, in the following example, one thread repeatedly calls the method one (but no more than Integer.MAX_VALUE times in all), and another thread repeatedly calls the method two:",8.86,15.02,324,175,90,99.1,414,114.12,FALSE,FALSE
300,5,BODY,"Without special dispensation, Overrider.toList would no longer override CollectionConverter.toList. Instead, the code would be illegal. This would significantly inhibit the use of generics, since library writers would hesitate to migrate existing code.",8.86,35.02,324,252,90,180.1,414,215.12,FALSE,FALSE
348,7,BODY,These are the names of the no-args public and protected methods in Object. Disallowing them as the names of record components avoids confusion in a number of,8.86,15.02,324,157,90,585.1,414,600.12,FALSE,FALSE
376,6,BODY,"Here, the method named move is overloaded in interface RealPointInterface with three different signatures, two of them declared and one inherited. Any non-abstract class that implements interface RealPointInterface must provide implementations of all three method signatures.",8.86,35.02,324,275,90,369.1,414,404.12,FALSE,FALSE
401,8,BODY,Here is an example using the Preliminary marker annotation interface from §9.6.1:,8.86,5.02,308,81,90,277.1,398,282.12,FALSE,FALSE
415,12,BODY,"The function type of a functional interface is defined nondeterministically: while the signatures in M are 'the same', they may be syntactically different (HashMap.Entry and Map.Entry, for example); the return type may be a subtype of every other return type, but there may be other return types that are also subtypes (List<?> and List<? extends Object>, for example); and the order of thrown types is unspecified. These distinctions are subtle, but they can sometimes be important. However, function types are not used in the Java programming language in such a way that the nondeterminism matters. Note that the return type and throws clause of a 'most specific method' are also defined nondeterministically when there are multiple abstract methods (§15.12.2.5). When a generic functional interface is parameterized by wildcards, there are many different instantiations that could satisfy the wildcard and produce different function types. For example, each of Predicate<Integer> (function type Integer -> boolean), Predicate<Number> (function type Number -> boolean), and Predicate<Object> (function type Object -> boolean) is a Predicate<? super Integer>. Sometimes, it is possible to known from the context, such as the parameter types of a lambda expression, which function type is intended (§15.27.3). Other times, it is necessary to pick one; in these circumstances, the bounds are used. (This simple strategy cannot guarantee that the resulting type will satisfy certain complex bounds, so not all complex cases are supported.)",8.86,187.02,324,1537,90,404.1,414,591.12,FALSE,FALSE
427,12,BODY,The method toCharArray in class String returns an array of characters containing the same character sequence as a String. The class StringBuffer implements useful methods on mutable arrays of characters.,8.86,25.02,324,203,90,542.1,414,567.12,FALSE,FALSE
441,3,BODY,"The declaration of the method thrower must have a throws clause because it can throw instances of TestException, which is a checked exception class (§11.1.1). A compile- time error would occur if the throws clause were omitted. Notice that the finally clause is executed on every invocation of thrower, whether or not an exception occurs, as shown by the '[thrower(...) done]' output that occurs for each invocation.",8.86,67.02,324,416,90,196.1,414,263.12,FALSE,FALSE
459,5,BODY,"This shows that the invocation of printThree in the constructor for class Super does not invoke the definition of printThree in class Super, but rather invokes the overriding definition of printThree in class Test. This method therefore runs before the field initializers of Test have been executed, which is why the first value output is 0, the default value to which the field three of Test is initialized. The later invocation of printThree in method main invokes the same definition of printThree, but by that point the initializer for instance variable three has been executed, and so the value 3 is printed.",8.86,65.02,324.01,613,90,260.1,414.01,325.12,FALSE,FALSE
530,2,BODY,"3.If the value is not the null reference, and no case label applies according to the rules of step 2, but there is a default label associated with the switch block, then the default label applies. A single case label can contain several case constants. The label applies to the value of the selector expression if any one of its constants is equal to the value of the selector expression. For example, in the following code, the case label applies if the enum variable day is either one of the enum constants shown: switch (day) { ... case SATURDAY, SUNDAY : System.out.println('It's the weekend!'); break; ... }",8.86,165.05,360,612,72,76.06,432,241.11,FALSE,FALSE
597,12,BODY,because the assignment of the string 'gone' to s occurs after the first two arguments to print3 have been evaluated.,8.86,15.02,324,116,90,588.1,414,603.12,FALSE,FALSE
656,9,BODY,"the occurrence of s before '.startsWith' is evaluated first, before the argument expression s = 'two'. Therefore, a reference to the string 'one' is remembered as the target reference before the local variable s is changed to refer to the string 'two'. As a result, the startsWith method is invoked for target object 'one' with argument 'two', so the result of the invocation is false, as the string 'one' does not start with 'two'. It follows that the test program does not print 'oops'.",8.86,55.02,324,488,90,403.1,414,458.12,FALSE,FALSE
703,3,BODY,Thus != behaves the same as ^ (§15.22.2) when applied to boolean operands.,8.86,5.02,284.21,74,90,144.1,374.21,149.12,FALSE,FALSE
808,4,BODY,"Our approach is to 'lift' the bounds inferred for the nested invocation (simply { α <: Object } in the case of emptyList) into the outer inference process (in this case, trying to infer β where the constructor is for type ArrayList<β>). We also infer dependencies between the nested inference variables and the outer inference variables (the constraint ‹List<α> → Collection<β>› would reduce to the dependency α = β). In this way, resolution of the inference variables in the nested invocation can wait until additional information can be inferred from the outer invocation (based on the assignment target, β = String).",8.86,86.59,324,619,90,474.04,414,560.63,FALSE,FALSE
824,7,BODY,"{ ‹1 → α›, ‹2.0 → α› } These are reduced to a new bound set, B1:",8.86,27.71,150.61,64,90,568.29,240.61,596,FALSE,FALSE
31,5,BODY,BreakStatement: break [Identifier] ;,8.85,14.95,83.8,36,108,202.15,191.8,217.1,FALSE,TRUE
112,2,BODY,•Exception parameters (§14.20); here the exception parameter e of the catch clause is declared to be of type Exception •Type parameters (§4.4); here the type parameter of MiscMath is a type variable T with the type Number as its declared bound •In any declaration that uses a parameterized type; here the type Number is used as a type argument (§4.5.1) in the parameterized type Collection<Number>. and in expressions of the following kinds: •Class instance creations (§15.9); here a local variable r of method gausser is initialized by a class instance creation expression that uses the type Random •Generic class (§8.1.2) instance creations (§15.9); here Number is used as a type argument in the expression new ArrayList<Number>() •Array creations (§15.10.1); here the local variable val of method gausser is initialized by an array creation expression that creates an array of double with size 2 •Generic method (§8.4.4) or constructor (§8.8.4) invocations (§15.12); here the method loop calls itself with an explicit type argument S •Casts (§15.16); here the return statement of the method ratio uses the float type in a cast •The instanceof operator (§15.20.2); here the instanceof operator tests whether e is assignment-compatible with the type ArithmeticException,8.85,251.02,324.01,1270,90,74.1,414.01,325.12,FALSE,FALSE
178,6,BODY,"These rules imply that declarations of class and interface types need not appear before uses of the types. In the following program, the use of PointList in class Point is valid, because the scope of the class declaration PointList includes both class Point and class PointList, as well as any other class or interface declarations in other compilation units of package points.",8.85,45.02,324.01,377,90,431.1,414.01,476.12,FALSE,FALSE
218,2,BODY,"then a subclass in another package may declare an unrelated move method, with the same signature (§8.4.2) and return type. Because the original move method is not accessible from package morepoints, super may not be used:",8.85,25.02,324,221,90,74.1,414,99.12,FALSE,FALSE
227,5,BODY,"For example, there is no special access relationship between a package named oliver and another package named oliver.twist, or between packages named evelyn.wood and evelyn.waugh. That is, the code in a package named oliver.twist has no better access to the classes and interfaces declared within package oliver than code in any other package.",8.85,45.02,324.01,343,90,242.1,414.01,287.12,FALSE,FALSE
247,9,BODY,and where a package client in module m.A refers to the public type Point in the exported package p:,8.85,15.02,324,99,90,499.1,414,514.12,FALSE,FALSE
288,4,BODY,If an instance of the class Point:,8.85,5.02,119.98,34,90,304.36,209.98,309.38,FALSE,FALSE
300,3,BODY,"Now, assume this code was written before the introduction of generics, and now the author of class CollectionConverter decides to generify the code, thus:",8.85,15.02,324.01,154,90,106.1,414.01,121.12,FALSE,FALSE
301,9,BODY,"We can declare an abstract class Point that requires its subclasses to implement toString if they are to be complete, instantiable classes:",8.85,15.02,324,139,90,519.1,414,534.12,FALSE,FALSE
313,3,BODY,"Here, the class SlowPoint overrides the declarations of method move of class Point with its own move method, which limits the distance that the point can move on each invocation of the method. When the move method is invoked for an instance of class SlowPoint, the overriding definition in class SlowPoint will always be called, even if the reference to the SlowPoint object is taken from a variable whose type is Point.",8.85,45.02,324.01,420,90,116.1,414.01,161.12,FALSE,FALSE
424,7,BODY,"before causing a NullPointerException in trying to index the second component of the array ia, which is a null reference.",8.85,15.02,324.01,121,90,588.1,414.01,603.12,FALSE,FALSE
425,3,BODY,See §9.6.4.4 for another situation where the difference between public and non-public methods of Object requires special care.,8.85,15.02,314,126,100,272.1,414,287.12,FALSE,FALSE
432,3,BODY,"Note that StackOverflowError, a subclass of VirtualMachineError, may be thrown synchronously by method invocation (§15.12.4.5) as well as asynchronously due to native method execution or Java Virtual Machine resource limitations. Similarly, OutOfMemoryError, another subclass of VirtualMachineError, may be thrown synchronously during class instance creation (§15.9.4, §12.5), array creation (§15.10.2, §10.6), class initialization (§12.4.2), and boxing conversion (§5.1.7), as well as asynchronously.",8.85,65.02,324,501,90,217.1,414,282.12,FALSE,FALSE
504,1,BODY,"The final declaration of Local is legal, since it occurs outside the scope of any prior declaration of Local.",8.85,15.02,324,109,90,74.1,414,89.12,FALSE,FALSE
545,5,BODY,Example 14.14-1. Enhanced for And Arrays,8.85,5.19,170.54,40,90,493.62,260.54,498.81,TRUE,FALSE
702,3,BODY,The methods Float.isNaN and Double.isNaN may also be used to test whether a value is NaN.,8.85,15.02,314,89,100,214.1,414,229.12,FALSE,FALSE
4,0,BODY,The Java® Language Specification,8.84,6.75,123.66,32,72,38.35,195.66,45.1,FALSE,TRUE
5,0,BODY,The Java® Language Specification,8.84,6.75,123.66,32,308.34,38.35,432,45.1,FALSE,TRUE
6,0,BODY,The Java® Language Specification,8.84,6.75,123.66,32,72,38.35,195.66,45.1,FALSE,TRUE
7,0,BODY,The Java® Language Specification,8.84,6.75,123.66,32,308.34,38.35,432,45.1,FALSE,TRUE
8,0,BODY,The Java® Language Specification,8.84,6.75,123.66,32,72,38.35,195.66,45.1,FALSE,TRUE
9,0,BODY,The Java® Language Specification,8.84,6.75,123.66,32,308.34,38.35,432,45.1,FALSE,TRUE
10,0,BODY,The Java® Language Specification,8.84,6.75,123.66,32,72,38.35,195.66,45.1,FALSE,TRUE
11,0,BODY,The Java® Language Specification,8.84,6.75,123.66,32,308.34,38.35,432,45.1,FALSE,TRUE
12,0,BODY,The Java® Language Specification,8.84,6.75,123.66,32,72,38.35,195.66,45.1,FALSE,TRUE
13,0,BODY,The Java® Language Specification,8.84,6.75,123.66,32,308.34,38.35,432,45.1,FALSE,TRUE
14,0,BODY,The Java® Language Specification,8.84,6.75,123.66,32,72,38.35,195.66,45.1,FALSE,TRUE
15,0,BODY,The Java® Language Specification,8.84,6.75,123.66,32,308.34,38.35,432,45.1,FALSE,TRUE
16,0,BODY,The Java® Language Specification,8.84,6.75,123.66,32,72,38.35,195.66,45.1,FALSE,TRUE
98,5,BODY,"In this program (which is not meant to be run), RawMembers<T> inherits the method:",8.84,5.02,307.38,82,90,419.1,397.38,424.12,FALSE,FALSE
192,7,BODY,This program declares: •a class Test •a class (static) variable x that is a member of the class Test •a class method main that is a member of the class Test •a parameter args of the main method •a local variable x of the main method,8.84,91.02,235.26,232,90,503.1,325.26,594.12,FALSE,FALSE
229,5,BODY,"A package name component or class name might contain a character that cannot correctly appear in a host file system's ordinary directory name, such as a Unicode character on a system that allows only ASCII characters in file names. As a convention, the character can be escaped by using, say, the @ character followed by four hexadecimal digits giving the numeric value of the character, as in the \uxxxx escape (§3.3). Under this convention, the package name: children.activities.crafts.papierM\u00e2ch\u00e9",8.84,88.01,324.01,509,90,360.1,414.01,448.11,FALSE,FALSE
234,2,BODY,"One can conclude this from the rule above and from the rules of observable compilation units, as follows. The predefined package java.lang declares the class Object, so the compilation unit for Object is always observable (§7.3). Hence, the java.lang package is observable, and the java package also. Furthermore, since Object is observable, the array type Object[] implicitly exists. Its superinterface java.io.Serializable (§10.1) also exists, hence the java.io package is observable.",8.84,55.02,324,486,90,74.1,414,129.12,FALSE,FALSE
286,5,BODY,"because the declaration of x in class Test hides the definition of x in class Point, so class Test does not inherit the field x from its superclass Point. Within the declaration of class Test, the simple name x refers to the field declared within class Test. Code in class Test may refer to the field x of class Point as super.x (or, because x is static, as Point.x). If the declaration of Test.x is deleted:",8.84,45.02,324,408,90,220.1,414,265.12,FALSE,FALSE
310,7,BODY,"Here, the abstract class Test inherits the abstract method foo from interface I1 and also the abstract method foo from interface I2. The key question in determining the inheritance of foo from I1 is: does the method foo in I2 override 'from I2' (§9.4.1.1) the method foo in I1? No, because I1 and I2 are not subinterfaces of each other. Thus, from the viewpoint of class Test, the inheritance of foo from I1 is unfettered; similarly for the inheritance of foo from I2. Per §8.4.8.4, class Test can inherit both foo methods;",8.84,55.02,324,523,90,542.1,414,597.12,FALSE,FALSE
318,2,BODY,"Now, at some point the author of StringSorter decides to generify the code:",8.84,5.02,284.31,75,90,74.1,374.31,79.12,FALSE,FALSE
388,2,BODY,"•If Foo has no @Target meta-annotation but FooContainer has an @Target meta-annotation, then @Foo may only be repeated on program elements where @FooContainer may appear. •If Foo has an @Target meta-annotation, then in the judgment of the designers of the Java programming language, FooContainer must be declared with knowledge of the Foo's applicability. Specifically, the kinds of program element where FooContainer may appear must logically be the same as, or a subset of, Foo's kinds. For example, if Foo is applicable to field and method declarations, then FooContainer may legitimately serve as Foo's containing annotation interface if FooContainer is applicable to just field declarations (preventing @Foo from being repeated on method declarations). But if FooContainer is applicable only to formal parameter declarations, then FooContainer was a poor choice of containing annotation interface by Foo because @FooContainer cannot be implicitly declared on some program elements where @Foo is repeated. Similarly, if Foo is applicable to field and method declarations, then FooContainer cannot legitimately serve as Foo's containing annotation interface if FooContainer is applicable to field and parameter declarations. While it would be possible to take the intersection of the program elements and make Foo repeatable on field declarations only, the presence of additional program elements for FooContainer indicates that FooContainer was not designed as a containing annotation interface for Foo. It would therefore be dangerous for Foo to rely on it.",8.84,235.02,324,1562,90,74.1,414,309.12,FALSE,FALSE
408,2,BODY,"annotation of interface FooContainer would be contained in yet another implicitly declared annotation. This complexity is undesirable in the judgment of the designers of the Java programming language. Another approach, treating the base annotations of interface Foo as if they had occurred alongside @Foo(2) in the explicit @FooContainer annotation, is undesirable because it could change how reflective programs interpret the @FooContainer annotation.",8.84,55.02,324,452,90,74.1,414,129.12,FALSE,FALSE
409,7,BODY,The following interface is not functional because it declares nothing which is not already a member of Object:,8.84,15.02,323.99,110,90,358.1,413.99,373.12,FALSE,FALSE
418,3,BODY,"The supertype relation for array types is not the same as the superclass relation. The direct supertype of Integer[] is Number[] according to §4.10.3, but the direct superclass of Integer[] is Object according to the Class object for Integer[] (§10.8). This does not matter in practice, because Object is also a supertype of all array types.",8.84,35.02,324.01,341,90,393.1,414.01,428.12,FALSE,FALSE
452,8,BODY,Example 12.4.1-2. Only The Class That Declares static Field Is Initialized,8.84,5.19,286.83,74,90,434.62,376.83,439.81,TRUE,FALSE
483,10,BODY,"If the method print in class Point is changed to be public, and then only the Point class is recompiled, and then executed with the previously existing binary for Test, then no linkage error occurs. This happens even though it is improper, at compile time, for a public method to be overridden by a protected method (as shown by the fact that the class Test could not be recompiled using this new Point class unless print in Test were changed to be public.)",8.84,55.02,324,457,90,464.1,414,519.12,FALSE,FALSE
485,10,BODY,"would result in a compile-time error, because the h in the source code for main would now be construed as referring to the char field declared in Super, and a char value can't be assigned to a String.",8.84,25.02,324,200,90,516.1,414,541.12,FALSE,FALSE
522,3,BODY,"If used, a default label should come last in a switch block. For compatibility reasons, a default label may appear before case labels that do not have a null literal or case patterns.",8.84,37.02,324,183,90,240.1,414,277.12,FALSE,FALSE
574,4,BODY,"does not result in a compile-time error. An optimizing compiler may realize that the statement x=3; will never be executed and may choose to omit the code for that statement from the generated class file, but the statement x=3; is not regarded as 'unreachable' in the technical sense specified here. The rationale for this differing treatment is to allow programmers to define 'flag' variables such as: static final boolean DEBUG = false;",8.84,88.01,324,438,90,162.1,414,250.11,FALSE,FALSE
624,4,BODY,because the monstrous expression's value is equivalent to a[b[3]] or a[3] or 14.,8.84,5.02,297.24,80,90,170.1,387.24,175.12,FALSE,FALSE
628,7,BODY,Example 15.11.1-2. Receiver Variable Is Irrelevant For static Field Access,8.84,5.19,289.52,74,90,415.62,379.52,420.81,TRUE,FALSE
716,3,BODY,"The rules above allow both assignments to be considered well-typed. Note that a reference conditional expression does not have to contain a poly expression as an operand in order to be a poly expression. It is a poly expression simply by virtue of the context in which it appears. For example, in the following code, the conditional expression is a poly expression, and each operand is considered to be in an assignment context targeting Class<? super Integer>:",8.84,67.02,324.01,461,90,118.1,414.01,185.12,FALSE,FALSE
797,6,BODY,"The class FinalFieldExample has a final int field x and a non-final int field y. One thread might execute the method writer and another might execute the method reader. Because the writer method writes f after the object's constructor finishes, the reader method will be guaranteed to see the properly initialized value for f.x: it will read the value 3. However, f.y is not final; the reader method is therefore not guaranteed to see the value 4 for it.",8.84,67.02,324,454,90,391.1,414,458.12,FALSE,FALSE
122,6,BODY,"In this example: •The local variable p of the method main of class Test has type Point and is initially assigned a reference to a new instance of class Point. •The local variable cp similarly has as its type ColoredPoint, and is initially assigned a reference to a new instance of class ColoredPoint. •The assignment of the value of cp to the variable p causes p to hold a reference to a ColoredPoint object. This is permitted because ColoredPoint is a subclass of Point, so the class ColoredPoint is assignment-compatible (§5.2) with the type Point. A ColoredPoint object includes support for all the methods of a Point. In addition to its particular fields r, g, and b, it has the fields of class Point, namely x and y. •The local variable c has as its type the interface type Colorable, so it can hold a reference to any object whose class implements Colorable; specifically, it can hold a reference to a ColoredPoint.",8.83,155.02,324,921,90,448.1,414,603.12,FALSE,FALSE
223,7,BODY,"Both p.O1.I and p.O2.I are fully qualified names that denote the member class I, but only p.O1.I is its canonical name.",8.83,15.02,324,119,90,247.1,414,262.12,FALSE,FALSE
241,7,BODY,"the declaration of the class Vector is permitted even though there is also a class java.util.Vector. Within this compilation unit, the simple name Vector refers to the class test.Vector, not to java.util.Vector (which can still be referred to by code within the compilation unit, but only by its fully qualified name).",8.83,35.02,324,318,90,568.1,414,603.12,FALSE,FALSE
257,7,BODY,"would result in a compile-time error; the class Point cannot be instantiated because it is abstract. However, a Point variable could correctly be initialized with a reference to any subclass of Point, and the class SimplePoint is not abstract, so the statement:",8.83,25.02,324,261,90,424.1,414,449.12,FALSE,FALSE
340,3,BODY,"The equals method in Enum is a final method that merely invokes super.equals on its argument and returns the result, thus performing an identity comparison.",8.83,15.02,324,156,90,189.1,414,204.12,FALSE,FALSE
392,9,BODY,"The use of @Override in the class declaration is legal by the first clause, because Foo.hashCode overrides from Foo the method Object.hashCode. For the interface declaration, consider that an interface has public abstract members which correspond to the public members of Object (§9.2). If an interface chooses to declare them explicitly (that is, to declare members that are override-equivalent to public methods of Object), then the interface is deemed to override them, and use of @Override is allowed.",8.83,77.02,324,505,90,502.23,414,579.25,FALSE,FALSE
404,3,BODY,"For example, in the field declaration @Foo public static String f;, the type which is closest to @Foo is String. (If the type of the field declaration had been written as java.lang.String, then java.lang.String would be the type closest to @Foo, and later rules would prohibit a type annotation from applying to the package name java.) In the generic method declaration @Foo <T> int[] m() {...}, the type written for the declared entity is int[], so @Foo applies to the element type int. Local variable declarations which do not use var are similar to formal parameter declarations of lambda expressions, in that both allow declaration annotations and type annotations in source code, but only the type annotations can be stored in the class file.",8.83,97.02,314,747,100,421.1,414,518.12,FALSE,FALSE
407,2,BODY,"Note that the illegal terms are illegal 'everywhere'. The ban on annotating package names applies broadly: to locations which are solely type contexts, such as class ... extends @TA java.lang.Object {...}, and to locations which are both declaration and type contexts, such as @TA java.lang.Object f;. (There are no locations which are solely declaration contexts where a package name could be annotated, as package, class, interface, and type parameter declarations introduce only simple names.) If TA is additionally meta-annotated with @Target(ElementType.FIELD), then the term @TA java.lang.Object is legal in locations which are both declaration and type contexts, such as a field declaration @TA java.lang.Object f;. Here, @TA is deemed to apply to the declaration of f (and not to the type java.lang.Object) because TA is applicable in the field declaration context.",8.83,117.02,324.01,873,90,74.1,414.01,191.12,FALSE,FALSE
480,2,BODY,"This version of class Super is not a subclass of Hyper. If we then run the existing binaries of Hyper and Test with the new version of Super, then a VerifyError is thrown at link time. The verifier complains because the result of new Super() cannot be passed as an argument in place of a formal parameter of type Hyper, because Super is not a subclass of Hyper. It is instructive to consider what might happen without the verification step: the program might run and print:",8.83,77.02,324,473,90,74.1,414,151.12,FALSE,FALSE
530,3,BODY,"If a case label with a case pattern applies, then this is because the process of pattern matching the value against the pattern has succeeded (§14.30.2). If a value successfully matches a pattern then the process of pattern matching initializes any pattern variables declared by the pattern. In C and C++ the body of a switch statement can be a statement and statements with case labels do not have to be immediately contained by that statement. Consider the simple loop: for (i = 0; i < n; ++i) foo();",8.83,88.01,324.01,502,90,259.1,414.01,347.11,FALSE,FALSE
547,4,BODY,"In the following example, a mathematical graph is represented by an array of arrays. A graph consists of a set of nodes and a set of edges; each edge is an arrow that points from some node to some other node, or from a node to itself. In this example it is assumed that there are no redundant edges; that is, for any two nodes P and Q, where Q may be the same as P, there is at most one edge from P to Q. Nodes are represented by integers, and there is an edge from node i to node edges[i] [j] for every i and j for which the array reference edges[i][j] does not throw an ArrayIndexOutOfBoundsException.",8.83,87.02,324,603,90,193.1,414,280.12,FALSE,FALSE
549,3,BODY,"It can be seen, then, that a continue statement always completes abruptly. See the descriptions of the while statement (§14.12), do statement (§14.13), and for statement (§14.14) for a discussion of the handling of abrupt termination because of continue. The preceding descriptions say 'attempts to transfer control' rather than just 'transfers control' because if there are any try statements (§14.20) within the continue target whose try blocks or catch clauses contain the continue statement, then any finally clauses of those try statements are executed, in order, innermost to outermost, before control is transferred to the continue target. Abrupt completion of a finally clause can disrupt the transfer of control initiated by a continue statement.",8.83,119.02,324,755,90,189.1,414,308.12,FALSE,FALSE
630,8,BODY,"Within class T3, the expression super.x has the same effect as ((T2)this).x when x has package access. Note that super.x is not specified in terms of a cast, due to difficulties around access to protected members of the superclass.",8.83,25.02,324,231,90,441.1,414,466.12,FALSE,FALSE
76,10,BODY,"Under IEEE 754, a floating-point operation with non-NaN arguments may generate a NaN result. IEEE 754 specifies a set of NaN bit patterns, but does not mandate which particular NaN bit pattern is used to represent a NaN result; this is left to the hardware architecture. A programmer can create NaNs with different bit patterns to encode, for example, retrospective diagnostic information. These NaN values can be created with the Float.intBitsToFloat and Double.longBitsToDouble methods for float and double, respectively. Conversely, to inspect the bit patterns of NaN values, the Float.floatToRawIntBits and Double.doubleToRawLongBits methods can be used for float and double, respectively.",8.82,85.02,324,693,90,454.1,414,539.12,FALSE,FALSE
134,3,BODY,"Using types from the java.util package as an example, no narrowing reference conversion exists from ArrayList<String> to ArrayList<Object>, or vice versa, because the type arguments String and Object are provably distinct. For the same reason, no narrowing reference conversion exists from ArrayList<String> to List<Object>, or vice versa. The rejection of provably distinct types is a simple static gate to prevent 'stupid' narrowing reference conversions.",8.82,55.02,314,457,100,406.23,414,461.25,FALSE,FALSE
194,3,BODY,using the class Vector declared here in preference to the generic class java.util.Vector (§8.1.2) that might be imported on demand.,8.82,15.02,324,131,90,96.1,414,111.12,FALSE,FALSE
202,2,BODY,"•Next, assuming that there is no class or interface named rpgpoet in any compilation unit of package org (and we know that there is no such class or interface because package org has a subpackage named rpgpoet), the qualified name org.rpgpoet is reclassified as a PackageName. •Next, because package org.rpgpoet has an accessible (§6.6) interface type named Music, the qualified name org.rpgpoet.Music is reclassified as a TypeName. •Finally, because the name org.rpgpoet.Music is a TypeName, the qualified name org.rpgpoet.Music.wizards is reclassified as an ExpressionName.",8.82,87.02,324.01,575,90,74.1,414.01,161.12,FALSE,FALSE
216,4,BODY,"Example 6.6-2. Access to public Fields, Methods, and Constructors",8.82,5.19,258.55,65,90,281.62,348.55,286.81,TRUE,FALSE
217,6,BODY,"However, this compilation unit cannot use or import points.PointList, which is not declared public and is therefore inaccessible outside package points.",8.82,15.02,324,152,90,374.1,414,389.12,FALSE,FALSE
227,3,BODY,"that has as a member a public class named Vector, even though the package java.util also declares a class named Vector. These two classes are different, reflected by the fact that they have different fully qualified names (§6.7). The fully qualified name of this example Vector is vector.Vector, whereas java.util.Vector is the fully qualified name of the Vector class included in the Java SE Platform. Because the package vector contains a class named Vector, it cannot also have a subpackage named Vector.",8.82,55.02,324,507,90,106.1,414,161.12,FALSE,FALSE
303,2,BODY,"8.4.3.3final Methods A method can be declared final to prevent subclasses from overriding or hiding it. It is a compile-time error to attempt to override or hide a final method. A private method and all methods declared immediately within a final class (§8.1.1.2) behave as if they are final, since it is impossible to override them. At run time, a machine-code generator or optimizer can 'inline' the body of a final method, replacing an invocation of the method with the code in its body. The inlining process must preserve the semantics of the method invocation. In particular, if the target of an instance method invocation is null, then a NullPointerException must be thrown even if the method is inlined. A Java compiler must ensure that the exception will be thrown at the correct point, so that the actual arguments to the method will be seen to have been evaluated in the correct order prior to the method invocation. Consider the example: final class Point { int x, y; void move(int dx, int dy) { x += dx; y += dy; } } class Test { public static void main(String[] args) { Point[] p = new Point[100]; for (int i = 0; i < p.length; i++) { p[i] = new Point(); p[i].move(i, p.length-1-i); } } }",8.82,322.11,360.01,1201,72,76.13,432.01,398.24,FALSE,FALSE
318,6,BODY,"This program uses the usual and conventional form for declaring a new exception type, in its declaration of the class BadPointException:",8.82,15.02,323.99,136,90,215.1,413.99,230.12,FALSE,FALSE
396,4,BODY,"The annotation @SafeVarargs has non-local effects because it suppresses unchecked warnings at method invocation expressions, in addition to an unchecked warning pertaining to the declaration of the variable arity method itself (§8.4.1). In contrast, the annotation @SuppressWarnings('unchecked') has local effects because it only suppresses unchecked warnings pertaining to the declaration of a method. The canonical target for @SafeVarargs is a method like java.util.Collections.addAll, whose declaration starts with:",8.82,77.02,324.01,518,90,375.23,414.01,452.25,FALSE,FALSE
409,3,BODY,"The definition of functional interface excludes methods in an interface that are also public methods in Object. This is to allow functional treatment of an interface like java.util.Comparator<T> that declares multiple abstract methods of which only one is really 'new' - int compare(T,T). The other - boolean equals(Object) - is an explicit declaration of an abstract method that would otherwise be implicitly declared in the interface (§9.2) and automatically implemented by every class that implements the interface. Note that if non-public methods of Object, such as clone(), are explicitly declared in an interface as public, they are not automatically implemented by every class that implements the interface. The implementation inherited from Object is protected while the interface method is public, so the only way to implement the interface would be for a class to override the non-public Object method with a public method.",8.82,127.02,324,933,90,125.1,414,252.12,FALSE,FALSE
409,9,BODY,"However, its subinterface can be functional by declaring an abstract method which is not a member of Object:",8.82,15.02,324,108,90,432.1,414,447.12,FALSE,FALSE
436,5,BODY,"A Java compiler is encouraged to issue a warning if a catch clause can catch checked exception class E1 and the try block corresponding to the catch clause can throw checked exception class E2, where E2 <: E1, and a preceding catch clause of the immediately enclosing try statement can catch checked exception class E3, where E2 <: E3 <: E1.",8.82,35.02,324,341,90,515.1,414,550.12,FALSE,FALSE
559,3,BODY,"Here, the exception BlewIt is thrown by the method blowUp. The try-catch statement in the body of main has two catch clauses. The run-time type of the exception is BlewIt which is not assignable to a variable of type RuntimeException, but is assignable to a variable of type BlewIt, so the output of the example is:",8.82,35.02,324,315,90,196.1,414,231.12,FALSE,FALSE
664,7,BODY,"The erasure of the actual method being invoked, D.id(), differs in its signature from that of the compile-time method declaration, C.id(). The former takes an argument of type String while the latter takes an argument of type Object. The invocation fails with a ClassCastException before the body of the method is executed. Such situations can only arise if the program gives rise to a compile-time unchecked warning (§4.8, §5.1.6, §5.1.9, §8.4.1, §8.4.8.3, §15.13.2, §15.12.4.2, §15.27.3). Implementations can enforce these semantics by creating bridge methods. In the above example, the following bridge method would be created in class D: Object id(Object x) { return id((String) x); }",8.82,120.01,324,688,90,321.1,414,441.11,FALSE,FALSE
723,4,BODY,"which indicates that the attempt to store a reference to a StringBuffer into an array whose components are of type Thread throws an ArrayStoreException. The code is type- correct at compile time: the assignment has a left-hand side of type Object[] and a right- hand side of type Object. At run time, the first actual argument to method testFour is a reference to an instance of 'array of Thread' and the third actual argument is a reference to an instance of class StringBuffer.",8.82,55.02,324,479,90,118.1,414,173.12,FALSE,FALSE
739,4,BODY,"The parameter types of explicitly typed lambdas are required to exactly match those of the function type. While it would be possible to be more flexible - allow boxing or contravariance, for example - this kind of generality seems unnecessary, and is inconsistent with the way overriding works in class declarations. A programmer ought to know exactly what function type is being targeted when writing a lambda expression, so the programmer should thus know exactly what signature must be overridden. (This is not the case for method references, so more flexibility is allowed when they are used.) In addition, more flexibility with parameter types would add to the complexity of type inference and overload resolution. Note that while boxing is not allowed in a strict invocation context, boxing of lambda result expressions is always allowed - that is, the result expression appears in an assignment context, regardless of the context enclosing the lambda expression. However, if an explicitly typed lambda expression is an argument to an overloaded method, a method signature that avoids boxing or unboxing the lambda result is preferred by the most specific check (§15.12.2.5). If the body of a lambda is a statement expression (that is, an expression that would be allowed to stand alone as a statement), it is compatible with a void-producing function type; any result is simply discarded. So, for example, both of the following are legal: // Predicate has a boolean result java.util.function.Predicate<String> p = s -> list.add(s); // Consumer has a void result java.util.function.Consumer<String> c = s -> list.add(s);",8.82,250.01,324.01,1626,90,279.1,414.01,529.11,FALSE,FALSE
799,5,BODY,Example 17.5.3-1. Aggressive Optimization of final Fields,8.82,5.19,224.88,57,90,518.62,314.88,523.81,TRUE,FALSE
32,2,BODY,BasicForStatement: for ( ; ; ) Statement for ( ; ; ForUpdate ) Statement for ( ; Expression ; ) Statement for ( ; Expression ; ForUpdate ) Statement for ( ForInit ; ; ) Statement for ( ForInit ; ; ForUpdate ) Statement for ( ForInit ; Expression ; ) Statement for ( ForInit ; Expression ; ForUpdate ) Statement,8.81,84.95,203.09,310,108,74.15,311.09,159.1,FALSE,TRUE
42,3,BODY,"Without this rule for > characters, two consecutive > brackets in a type such as List<List<String>> would be tokenized as the signed right shift operator >>, while three consecutive > brackets in a type such as List<List<List<String>>> would be tokenized as the unsigned right shift operator >>>. Worse, the tokenization of four or more consecutive > brackets in a type such as List<List<List<List<String>>>> would be ambiguous, as various combinations of >, >>, and >>> tokens could represent the >>>> characters.",8.81,65.02,314.01,514,100,112.1,414.01,177.12,FALSE,FALSE
89,2,BODY,"•Pair<String,Integer> Here are some incorrect parameterizations of those generic classes: •Seq<int> is illegal, as primitive types cannot be type arguments. •Pair<String> is illegal, as there are not enough type arguments. •Pair<String,String,String> is illegal, as there are too many type arguments. A parameterized type may be a parameterization of a generic class or interface which is nested. For example, if a non-generic class C has a generic member class D with one type parameter, then C.D<Object> is a parameterized type. Meanwhile, if a generic class C with one type parameter has a non-generic member class D, then the member class type C<String>.D is a parameterized type, even though the class D is not generic.",8.81,143.02,324,724,90,74.1,414,217.12,FALSE,FALSE
144,3,BODY,"Capture conversion is designed to make wildcards more useful. To understand the motivation, let's begin by looking at the method java.util.Collections.reverse():",8.81,15.02,324,161,90,323.1,414,338.12,FALSE,FALSE
301,7,BODY,"The overriding declaration of method get in class InfiniteBuffer states that method get in any subclass of InfiniteBuffer never throws a BufferEmpty exception, putatively because it generates the data in the buffer, and thus can never run out of data.",8.81,25.02,324,251,90,452.1,414,477.12,FALSE,FALSE
314,4,BODY,"The class BufferOutput implements a very simple buffered version of an OutputStream, flushing the output when the buffer is full or flush is invoked. The subclass LineBufferOutput declares only a constructor and a single method putchar, which overrides the method putchar of BufferOutput. It inherits the methods putstr and flush from class BufferOutput. In the putchar method of a LineBufferOutput object, if the character argument is a newline, then it invokes the flush method. The critical point about overriding in this example is that the method putstr, which is declared in class BufferOutput, invokes the putchar method defined by the current object this, which is not necessarily the putchar method declared in class BufferOutput. Thus, when putstr is invoked in main using the LineBufferOutput object lbo, the invocation of putchar in the body of the putstr method is an invocation of the putchar of the object lbo, the overriding declaration of putchar that checks for a newline. This allows a subclass of BufferOutput to change the behavior of the putstr method without redefining it. Documentation for a class such as BufferOutput, which is designed to be extended, should clearly indicate what is the contract between the class and its subclasses, and should clearly indicate that subclasses may override the putchar method in this way. The implementor of the BufferOutput class would not, therefore, want to change the implementation of putstr in a future implementation of BufferOutput not to use the method putchar, because this would break the pre-existing contract with subclasses. See the discussion of binary compatibility in §13 (Binary Compatibility), especially §13.2.",8.81,251.02,324,1692,90,138.1,414,389.12,FALSE,FALSE
334,8,BODY,"In the code below, ChildOfInner has no lexically enclosing class or interface declaration, so an instance of ChildOfInner has no enclosing instance. However, the superclass of ChildOfInner (Inner) has a lexically enclosing class declaration (Outer), and an instance of Inner must have an enclosing instance of Outer. The enclosing instance of Outer is set when an instance of Inner is created. Therefore, when we create an instance of ChildOfInner, which is implicitly an instance of Inner, we must provide the enclosing instance of Outer via a qualified superclass invocation statement in ChildOfInner's constructor. The instance of Outer is called the immediately enclosing instance of ChildOfInner with respect to Inner.",8.81,85.02,324.01,723,90,404.1,414.01,489.12,FALSE,FALSE
337,9,BODY,"the public class PackageOnly can be instantiated only within the package just, in which it is declared. This restriction would also apply if the constructor of PackageOnly was protected, although in that case, it would be possible for code in other packages to instantiate subclasses of PackageOnly.",8.81,35.02,324,299,90,512.1,414,547.12,FALSE,FALSE
392,3,BODY,The classic example concerns the equals method. Programmers write the following in class Foo:,8.81,15.02,324,93,90,145.23,414,160.25,FALSE,FALSE
423,4,BODY,"The variable pa has type Point[] and the variable cpa has as its value a reference to an object of type ColoredPoint[]. A ColoredPoint can be assigned to a Point; therefore, the value of cpa can be assigned to pa. A reference to this array pa, for example, testing whether pa[1] is null, will not result in a run-time type error. This is because the element of the array of type ColoredPoint[] is a ColoredPoint, and every ColoredPoint can stand in for a Point, since Point is the superclass of ColoredPoint. On the other hand, an assignment to the array pa can result in a run-time error. At compile time, an assignment to an element of pa is checked to make sure that the value assigned is a Point. But since pa holds a reference to an array of ColoredPoint, the assignment is valid only if the type of the value assigned at run time is, more specifically, a ColoredPoint. The Java Virtual Machine checks for such a situation at run time to ensure that the assignment is valid; if not, an ArrayStoreException is thrown.",8.81,161.02,324.01,1021,90,128.1,414.01,289.12,FALSE,FALSE
444,4,BODY,"will typically start a Java Virtual Machine by invoking method main of class Test (a class in an unnamed package), passing it an array containing the four strings 'reboot', 'Bob', 'Dot', and 'Enzo'.",8.81,25.02,324,198,90,156.1,414,181.12,FALSE,FALSE
536,0,BODY,14.13The do Statement,8.81,4.95,99.16,21,36,40.15,135.16,45.1,FALSE,TRUE
537,1,BODY,The do Statement14.13,8.81,4.95,99.16,21,368.84,40.15,468,45.1,FALSE,TRUE
629,3,BODY,"Even though the result of favorite() is null, a NullPointerException is not thrown. That 'Mount ' is printed demonstrates that the Primary expression is indeed fully evaluated at run time, despite the fact that only its type, not its value, is used to determine which field to access (because the field mountain is static).",8.81,35.02,324.01,323,90,96.1,414.01,131.12,FALSE,FALSE
661,3,BODY,"Here, the subclass ColoredPoint extends the clear abstraction defined by its superclass Point. It does so by overriding the clear method with its own method, which invokes the clear method of its superclass, using the form super.clear(). This method is then invoked whenever the target object for an invocation of clear is a ColoredPoint. Even the method move in Point invokes the clear method of class ColoredPoint when the class of this is ColoredPoint, as shown by the output of this test program:",8.81,77.02,324.01,500,90,256.1,414.01,333.12,FALSE,FALSE
797,3,BODY,Example 17.5-1. final Fields In The Java Memory Model,8.81,5.19,221.63,53,90,123.62,311.63,128.81,TRUE,FALSE
800,3,BODY,"In the d method, the compiler is allowed to reorder the reads of x and the call to g freely. Thus, new A().f() could return -1, 0, or 1.",8.81,15.02,324,136,90,226.1,414,241.12,FALSE,FALSE
825,3,BODY,"α = Number & Comparable<? extends Number & Comparable<?>> We have thus demonstrated that the method is applicable; since no other candidates exist, it is the most specific applicable method. Still, the type of the method invocation, and its compatibility with the target type in the assignment, is not determined until further inference can occur, as described in the next section.",8.81,57.71,324,381,90,134.67,414,192.37,FALSE,FALSE
839,2,BODY,"Now we resolve α, yielding α = Y, a fresh type variable with upper bound CharSequence. Finally, we find the upward projection of Mapper<Y> with respect to Y, inferring that the type of the record pattern is Mapper<? extends CharSequence>. Once we know the type of the record pattern, we can find its component types, which are matched against the component patterns of the record pattern. Pattern variables in and out both have type CharSequence.",8.81,67.71,324,446,90,77.04,414,144.75,FALSE,FALSE
75,5,BODY,"and then encounters an ArithmeticException in the division by l - i, because l - i is zero. The first multiplication is performed in 32-bit precision, whereas the second multiplication is a long multiplication. The value -727379968 is the decimal value of the low 32 bits of the mathematical result, 1000000000000, which is a value too large for type int.",8.8,45.02,324.01,355,90,190.1,414.01,235.12,FALSE,FALSE
144,6,BODY,"The implementation needs to copy the list, extract elements from the copy, and insert them into the original. To do this in a type-safe manner, we need to give a name, T, to the element type of the incoming list. We do this in the private service method rev(). This requires us to pass the incoming argument list, of type List<?>, as an argument to rev(). In general, List<?> is a list of unknown type. It is not a subtype of List<T>, for any type T. Allowing such a subtype relation would be unsound. Given the method: public static <T> void fill(List<T> l, T obj)",8.8,76.01,324.01,565,90,513.1,414.01,589.11,FALSE,FALSE
149,3,BODY,"because not all short values are char values, and neither are all char values short values.",8.8,5.02,324,91,90,136.1,414,141.12,FALSE,FALSE
181,2,BODY,It should be noted that there is no rule for introducing a pattern variable by a && b when false. This is because it cannot be determined at compile time which operand will evaluate to false.,8.8,25.02,324.01,191,90,74.1,414.01,99.12,FALSE,FALSE
248,6,BODY,"The reference from code in m.A to the exported public type Point in m.D is legal because m.A reads m.D, and m.D exports the package containing Point. Resolution determines that m.A reads m.D as follows: •m.A requires m.B and therefore reads m.B. •Since m.A reads m.B, and since m.B requires transitive m.C, resolution determines that m.A reads m.C. •Then, since m.A reads m.C, and since m.C requires transitive m.D, resolution determines that m.A reads m.D. In effect, a module may read another module through multiple levels of dependence, in order to support arbitrary amounts of refactoring. Once a module is released for someone to reuse (via requires), the module's author has committed to its name and API but is free to refactor its content into other modules which the original module reuses (via requires transitive) for the benefit of consumers. In the example above, package p may have been exported originally by m.B (thus, m.A requires m.B) but refactoring has caused some of m.B's content to move into m.C and m.D. By using a chain of requires transitive directives, the family of m.B, m.C, and m.D can preserve access to package p for code in m.A without forcing any changes to the requires directives of m.A. Note that package p in m.D is not 're-exported' by m.C and m.B; rather, m.A is made to read m.D directly.",8.8,211.02,324.01,1330,90,202.1,414.01,413.12,FALSE,FALSE
268,5,BODY,"Here, the relationships are as follows: •The class Point is a direct subclass of Object. •The class Object is the direct superclass of the class Point. •The class ColoredPoint is a direct subclass of class Point. •The class Point is the direct superclass of class ColoredPoint. The declaration of class Colored3dPoint causes a compile-time error because it attempts to extend the final class ColoredPoint.",8.8,107.02,324,405,90,169.1,414,276.12,FALSE,FALSE
302,2,BODY,This abstract declaration of toString overrides the non-abstract toString method of the class Object. (Object is the implicit direct superclass of class Point.) Adding the code:,8.8,25.02,324,177,90,74.1,414,99.12,FALSE,FALSE
334,10,BODY,"Perhaps surprisingly, the same instance of Outer may serve as the immediately enclosing instance of ChildOfInner with respect to Inner for multiple instances of ChildOfInner. These instances of ChildOfInner are implicitly linked to the same instance of Outer.",8.8,25.02,324,259,90,578.1,414,603.12,FALSE,FALSE
389,2,BODY,"An annotation interface which is both repeatable and containing is subject to the rules on mixing annotations of repeatable annotation interface with annotations of containing annotation interface (§9.7.5). For example, it is not possible to write multiple @Foo annotations alongside multiple @FooContainer annotations, nor is it possible to write multiple @FooContainer annotations alongside multiple @FooContainerContainer annotations. However, if the annotation interface FooContainerContainer was itself repeatable, then it would be possible to write multiple @Foo annotations alongside multiple @FooContainerContainer annotations.",8.8,75.02,324,635,90,74.1,414,149.12,FALSE,FALSE
403,2,BODY,"@Foo is a declaration annotation on f if Foo is meta-annotated by @Target(ElementType.FIELD), and a type annotation on int if Foo is meta-annotated by @Target(ElementType.TYPE_USE). It is possible for @Foo to be both a declaration annotation and a type annotation simultaneously. Type annotations can apply to an array type or any component type thereof (§10.1). For example, assuming that A, B, and C are annotation interfaces meta-annotated with @Target(ElementType.TYPE_USE), then given the field declaration:",8.8,77.02,324,512,90,74.1,414,151.12,FALSE,FALSE
486,4,BODY,Example 13.4.9-1. Changing A Variable To Be final,8.8,5.19,202.15,49,90,253.62,292.15,258.81,TRUE,FALSE
490,10,BODY,"If Super is recompiled but not Test, then running the new binary with the existing binary of Test results in an AbstractMethodError, because class Test has no implementation of the method out, and is therefore is (or should be) abstract.",8.8,25.02,324.01,237,90,569.1,414.01,594.12,FALSE,FALSE
491,9,BODY,"If Super is recompiled but not Test, then running the new binary with the existing binary of Test results in an IncompatibleClassChangeError because the class Test improperly tries to override the instance method out.",8.8,25.02,324.01,217,90,389.1,414.01,414.12,FALSE,FALSE
495,8,BODY,"If a sealed interface I did have a sealed direct superinterface, then deleting the sealed modifier would prevent I from being recompiled, as every interface with a sealed direct superinterface must be sealed or non-sealed.",8.8,25.02,324,222,90,566.1,414,591.12,FALSE,FALSE
512,0,BODY,14.9The if Statement,8.8,4.95,99.16,20,36,40.15,135.16,45.1,FALSE,TRUE
568,7,BODY,"In the following example, a yield statement is used to produce a value for the enclosing switch expression.",8.8,15.02,323.99,107,90,445.1,413.99,460.12,FALSE,FALSE
603,4,BODY,This is because the decimal literals 2147483648 and 9223372036854775808L are allowed only as an operand of the unary minus operator (§3.10.1).,8.8,15.02,324,142,90,262.1,414,277.12,FALSE,FALSE
639,3,BODY,Now consider a third compilation unit that uses ColoredPoint:,8.8,5.02,233.09,61,90,276.1,323.09,281.12,FALSE,FALSE
640,3,BODY,"If the programmer then runs the old binary file for Test with the new binary file for ColoredPoint, the output is still:",8.8,15.02,324,120,90,126.1,414,141.12,FALSE,FALSE
662,4,BODY,Example 15.12.4.4-2. Method Invocation Using super,8.8,5.19,203.89,50,90,239.62,293.89,244.81,TRUE,FALSE
825,2,BODY,"{ α <: Object, Integer <: α, Double <: α } Then, to test whether the method is applicable, we attempt to resolve these bounds. We succeed, producing the rather complex instantiation",8.8,37.71,323.99,181,90,77.04,413.99,114.75,FALSE,FALSE
81,3,BODY,"declares a class type Point, an interface type Move, and uses an array type int[] (an array of int) to declare the field metrics of the class Point.",8.79,15.02,324,148,90,479.1,414,494.12,FALSE,FALSE
201,8,BODY,"First of all, the name org.rpgpoet.Music.wizards.length is classified as an ExpressionName because it functions as a PostfixExpression. Therefore, each of the names:",8.79,15.02,324,165,90,475.1,414,490.12,FALSE,FALSE
218,7,BODY,"Example 6.6-5. Access to private Fields, Methods, and Constructors",8.79,5.19,262.98,66,90,365.62,352.98,370.81,TRUE,FALSE
257,5,BODY,"Here, a class Point is declared that must be declared abstract, because it contains a declaration of an abstract method named alert. The subclass of Point named ColoredPoint inherits the abstract method alert, so it must also be declared abstract. On the other hand, the subclass of Point named SimplePoint provides an implementation of alert, so it need not be abstract. The statement:",8.79,67.02,324,386,90,318.1,414,385.12,FALSE,FALSE
278,6,BODY,"Here, the class variable totalMoves can be used only within the class Point; it is not inherited by the subclass Point3d. A compile-time error occurs because method move of class Point3d tries to increment totalMoves.",8.79,25.02,324,217,90,341.1,414,366.12,FALSE,FALSE
302,4,BODY,"results in a compile-time error because the invocation super.toString() refers to method toString in class Point, which is abstract and therefore cannot be invoked. Method toString of class Object can be made available to class ColoredPoint only if class Point explicitly makes it available through some other method, as in:",8.79,35.02,324,324,90,188.1,414,223.12,FALSE,FALSE
318,5,BODY,Example 8.4.8.3-3. Incorrect Overriding because of throws,8.79,5.19,225.04,57,90,191.62,315.04,196.81,TRUE,FALSE
411,10,BODY,"Functional<S,T> is a functional interface - I.m is return-type-substitutable for J.m and K.m - but the functional interface type Functional<String,Integer> clearly cannot be implemented with a single method. However, other parameterizations of Functional<S,T> which are functional interface types are possible.",8.79,35.02,324,310,90,563.1,414,598.12,FALSE,FALSE
491,3,BODY,Example 13.4.17-1. Changing A Method To Be final,8.79,5.19,203.15,48,90,189.62,293.15,194.81,TRUE,FALSE
624,11,BODY,Example 15.10.4-3. null Array Reference,8.79,5.19,159.43,39,90,458.62,249.43,463.81,TRUE,FALSE
655,4,BODY,Example 15.12.4.1-1. Target References and static Methods,8.79,5.19,233.54,57,90,512.62,323.54,517.81,TRUE,FALSE
697,7,BODY,"However, this fact is not useful. For example, a<b<c parses as (a<b)<c, which is always a compile-time error, because the type of a<b is always boolean and < is not an operator on boolean values.",8.79,25.02,324,195,90,458.1,414,483.12,FALSE,FALSE
707,1,BODY,Conditional Operator ? :15.25,8.79,4.95,131.56,29,336.44,40.15,468,45.1,FALSE,TRUE
708,0,BODY,15.25Conditional Operator ? :,8.79,4.95,132.81,29,36,40.15,168.81,45.1,FALSE,TRUE
709,1,BODY,Conditional Operator ? :15.25,8.79,4.95,131.56,29,336.44,40.15,468,45.1,FALSE,TRUE
710,0,BODY,15.25Conditional Operator ? :,8.79,4.95,132.81,29,36,40.15,168.81,45.1,FALSE,TRUE
711,1,BODY,Conditional Operator ? :15.25,8.79,4.95,131.56,29,336.44,40.15,468,45.1,FALSE,TRUE
712,0,BODY,15.25Conditional Operator ? :,8.79,4.95,132.81,29,36,40.15,168.81,45.1,FALSE,TRUE
713,1,BODY,Conditional Operator ? :15.25,8.79,4.95,131.56,29,336.44,40.15,468,45.1,FALSE,TRUE
714,0,BODY,15.25Conditional Operator ? :,8.79,4.95,132.81,29,36,40.15,168.81,45.1,FALSE,TRUE
715,1,BODY,Conditional Operator ? :15.25,8.79,4.95,131.56,29,336.44,40.15,468,45.1,FALSE,TRUE
94,3,BODY,"For example, if a generic class X<T> has a generic member class Y<U>, then the type X<?>.Y<?> is reifiable because X<?> is reifiable and Y<?> is reifiable. The type X<?>.Y<Object> is not reifiable because Y<Object> is not reifiable.",8.78,25.02,314,232,100,188.1,414,213.12,FALSE,FALSE
123,2,BODY,"Note that an expression such as new Colorable() is not valid because it is not possible to create an instance of an interface, only of a class. However, the expression new Colorable() { public void setColor... } is valid because it declares an anonymous class (§15.9.5) that implements the Colorable interface.",8.78,35.02,324,310,90,74.1,414,109.12,FALSE,FALSE
216,7,BODY,the public class Point has as public members the move method and the moves field. These public members are accessible to any other package that has access to package points. The fields x and y are not public and therefore are accessible only from within the package points.,8.78,35.02,324,273,90,449.1,414,484.12,FALSE,FALSE
269,11,BODY,This program results in a compile-time error because the names java.lang.Cloneable and Cloneable refer to the same interface.,8.78,15.02,324,125,90,588.1,414,603.12,FALSE,FALSE
272,3,BODY,"This program causes a compile-time error, because ColoredPoint is not an abstract class but fails to provide an implementation of methods setColor and getColor of the interface Colorable. In the following program:",8.78,47.02,324,213,90,106.1,414,153.12,FALSE,FALSE
318,4,BODY,"An unchecked warning would be given when compiling Overrider against the new definition of StringSorter because the return type of Overrider.toList is List, which is not a subtype of the return type of the overridden method, List<String>.",8.78,25.02,324,238,90,148.1,414,173.12,FALSE,FALSE
321,5,BODY,"Here, the class Point has two members that are methods with the same name, move. The overloaded move method of class Point chosen for any particular method invocation is determined at compile time by the overloading resolution procedure given in §15.12. In total, the members of the class Point are the float instance variables x and y declared in Point, the two declared move methods, the declared toString method, and the members that Point inherits from its implicit direct superclass Object (§4.3.2), such as the method hashCode. Note that Point does not inherit the toString method of class Object because that method is overridden by the declaration of the toString method in class Point.",8.78,97.02,324.01,694,90,383.1,414.01,480.12,FALSE,FALSE
427,6,BODY,Example 10.8-2. Array Class Objects Are Shared,8.78,5.19,190.12,46,90,203.62,280.12,208.81,TRUE,FALSE
527,4,BODY,"It is tempting to apply the logic from the previous example to rewrite the set containing the patterns IPair(A a, A a), IPair(B b, B b), IPair(C c, C c) to the set containing the pattern IPair(I i, I j), and hence conclude that the switch block exhausts the type IPair. But this is incorrect as, for example, the switch block does not actually have a label that matches an IPair value whose first component is an A value, and second component is a B value. It is only valid to combine record patterns on one component if they match the same values in the other components. For example, the set containing the three record patterns IPair(A a, I i), IPair(B b, I i), and IPair(C c, I i) can be reduced to the pattern IPair(I j, I i).",8.78,85.02,324.01,731,90,422.1,414.01,507.12,FALSE,FALSE
533,6,BODY,Example 14.11.3-1. Fall-Through in the switch Statement,8.78,5.19,221.32,55,90,430.62,311.32,435.81,TRUE,FALSE
602,3,BODY,Example 15.8.3-1. The this Expression,8.78,5.19,150.47,37,90,168.62,240.47,173.81,TRUE,FALSE
242,10,BODY,"then within that compilation unit, the simple name Vector and the fully qualified name java.util.Vector refer to the same class.",8.77,15.02,324,128,90,549.1,414,564.12,FALSE,FALSE
279,3,BODY,"An invocation morePoints.OnePoint.getOne() in yet a third package would return a Point3d that can be used as a Point, even though the type Point3d is not available outside the package morePoints. The two-argument version of method move could then be invoked for that object, which is permissible because method move of Point3d is public (as it must be, for any method that overrides a public method must itself be public, precisely so that situations such as this will work out correctly). The fields x and y of that object could also be accessed from such a third package. While the field z of class Point3d is public, it is not possible to access this field from code outside the package morePoints, given only a reference to an instance of class Point3d in a variable p of type Point. This is because the expression p.z is not correct, as p has type Point and class Point has no field named z; also, the expression ((Point3d)p).z is not correct, because the class type Point3d cannot be referred to outside package morePoints. The declaration of the field z as public is not useless, however. If there were to be, in package morePoints, a public subclass Point4d of the class Point3d:",8.77,169.02,324,1187,90,236.1,414,405.12,FALSE,FALSE
318,10,BODY,"A different compile-time error now occurs, because the body of the method move cannot throw a checked exception, namely BadPointException, that does not appear in the throws clause for move.",8.77,25.02,324,190,90,575.1,414,600.12,FALSE,FALSE
336,7,BODY,where the default constructor is public because the class Point is public.,8.77,5.02,276.05,74,90,479.1,366.05,484.12,FALSE,FALSE
410,2,BODY,"The following interface is not functional because while it only declares one abstract method which is not a member of Object, it declares two abstract methods which are not public members of Object:",8.77,25.02,324,198,90,74.1,414,99.12,FALSE,FALSE
522,5,BODY,"If used, a case null, default label should come last in a switch block.",8.77,5.02,265.03,71,90,376.1,355.03,381.12,FALSE,FALSE
560,5,BODY,Example 14.20.2-1. Handling An Uncaught Exception With finally,8.77,5.19,260.52,62,90,518.62,350.52,523.81,TRUE,FALSE
698,5,BODY,"For example, -0.0<0.0 is false, but -0.0<=0.0 is true. Note, however, that the methods Math.min and Math.max treat negative zero as being strictly smaller than positive zero.",8.77,37.02,314,174,100,293.1,414,330.12,FALSE,FALSE
98,7,BODY,"from the Collection<String> superinterface. The raw type RawMembers inherits iterator() from Collection, the erasure of Collection<String>, which means that the return type of iterator() in RawMembers is Iterator. As a result, the attempt to assign rw.iterator() to Iterator<String> requires an unchecked conversion, so a compile-time unchecked warning is issued. In contrast, RawMembers inherits myNumbers() from the NonGeneric class whose erasure is also NonGeneric. Thus, the return type of myNumbers() in RawMembers is not erased, and the attempt to assign rw.myNumbers() to Collection<Number> requires no unchecked conversion, so no compile-time unchecked warning is issued. Similarly, the static member cng retains its parameterized type even when accessed through a object of raw type. Note that access to a static member through an instance is considered bad style and is discouraged.",8.76,139.02,324,892,90,463.1,414,602.12,FALSE,FALSE
174,2,BODY,"One-character local variable or parameter names should be avoided, except for temporary and looping variables, or where a variable holds an undistinguished value of a type. Conventional one-character names are: •b for a byte •c for a char •d for a double •e for an Exception •f for a float •i, j, and k for ints •l for a long •o for an Object •s for a String •v for an arbitrary value of some type Local variable or parameter names that consist of only two or three lowercase letters should not conflict with the initial country codes and domain names that are the first component of unique package names.",8.76,233.02,324,605,90,74.1,414,307.12,FALSE,FALSE
226,6,BODY,"Here are some examples: •Because the package java.awt has a subpackage image, it cannot (and does not) contain a declaration of a class or interface named image. •If there is a package named mouse and a member class Button in that package (which then might be referred to as mouse.Button), then there cannot be any package with the fully qualified name mouse.Button or mouse.Button.Click. •If com.nighthacks.java.jag is the fully qualified name of a class, then there cannot be any package whose fully qualified name is either com.nighthacks.java.jag or com.nighthacks.java.jag.scrabble. It is however possible for members of different packages to have the same simple name. For example, it is possible to declare a package:",8.76,141.02,324.01,724,90,445.1,414.01,586.12,FALSE,FALSE
237,3,BODY,"Note that an import declaration cannot import a subpackage, only a class or interface. For example, it does not work to try to import java.util and then use the name util.Random to refer to the type java.util.Random:",8.76,37.02,324,216,90,99.1,414,136.12,FALSE,FALSE
248,4,BODY,The program client.Test may be run as follows:,8.76,5.02,186.03,46,90,158.1,276.03,163.12,FALSE,FALSE
284,2,BODY,"the fields RED, GREEN, and BLUE are inherited by the class PaintedPoint both through its direct superclass ColoredPoint and through its direct superinterface Paintable. The simple names RED, GREEN, and BLUE may nevertheless be used without ambiguity within the class PaintedPoint to refer to the fields declared in interface Colorable.",8.76,35.02,324,335,90,74.1,414,109.12,FALSE,FALSE
319,7,BODY,"This is also illegal, since D.id(String) is a member of D, D.id(Integer) is declared in D, and: •The two methods have the same name, id •D.id(Integer) is accessible to D •The two methods have different signatures (and neither is a subsignature of the other) •D.id(String) overrides C<String>.id(String) and D.id(Integer) overrides I.id(Integer) yet the two overridden methods have the same erasure",8.76,95.02,324,397,90,439.1,414,534.12,FALSE,FALSE
387,5,BODY,"An annotation whose interface declaration indicates a target of java.lang.annotation.ElementType.TYPE can appear in at least as many locations as an annotation whose interface declaration indicates a target of java.lang.annotation.ElementType.ANNOTATION_TYPE. For example, given the following declarations of repeatable and containing annotation interfaces:",8.76,45.02,324,357,90,205.1,414,250.12,FALSE,FALSE
478,5,BODY,"A non-sealed class C must have a sealed direct superclass or a sealed direct superinterface (§8.1.1.2). Deleting the non-sealed modifier would prevent C from being recompiled, as every class with a sealed direct superclass or a sealed direct superinterface must be either final, sealed, or non-sealed.",8.76,35.02,324,301,90,314.23,414,349.25,FALSE,FALSE
478,7,BODY,"If a final class C did have a sealed direct superclass or a sealed direct superinterface, then deleting the final modifier would prevent C from being recompiled, as every class with a sealed direct superclass or a sealed direct superinterface must be either final, sealed, or non-sealed (§8.1.1.2).",8.76,35.02,324,298,90,497.36,414,532.38,FALSE,FALSE
483,4,BODY,If the package points defines the class Point:,8.76,5.02,172.01,46,90,192.1,262.01,197.12,FALSE,FALSE
495,6,BODY,"A non-sealed interface I must have a sealed direct superinterface. Deleting the non- sealed modifier would prevent I from being recompiled, as every interface with a sealed direct superinterface must be sealed or non-sealed.",8.76,25.02,324,224,90,486.1,414,511.12,FALSE,FALSE
797,7,BODY,Example 17.5-2. final Fields For Security,8.76,5.19,161.88,41,90,476.62,251.88,481.81,TRUE,FALSE
68,7,BODY,Example 3.10.6-4. Text blocks evaluate to String,8.75,5.19,187.81,48,90,382.62,277.81,387.81,TRUE,FALSE
218,6,BODY,"it terminates normally. If move of Point were overridden by move in PlusPoint, then this program would recurse infinitely, until a StackOverflowError occurred.",8.75,15.02,324,159,90,332.1,414,347.12,FALSE,FALSE
317,10,BODY,and assume that someone subclasses StringSorter:,8.75,5.02,193.83,48,90,538.1,283.83,543.12,FALSE,FALSE
337,3,BODY,"The default constructor for Inner is protected. However, the constructor is protected relative to Inner, while Inner is protected relative to Outer. So, Inner is accessible in SonOfOuter, since it is a subclass of Outer. Inner's constructor is not accessible in SonOfOuter, because the class SonOfOuter is not a subclass of Inner! Hence, even though Inner is accessible, its default constructor is not.",8.75,45.02,324,402,90,146.1,414,191.12,FALSE,FALSE
384,6,BODY,Here is a refinement of the RequestForEnhancement annotation interface from §9.6.1:,8.75,5.02,320.25,83,90,357.1,410.25,362.12,FALSE,FALSE
393,3,BODY,"Because Object.clone is not public, there is no member called clone implicitly declared in Quux. Therefore, the explicit declaration of clone in Quux is not deemed to 'implement' any other method, and it is erroneous to use @Override. (The fact that Quux.clone is public is not relevant.) In contrast, a class declaration that declares clone is simply overriding Object.clone, so is able to use @Override:",8.75,67.02,324,405,90,128.1,414,195.12,FALSE,FALSE
420,9,BODY,"Brackets are allowed in declarators as a nod to the tradition of C and C++. The general rules for variable declaration, however, permit brackets to appear on both the type and in declarators, so that the local variable declaration statement: float[][] f[][], g[][][], h[];  // Yechh!",8.75,46.01,324,283,90,258.1,414,304.11,FALSE,FALSE
511,7,BODY,"Unlike C and C++, the Java programming language allows only certain forms of expressions to be used as expression statements. For example, it is legal to use a method invocation expression (§15.12): System.out.println('Hello world');  // OK",8.75,46.01,323.99,240,90,435.1,413.99,481.11,FALSE,FALSE
716,5,BODY,"If the conditional expression was not a poly expression, then a compile-time error would occur, as its type would be lub(Class<Integer>, Class<Number>) = Class<? extends Number> which is incompatible with the return type of choose.",8.75,25.02,324,231,90,264.1,414,289.12,FALSE,FALSE
810,2,BODY,"The key piece of information to derive from a compatibility constraint involving a lambda expression is the set of bounds on inference variables appearing in the target function type's return type. This is crucial, because functional interfaces are often generic, and many methods operating on these types are generic, too. In the simplest case, a lambda expression may simply provide a lower bound for an inference variable: <T> List<T> makeThree(Factory<T> factory) { ... } String s = makeThree(() -> 'abc').get(2);",8.75,98.01,324.01,517,90,74.1,414.01,172.11,FALSE,FALSE
151,2,BODY,"•The value of veclong cannot be assigned to a Long variable, because Long is a class type other than Object. An array can be assigned only to a variable of a compatible array type, or to a variable of type Object, Cloneable or java.io.Serializable. •The value of veclong cannot be assigned to vecshort, because they are arrays of primitive type, and short and long are not the same primitive type. •The value of cpvec can be assigned to pvec, because any reference that could be the value of an expression of type ColoredPoint can be the value of a variable of type Point. The subsequent assignment of the new Point to a component of pvec then would throw an ArrayStoreException (if the program were otherwise corrected so that it could be compiled), because a ColoredPoint array cannot have an instance of Point as the value of a component. •The value of pvec cannot be assigned to cpvec, because not every reference that could be the value of an expression of type Point can correctly be the value of a variable of type ColoredPoint. If the value of pvec at run time were a reference to an instance of Point[], and the assignment to cpvec were allowed, a simple reference to a component of cpvec, say, cpvec[0], could return a Point, and a Point is not a ColoredPoint. Thus to allow such an assignment would allow a violation of the type system. A cast may be used (§5.5, §15.16) to ensure that pvec references a ColoredPoint[]: cpvec = (ColoredPoint[])pvec;  // OK, but may throw an // exception at run time",8.74,220.01,324.01,1510,90,74.1,414.01,294.11,FALSE,FALSE
220,3,BODY,"Example 6.6.2-1. Access to protected Fields, Methods, and Constructors",8.74,5.19,278.59,70,90,256.62,368.59,261.81,TRUE,FALSE
259,4,BODY,"Thus, a subclass of a non-sealed class cannot itself be declared non-sealed.",8.74,5.02,287.2,76,90,196.1,377.2,201.12,FALSE,FALSE
304,3,BODY,"For example, the class RandomAccessFile of the package java.io might declare the following native methods:",8.74,15.02,324,106,90,158.23,414,173.25,FALSE,FALSE
630,4,BODY,Example 15.11.2-1. The super Expression,8.74,5.19,159.4,39,90,145.62,249.4,150.81,TRUE,FALSE
45,3,BODY,"For example, the identifiers consisting of the single letters LATIN CAPITAL LETTER A (A, \u0041), LATIN SMALL LETTER A (a, \u0061), GREEK CAPITAL LETTER ALPHA (A, \u0391), CYRILLIC SMALL LETTER A (a, \u0430) and MATHEMATICAL BOLD ITALIC SMALL A (a, \ud835\udc82) are all different. Unicode composite characters are different from their canonical equivalent decomposed characters. For example, a LATIN CAPITAL LETTER A ACUTE (Á, \u00c1) is different from a LATIN CAPITAL LETTER A (A, \u0041) immediately followed by a NON- SPACING ACUTE (´, \u0301) in identifiers. See The Unicode Standard, Section 3.11 'Normalization Forms'. Examples of identifiers are: •String •i3 • αρετη •MAX_VALUE •isLetterOrDigit",8.73,205.02,324,702,90,125.1,414,330.12,FALSE,FALSE
278,4,BODY,Example 8.2-4. Inheritance of private Class Members,8.73,5.19,208.48,51,90,169.62,298.48,174.81,TRUE,FALSE
376,4,BODY,Example 9.4.2-1. Overloading an abstract Method Declaration,8.73,5.19,243.17,59,90,267.62,333.17,272.81,TRUE,FALSE
538,0,BODY,14.14The for Statement,8.73,4.95,103.55,22,36,40.15,139.55,45.1,FALSE,TRUE
539,1,BODY,The for Statement14.14,8.73,4.95,103.56,22,364.44,40.15,468,45.1,FALSE,TRUE
540,0,BODY,14.14The for Statement,8.73,4.95,103.55,22,36,40.15,139.55,45.1,FALSE,TRUE
541,1,BODY,The for Statement14.14,8.73,4.95,103.56,22,364.44,40.15,468,45.1,FALSE,TRUE
542,0,BODY,14.14The for Statement,8.73,4.95,103.55,22,36,40.15,139.55,45.1,FALSE,TRUE
543,1,BODY,The for Statement14.14,8.73,4.95,103.56,22,364.44,40.15,468,45.1,FALSE,TRUE
544,0,BODY,14.14The for Statement,8.73,4.95,103.55,22,36,40.15,139.55,45.1,FALSE,TRUE
545,1,BODY,The for Statement14.14,8.73,4.95,103.56,22,364.44,40.15,468,45.1,FALSE,TRUE
554,0,BODY,14.20The try statement,8.73,4.95,102.56,22,36,40.15,138.56,45.1,FALSE,TRUE
555,1,BODY,The try statement14.20,8.73,4.95,102.56,22,365.44,40.15,468,45.1,FALSE,TRUE
556,0,BODY,14.20The try statement,8.73,4.95,102.56,22,36,40.15,138.56,45.1,FALSE,TRUE
557,1,BODY,The try statement14.20,8.73,4.95,102.56,22,365.44,40.15,468,45.1,FALSE,TRUE
558,0,BODY,14.20The try statement,8.73,4.95,102.56,22,36,40.15,138.56,45.1,FALSE,TRUE
559,1,BODY,The try statement14.20,8.73,4.95,102.56,22,365.44,40.15,468,45.1,FALSE,TRUE
560,0,BODY,14.20The try statement,8.73,4.95,102.56,22,36,40.15,138.56,45.1,FALSE,TRUE
561,1,BODY,The try statement14.20,8.73,4.95,102.56,22,365.44,40.15,468,45.1,FALSE,TRUE
562,0,BODY,14.20The try statement,8.73,4.95,102.56,22,36,40.15,138.56,45.1,FALSE,TRUE
563,1,BODY,The try statement14.20,8.73,4.95,102.56,22,365.44,40.15,468,45.1,FALSE,TRUE
564,0,BODY,14.20The try statement,8.73,4.95,102.56,22,36,40.15,138.56,45.1,FALSE,TRUE
565,1,BODY,The try statement14.20,8.73,4.95,102.56,22,365.44,40.15,468,45.1,FALSE,TRUE
566,0,BODY,14.20The try statement,8.73,4.95,102.56,22,36,40.15,138.56,45.1,FALSE,TRUE
567,1,BODY,The try statement14.20,8.73,4.95,102.56,22,365.44,40.15,468,45.1,FALSE,TRUE
824,6,BODY,{ α <: Object } The initial constraint formula set is as follows:,8.73,27.71,167.74,65,90,520.67,257.74,548.37,FALSE,FALSE
220,6,BODY,and the threePoint package declares:,8.72,5.02,142.46,36,90,394.1,232.46,399.12,FALSE,FALSE
285,10,BODY,causes the value of q.origin.useCount to be 1; this is so because p.origin and q.origin refer to the same variable.,8.72,15.02,324,115,90,519.1,414,534.12,FALSE,FALSE
319,5,BODY,"This is illegal since D.id(Object) is a member of D, C<String>.id(String) is declared in a supertype of D, and: •The two methods have the same name, id •C<String>.id(String) is accessible to D •The signature of D.id(Object) is not a subsignature of that of C<String>.id(String) •The two methods have the same erasure Two different methods of a class may not override methods with the same erasure:",8.72,117.02,324,397,90,193.1,414,310.12,FALSE,FALSE
372,2,BODY,"Note that an interface method may not be declared with protected or package access, or with the modifiers final, synchronized, or native.",8.72,15.02,324,137,90,74.1,414,89.12,FALSE,FALSE
547,3,BODY,Example 14.15-1. The break Statement,8.72,5.19,149.13,36,90,169.62,239.13,174.81,TRUE,FALSE
568,6,BODY,Example 14.21-1. The yield Statement,8.72,5.19,149.13,36,90,421.62,239.13,426.81,TRUE,FALSE
719,3,BODY,"This check is similar to a narrowing cast (§5.5, §15.16), except that if the check fails, an ArrayStoreException is thrown rather than a ClassCastException.",8.72,15.02,304,156,110,112.1,414,127.12,FALSE,FALSE
386,3,BODY,Note that it is permissible for AC to be @Inherited while A is not @Inherited.,8.71,5.02,291.15,78,108,125.1,399.15,130.12,FALSE,FALSE
386,8,BODY,"Compiling the Foo declaration produces a compile-time error because Foo uses @Repeatable to attempt to specify FooContainer as its containing annotation interface, but FooContainer is not in fact a containing annotation interface of Foo. (The return type of FooContainer.value() is not Foo[].)",8.71,35.02,324,293,90,321.1,414,356.12,FALSE,FALSE
427,1,BODY,An Array of Characters Is Not a String10.9,8.71,4.95,184.62,42,283.38,40.15,468,45.1,FALSE,TRUE
478,3,BODY,"If a sealed class C did have a sealed direct superclass or a sealed direct superinterface, then deleting the sealed modifier would prevent C from being recompiled, as every class with a sealed direct superclass or a sealed direct superinterface must be either final, sealed, or non-sealed.",8.71,35.02,324.01,289,90,170.1,414.01,205.12,FALSE,FALSE
496,10,BODY,"If I is recompiled but not Test, then running the new binary with the existing binary for Test will result in a NoSuchMethodError.",8.71,15.02,323.99,130,90,522.1,413.99,537.12,FALSE,FALSE
827,6,BODY,"{ α <: Object, Integer <: α, Double <: α, α = Number } These bounds are trivially resolved:",8.71,27.71,221.23,91,90,239.92,311.23,267.63,FALSE,FALSE
218,4,BODY,"Because move of Point is not overridden by move in PlusPoint, the method moveAlso in Point never calls the method move in PlusPoint. Thus if you delete the super.move call from PlusPoint and execute the test program:",8.7,25.02,324,216,90,198.1,414,223.12,FALSE,FALSE
258,2,BODY,"These declarations result in a compile-time error: it would be impossible for any subclass of class Colored to provide an implementation of a method named setColor, taking one argument of type int, that can satisfy both abstract method specifications, because the one in interface Colorable requires the same method to return no value, while the one in class Colored requires the same method to return a value of type int (§8.4). A class type should be declared abstract only if the intent is that subclasses can be created to complete the implementation. If the intent is simply to prevent instantiation of a class, the proper way to express this is to declare a constructor (§8.8.10) of no arguments, make it private, never invoke it, and declare no other constructors. A class of this form usually contains class methods and variables. The class Math is an example of a class that cannot be instantiated; its declaration looks like this: public final class Math { private Math() { }  // never instantiate this class . . . declarations of class variables and methods . . . }",8.7,190.01,324.01,1076,90,74.1,414.01,264.11,FALSE,FALSE
266,5,BODY,"Here, every instance of WithDeepNesting.Nested.DeeplyNested has an enclosing instance of class WithDeepNesting.Nested (its immediately enclosing instance) and an enclosing instance of class WithDeepNesting (its 2nd lexically enclosing instance).",8.7,25.02,324,245,90,432.1,414,457.12,FALSE,FALSE
268,8,BODY,"Here, the relationships are as follows: •The class Point is a superclass of class ColoredPoint. •The class Point is a superclass of class Colored3dPoint. •The class ColoredPoint is a subclass of class Point. •The class ColoredPoint is a superclass of class Colored3dPoint. •The class Colored3dPoint is a subclass of class ColoredPoint. •The class Colored3dPoint is a subclass of class Point.",8.7,107.02,258.52,391,90,356.1,348.52,463.12,FALSE,FALSE
271,6,BODY,Class C causes a compile-time error because it attempts to be a subtype of both I<Integer> and I<String>.,8.7,15.02,324,105,90,347.1,414,362.12,FALSE,FALSE
531,6,BODY,"In Java SE 21, in addition to supporting case patterns, the two limitations of switch statements (and switch expressions) listed above were relaxed to (i) allow a selector expression of any reference type, and (ii) to allow a case label with a null literal. The designers of the Java programming language also decided that enhanced switch statements should align with switch expressions and be required to be exhaustive. This is often achieved with the addition of a trivial default label. For example, the following enhanced switch statement is not exhaustive: Object o = ...; switch (o) {    // Error - non-exhaustive switch!",8.7,96.01,324,627,90,503.1,414,599.11,FALSE,FALSE
827,3,BODY,"{ α <: Object, Integer <: α, Double <: α } The new constraint formula set is as follows:",8.7,27.71,172.68,88,90,131.04,262.68,158.75,FALSE,FALSE
61,2,BODY,"•'\'' •'\u03a9' •'\uFFFF' •'\177' •'™' Because Unicode escapes are processed very early, it is not correct to write '\u000a' for a character literal whose value is linefeed (LF); the Unicode escape \u000a is transformed into an actual linefeed in translation step 1 (§3.3) and the linefeed becomes a LineTerminator in step 2 (§3.4), so the character literal is not valid in step 3. Instead, one should use the escape sequence '\n'. Similarly, it is not correct to write '\u000d' for a character literal whose value is carriage return (CR). Instead, use '\r'. Finally, it is not possible to write '\u0027' for a character literal containing an apostrophe ('). In C and C++, a character literal may contain representations of more than one character, but the value of such a character literal is implementation-defined. In the Java programming language, a character literal always represents exactly one character.",8.69,193.02,324.01,912,90,74.1,414.01,267.12,FALSE,FALSE
102,4,BODY,"The reason for computing the set of erased supertypes is to deal with situations where the set of types includes several distinct parameterizations of a generic type. For example, given List<String> and List<Object>, simply intersecting the sets ST(List<String>) = { List<String>, Collection<String>, Object } and ST(List<Object>) = { List<Object>, Collection<Object>, Object } would yield a set { Object }, and we would have lost track of the fact that the upper bound can safely be assumed to be a List. In contrast, intersecting EST(List<String>) = { List, Collection, Object } and EST(List<Object>) = { List, Collection, Object } yields { List, Collection, Object }, which will eventually enable us to produce List<?>.",8.69,119.02,314,722,100,438.1,414,557.12,FALSE,FALSE
279,5,BODY,"then class Point4d would inherit the field z, which, being public, could then be accessed by code in packages other than morePoints, through variables and expressions of the public type Point4d.",8.69,25.02,324,194,90,504.1,414,529.12,FALSE,FALSE
385,6,BODY,Note that it is permissible for AC to be @Documented while A is not @Documented.,8.69,5.02,300.75,80,108,595.1,408.75,600.12,FALSE,FALSE
406,5,BODY,"For example, assume an annotation interface TA which is meta-annotated with just @Target(ElementType.TYPE_USE). The terms @TA java.lang.Object and java.@TA lang.Object are illegal because the simple name to which @TA is closest is classified as a package name. On the other hand, java.lang.@TA Object is legal.",8.69,35.02,324,310,90,553.1,414,588.12,FALSE,FALSE
490,4,BODY,Example 13.4.16-1. Changing A Method To Be abstract,8.69,5.19,216.43,51,90,339.62,306.43,344.81,TRUE,FALSE
730,3,BODY,"Lambda expressions are always poly expressions (§15.2). It is a compile-time error if a lambda expression occurs in a program in someplace other than an assignment context (§5.2), an invocation context (§5.3), or a casting context (§5.5). Evaluation of a lambda expression produces an instance of a functional interface (§9.8). Lambda expression evaluation does not cause the execution of the expression's body; instead, this may occur at a later time when an appropriate method of the functional interface is invoked. Here are some examples of lambda expressions: () -> {}                // No parameters; result is void () -> 42                // No parameters, expression body () -> null              // No parameters, expression body () -> { return 42; }    // No parameters, block body with return () -> { System.gc(); }  // No parameters, void block body () -> {                 // Complex block body with returns if (true) return 12; else { int result = 15; for (int i = 1; i < 10; i++) result *= i; return result; } } (int x) -> x+1              // Single declared-type parameter (int x) -> { return x+1; }  // Single declared-type parameter (x) -> x+1                  // Single inferred-type parameter x -> x+1                    // Parentheses optional for // single inferred-type parameter (String s) -> s.length()      // Single declared-type parameter (Thread t) -> { t.start(); }  // Single declared-type parameter s -> s.length()               // Single inferred-type parameter t -> { t.start(); }           // Single inferred-type parameter (int x, int y) -> x+y  // Multiple declared-type parameters (x, y) -> x+y          // Multiple inferred-type parameters (x, int y) -> x+y    // Illegal: can't mix inferred and declared types (x, final y) -> x+y  // Illegal: no modifiers with inferred types",8.69,452.04,360.01,1814,72,113.06,432.01,565.11,FALSE,FALSE
734,5,BODY,"This rule prevents a mix of inferred and declared types in the formal parameters, such as (x, int y) -> BODY or (var x, int y) -> BODY. Note that if all the formal parameters have inferred types, the grammar prevents a mix of identifiers and var parameter specifiers, such as (x, var y) -> BODY or (var x, y) -> BODY.",8.69,35.02,324,317,90,238.1,414,273.12,FALSE,FALSE
838,9,BODY,"Mapper<α> has the supertype UnaryOperator<α>, so we'll reduce the constraint formula ‹UnaryOperator<β>= UnaryOperator<α>›. This leads to the bound α=β. Incorporation further infers that α <: CharSequence.",8.69,33.12,324,204,90,570.16,414,603.28,FALSE,FALSE
145,3,BODY,"So, without some special dispensation, we can see that the call from reverse() to rev() would be disallowed. If this were the case, the author of reverse() would be forced to write its signature as: public static <T> void reverse(List<T> list)",8.68,46.01,324,243,90,158.1,414,204.11,FALSE,FALSE
173,2,BODY,"very few public or protected fields, except for fields that are constants (static final fields). Fields should have names that are nouns, noun phrases, or abbreviations for nouns. Examples of this convention are the fields buf, pos, and count of the class java.io.ByteArrayInputStream and the field bytesTransferred of the class java.io.InterruptedIOException. Constant Names The names of constants in interfaces should be, and final variables of classes may conventionally be, a sequence of one or more words, acronyms, or abbreviations, all uppercase, with components separated by underscore '_' characters. Constant names should be descriptive and not unnecessarily abbreviated. Conventionally they may be any appropriate part of speech. Examples of names for constants include MIN_VALUE, MAX_VALUE, MIN_RADIX, and MAX_RADIX of the class Character. A group of constants that represent alternative values of a set, or, less frequently, masking bits in an integer value, are sometimes usefully specified with a common acronym as a name prefix. For example: interface ProcessStates { int PS_RUNNING   = 0; int PS_SUSPENDED = 1; }",8.68,310.01,324.01,1129,90,74.1,414.01,384.11,FALSE,FALSE
175,3,BODY,"the identifiers Test, main, and the first occurrences of args and c are not names. Rather, they are identifiers used in declarations to specify the names of the declared entities. The names String, Class, System.out.getClass, System.out.println, c.toString, args, and args.length appear in the example.",8.68,35.02,324,302,90,544.1,414,579.12,FALSE,FALSE
222,4,BODY,"•The fully qualified name of the type long is 'long'. •The fully qualified name of the package java.lang is 'java.lang' because it is subpackage lang of package java. •The fully qualified name of the class Object, which is defined in the package java.lang, is 'java.lang.Object'. •The fully qualified name of the interface Enumeration, which is defined in the package java.util, is 'java.util.Enumeration'. •The fully qualified name of the type 'array of double' is 'double[]'. •The fully qualified name of the type 'array of array of array of array of String' is 'java.lang.String[][][][]'. In the code:",8.68,147.02,324.01,604,90,434.1,414.01,581.12,FALSE,FALSE
223,3,BODY,the fully qualified name of the type Point is 'points.Point'; the fully qualified name of the type PointVec is 'points.PointVec'; and the fully qualified name of the type of the field vec of class PointVec is 'points.Point[]'.,8.68,25.02,324.01,226,90,106.1,414.01,131.12,FALSE,FALSE
271,3,BODY,"Here, the relationships are as follows: •The interface Paintable is a superinterface of class PaintedPoint. •The interface Colorable is a superinterface of class ColoredPoint and of class PaintedPoint. •The interface Paintable is a subinterface of the interface Colorable, and Colorable is a superinterface of Paintable, as defined in §9.1.3. The class PaintedPoint has Colorable as a superinterface both because it is a superinterface of ColoredPoint and because it is a superinterface of Paintable.",8.68,111.02,324,500,90,156.1,414,267.12,FALSE,FALSE
514,4,BODY,"Invoking Baz.testAsserts() causes Baz to be initialized. Before this can happen, Bar must be initialized. Bar's static initializer again invokes Baz.testAsserts(). Because initialization of Baz is already in progress by the current thread, the second invocation executes immediately, though Baz is not initialized (§12.4.2). Because of the rule above, if the program above is executed without enabling assertions, it must print: Asserts enabled Asserts disabled",8.68,98.01,324,461,90,489.1,414,587.11,FALSE,FALSE
96,5,BODY,"This means that the ban on 'rare' types extends to the case where the qualifying type is parameterized, but we attempt to use the inner class as a raw type: Outer<Integer>.Inner x = null; // illegal",8.67,36.01,323.99,198,90,397.1,413.99,433.11,FALSE,FALSE
486,10,BODY,"If Super is recompiled but not Test, then running the new binary with the existing binary of Test results in a IllegalAccessError.",8.67,15.02,324.01,130,90,453.1,414.01,468.12,FALSE,FALSE
498,4,BODY,"If Cowboy is recompiled but not CowboyArtist, then running the new binary with the existing binary for CowboyArtist will link without error but cause an IncompatibleClassChangeError when main attempts to invoke draw().",8.67,25.02,324,218,90,158.1,414,183.12,FALSE,FALSE
700,7,BODY,"The first instanceof expression is legal because there is a casting conversion from List<Integer> to ArrayList<Integer>. However, the second and third instanceof",8.67,15.02,324,161,90,586.1,414,601.12,FALSE,FALSE
715,5,BODY,"It also allows use of extra information to improve type checking of generic method invocations. Prior to Java SE 8, this assignment was well-typed: List<String> ls = Arrays.asList();",8.67,36.01,324,182,90,553.1,414,589.11,FALSE,FALSE
808,3,BODY,"When both the outer and the nested invocation require inference, the problem is more difficult. For example: List<String> ls = new ArrayList<>(Collections.emptyList());",8.67,36.01,323.99,168,90,417.1,413.99,453.11,FALSE,FALSE
824,3,BODY,A most specific applicable method for the invocation must be identified as described in §15.12. The only potentially applicable method (§15.12.2.1) is declared as follows: public static <T> List<T> asList(T... a),8.67,36.01,324,212,90,386.1,414,422.11,FALSE,FALSE
826,3,BODY,B2.,8.67,6.14,12.2,3,92,468.06,104.2,474.2,FALSE,TRUE
833,2,BODY,produces spurious errors in cases where a lambda expression has explicit parameter types that do not correspond to the wildcard bounds. For example: Predicate<? super Integer> p = (Number n) -> n.equals(23);,8.67,36.01,324,207,90,74.1,414,110.11,FALSE,FALSE
277,10,BODY,"the public and protected fields x, y, useCount, and totalUseCount are inherited in all subclasses of Point.",8.66,15.02,324,107,90,587.1,414,602.12,FALSE,FALSE
299,7,BODY,"This program causes a compile-time error because it declares two move methods with the same (and hence, override-equivalent) signature. This is an error even though one of the declarations is abstract. The notion of subsignature is designed to express a relationship between two methods whose signatures are not identical, but in which one may override the other. Specifically, it allows a method whose signature does not use generic types to override any generified version of that method. This is important so that library designers may freely generify methods independently of clients that define subclasses or subinterfaces of the library. Consider the example: class CollectionConverter { List toList(Collection c) {...} } class Overrider extends CollectionConverter {",8.66,160.01,324,773,90,442.1,414,602.11,FALSE,FALSE
373,3,BODY,"Right inherits name() from Top, but Bottom inherits name() from Left, not Right. This is because name() from Left overrides the declaration of name() in Top.",8.66,15.02,324,157,90,176.1,414,191.12,FALSE,FALSE
392,8,BODY,"This behavior differs from Java SE 5.0, where @Override only caused a compile-time error if applied to a method that implemented a method from a superinterface that was not also present in a superclass. The clause about overriding a public method of Object is motivated by use of @Override in an interface. Consider the following declarations: class Foo     { @Override public int hashCode() {..} } interface Bar { @Override int hashCode(); }",8.66,88.01,324.01,442,90,396.23,414.01,484.24,FALSE,FALSE
409,11,BODY,"Similarly, the well known interface java.util.Comparator<T> is functional because it has one abstract non-Object method:",8.66,15.02,324,120,90,506.1,414,521.12,FALSE,FALSE
751,2,BODY,"For example, the local variable k is definitely assigned a value after evaluation of the expression: a && ((k=m) > 5)",8.66,36.01,323.99,117,90,175.1,413.99,211.11,FALSE,FALSE
781,8,BODY,Table 17.4-A. Surprising results caused by statement reordering - original code Thread 1 1: r2 = A; 2: B = 1;,8.66,60.25,303.49,109,90,470.62,393.49,530.87,FALSE,FALSE
136,4,BODY,"Even though class D does not implement J, it is still possible for an instance of D to be an instance of J, for example, if the following declaration occurs: class E extends D implements J {}",8.65,36.01,324,191,90,349.1,414,385.11,FALSE,FALSE
228,7,BODY,"corresponding to the packages java.applet, java.awt, java.io, java.lang, java.net, and java.util that are defined as part of the Java SE Platform API.",8.65,15.02,324,150,90,575.1,414,590.12,FALSE,FALSE
288,3,BODY,Example 8.3.1.3-1. Persistence of transient Fields,8.64,5.19,193.09,50,90,280.88,283.09,286.07,TRUE,FALSE
426,0,BODY,10.8Class Objects for Arrays,8.64,4.95,129.55,28,36,40.15,165.55,45.1,FALSE,TRUE
511,9,BODY,Note that the Java programming language does not allow a 'cast to void' - void is not a type - so the traditional C trick of writing an expression statement such as: (void)... ;  // incorrect!,8.64,36.01,324,192,90,543.1,414,579.11,FALSE,FALSE
136,3,BODY,"As class C is final and does not implement I, there can be no instances of C that are also an instance of I, so C and I are disjoint. Therefore, there is no narrowing reference conversion from C to I. In contrast, consider the following declarations: interface J {} class D     {}",8.63,78.01,324,280,90,253.1,414,331.11,FALSE,FALSE
285,2,BODY,Example 8.3.1.1-1. static Fields,8.63,5.19,124.82,32,90,75.62,214.82,80.81,TRUE,FALSE
838,8,BODY,"In this case, R is the record class Mapper, and T is the type UnaryOperator<? extends CharSequence>. T is checked cast convertible to raw Mapper, so we'll infer an instantiation for α in Mapper<α>. T' is the type UnaryOperator<β>, where β has upper bound CharSequence.",8.63,38.65,324.01,268,90,511.59,414.01,550.24,FALSE,FALSE
147,3,BODY,"is allowed. Without the narrowing, the fact that the integer literal 42 has type int would mean that a cast to byte would be required: byte theAnswer = (byte)42;  // cast is permitted but not required",8.62,36.01,324,200,90,386.1,414,422.11,FALSE,FALSE
553,0,BODY,"BLOCKS, STATEMENTS, AND PATTERNSThe synchronized Statement14.19",8.62,4.95,396,63,72,40.15,468,45.1,FALSE,TRUE
569,4,BODY,"This section is devoted to a precise explanation of the word 'reachable.' The idea is that there must be some possible execution path from the beginning of the constructor, method, instance initializer, or static initializer that contains the statement to the statement itself. The analysis takes into account the structure of statements. Except for the special treatment of while, do, and for statements whose condition expression has the constant value true, the values of expressions are not taken into account in the flow analysis. For example, a Java compiler will accept the code: { int n = 5; while (n > 7) k = 2; }",8.62,128.01,324,622,90,202.1,414,330.11,FALSE,FALSE
787,5,BODY,T2 may accomplish this by calling T1.isAlive() or T1.join().,8.62,5.02,241.14,60,100,186.1,341.14,191.12,FALSE,FALSE
638,9,BODY,and one for class ColoredPoint:,8.61,5.02,123.08,31,90,552.1,213.08,557.12,FALSE,FALSE
736,7,BODY,"Similar rules on variable use apply in the body of an inner class (§8.1.3). The restriction to effectively final variables prohibits access to dynamically-changing local variables, whose capture would likely introduce concurrency problems. Compared to the final restriction, it reduces the clerical burden on programmers. The restriction to effectively final variables includes standard loop variables, but not enhanced-for loop variables, which are treated as distinct for each iteration of the loop (§14.14.2). The following lambda bodies demonstrate use of effectively final variables. void m1(int x) { int y = 1; foo(() -> x+y); // Legal: x and y are both effectively final. }",8.61,160.01,324,680,90,426.1,414,586.11,FALSE,FALSE
31,7,BODY,BreakStatement: break ; break Identifier ;,8.6,24.95,76.8,42,108,256.15,184.8,281.1,FALSE,TRUE
309,7,BODY,"In other words, a method with a return type must return only by using a return statement that provides a value return; the method is not allowed to 'drop off the end of its body'. See §14.17 for the precise rules about return statements in a method body. It is possible for a method to have a return type and yet contain no return statements. Here is one example: class DizzyDean { int pitch() { throw new RuntimeException('90 mph?!'); } }",8.6,98.01,324,439,90,383.1,414,481.11,FALSE,FALSE
596,13,BODY,"For example, it is not correct for a Java compiler to rewrite 4.0*x*0.5 as 2.0*x; while roundoff happens not to be an issue here, there are large values of x for which the first expression produces infinity (because of overflow) but the second expression produces a finite result. So, for example, the test program: class Test { public static void main(String[] args) { double d = 8E307;",8.6,98.01,324,387,90,495.1,414,593.11,FALSE,FALSE
780,5,BODY,"For example, in the following (broken) code fragment, assume that this.done is a non- volatile boolean field:",8.6,15.02,324,109,90,559.1,414,574.12,FALSE,FALSE
782,3,BODY,Table 17.4-B. Surprising results caused by statement reordering - valid compiler transformation Thread 1 B = 1; r2 = A;,8.6,72.45,341.99,119,90,169.62,431.99,242.07,TRUE,FALSE
789,6,BODY,"Table 17.4.5-A. Behavior allowed by happens-before consistency, but not sequential consistency. Thread 1 B = 1; r2 = A;",8.6,72.45,342,119,90,494.12,432,566.57,TRUE,FALSE
796,0,BODY,17.5final Field Semantics,8.6,4.95,119.26,25,36,40.15,155.26,45.1,FALSE,TRUE
797,1,BODY,final Field Semantics17.5,8.6,4.95,119.26,25,348.74,40.15,468,45.1,FALSE,TRUE
798,0,BODY,17.5final Field Semantics,8.6,4.95,119.26,25,36,40.15,155.26,45.1,FALSE,TRUE
799,1,BODY,final Field Semantics17.5,8.6,4.95,119.26,25,348.74,40.15,468,45.1,FALSE,TRUE
800,0,BODY,17.5final Field Semantics,8.6,4.95,119.26,25,36,40.15,155.26,45.1,FALSE,TRUE
146,3,BODY,"The toString method is defined by the primordial class Object (§4.3.2). Many classes override it, notably Boolean, Character, Integer, Long, Float, Double, and String.",8.59,25.02,314,167,100,341.1,414,366.12,FALSE,FALSE
549,4,BODY,Example 14.16-1. The continue Statement,8.59,5.19,162.41,39,90,326.62,252.41,331.81,TRUE,FALSE
228,5,BODY,"As an extremely simple example of storing packages in a file system, all the packages and source and binary code in a project might be stored in a single directory and its subdirectories. Each immediate subdirectory of this directory would represent a top level package, that is, one whose fully qualified name consists of a single simple name. Each further level of subdirectory would represent a subpackage of the package represented by the containing directory, and so on. The directory might contain the following immediate subdirectories: com gls jag java wnj",8.58,138.01,324,564,90,253.1,414,391.11,FALSE,FALSE
378,9,BODY,"This rule, together with the syntactic restriction on annotation interface declarations noted above, ensures that an annotation interface always has a canonical name (§6.7). Having such a name is important because the purpose of an annotation interface is to be used by annotations in other compilation units. Since a local class or interface does not have a canonical name, an annotation interface declared anywhere within its syntactic body (if that were allowed) would not have a canonical name either. The following code shows the effect of this rule and the related syntactic restriction: class C { @interface A1 {}  /* Legal: an annotation interface can be a member interface */  void m() {",8.58,138.01,324.01,696,90,462.1,414.01,600.11,FALSE,FALSE
403,4,BODY,"@A applies to the array type int[][], @B applies to its component type int[], and @C applies to the element type int. For more examples, see §10.2. An important property of this syntax is that, in two declarations that differ only in the number of array levels, the annotations to the left of the type refer to the same type. For example, @C applies to the type int in all of the following declarations: @C int f; @C int[] f; @C int[][] f;",8.58,98.01,324,439,90,190.1,414,288.11,FALSE,FALSE
535,1,BODY,The while Statement14.12,8.58,4.95,112.36,24,355.64,40.15,468,45.1,FALSE,TRUE
546,0,BODY,14.15The break Statement,8.58,4.95,112.35,24,36,40.15,148.35,45.1,FALSE,TRUE
547,1,BODY,The break Statement14.15,8.58,4.95,112.36,24,355.64,40.15,468,45.1,FALSE,TRUE
551,1,BODY,The throw Statement14.18,8.58,4.95,112.36,24,355.64,40.15,468,45.1,FALSE,TRUE
552,0,BODY,14.18The throw Statement,8.58,4.95,112.35,24,36,40.15,148.35,45.1,FALSE,TRUE
568,0,BODY,14.21The yield Statement,8.58,4.95,112.35,24,36,40.15,148.35,45.1,FALSE,TRUE
701,2,BODY,expressions both cause a compile-time error because there is no casting conversion from List<Integer> to ArrayList<String> or ArrayList<Object>.,8.58,15.02,324,144,90,74.1,414,89.12,FALSE,FALSE
702,5,BODY,"For example, -0.0==0.0 is true.",8.58,5.02,124.9,31,100,265.1,224.9,270.12,FALSE,FALSE
777,4,BODY,"A call of wait(long millisecs) with a parameter of zero, or a call of wait(long millisecs, int nanosecs) with two zero parameters, is equivalent to an invocation of wait().",8.58,25.02,324,172,90,262.1,414,287.12,FALSE,FALSE
675,3,BODY,"The implementation may be optimized so that when a lambda-derived object is passed around and converted to various types, this does not result in many levels of adaptation logic around the core lambda body. Unlike a lambda expression, a method reference can be congruent with a generic function type (that is, a function type that has type parameters). This is because the lambda expression would need to be able to declare type parameters, and no syntax supports this; while for a method reference, no such declaration is necessary. For example, the following program is legal: interface ListFactory { <T> List<T> make(); } ListFactory lf  = ArrayList::new; List<String> ls = lf.make(); List<Number> ln = lf.make();",8.57,168.01,324,716,90,299.1,414,467.11,FALSE,FALSE
95,5,BODY,"The type of the member(s) of Inner depends on the type parameter of Outer. If Outer is raw, Inner must be treated as raw as well, as there is no valid binding for T. This rule applies only to inner member classes that are not inherited. Inherited inner member classes that depend on type variables will be inherited as raw types as a consequence of the rule that the supertypes of a raw type are erased, described later in this section. Another implication of the rules above is that a generic inner class of a raw type can itself only be used as a raw type: class Outer<T>{ class Inner<S> { S s; } }",8.56,150.01,324.01,600,90,443.1,414.01,593.11,FALSE,FALSE
114,2,BODY,"In a simple example as given above, it may appear that it should be straightforward to identify the situation at compile time and give an error. However, in the general (and typical) case, the value of the variable l may be the result of an invocation of a separately compiled method, or its value may depend upon arbitrary control flow. The code above is therefore very atypical, and indeed very bad style. Furthermore, the fact that Object[] is a supertype of all array types means that unsafe aliasing can occur which leads to heap pollution. For example, the following code compiles because it is statically type-correct: static void m(List<String>... stringLists) { Object[] array = stringLists; List<Integer> tmpList = Arrays.asList(42); array[0] = tmpList;                // (1) String s = stringLists[0].get(0);  // (2) }",8.56,158.01,324.01,829,90,74.1,414.01,232.11,FALSE,FALSE
216,8,BODY,Example 6.6-3. Access to public and Non-public Classes,8.56,5.19,218.38,54,90,502.62,308.38,507.81,TRUE,FALSE
387,7,BODY,"@Foo can appear on any class or interface declaration while @FooContainer can appear on only annotation interface declarations. Therefore, the following annotation interface declaration is legal: @Foo @Foo @interface Anno {}",8.56,56.01,324,224,90,399.1,414,455.11,FALSE,FALSE
393,2,BODY,"However, consider an interface that attempts to use @Override on a clone method: (finalize could also be used in this example) interface Quux { @Override Object clone(); }",8.55,36.01,324,171,90,74.1,414,110.11,FALSE,FALSE
575,11,BODY,"In fact, because the fields of interfaces are always static and final, we recommend that only constant expressions be assigned to fields of interfaces. We note, but do not recommend, that if a field of primitive type of an interface may change, its value may be expressed idiomatically as in: interface Flags { boolean debug = Boolean.valueOf(true).booleanValue(); }",8.55,76.01,324,366,90,394.1,414,470.11,FALSE,FALSE
622,2,BODY,Example 15.10.2-3. OutOfMemoryError and Dimension Expression Evaluation,8.55,5.19,295.13,71,90,75.62,385.13,80.81,TRUE,FALSE
435,2,BODY,"For example, the statement throw new java.io.FileNotFoundException(); can throw java.io.FileNotFoundException only. Formally, it is not the case that it 'can throw' a subclass or superclass of java.io.FileNotFoundException.",8.54,25.02,324,223,90,74.1,414,99.12,FALSE,FALSE
781,9,BODY,Thread 2 3: r1 = B; 4: A = 2;,8.54,39,42.85,29,263,491.87,305.85,530.87,FALSE,FALSE
185,5,BODY,"The pattern variable s is introduced by the instanceof expression and is in scope in the first contained statement (the assignment statement in the then block), but it is not in scope in the second contained statement (the expression statement in the else block). Moreover, combined with the treatment for boolean expressions, the scope of pattern variables is robust against code refactorings that exploit the familar boolean logical equivalences. For example, the previous code can be rewritten as: if (!(e instanceof String s)) { System.out.println(e);  // s not in scope } else { counter += s.length(); }",8.53,128.01,324,608,90,424.1,414,552.11,FALSE,FALSE
277,8,BODY,Example 8.2-3. Inheritance of public and protected Class Members,8.53,5.19,262.91,64,90,439.62,352.91,444.81,TRUE,FALSE
289,2,BODY,Example 8.3.1.4-1. volatile Fields,8.53,5.19,133.68,34,90,75.62,223.68,80.81,TRUE,FALSE
408,5,BODY,"With only one base annotation of the repeatable annotation interface Foo, no container annotation is implicitly declared, even if FooContainer is the containing annotation interface of Foo. However, repeating the annotation of interface FooContainer, as in: @Foo(1) @FooContainer({@Foo(2)}) @FooContainer({@Foo(3)}) class A {}",8.53,56.01,324,326,90,251.1,414,307.11,FALSE,FALSE
802,0,BODY,17.7Non-Atomic Treatment of double and long,8.53,4.95,194.14,43,36,40.15,230.14,45.1,FALSE,TRUE
228,6,BODY,"where directory java would contain the Java SE Platform packages; the directories jag, gls, and wnj might contain packages that three of the authors of this specification created for their personal use and to share with each other within this small group; and the directory com would contain packages procured from companies that used the conventions described in §6.1 to generate unique names for their packages. Continuing the example, the directory java would contain, among others, the following subdirectories: applet awt io lang net util",8.52,148.01,324.01,543,90,409.1,414.01,557.11,FALSE,FALSE
513,1,BODY,The assert Statement14.10,8.52,4.95,116.76,25,351.24,40.15,468,45.1,FALSE,TRUE
514,0,BODY,14.10The assert Statement,8.52,4.95,116.75,25,36,40.15,152.75,45.1,FALSE,TRUE
515,1,BODY,The assert Statement14.10,8.52,4.95,116.76,25,351.24,40.15,468,45.1,FALSE,TRUE
516,0,BODY,14.11The switch Statement,8.52,4.95,116.75,25,36,40.15,152.75,45.1,FALSE,TRUE
517,1,BODY,The switch Statement14.11,8.52,4.95,116.76,25,351.24,40.15,468,45.1,FALSE,TRUE
518,0,BODY,14.11The switch Statement,8.52,4.95,116.75,25,36,40.15,152.75,45.1,FALSE,TRUE
519,1,BODY,The switch Statement14.11,8.52,4.95,116.76,25,351.24,40.15,468,45.1,FALSE,TRUE
520,0,BODY,14.11The switch Statement,8.52,4.95,116.75,25,36,40.15,152.75,45.1,FALSE,TRUE
521,1,BODY,The switch Statement14.11,8.52,4.95,116.76,25,351.24,40.15,468,45.1,FALSE,TRUE
522,0,BODY,14.11The switch Statement,8.52,4.95,116.75,25,36,40.15,152.75,45.1,FALSE,TRUE
523,1,BODY,The switch Statement14.11,8.52,4.95,116.76,25,351.24,40.15,468,45.1,FALSE,TRUE
524,0,BODY,14.11The switch Statement,8.52,4.95,116.75,25,36,40.15,152.75,45.1,FALSE,TRUE
525,1,BODY,The switch Statement14.11,8.52,4.95,116.76,25,351.24,40.15,468,45.1,FALSE,TRUE
526,0,BODY,14.11The switch Statement,8.52,4.95,116.75,25,36,40.15,152.75,45.1,FALSE,TRUE
527,1,BODY,The switch Statement14.11,8.52,4.95,116.76,25,351.24,40.15,468,45.1,FALSE,TRUE
528,0,BODY,14.11The switch Statement,8.52,4.95,116.75,25,36,40.15,152.75,45.1,FALSE,TRUE
529,1,BODY,The switch Statement14.11,8.52,4.95,116.76,25,351.24,40.15,468,45.1,FALSE,TRUE
530,0,BODY,14.11The switch Statement,8.52,4.95,116.75,25,36,40.15,152.75,45.1,FALSE,TRUE
531,1,BODY,The switch Statement14.11,8.52,4.95,116.76,25,351.24,40.15,468,45.1,FALSE,TRUE
532,0,BODY,14.11The switch Statement,8.52,4.95,116.75,25,36,40.15,152.75,45.1,FALSE,TRUE
533,1,BODY,The switch Statement14.11,8.52,4.95,116.76,25,351.24,40.15,468,45.1,FALSE,TRUE
534,0,BODY,14.11The switch Statement,8.52,4.95,116.75,25,36,40.15,152.75,45.1,FALSE,TRUE
550,0,BODY,14.17The return Statement,8.52,4.95,116.75,25,36,40.15,152.75,45.1,FALSE,TRUE
217,8,BODY,"If none of the access modifiers public, protected, or private are specified, a class member or constructor has package access: it is accessible throughout the package that contains the declaration of the class in which the class member is declared, but the class member or constructor is not accessible in any other package. If a public class has a method or constructor with package access, then this method or constructor is not accessible to or inherited by a subclass declared outside this package. For example, if we have: package points; public class Point { public int x, y; void move(int dx, int dy) { x += dx; y += dy; } public void moveAlso(int dx, int dy) { move(dx, dy); } }",8.51,160.01,324,686,90,431.1,414,591.11,FALSE,FALSE
406,2,BODY,"object at run time. On the other hand, if Outer.this is not legal - because the class where it appears has no enclosing instance of Outer at run time - then Outer may not be annotated because it is logically just a name, akin to components of a package name in a fully qualified type name. For example, in the following program, it is not possible to write A.this in the body of B, as B has no lexically enclosing instances. Therefore, it is not possible to apply @Foo to A in the type A.B, because A is logically just a name, not a type. @Target(ElementType.TYPE_USE) @interface Foo {} class A { static class B {} } @Foo A.B x;  // Illegal",8.51,168.01,324.01,640,90,74.1,414.01,242.11,FALSE,FALSE
43,4,BODY,"As a result, the following text is a single complete comment: /* this comment /* // /** ends here: */",8.5,26.01,218.74,101,90,549.36,308.74,575.37,FALSE,FALSE
147,5,BODY,"An example of such an illegal chain would be: Integer, Comparable<Integer>, Comparable, Comparable<String>",8.5,26.01,288,106,90,508.1,378,534.11,FALSE,FALSE
229,4,BODY,would be transformed into the directory name: jag/scrabble/board,8.5,26.01,167.47,64,90,316.1,257.47,342.11,FALSE,FALSE
229,6,BODY,which can also be written using full Unicode as: children.activities.crafts.papierMâché,8.5,26.01,182.4,87,90,466.1,272.4,492.11,FALSE,FALSE
229,7,BODY,might be mapped to the directory name: children/activities/crafts/papierM@00e2ch@00e9,8.5,26.01,220.8,85,90,510.1,310.8,536.11,FALSE,FALSE
236,3,BODY,Example 7.5.1-1. Single-Type-Import import java.util.Vector;,8.5,23.49,142.75,60,90,252.62,232.75,276.11,FALSE,FALSE
242,4,BODY,"Example 7.6-3. Fully Qualified Names class Point { int x, y; }",8.5,23.49,146.01,62,90,280.62,236.01,304.11,FALSE,FALSE
242,9,BODY,"For example, if a compilation unit contains the single-type-import declaration (§7.5.1): import java.util.Vector;",8.5,26.01,313.22,113,90,505.1,403.22,531.11,FALSE,FALSE
381,5,BODY,"For example, this is illegal: @interface SelfRef { SelfRef value(); }",8.5,26.01,187.2,69,90,410.1,277.2,436.11,FALSE,FALSE
392,5,BODY,when they mean to write: public boolean equals(Object that) { ... },8.5,26.01,201.6,67,90,199.23,291.6,225.24,FALSE,FALSE
402,13,BODY,"For example, given the field declaration: @Foo int f;",8.5,26.01,146.47,53,90,571.1,236.47,597.11,FALSE,FALSE
407,6,BODY,"In other words, it is not possible to repeat annotations where an annotation of the same interface as their container also appears. This prohibits obtuse code like: @Foo(0) @Foo(1) @FooContainer({@Foo(2)}) class A {}",8.5,46.01,323.99,216,90,512.1,413.99,558.11,FALSE,FALSE
444,3,BODY,"For example, in a UNIX implementation, the command line: java Test reboot Bob Dot Enzo",8.5,26.01,217.98,86,90,112.1,307.98,138.11,FALSE,FALSE
487,4,BODY,rather than: public static final int N = ...;,8.5,26.01,153.6,45,90,202.1,243.6,228.11,FALSE,FALSE
487,5,BODY,There is no problem with: public static int N = ...;,8.5,26.01,124.8,52,90,246.1,214.8,272.11,FALSE,FALSE
511,8,BODY,but it is not legal to use a parenthesized expression (§15.8.5): (System.out.println('Hello world'));  // illegal,8.5,26.01,230.4,113,90,499.1,320.4,525.11,FALSE,FALSE
538,7,BODY,The following code is one possible implementation of the toHexString method of class Integer:,8.5,15.02,324,93,90,339.1,414,354.12,FALSE,FALSE
574,2,BODY,"As an example, the following statement results in a compile-time error: while (false) { x=3; }",8.5,26.01,256.72,94,90,74.1,346.72,100.11,FALSE,FALSE
574,5,BODY,and then write code such as: if (DEBUG) { x=3; },8.5,26.01,101.73,48,90,268.1,191.73,294.11,FALSE,FALSE
578,3,BODY,Consider the following declaration of a record class: record R<T>(ArrayList<T> a){},8.5,26.01,188.71,83,100,157.1,288.71,183.11,FALSE,FALSE
619,3,BODY,"For example, the type of the creation expression: new double[3][3][]",8.5,26.01,175.97,68,90,157.1,265.97,183.11,FALSE,FALSE
619,4,BODY,is: double[][][],8.5,26.01,57.6,16,90,201.1,147.6,227.11,FALSE,FALSE
624,3,BODY,prints: 14,8.5,26.01,27.6,10,90,126.1,117.6,152.11,FALSE,FALSE
656,5,BODY,"Here favorite() returns null, yet no NullPointerException is thrown.",8.5,5.02,279.68,68,90,210.1,369.68,215.12,FALSE,FALSE
704,5,BODY,"For example, the result of the expression: 0xff00 & 0xf0f0",8.5,26.01,149.23,58,90,406.1,239.23,432.11,FALSE,FALSE
704,6,BODY,is: 0xf000,8.5,26.01,28.8,10,90,450.1,118.8,476.11,FALSE,FALSE
704,7,BODY,The result of the expression: 0xff00 ^ 0xf0f0,8.5,26.01,102.48,45,90,494.1,192.48,520.11,FALSE,FALSE
704,8,BODY,is: 0x0ff0,8.5,26.01,28.8,10,90,538.1,118.8,564.11,FALSE,FALSE
705,3,BODY,is: 0xfff0,8.5,26.01,28.8,10,90,96.1,118.8,122.11,FALSE,FALSE
716,2,BODY,"but this was not: List<String> ls = ... ? Arrays.asList() : Arrays.asList('a','b');",8.5,26.01,312,83,90,74.1,402,100.11,FALSE,FALSE
736,4,BODY,This is neither: () -> { if (...) return 'done'; System.out.println('done'); },8.5,26.01,292.8,78,90,182.1,382.8,208.11,FALSE,FALSE
793,6,BODY,Table 17.4.8-A. Happens-before consistency is not sufficient Thread 1 r1 = x; if (r1 != 0) y = 1;if (r2 != 0) x = 1;,8.5,59.45,264.2,116,90,311.12,354.2,370.57,FALSE,FALSE
793,7,BODY,Thread 2 r2 = y;,8.5,21.2,35.25,16,263,332.37,298.25,353.57,FALSE,FALSE
826,5,BODY,The most specific applicable method was identified as: public static <T> List<T> asList(T... a),8.5,26.01,197.72,95,90,567.1,287.72,593.11,FALSE,FALSE
578,4,BODY,"Given the record pattern R<String>(var b), the type of the pattern variable b is ArrayList<String>.",8.49,15.02,314,99,100,201.1,414,216.12,FALSE,FALSE
574,3,BODY,because the statement x=3; is not reachable; but the superficially similar case: if (false) { x=3; },8.48,26.01,282.9,100,90,118.1,372.9,144.11,FALSE,FALSE
741,1,BODY,switch Expressions15.28,8.48,4.95,109.02,23,358.98,40.15,468,45.1,FALSE,TRUE
742,0,BODY,15.28switch Expressions,8.48,4.95,109.02,23,36,40.15,145.02,45.1,FALSE,TRUE
743,1,BODY,switch Expressions15.28,8.48,4.95,109.02,23,358.98,40.15,468,45.1,FALSE,TRUE
744,0,BODY,15.28switch Expressions,8.48,4.95,109.02,23,36,40.15,145.02,45.1,FALSE,TRUE
460,6,BODY,"For efficiency, an implementation may keep track of classes that do not override the finalize method of class Object, or override it in a trivial way. For example: protected void finalize() throws Throwable { super.finalize(); }",8.46,78.01,324,228,90,454.1,414,532.11,FALSE,FALSE
485,6,BODY,Suppose that a new version of class Super is then compiled: class Super extends Hyper { char h = 'h'; },8.46,26.01,224.4,103,90,304.1,314.4,330.11,FALSE,FALSE
533,7,BODY,"When a switch label applies, and that switch label is for a switch rule, the switch rule expression or statement introduced by the switch label is executed, and nothing else. In the case of a switch label for a statement group, all the block statements in the switch block that follow the switch label are executed, including those that appear after subsequent switch labels. The effect is that, as in C and C++, execution of statements can 'fall through labels.' For example, the program: class TooMany { static void howMany(int k) { switch (k) { case 1: System.out.print('one '); case 2: System.out.print('too '); case 3: System.out.println('many'); }",8.46,148.01,324.01,653,90,454.1,414.01,602.11,FALSE,FALSE
487,3,BODY,"If the read-only nature of final is required, a better choice is to declare a private static variable and a suitable accessor method to get its value. Thus we recommend: private static int N; public static int getN() { return N; }",8.45,46.01,324,230,90,138.1,414,184.11,FALSE,FALSE
56,8,BODY,Examples of int literals: 0    2    0372    0xDada_Cafe    1996    0x00_FF__00_FF,8.44,26.01,264,81,90,405.1,354,431.11,FALSE,FALSE
88,4,BODY,"Given the generic classes in the examples of §8.1.2, here are some well-formed parameterized types: •Seq<String> •Seq<Seq<String>> •Seq<String>.Zipper<Integer>",8.44,69.02,324,159,90,528.1,414,597.12,FALSE,FALSE
320,6,BODY,"The first compile-time error above, regarding a class C that inherits a concrete method, can happen if a superclass of C is generic, and the superclass has two methods that were distinct in the generic declaration but have the same signature in the parameterization (§4.5) used by C. For example: class A<T> { void m(String s) {} // 1 void m(T t) {} // 2 } class C extends A<String> {}",8.44,96.01,324,385,90,450.1,414,546.11,FALSE,FALSE
554,4,BODY,Example 14.19-1. The synchronized Statement,8.44,5.19,180.13,43,90,313.62,270.13,318.81,TRUE,FALSE
557,4,BODY,"A multi-catch clause can be thought of as a sequence of uni-catch clauses. That is, a catch clause where the type of the exception parameter is denoted as a union D1|D2|...|Dn is equivalent to a sequence of n catch clauses where the types of the exception parameters are class types D1, D2, ..., Dn respectively. In the Block of each of the n catch clauses, the declared type of the exception parameter is lub(D1, D2, ..., Dn). For example, the following code: try { ... throws ReflectiveOperationException ... } catch (ClassNotFoundException | IllegalAccessException ex) { ... body ... }",8.44,126.01,324,588,90,278.1,414,404.11,FALSE,FALSE
522,7,BODY,"The first condition prevents a statement group from 'falling through' to another statement group without initializing pattern variables. For example, were the statement labeled by case Integer i reachable from the preceding statement group, the pattern variable i would not have been initialized: Object o = 'Hello'; switch (o) { case String s: System.out.println('String: ' + s );  // No break! case Integer i:",8.43,96.01,324.01,411,90,500.1,414.01,596.11,FALSE,FALSE
527,3,BODY,"Determining whether this switch block is exhaustive requires the analysis of the combination of the record patterns. The set containing the record pattern Box(I i) covers the type Box, and so the set containing the patterns Box(A a), Box(B b), and Box(C c) can be rewritten to the set containing the pattern Box(I i). This is because the set containing the patterns A a, B b, C c reduces to the pattern I i (because the same set covers the type I), and thus the set containing the patterns Box(A a), Box(B b), Box(C c) reduces to the pattern Box(I i). However, rewriting a set of record patterns is not always so simple. For example: record IPair(I i, I j){} int testNonExhaustiveRecordPatterns(IPair p) { return switch (p) {     // Not Exhaustive! case IPair(A a, A a) -> 0; case IPair(B b, B b) -> 1; case IPair(C c, C c) -> 2; }; }",8.43,188.01,324,834,90,216.1,414,404.11,FALSE,FALSE
56,9,BODY,Examples of long literals: 0l    0777L    0x100000000L    2_147_483_648L    0xC0B0L,8.42,26.01,268.8,83,90,449.1,358.8,475.11,FALSE,FALSE
525,3,BODY,"As the switch block contains case patterns that match against all values of types A, B and C, and no other instances of type I are permitted, this switch block is exhaustive. The fact that a permitted direct subclass or subinterface may only extend a particular parameterization of a generic sealed superclass or superinterface means that it may not always need to be considered when determining whether a switch block is exhaustive. For example: sealed interface J<X> permits D, E {} final class D<Y> implements J<String> {} final class E<X> implements J<X> {} static int testExhaustive2(J<Integer> ji) { return switch(ji) {          // Exhaustive! case E<Integer> e -> 42; }; }",8.42,168.01,314.01,679,100,337.1,414.01,505.11,FALSE,FALSE
531,5,BODY,"Prior to Java SE 21, switch statements (and switch expressions) were limited in two ways: (i) the type of the selector expression was restricted to either an integral type (excluding long), an enum type, or String and (ii) no case null labels were supported. Moreover, unlike switch expressions, switch statements did not have to be exhaustive. This is often the cause of difficult-to-detect bugs, where no switch label applies and the switch statement will silently do nothing. For example: enum E { A, B, C } E e = ...; switch (e) { case A -> System.out.println('A'); case B -> System.out.println('B'); // No case for C! }",8.42,136.01,324,624,90,349.1,414,485.11,FALSE,FALSE
59,5,BODY,Examples of float literals: 1e1f    2.f    .3f    0f    3.14f    6.022137e+23f,8.41,26.01,240,78,90,406.1,330,432.11,FALSE,FALSE
247,4,BODY,Example 7.1.1-1. Resolution of requires transitive directives,8.41,5.19,240.44,61,90,237.62,330.44,242.81,TRUE,FALSE
365,3,BODY,"The canonical name of a class or interface does not need to be used in a permits clause, but a permits clause can only specify a class or interface once. For example, the following program fails to compile: package p; sealed interface I permits C, D, p.C {}  // error non-sealed class C implements I {} non-sealed class D implements I {}",8.41,96.01,324,337,90,189.1,414,285.11,FALSE,FALSE
548,0,BODY,14.16The continue Statement,8.41,4.95,125.55,27,36,40.15,161.55,45.1,FALSE,TRUE
549,1,BODY,The continue Statement14.16,8.41,4.95,125.56,27,342.44,40.15,468,45.1,FALSE,TRUE
304,6,BODY,Example 8.4.3.6-1. synchronized Monitors,8.4,5.19,163.88,40,90,530.62,253.88,535.81,TRUE,FALSE
59,6,BODY,Examples of double literals: 1e1    2.    .3    0.0    3.14    1e-9d    1e137,8.39,26.01,230.4,77,90,450.1,320.4,476.11,FALSE,FALSE
305,4,BODY,Example 8.4.3.6-2. synchronized Methods,8.38,5.19,161.88,39,90,354.62,251.88,359.81,TRUE,FALSE
60,8,BODY,The following are examples of char literals: •'a' •'%' •'\t' •'\\',8.36,75.02,161.18,66,90,523.23,251.18,598.25,FALSE,FALSE
672,3,BODY,"A method reference expression of the form ReferenceType :: [TypeArguments] Identifier can be interpreted in different ways. If Identifier refers to an instance method, then the implicit lambda expression has an extra parameter compared to if Identifier refers to a static method. It is possible for ReferenceType to have both kinds of applicable methods, so the search algorithm described above identifies them separately, since there are different parameter types for each case. An example of ambiguity is: interface Fun<T,R> { R apply(T arg); }  class C { int size() { return 0; } static int size(Object arg) { return 0; }  void test() { Fun<C, Integer> f1 = C::size; // Error: instance method size() // or static method size(Object)? } }",8.36,208.01,324.01,740,90,112.1,414.01,320.11,FALSE,FALSE
33,3,BODY,BooleanLiteral: t r u e f a l s e,8.33,24.22,57.5,33,108,96.15,165.5,120.37,FALSE,FALSE
42,5,BODY,"For example, in this simple piece of code: class Empty { }",8.33,36.01,150.98,58,90,226.1,240.98,262.11,FALSE,FALSE
62,8,BODY,and the compilation unit: package other; public class Other { public static String hello = 'Hello'; },8.33,36.01,306,101,90,566.1,396,602.11,FALSE,FALSE
76,3,BODY,K-1,8.33,4.75,12.27,3,145.16,84.11,157.43,88.86,FALSE,FALSE
76,4,BODY,N-1,8.33,4.75,12.27,3,350.76,116.11,363.03,120.86,FALSE,FALSE
76,5,BODY,N-1,8.33,4.75,12.27,3,236.12,142.11,248.4,146.86,FALSE,FALSE
113,5,BODY,"For example, the code: List l = new ArrayList<Number>(); List<String> ls = l;  // Unchecked warning",8.33,36.01,201.6,99,90,444.1,291.6,480.11,FALSE,FALSE
217,3,BODY,"two classes are declared in the compilation unit. The class Point is available outside the package points, while the class PointList is available for access only within the package. Thus a compilation unit in another package can access points.Point, either by using its fully qualified name: package pointsUser; class Test1 { public static void main(String[] args) { points.Point p = new points.Point(); System.out.println(p.x + ' ' + p.y); } }",8.33,116.01,324,444,90,116.1,414,232.11,FALSE,FALSE
381,6,BODY,and so is this: @interface Ping { Pong value(); } @interface Pong { Ping value(); },8.33,36.01,163.2,83,90,454.1,253.2,490.11,FALSE,FALSE
408,4,BODY,This rule is designed to allow the following code: @Foo(1) @FooContainer({@Foo(2)}) class A {},8.33,36.01,178.49,94,90,197.1,268.49,233.11,FALSE,FALSE
418,5,BODY,Example 10.2-1. Declarations of Array Variables int[]     ai;        // array of int short[][] as;        // array of array of short,8.33,33.49,243.6,132,90,568.62,333.6,602.11,FALSE,FALSE
597,3,BODY,prints: Infinity 1.6E308,8.33,36.01,38.4,24,90,126.1,128.4,162.11,FALSE,FALSE
664,6,BODY,"Now, given an invocation: C c = new D(); c.id(new Object());  // fails with a ClassCastException",8.33,36.01,282,96,90,267.1,372,303.11,FALSE,FALSE
723,6,BODY,"For example, the following code is correct: short x = 3; x += 4.6;",8.33,36.01,155.22,66,90,269.1,245.22,305.11,FALSE,FALSE
735,8,BODY,The following lambda bodies are void-compatible: () -> {} () -> { System.out.println('done'); },8.33,36.01,182.73,95,90,565.1,272.73,601.11,FALSE,FALSE
736,2,BODY,These are value-compatible: () -> { return 'done'; } () -> { if (...) return 1; else return 0; },8.33,36.01,206.4,96,90,74.1,296.4,110.11,FALSE,FALSE
736,3,BODY,These are both: () -> { throw new RuntimeException(); } () -> { while (true); },8.33,36.01,187.2,79,90,128.1,277.2,164.11,FALSE,FALSE
782,4,BODY,Thread 2 r1 = B; A = 2;,8.33,38.2,35.25,23,263,203.87,298.25,242.07,FALSE,FALSE
782,7,BODY,Thread 2 r6 = p; r6.x = 3;,8.33,38.2,43.2,26,263,508.37,306.2,546.57,FALSE,FALSE
783,4,BODY,Thread 2 r6 = p; r6.x = 3;,8.33,38.2,43.2,26,263,138.87,306.2,177.07,FALSE,FALSE
789,7,BODY,Thread 2 A = 2; r1 = B;,8.33,38.2,35.25,23,263,528.37,298.25,566.57,FALSE,FALSE
393,5,BODY,"The clause about a record class is due to the special meaning of @Override in a record declaration. Namely, it can be used to specify that a method declaration is an accessor method for a record component. Consider the following record declaration: record Roo(int x) { @Override public int x() { return Math.abs(x); } }",8.32,96.01,324,319,90,234.1,414,330.11,FALSE,FALSE
723,7,BODY,and results in x having the value 7 because it is equivalent to: short x = 3; x = (short)(x + 4.6);,8.32,36.01,221.58,99,90,323.1,311.58,359.11,FALSE,FALSE
827,4,BODY,{ ‹List<α> → List<Number>› },8.32,5.86,123.96,28,90,178.67,213.96,184.53,FALSE,FALSE
96,2,BODY,It is not possible to access Inner as a partially raw type (a 'rare' type): Outer.Inner<Double> x = null;  // illegal Double d = x.s;,8.31,36.01,257.79,133,90,74.1,347.79,110.11,FALSE,FALSE
273,3,BODY,"The canonical name of a class does not need to be used in a permits clause, but a permits clause can only specify a class once. For example, the following program fails to compile: package p; sealed class A     permits B, C, p.B {}  // error non-sealed class B extends A {} non-sealed class C extends A {}",8.31,86.01,324.01,305,90,144.1,414.01,230.11,FALSE,FALSE
521,3,BODY,"A case label with more than one case pattern is dominated if any one of these patterns is dominated by a pattern that appears as a case pattern in a preceding unguarded case label, and so the following results in a compile-time error (as the type pattern Integer _ is dominated by the type pattern Number _): Object obj = ... switch (obj) { case Number _ -> System.out.println('A Number'); case Integer _, String _ ->       // Error - dominated! System.out.println('An Integer or a String'); ... }",8.3,126.01,314,497,100,96.1,414,222.11,FALSE,FALSE
518,3,BODY,"If a case label with more than one case pattern could declare pattern variables, then it would not be clear which variables would be initialized if the case label were to apply. For example: Object obj = ...; switch (obj) { case Integer i, Boolean b -> { ...       // Error! Is i or b initialized? } ... }",8.29,106.01,324,305,90,157.1,414,263.11,FALSE,FALSE
782,6,BODY,Table 17.4-C. Surprising results caused by forward substitution Thread 1 r1 = p; r2 = r1.x; r3 = q; r4 = r3.x; r5 = r1.x;,8.29,110.45,244.27,121,90,487.12,334.27,597.57,FALSE,FALSE
783,3,BODY,Table 17.4-D. Surprising results caused by forward substitution Thread 1 r1 = p; r2 = r1.x; r3 = q; r4 = r3.x; r5 = r2;,8.29,110.45,244.27,119,90,117.62,334.27,228.07,FALSE,FALSE
229,2,BODY,"Still continuing the example, if we were to look inside the directory util, we might see the following files: BitSet.java        Observable.java BitSet.class       Observable.class Date.java          Observer.java Date.class         Observer.class ...",8.28,76.01,324,251,90,74.1,414,150.11,FALSE,FALSE
520,3,BODY,"The definition of one pattern dominating another pattern is based on types. For example, the type pattern Object o dominates the type pattern String s, and so the following results in a compile-time error: Object obj = ... switch (obj) { case Object o -> System.out.println('An object'); case String s ->                 // Error! System.out.println('A string'); }",8.28,106.01,314,364,100,125.1,414,231.11,FALSE,FALSE
520,5,BODY,"On the other hand, a guarded case label with a case pattern is not considered to dominate an unguarded case label with the same case pattern. This allows the following common pattern programming style: Integer j = ...; switch (j) { case Integer i when i <= 0 -> System.out.println('Less than or equal to zero'); case Integer i -> System.out.println('An integer'); }",8.28,106.01,314,365,100,373.1,414,479.11,FALSE,FALSE
144,5,BODY,"The method reverses the list provided as a parameter. It works for any type of list, and so the use of the wildcard type List<?> as the type of the formal parameter is entirely appropriate. Now consider how one would implement reverse(): public static void reverse(List<?> list) { rev(list); } private static <T> void rev(List<T> list) { List<T> tmp = new ArrayList<T>(list); for (int i = 0; i < list.size(); i++) { list.set(i, tmp.get(list.size() - i - 1)); } }",8.27,118.01,324.01,462,90,377.1,414.01,495.11,FALSE,FALSE
406,3,BODY,"On the other hand, in the following program, it is possible to write C.this in the body of D. Therefore, it is possible to apply @Foo to C in the type C.D, because C represents the type of some object at run time. @Target(ElementType.TYPE_USE) @interface Foo {} class Test { static class C { class D {} } @Foo C.D x;  // Legal }",8.26,136.01,324,328,90,260.1,414,396.11,FALSE,FALSE
634,3,BODY,"No syntax supports a combination of these forms, that is, invoking a superinterface method of a lexically enclosing class declaration, as if the invocation were of the form InterfaceName . super in the lexically enclosing class declaration. class Subclass3 implements Superinterface { void foo() { throw new UnsupportedOperationException(); } Runnable tweak = new Runnable() { void run() { Subclass3.Superinterface.super.foo();  // Illegal } }; }",8.26,126.01,323.99,446,90,196.1,413.99,322.11,FALSE,FALSE
95,4,BODY,"To see why the name of an inner member class of a raw type is considered raw, consider the following example: class Outer<T>{ T t; class Inner { T setOuterT(T t1) { t = t1; return t; } } }",8.25,86.01,324,188,90,339.1,414,425.11,FALSE,FALSE
260,5,BODY,"For instance, executing the code: Vector<String>  x = new Vector<String>(); Vector<Integer> y = new Vector<Integer>(); boolean b = x.getClass() == y.getClass();",8.25,46.01,201.6,160,90,484.1,291.6,530.11,FALSE,FALSE
358,5,BODY,"The intent of a compact constructor declaration is that only code to validate or normalize parameters needs to be given in the constructor body; the remaining initialization code is supplied by the compiler. For example, the following record class has a compact constructor that simplifies a rational number: record Rational(int num, int denom) { private static int gcd(int a, int b) { if (b == 0) return Math.abs(a); else return gcd(b, a % b); }  Rational { int gcd = gcd(num, denom); num    /= gcd; denom  /= gcd; } }",8.25,166.01,324.01,519,90,231.1,414.01,397.11,FALSE,FALSE
381,3,BODY,"This rule precludes elements with nested array types, such as: @interface Verboten { String[][] value(); }",8.25,46.01,221.96,106,90,194.1,311.96,240.11,FALSE,FALSE
526,3,BODY,"A record pattern whose component patterns all cover the type of the corresponding record component is considered to cover the record type. For example: record Test<X>(Object o, X x){} static int testExhaustiveRecordPattern(Test<String> r) { return switch(r) {                           // Exhaustive! case Test<String>(Object o, String s) -> 0; }; }",8.25,86.01,314.01,349,100,125.1,414.01,211.11,FALSE,FALSE
545,4,BODY,will be translated to: for (Iterator<Integer> #i = l.iterator(); #i.hasNext(); ) { float #i0 = (Integer)#i.next(); ...,8.25,46.01,283.2,118,90,418.1,373.2,464.11,FALSE,FALSE
667,3,BODY,Here are some more method reference expressions: String::valueOf       // overload resolution needed Arrays::sort          // type arguments inferred from context Arrays::<String>sort  // explicit type arguments,8.25,46.01,292.8,211,90,206.1,382.8,252.11,FALSE,FALSE
672,5,BODY,"The search is smart enough to ignore ambiguities in which all the applicable methods (from both searches) are instance methods: interface Fun<T,R> { R apply(T arg); }  class C { int size() { return 0; } int size(Object arg) { return 0; } int size(C arg) { return 0; }",8.25,86.01,324.01,267,90,512.1,414.01,598.11,FALSE,FALSE
520,6,BODY,"The only exception is where the guard is a constant expression that has the value true, for example: Integer j = ...; switch (j) { case Integer i when true ->            // Ok System.out.println('An integer'); case Integer i ->                      // Error! System.out.println('An integer');",8.24,86.01,314,292,100,497.1,414,583.11,FALSE,FALSE
245,4,BODY,"To aid comprehension, it is customary, though not required, for a module declaration to group its directives, so that the requires directives which pertain to modules are visually distinct from the exports and opens directives which pertain to packages, and from the uses and provides directives which pertain to services. For example: module com.example.foo { requires com.example.foo.http; requires java.logging; requires transitive com.example.foo.network; exports com.example.foo.bar; exports com.example.foo.internal to com.example.foo.probe; opens com.example.foo.quux; opens com.example.foo.internal to com.example.foo.network, com.example.foo.probe; uses com.example.foo.spi.Intf; provides com.example.foo.spi.Intf with com.example.foo.Impl; }",8.22,206.01,324.01,751,90,277.1,414.01,483.11,FALSE,FALSE
400,10,BODY,"Here is an example of a normal annotation that takes advantage of default values, using the annotation interface from §9.6.2: @RequestForEnhancement( id       = 4561414, synopsis = 'Balance the federal budget' ) public static void balanceFederalBudget() { throw new UnsupportedOperationException('Not implemented'); }",8.22,96.01,324,317,90,505.1,414,601.11,FALSE,FALSE
518,4,BODY,"Even if only one of the case patterns declares a pattern variable, it would still not be clear whether the variable was initialized or not; for example: Object obj = ...; switch (obj) { case Integer i, Boolean _ -> { ...       // Error! Is i initialized? } ... }",8.22,96.01,324.01,262,90,281.1,414.01,377.11,FALSE,FALSE
184,3,BODY,"For example, in the following if-then-else statement, the scope of the pattern variable s includes one substatement but not another: Object o = ... if (o instanceof String s) // s in scope for this substatement; no cast of o needed System.out.println(s.replace('*', '_')); else // s not in scope for this substatement (hence, error) System.out.println(s);",8.21,96.01,324,355,90,125.1,414,221.11,FALSE,FALSE
283,9,BODY,"If the same field declaration is inherited from an interface by multiple paths, the field is considered to be inherited only once. It may be referred to by its simple name without ambiguity. For example, in the code: interface Colorable { int RED = 0xff0000, GREEN = 0x00ff00, BLUE = 0x0000ff; } interface Paintable extends Colorable { int MATTE = 0, GLOSSY = 1; } class Point { int x, y; } class ColoredPoint extends Point implements Colorable {} class PaintedPoint extends ColoredPoint implements Paintable { int p = RED; }",8.21,146.01,324,525,90,431.1,414,577.11,FALSE,FALSE
342,3,BODY,"Static initialization of this enum would throw a NullPointerException because the static variable colorMap is uninitialized when the constructors for the enum constants run. The restriction above ensures that such code cannot be compiled. However, the code can easily be refactored to work properly: import java.util.HashMap; import java.util.Map;  enum Color { RED, GREEN, BLUE;  static final Map<String,Color> colorMap = new HashMap<String,Color>(); static { for (Color c : Color.values()) colorMap.put(c.toString(), c); } }",8.21,176.01,324,526,90,156.1,414,332.11,FALSE,FALSE
32,12,BODY,ZeroToThree: 0 1 2 3,8.2,44.22,50.5,20,108,446.15,158.5,490.37,FALSE,FALSE
303,3,BODY,Inlining the method move of class Point in method main would transform the for loop to the form: for (int i = 0; i < p.length; i++) { p[i] = new Point(); Point pi = p[i]; int j = p.length-1-i; pi.x += i; pi.y += j; },8.2,96.01,324,216,90,416.23,414,512.24,FALSE,FALSE
336,6,BODY,"is equivalent to the declaration: public class Point { int x, y; public Point() { super(); } }",8.2,56.01,166.8,94,90,405.1,256.8,461.11,FALSE,FALSE
514,3,BODY,"This rule is motivated by a case that demands special treatment. Recall that the assertion status of a class is set no later than the time it is initialized. It is possible, though generally not desirable, to execute methods or constructors prior to initialization. This can happen when a class hierarchy contains a circularity in its static initialization, as in the following example: public class Foo { public static void main(String[] args) { Baz.testAsserts(); // Will execute after Baz is initialized. } } class Bar { static { Baz.testAsserts(); // Will execute before Baz is initialized! } } class Baz extends Bar { static void testAsserts() { boolean enabled = false; assert  enabled = true; System.out.println('Asserts ' + (enabled ? 'enabled' : 'disabled')); } }",8.2,256.01,324.02,772,90,215.1,414.02,471.11,FALSE,FALSE
521,5,BODY,"For example, a case label with an Integer type pattern dominates a case label with an integer literal: Integer j = ...; switch (j) { case Integer i -> System.out.println('An integer'); case 42 ->                              // Error - dominated! System.out.println('42!'); }",8.2,96.01,314,275,100,394.1,414,490.11,FALSE,FALSE
633,3,BODY,"The TypeName . super syntax is overloaded: traditionally, the TypeName refers to a lexically enclosing class declaration, and the target is the superclass of this class, as if the invocation were an unqualified super in the lexically enclosing class declaration. class Superclass { void foo() { System.out.println('Hi'); } } class Subclass1 extends Superclass { void foo() { throw new UnsupportedOperationException(); } Runnable tweak = new Runnable() { void run() { Subclass1.super.foo();  // Gets the 'println' behavior } }; }",8.2,166.01,324,528,90,310.1,414,476.11,FALSE,FALSE
667,4,BODY,"Here are some method reference expressions that represent a deferred creation of an object or an array: ArrayList<String>::new     // constructor for parameterized type ArrayList::new             // inferred type arguments // for generic class Foo::<Integer>new          // explicit type arguments // for generic constructor Bar<String>::<Integer>new  // generic class, generic constructor Outer.Inner::new           // inner class constructor int[]::new                 // array creation",8.2,106.01,324,488,90,270.1,414,376.11,FALSE,FALSE
691,3,BODY,This program produces the output: 5.0%3.0 produces 2.0 5.0%(-3.0) produces 2.0 (-5.0)%3.0 produces -2.0 (-5.0)%(-3.0) produces -2.0,8.2,56.01,147.6,131,90,206.1,237.6,262.11,FALSE,FALSE
520,4,BODY,"A guarded case label with a case pattern is dominated by a case label with the same pattern but without the guard. For example, the following results in a compile-time error: String str = ...; switch (str) { case String s -> System.out.println('A string'); case String s when s.length() == 2 ->  // Error! System.out.println('Two character string'); ... }",8.19,106.01,314.01,355,100,249.1,414.01,355.11,FALSE,FALSE
524,4,BODY,"A default label is permitted, but not required, in the case where the names of all the enum constants appear as case constants. For example: enum E { F, G, H } static int testEnumExhaustive(E e) { return switch(e) { case F -> 0; case G -> 1; case H -> 2;    // No default required! }; }",8.18,106.01,313.99,286,100,439.23,413.99,545.24,FALSE,FALSE
62,2,BODY,"The following are examples of string literals: ''                    // the empty string '\''                  // a string containing ' alone 'This is a string'    // a string containing 16 characters 'This is a ' +        // actually a string-valued constant expression, 'two-line string'    // formed from two string literals",8.17,66.01,336,327,90,74.1,426,140.11,FALSE,FALSE
145,2,BODY,"the following code would undermine the type system: List<String> ls = new ArrayList<String>(); List<?> l = ls; Collections.fill(l, new Object());  // not legal - but assume it was! String s = ls.get(0); // ClassCastException - ls contains // Objects, not Strings.",8.17,66.01,331.2,263,90,74.1,421.2,140.11,FALSE,FALSE
344,8,BODY,The program produces the output: java Operation 2.0 4.0 2.0 PLUS 4.0 = 6.0 2.0 MINUS 4.0 = -2.0 2.0 TIMES 4.0 = 8.0 2.0 DIVIDED_BY 4.0 = 0.5,8.17,66.01,133.2,140,90,536.1,223.2,602.11,FALSE,FALSE
352,3,BODY,"For example, a record class can inherit default methods from its direct superinterfaces, although the default method bodies have no knowledge of the component fields of the record class. The following program prints Logged: public class Test { interface Logging { default void logAction() { System.out.println('Logged'); } }  record Point(int i, int j) implements Logging {}  public static void main(String[] args) { Point p = new Point(10, 20); p.logAction(); } }",8.17,176.01,324,464,90,151.1,414,327.11,FALSE,FALSE
382,3,BODY,The following annotation interface declaration defines an annotation interface with several elements: /** * Describes the 'request-for-enhancement' (RFE) * that led to the presence of the annotated API element. */ @interface RequestForEnhancement { int    id();        // Unique ID number associated with RFE String synopsis();  // Synopsis of RFE String engineer();  // Name of engineer who implemented RFE String date();      // Date RFE was implemented },8.17,126.01,325.2,457,90,99.1,415.2,225.11,FALSE,FALSE
532,3,BODY,but it can easily be made exhaustive: Object o = ...; switch (o) { case String s -> System.out.println('A string!'); default -> {} },8.17,66.01,254.4,132,90,106.1,344.4,172.11,FALSE,FALSE
184,5,BODY,"For example, in the following method, the scope of the pattern variable s includes the method body following the if statement: void test(Object o) { if (!(o instanceof String s)) { throw new IllegalArgumentException(); } // This point is only reachable if the pattern match succeeded // Thus, s is in scope for the rest of the block ... System.out.println(s.repeat(5)); ... }",8.16,126.01,324,375,90,301.1,414,427.11,FALSE,FALSE
523,3,BODY,Switch blocks consisting of switch label statement groups allow multiple labels to apply to a statement group. The second condition prevents a statement group from being executed based on one label without initializing the pattern variables of another label. For example: Object o = 'Hello World'; switch (o) { case String s: case Integer i: System.out.println(i + 1);  // Error! Can be reached // without matching the // pattern `Integer i` default: } Object obj = null; switch (obj) { case null: case String s: System.out.println(s);      // Error! Can be reached // without matching the // pattern `String s` default: },8.14,216.01,324,622,90,136.1,414,352.11,FALSE,FALSE
530,4,BODY,"where n is known to be positive. A trick known as Duff's device can be used in C or C++ to unroll the loop, but this is not valid code in the Java programming language: int q = (n+7)/8; switch (n%8) { case 0: do { foo();    // Great C hack, Tom, case 7:      foo();    // but it's not valid here. case 6:      foo(); case 5:      foo(); case 4:      foo(); case 3:      foo(); case 2:      foo(); case 1:      foo(); } while (--q > 0); }",8.14,146.01,324,437,90,365.1,414,511.11,FALSE,FALSE
558,6,BODY,Example 14.20.1-1. Catching An Exception class BlewIt extends Exception { BlewIt() { } BlewIt(String s) { super(s); } } class Test { static void blowUp() throws BlewIt { throw new BlewIt(); },8.14,73.49,320.4,191,90,528.62,410.4,602.11,FALSE,FALSE
462,2,BODY,"For example, consider the Finalizer Guardian pattern: class Foo { private final Object finalizerGuardian = new Object() { protected void finalize() throws Throwable { /* finalize outer Foo object */ } } }",8.13,86.01,283.2,204,90,74.1,373.2,160.11,FALSE,FALSE
518,5,BODY,"The following does not result in a compile-time error: Object obj = ...; switch (obj) { case Integer _, Boolean _ -> { ...       // Matches both an Integer and a Boolean } ... }",8.13,86.01,259.2,177,90,395.1,349.2,481.11,FALSE,FALSE
672,4,BODY,"This ambiguity cannot be resolved by providing an applicable instance method which is more specific than an applicable static method: interface Fun<T,R> { R apply(T arg); }  class C { int size() { return 0; } static int size(Object arg) { return 0; } int size(C arg) { return 0; }  void test() { Fun<C, Integer> f1 = C::size; // Error: instance method size() // or static method size(Object)? } }",8.12,156.01,323.99,396,90,338.1,413.99,494.11,FALSE,FALSE
245,5,BODY,The opens directives can be avoided if the module is open: open module com.example.foo { requires com.example.foo.http; requires java.logging; requires transitive com.example.foo.network;  exports com.example.foo.bar; exports com.example.foo.internal to com.example.foo.probe;,8.11,96.01,297.6,276,90,501.1,387.6,597.11,FALSE,FALSE
485,9,BODY,even though compiling the source for these binaries: class Hyper { String h = 'Hyper'; } class Super extends Hyper { char h = 'h'; } class Test extends Super { public static void main(String[] args) { String s = new Test().h; System.out.println(s); } },8.11,96.01,234,252,90,402.1,324,498.11,FALSE,FALSE
237,8,BODY,and then the compilation unit: package strange; import java.util.Vector; import Vector.Mosquito; class Test { public static void main(String[] args) { System.out.println(new Vector().getClass()); System.out.println(new Mosquito().getClass()); } },8.1,106.01,282,246,90,304.1,372,410.11,FALSE,FALSE
358,6,BODY,"The compact constructor Rational {...} behaves the same as this normal constructor: Rational(int num, int denom) { int gcd = gcd(num, denom); num    /= gcd; denom  /= gcd; this.num   = num; this.denom = denom; }",8.1,86.01,322.15,211,90,415.1,412.15,501.11,FALSE,FALSE
75,9,BODY,(e - N + 1),8.09,4.75,34.33,11,106.22,477.11,140.55,481.86,FALSE,FALSE
523,4,BODY,"Both of these conditions apply only when the case pattern declares pattern variables. The following examples, in contrast, are unproblematic: record R() {} record S() {} Object o = 'Hello World'; switch (o) { case String s: System.out.println(s);      // No break case R():                       // No pattern variables declared System.out.println('It's either an R or a string'); break; default: } Object ob = new R(); switch (ob) { case R(): case S():                       // Multiple case labels System.out.println('Either R or an S'); break; default: } Object obj = null;",8.09,226.01,326.4,576,90,370.1,416.4,596.11,FALSE,FALSE
97,3,BODY,"Example 4.8-1. Raw Types class Cell<E> { E value;  Cell(E v)     { value = v; } E get()       { return value; } void set(E v) { value = v; }  public static void main(String[] args) { Cell x = new Cell<String>('abc'); System.out.println(x.value);  // OK, has type Object System.out.println(x.get());  // OK, has type Object",8.08,123.49,310.8,322,90,477.62,400.8,601.11,FALSE,FALSE
277,9,BODY,"Given the class Point: package points; public class Point { public int x, y; protected int useCount = 0; static protected int totalUseCount = 0; public void move(int dx, int dy) { x += dx; y += dy; useCount++; totalUseCount++; } }",8.08,106.01,282,230,90,463.1,372,569.11,FALSE,FALSE
557,5,BODY,is semantically equivalent to the following code: try { ... throws ReflectiveOperationException ... } catch (final ClassNotFoundException ex1) { final ReflectiveOperationException ex = ex1; ... body ... } catch (final IllegalAccessException ex2) { final ReflectiveOperationException ex = ex2; ... body ... },8.08,126.01,230.4,307,90,422.1,320.4,548.11,FALSE,FALSE
750,4,BODY,A Java compiler will accept the code: void unflow(boolean flag) { final int k; if (flag) { k = 3; System.out.println(k); } else { k = 4; System.out.println(k); } },8.08,126.01,162,163,90,143.1,252,269.11,FALSE,FALSE
298,3,BODY,"Here are some examples of receiver parameters in instance methods and inner classes' constructors: class Test { Test(/* ?? ?? */) {} // No receiver parameter is permitted in the constructor of // a top level class, as there is no conceivable type or name. void m(Test this) {} // OK: receiver parameter in an instance method static void n(Test this) {} // Illegal: receiver parameter in a static method class A { A(Test Test.this) {} // OK: the receiver parameter represents the instance // of Test which immediately encloses the instance // of A being constructed. void m(A this) {} // OK: the receiver parameter represents the instance // of A for which A.m() is invoked. class B { B(Test.A A.this) {} // OK: the receiver parameter represents the instance // of A which immediately encloses the instance of B // being constructed. void m(Test.A.B this) {} // OK: the receiver parameter represents the instance // of B for which B.m() is invoked. } }",8.07,346.01,384,951,90,254.1,474,600.11,FALSE,FALSE
305,3,BODY,has exactly the same effect as: class BumpTest { int count; void bump() { synchronized (this) { count++; } } static int classCount; static void classBump() { try { synchronized (Class.forName('BumpTest')) { classCount++; } } catch (ClassNotFoundException e) {} } },8.07,156.01,282,264,90,176.1,372,332.11,FALSE,FALSE
270,4,BODY,"Example 8.1.5-2. Superinterfaces interface Colorable { void setColor(int color); int getColor(); } enum Finish { MATTE, GLOSSY } interface Paintable extends Colorable { void setFinish(Finish finish); Finish getFinish(); }  class Point { int x, y; } class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } public int getColor() { return color; } }",8.06,173.49,306,413,90,423.62,396,597.11,FALSE,FALSE
91,3,BODY,Example 4.5.1-1. Unbounded Wildcards import java.util.ArrayList; import java.util.Collection;  class Test { static void printCollection(Collection<?> c) { // a wildcard collection for (Object o : c) { System.out.println(o); } }  public static void main(String[] args) { Collection<String> cs = new ArrayList<String>(); cs.add('hello'); cs.add('world'); printCollection(cs); } },8.05,193.49,291.6,377,90,179.62,381.6,373.11,FALSE,FALSE
801,5,BODY,"The following program is a test case to detect word tearing: public class WordTearing extends Thread { static final int LENGTH = 8; static final int ITERS  = 1000000; static byte[] counts    = new byte[LENGTH]; static Thread[] threads = new Thread[LENGTH];  final int id; WordTearing(int i) { id = i; }  public void run() { byte v = 0; for (int i = 0; i < ITERS; i++) { byte v2 = counts[id]; if (v != v2) { System.err.println('Word-Tearing found: ' + 'counts[' + id + '] = '+ v2 + ', should be ' + v);",8.05,206.01,310.8,501,90,396.1,400.8,602.11,FALSE,FALSE
693,7,BODY,"In this jocular little example: class Bottles { static void printSong(Object stuff, int n) { String plural = (n == 1) ? '' : 's'; loop: while (true) { System.out.println(n + ' bottle' + plural + ' of ' + stuff + ' on the wall,'); System.out.println(n + ' bottle' + plural + ' of ' + stuff + ';'); System.out.println('You take one down ' + 'and pass it around:'); --n; plural = (n == 1) ? '' : 's'; if (n == 0) break loop; System.out.println(n + ' bottle' + plural + ' of ' + stuff + ' on the wall!'); System.out.println(); } System.out.println('No bottles of ' + stuff + ' on the wall!'); }  public static void main(String[] args) { printSong('slime', 3); } }",8.04,276.01,291.6,659,90,197.1,381.6,473.11,FALSE,FALSE
55,2,BODY,31,8,4.6,8.25,2,318.48,71.11,326.73,75.72,FALSE,FALSE
55,4,BODY,31,8,4.6,8.25,2,198.09,161.11,206.34,165.72,FALSE,FALSE
55,5,BODY,31,8,4.6,8.25,2,295.23,193.11,303.48,197.72,FALSE,FALSE
55,6,BODY,31,8,4.6,8.25,2,304.3,282.11,312.55,286.72,FALSE,FALSE
55,7,BODY,63,8,4.6,8.25,2,377.88,479.11,386.13,483.72,FALSE,FALSE
55,8,BODY,63,8,4.6,8.25,2,338.46,569.11,346.71,573.72,FALSE,FALSE
56,3,BODY,63,8,4.6,8.25,2,382.29,84.11,390.54,88.72,FALSE,FALSE
56,5,BODY,63,8,4.6,8.25,2,391.43,186.11,399.68,190.72,FALSE,FALSE
58,6,BODY,-23127,8,4.6,40.79,6,380.91,415.11,421.69,419.72,FALSE,FALSE
58,7,BODY,-149,8,4.6,15.12,4,411.16,472.11,426.28,476.72,FALSE,FALSE
59,2,BODY,-521023,8,4.6,44.63,7,384.62,71.11,429.25,75.72,FALSE,FALSE
59,4,BODY,-1074,8,4.6,19.25,5,410,141.11,429.25,145.72,FALSE,FALSE
62,7,BODY,"package testPackage; class Test { public static void main(String[] args) { String hello = 'Hello', lo = 'lo'; System.out.println(hello == 'Hello'); System.out.println(Other.hello == hello); System.out.println(other.Other.hello == hello); System.out.println(hello == ('Hel'+'lo')); System.out.println(hello == ('Hel'+lo)); System.out.println(hello == ('Hel'+lo).intern()); } } class Other { static String hello = 'Hello'; }",8,124.22,278.4,422,108,423.89,386.4,548.11,FALSE,FALSE
63,3,BODY,true true true true false true,8,54.22,24,30,108,95.89,132,150.11,FALSE,FALSE
64,6,BODY,"String html = '<html>\n' + '    <body>\n' + '        <p>Hello, world</p>\n' + '    </body>\n' + '</html>\n'; String html = '''",8,64.22,225.6,126,108,537.89,333.6,602.11,FALSE,FALSE
65,2,BODY,"<html> <body> <p>Hello, world</p> </body> </html> ''';",8,54.22,196.8,54,108,73.89,304.8,128.11,FALSE,FALSE
65,4,BODY,"class Test { public static void main(String[] args) { // The six characters w i n t e r String season = ''' winter''';  // The seven characters w i n t e r LF String period = ''' winter ''';  // The ten characters H i , SP ' B o b ' LF String greeting = ''' Hi, 'Bob' ''';  // The eleven characters H i , LF SP ' B o b ' LF String salutation = ''' Hi, 'Bob' ''';  // The empty string (zero length) String empty = ''' ''';  // The two characters ' LF String quote = ''' ' ''';  // The two characters \ LF String backslash = ''' \\ '''; } }",8,364.22,278.4,538,108,167.89,386.4,532.11,FALSE,FALSE
66,5,BODY,"class Story1 { public static void main(String[] args) { String story = ''' 'When I use a word,' Humpty Dumpty said, in rather a scornful tone, 'it means just what I choose it to mean - neither more nor less.' 'The question is,' said Alice, 'whether you can make words mean so many different things.' 'The question is,' said Humpty Dumpty, 'which is to be master - that's all.' '''; } }",8,124.22,292.8,385,108,169.89,400.8,294.11,FALSE,FALSE
66,7,BODY,"class Story2 { public static void main(String[] args) { String story = ''' 'When I use a word,' Humpty Dumpty said, in rather a scornful tone, 'it means just what I choose it to mean - neither more nor less.' 'The question is,' said Alice, 'whether you can make words mean so many different things.' 'The question is,' said Humpty Dumpty, 'which is to be master - that's all.'''';  // error } }",8,114.22,307.2,394,108,363.89,415.2,478.11,FALSE,FALSE
66,9,BODY,"class Story3 { public static void main(String[] args) { String story = ''' 'When I use a word,' Humpty Dumpty said, in rather a scornful tone, 'it means just what I choose it to mean - neither more nor less.' 'The question is,' said Alice, 'whether you can make words mean so many different things.' 'The question is,' said Humpty Dumpty,",8,84.22,292.8,338,108,517.89,400.8,602.11,FALSE,FALSE
67,2,BODY,'which is to be master - that's all.\'''';  // OK } },8,24.22,297.6,53,108,73.89,405.6,98.11,FALSE,FALSE
67,4,BODY,class Code { public static void main(String[] args) { String text = ''' The quick brown fox jumps over the lazy dog ''';  String code = ''' String text = \''' The quick brown fox jumps over the lazy dog \'''; '''; } },8,134.22,288,217,108,147.89,396,282.11,FALSE,FALSE
68,3,BODY,"String html = ''' <html>\r <body>\r <p>Hello, world</p>\r </body>\r </html>\r ''';",8,64.22,206.4,82,108,105.89,314.4,170.11,FALSE,FALSE
68,5,BODY,"|<html>\u000D\u000A |    <body>\u000D\u000A |        <p>Hello, world</p>\u000D\u000A |    </body>\u000D\u000A |</html>\u000D\u000A",8,44.22,192,130,108,229.89,300,274.11,FALSE,FALSE
68,9,BODY,System.out.println('ab' + ''' cde '''); String cde = ''' abcde'''.substring(2); String math = ''' 1+1 equals \ ''' + String.valueOf(2); @Preconditions(''' rate > 0 && rate <= MAX_REFRESH_RATE ''') public void setRefreshRate(int rate) { ... },8,154.22,211.2,241,108,447.89,319.2,602.11,FALSE,FALSE
74,5,BODY,class Test { public static void main(String[] args) { int i = 1000000; System.out.println(i * i);,8,34.22,216,97,108,567.89,324,602.11,FALSE,FALSE
75,2,BODY,long l = i; System.out.println(l * l); System.out.println(20296 / (l - i)); } },8,44.22,216,79,108,73.89,324,118.11,FALSE,FALSE
75,4,BODY,-727379968 1000000000000,8,14.22,62.4,24,108,157.89,170.4,172.11,FALSE,FALSE
78,4,BODY,class Test { public static void main(String[] args) { // An example of overflow: double d = 1e308; System.out.print('overflow produces infinity: '); System.out.println(d + '*10==' + d*10); // An example of gradual underflow: d = 1e-305 * Math.PI; System.out.print('gradual underflow: ' + d + '\n   '); for (int i = 0; i < 4; i++) System.out.print(' ' + (d /= 100000)); System.out.println(); // An example of NaN: System.out.print('0.0/0.0 is Not-a-Number: '); d = 0.0/0.0; System.out.println(d); // An example of inexact results and rounding:,8,164.22,302.4,542,108,437.89,410.4,602.11,FALSE,FALSE
79,2,BODY,System.out.print('inexact results with float:'); for (int i = 0; i < 100; i++) { float z = 1.0f / i; if (z * i != 1.0f) System.out.print(' ' + i); } System.out.println(); // Another example of inexact results and rounding: System.out.print('inexact results with double:'); for (int i = 0; i < 100; i++) { double z = 1.0 / i; if (z * i != 1.0) System.out.print(' ' + i); } System.out.println(); // An example of cast to integer rounding: System.out.print('cast to int rounds toward 0: '); d = 12345.6; System.out.println((int)d + ' ' + (int)(-d)); } },8,204.22,288,550,108,73.89,396,278.11,FALSE,FALSE
79,4,BODY,overflow produces infinity: 1.0E308*10==Infinity gradual underflow: 3.141592653589793E-305 3.1415926535898E-310 3.141592653E-315 3.142E-320 0.0 0.0/0.0 is Not-a-Number: NaN inexact results with float: 0 41 47 55 61 82 83 94 97 inexact results with double: 0 49 98 cast to int rounds toward 0: 12345 -12345,8,64.22,268.8,305,108,317.89,376.8,382.11,FALSE,FALSE
82,5,BODY,"class Point { int x, y; Point() { System.out.println('default'); } Point(int x, int y) { this.x = x; this.y = y; }  /* A Point instance is explicitly created at class initialization time: */ static Point origin = new Point(0,0);  /* A String can be implicitly created by a + operator: */ public String toString() { return '(' + x + ',' + y + ')'; } }  class Test { public static void main(String[] args) { /* A Point is explicitly created using newInstance: */ Point p = null; try { p = (Point)Class.forName('Point').newInstance(); } catch (Exception e) { System.out.println(e); }  /* An array is implicitly created by an array initializer: */ Point[] a = { new Point(0,0), new Point(1,1) };  /* Strings are implicitly created by + operators: */ System.out.println('p: ' + p);",8,314.22,312,776,108,287.89,420,602.11,FALSE,FALSE
83,2,BODY,"System.out.println('a: { ' + a[0] + ', ' + a[1] + ' }');  /* An array is explicitly created by an array creation expression: */ String[] sa = new String[2]; sa[0] = 'he'; sa[1] = 'llo'; System.out.println(sa[0] + sa[1]); } }",8,84.22,312,224,108,73.89,420,158.11,FALSE,FALSE
83,4,BODY,"default p: (0,0) a: { (0,0), (1,1) } hello",8,34.22,91.2,42,108,197.89,199.2,232.11,FALSE,FALSE
83,7,BODY,class Value { int val; }  class Test { public static void main(String[] args) {,8,34.22,216,79,108,567.89,324,602.11,FALSE,FALSE
84,2,BODY,int i1 = 3; int i2 = i1; i2 = 4; System.out.print('i1==' + i1); System.out.println(' but i2==' + i2); Value v1 = new Value(); v1.val = 5; Value v2 = v1; v2.val = 6; System.out.print('v1.val==' + v1.val); System.out.println(' and v2.val==' + v2.val); } },8,124.22,259.2,253,108,73.89,367.2,198.11,FALSE,FALSE
84,4,BODY,i1==3 but i2==4 v1.val==6 and v2.val==6,8,14.22,110.4,39,108,237.89,218.4,252.11,FALSE,FALSE
87,4,BODY,package TypeVarMembers;  class C { public    void mCPublic()    {} protected void mCProtected() {} void mCPackage()   {} private   void mCPrivate()   {} }  interface I { void mI(); }  class CT extends C implements I { public void mI() {} }  class Test { <T extends C & I> void test(T t) { t.mI();           // OK t.mCPublic();     // OK t.mCProtected();  // OK t.mCPackage();    // OK t.mCPrivate();    // Compile-time error } },8,254.22,230.4,428,108,277.89,338.4,532.11,FALSE,FALSE
91,5,BODY,public Method getMethod(Class<?>[] parameterTypes) { ... },8,4.22,278.4,58,108,464.89,386.4,469.11,FALSE,FALSE
91,7,BODY,boolean addAll(Collection<? extends E> c),8,4.22,196.8,41,108,517.89,304.8,522.11,FALSE,FALSE
91,9,BODY,<T> boolean addAll(Collection<T> c),8,4.22,168,35,108,591.89,276,596.11,FALSE,FALSE
92,3,BODY,"Reference(T referent, ReferenceQueue<? super T> queue)",8,4.22,259.2,54,108,135.89,367.2,140.11,FALSE,FALSE
98,2,BODY,x.set('def');                 // unchecked warning } },8,24.22,283.2,54,108,73.89,391.2,98.11,FALSE,FALSE
98,4,BODY,"import java.util.ArrayList; import java.util.Collection; import java.util.Iterator;  class NonGeneric { Collection<Number> myNumbers() { return null; } }  abstract class RawMembers<T> extends NonGeneric implements Collection<String> { static Collection<NonGeneric> cng = new ArrayList<NonGeneric>();  public static void main(String[] args) { RawMembers rw = null;  Collection<Number> cn = rw.myNumbers(); // OK  Iterator<String> is   = rw.iterator(); // Unchecked warning  Collection<NonGeneric> cnn = rw.cng; // OK, static member } }",8,254.22,292.8,534,108,146.89,400.8,401.11,FALSE,FALSE
98,6,BODY,Iterator<String> iterator(),8,4.22,129.6,27,108,440.89,237.6,445.11,FALSE,FALSE
111,3,BODY,import java.util.ArrayList; import java.util.Collection; import java.util.Random;  class MiscMath<T extends Number> { int divisor; MiscMath(int divisor) { this.divisor = divisor; } float ratio(long l) { try { l /= divisor; } catch (Exception e) { if (e instanceof ArithmeticException) l = Long.MAX_VALUE; else l = 0; } return (float)l; } double gausser() { Random r = new Random(); double[] val = new double[2]; val[0] = r.nextGaussian(); val[1] = r.nextGaussian(); return (val[0] + val[1]) / 2; } Collection<Number> fromArray(Number[] na) { Collection<Number> cn = new ArrayList<Number>(); for (Number n : na) cn.add(n); return cn; } <S> void loop(S s) { this.<S>loop(s); } },8,314.22,273.6,676,108,94.89,381.6,409.11,FALSE,FALSE
117,4,BODY,"class Point { static int numPoints;   // numPoints is a class variable int x, y;               // x and y are instance variables int[] w = new int[10];  // w[0] is an array component int setX(int x) {       // x is a method parameter int oldx = this.x;  // oldx is a local variable this.x = x; return oldx; } boolean equalAtX(Object o) { if (o instanceof Point p)  // p is a pattern variable return this.x == p.x; else return false; } }",8,154.22,297.6,436,108,284.89,405.6,439.11,FALSE,FALSE
118,5,BODY,"class Point { int x, y; int useCount; Point(int x, int y) { this.x = x; this.y = y; } static final Point origin = new Point(0, 0); }",8,54.22,249.6,132,108,296.89,357.6,351.11,FALSE,FALSE
120,3,BODY,"class Point { static int npoints; int x, y; Point root; }  class Test { public static void main(String[] args) { System.out.println('npoints=' + Point.npoints); Point p = new Point(); System.out.println('p.x=' + p.x + ', p.y=' + p.y); System.out.println('p.root=' + p.root); } }",8,134.22,283.2,278,108,262.89,391.2,397.11,FALSE,FALSE
120,5,BODY,"npoints=0 p.x=0, p.y=0 p.root=null",8,24.22,57.6,34,108,436.89,165.6,461.11,FALSE,FALSE
122,5,BODY,"interface Colorable { void setColor(byte r, byte g, byte b); }  class Point { int x, y; }  class ColoredPoint extends Point implements Colorable { byte r, g, b; public void setColor(byte rv, byte gv, byte bv) { r = rv; g = gv; b = bv; } }  class Test { public static void main(String[] args) { Point p = new Point(); ColoredPoint cp = new ColoredPoint(); p = cp; Colorable c = cp; } }",8,204.22,268.8,384,108,225.89,376.8,430.11,FALSE,FALSE
127,3,BODY,"class Test { public static void main(String[] args) { // Casting conversion (5.5) of a float literal to // type int. Without the cast operator, this would // be a compile-time error, because this is a // narrowing conversion (5.1.3): int i = (int)12.5f;  // String conversion (5.4) of i's int value: System.out.println('(int)12.5f==' + i);",8,94.22,283.2,339,108,507.89,391.2,602.11,FALSE,FALSE
128,2,BODY,"// Assignment conversion (5.2) of i's value to type // float. This is a widening conversion (5.1.2): float f = i;  // String conversion of f's float value: System.out.println('after float widening: ' + f);  // Numeric promotion (5.6) of i's value to type // float. This is a binary numeric promotion. // After promotion, the operation is float*float: System.out.print(f); f = f * i;  // Two string conversions of i and f: System.out.println('*' + i + '==' + f);  // Invocation conversion (5.3) of f's value // to type double, needed because the method Math.sin // accepts only a double argument: double d = Math.sin(f);  // Two string conversions of f and d: System.out.println('Math.sin(' + f + ')==' + d); } }",8,254.22,297.6,711,108,73.89,405.6,328.11,FALSE,FALSE
128,4,BODY,(int)12.5f==12 after float widening: 12.0 12.0*12==144.0 Math.sin(144.0)==-0.49102159389846934,8,34.22,177.6,94,108,367.89,285.6,402.11,FALSE,FALSE
130,4,BODY,class Test { public static void main(String[] args) { int big = 1234567890; float approx = big; System.out.println(big - (int)approx); } },8,64.22,225.6,138,108,174.89,333.6,239.11,FALSE,FALSE
130,6,BODY,-46,8,4.22,14.4,3,108,278.89,122.4,283.11,FALSE,FALSE
132,4,BODY,class Test { public static void main(String[] args) { float fmin = Float.NEGATIVE_INFINITY; float fmax = Float.POSITIVE_INFINITY; System.out.println('long: ' + (long)fmin + '..' + (long)fmax); System.out.println('int: ' + (int)fmin + '..' + (int)fmax); System.out.println('short: ' + (short)fmin + '..' + (short)fmax); System.out.println('char: ' + (int)(char)fmin + '..' + (int)(char)fmax); System.out.println('byte: ' + (byte)fmin + '..' + (byte)fmax); } },8,154.22,268.8,458,108,126.89,376.8,281.11,FALSE,FALSE
132,6,BODY,long: -9223372036854775808..9223372036854775807 int: -2147483648..2147483647 short: 0..-1 char: 0..65535 byte: 0..-1,8,44.22,225.6,116,108,320.89,333.6,365.11,FALSE,FALSE
132,9,BODY,class Test { public static void main(String[] args) { // A narrowing of int to short loses high bits: System.out.println('(short)0x12345678==0x' + Integer.toHexString((short)0x12345678)); // An int value too big for byte changes sign and magnitude: System.out.println('(byte)255==' + (byte)255); // A float value too big to fit gives largest int value: System.out.println('(int)1e20f==' + (int)1e20f);,8,84.22,331.2,401,108,517.89,439.2,602.11,FALSE,FALSE
133,2,BODY,// A NaN converted to int yields zero: System.out.println('(int)NaN==' + (int)Float.NaN); // A double value too large for float yields infinity: System.out.println('(float)-1e100==' + (float)-1e100); // A double value too small for float underflows to zero: System.out.println('(float)1e-50==' + (float)1e-50); } },8,74.22,316.8,314,108,73.89,424.8,148.11,FALSE,FALSE
133,4,BODY,(short)0x12345678==0x5678 (byte)255==-1 (int)1e20f==2147483647 (int)NaN==0 (float)-1e100==-Infinity (float)1e-50==0.0,8,54.22,120,117,108,187.89,228,242.11,FALSE,FALSE
143,3,BODY,k,8,4.6,4.13,1,341.53,143.11,345.65,147.72,FALSE,FALSE
143,4,BODY,kk,8,4.6,84.95,2,170.69,156.11,255.64,160.72,FALSE,FALSE
144,4,BODY,public static void reverse(List<?> list);,8,4.22,196.8,41,90,354.89,286.8,359.11,FALSE,FALSE
148,6,BODY,"class Test { public static void main(String[] args) { short s = 12;      // narrow 12 to short float f = s;       // widen short to float System.out.println('f=' + f); char c = '\u0123'; long l = c;        // widen char to long System.out.println('l=0x' + Long.toString(l,16)); f = 1.23f; double d = f;      // widen float to double System.out.println('d=' + d); } }",8,124.22,278.4,366,108,359.89,386.4,484.11,FALSE,FALSE
148,8,BODY,f=12.0 l=0x123 d=1.2300000190734863,8,24.22,96,35,108,523.89,204,548.11,FALSE,FALSE
148,10,BODY,class Test { public static void main(String[] args) {,8,14.22,216,53,108,587.89,324,602.11,FALSE,FALSE
149,2,BODY,short s = 123; char c = s;    // error: would require cast s = c;         // error: would require cast } },8,44.22,249.6,106,108,73.89,357.6,118.11,FALSE,FALSE
149,5,BODY,"class Point { int x, y; } class Point3D extends Point { int z; } interface Colorable { void setColor(int color); }  class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } }  class Test { public static void main(String[] args) { // Assignments to variables of class type: Point p = new Point(); p = new Point3D(); // OK because Point3D is a subclass of Point Point3D p3d = p; // Error: will require a cast because a Point // might not be a Point3D (even though it is, // dynamically, in this example.)  // Assignments to variables of type Object: Object o  = p;          // OK: any object to Object int[] a   = new int[3]; Object o2 = a;          // OK: an array to Object  // Assignments to variables of interface type: ColoredPoint cp = new ColoredPoint(); Colorable c = cp; // OK: ColoredPoint implements Colorable  // Assignments to variables of array type: byte[] b = new byte[4]; a = b; // Error: these are not arrays of the same primitive type Point3D[] p3da = new Point3D[3]; Point[] pa = p3da; // OK: since we can assign a Point3D to a Point p3da = pa; // Error: (cast needed) since a Point // can't be assigned to a Point3D } }",8,414.22,326.4,1204,108,178.89,434.4,593.11,FALSE,FALSE
150,3,BODY,"class Point { int x, y; } interface Colorable { void setColor(int color); } class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } }  class Test { public static void main(String[] args) { Point p = new Point(); ColoredPoint cp = new ColoredPoint(); // Okay because ColoredPoint is a subclass of Point: p = cp; // Okay because ColoredPoint implements Colorable: Colorable c = cp; // The following cause compile-time errors because // we cannot be sure they will succeed, depending on // the run-time type of p; a run-time check will be // necessary for the needed narrowing conversion and // must be indicated by including a cast: cp = p;    // p might be neither a ColoredPoint // nor a subclass of ColoredPoint c = p;     // p might not implement Colorable } }",8,244.22,292.8,829,108,115.89,400.8,360.11,FALSE,FALSE
150,5,BODY,"class Point { int x, y; } class ColoredPoint extends Point { int color; }  class Test { public static void main(String[] args) { long[] veclong = new long[100]; Object o = veclong;          // okay Long l = veclong;            // compile-time error short[] vecshort = veclong;  // compile-time error Point[] pvec = new Point[100]; ColoredPoint[] cpvec = new ColoredPoint[100]; pvec = cpvec;                // okay pvec[0] = new Point();       // okay at compile time, // but would throw an // exception at run time cpvec = pvec;                // compile-time error } }",8,174.22,297.6,569,108,405.89,405.6,580.11,FALSE,FALSE
157,3,BODY,"class Point { int x, y; } interface Colorable { void setColor(int color); } class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } } final class EndPoint extends Point {}  class Test { public static void main(String[] args) { Point p = new Point(); ColoredPoint cp = new ColoredPoint(); Colorable c; // The following may cause errors at run time because // we cannot be sure they will succeed; this possibility // is suggested by the casts: cp = (ColoredPoint)p;  // p might not reference an // object which is a ColoredPoint // or a subclass of ColoredPoint c = (Colorable)p;      // p might not be Colorable // The following are incorrect at compile time because // they can never succeed as explained in the text: Long l = (Long)p;            // compile-time error #1 EndPoint e = new EndPoint(); c = (Colorable)e;            // compile-time error #2 } }",8,264.22,312,925,108,94.89,420,359.11,FALSE,FALSE
158,3,BODY,"class Point { int x, y; Point(int x, int y) { this.x = x; this.y = y; } public String toString() { return '('+x+','+y+')'; } } interface Colorable { void setColor(int color); } class ColoredPoint extends Point implements Colorable { int color; ColoredPoint(int x, int y, int color) { super(x, y); setColor(color); } public void setColor(int color) { this.color = color; } public String toString() { return super.toString() + '@' + color; } }  class Test { public static void main(String[] args) { Point[] pa = new ColoredPoint[4]; pa[0] = new ColoredPoint(2, 2, 12); pa[1] = new ColoredPoint(4, 5, 24); ColoredPoint[] cpa = (ColoredPoint[])pa; System.out.print('cpa: {'); for (int i = 0; i < cpa.length; i++) System.out.print((i == 0 ? ' ' : ', ') + cpa[i]); System.out.println(' }'); } }",8,284.22,297.6,788,108,94.89,405.6,379.11,FALSE,FALSE
158,5,BODY,"cpa: { (2,2)@12, (4,5)@24, null, null }",8,4.22,187.2,39,108,418.89,295.2,423.11,FALSE,FALSE
159,3,BODY,"class Point { int x, y; } interface Colorable { void setColor(int color); } class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } }  class Test { public static void main(String[] args) { Point[] pa = new Point[100];  // The following line will throw a ClassCastException: ColoredPoint[] cpa = (ColoredPoint[])pa; System.out.println(cpa[0]); int[] shortvec = new int[2]; Object o = shortvec;  // The following line will throw a ClassCastException: Colorable c = (Colorable)o; c.setColor(0); } }",8,214.22,302.4,562,108,94.89,410.4,309.11,FALSE,FALSE
162,5,BODY,"class Test { public static void main(String[] args) { byte  b = 2; int[] a = new int[b];  // dimension expression promotion char  c = '\u0001'; a[c] = 1;              // index expression promotion a[0] = -c;             // unary - promotion System.out.println('a: ' + a[0] + ',' + a[1]); b = -1; int i = ~b;            // bitwise complement promotion System.out.println('~0x' + Integer.toHexString(b) + '==0x' + Integer.toHexString(i)); i = b << 4L;           // shift promotion (left operand) System.out.println('0x' + Integer.toHexString(b) + '<<4L==0x' + Integer.toHexString(i)); } }",8,164.22,321.6,586,108,255.89,429.6,420.11,FALSE,FALSE
162,7,BODY,"a: -1,1 ~0xffffffff==0x0 0xffffffff<<4L==0xfffffff0",8,24.22,124.8,51,108,459.89,232.8,484.11,FALSE,FALSE
162,9,BODY,"class Test { public static void main(String[] args) { int i    = 0; float f  = 1.0f; double d = 2.0; // First int*float is promoted to float*float, then // float==double is promoted to double==double: if (i * f == d) System.out.println('oops');",8,84.22,288,244,108,517.89,396,602.11,FALSE,FALSE
163,2,BODY,// A char&byte is promoted to int&int: byte b = 0x1f; char c = 'G'; int control = c & b; System.out.println(Integer.toHexString(control));  // Here int:float is promoted to float:float: f = (b==0) ? i : 4.0f; System.out.println(1.0/f); } },8,104.22,278.4,239,108,73.89,386.4,178.11,FALSE,FALSE
163,4,BODY,7 0.25,8,14.22,19.2,6,108,217.89,127.2,232.11,FALSE,FALSE
170,4,BODY,com.nighthacks.scrabble.dictionary org.openjdk.compiler.source.tree net.jcip.annotations edu.cmu.cs.bovik.cheese gov.whitehouse.socks.mousefinder,8,44.22,163.2,145,108,342.89,271.2,387.11,FALSE,FALSE
171,4,BODY,com.nighthacks.scrabble org.openjdk.compiler net.jcip.annotations,8,24.22,110.4,65,108,126.89,218.4,151.11,FALSE,FALSE
171,7,BODY,ClassLoader SecurityManager Thread Dictionary BufferedInputStream,8,44.22,91.2,65,108,367.89,199.2,412.11,FALSE,FALSE
172,4,BODY,"public class HashSet<E> extends AbstractSet<E> { ... } public class HashMap<K,V> extends AbstractMap<K,V> { ... } public class ThreadLocal<T> { ... } public interface Functor<T, X extends Throwable> { T eval() throws X; }",8,54.22,278.4,221,108,188.89,386.4,243.11,FALSE,FALSE
178,7,BODY,"package points; class Point { int x, y; PointList list; Point next; }  class PointList { Point first; }",8,94.22,96,103,108,492.89,204,587.11,FALSE,FALSE
179,4,BODY,class Test1 { static int x; public static void main(String[] args) { int x = x; } },8,54.22,216,83,108,160.89,324,215.11,FALSE,FALSE
179,6,BODY,class Test2 { static int x; public static void main(String[] args) { int x = (x=2)*2; System.out.println(x); } },8,64.22,216,112,108,254.89,324,319.11,FALSE,FALSE
179,8,BODY,4,8,4.22,4.8,1,108,368.89,112.8,373.11,FALSE,FALSE
179,10,BODY,"class Test3 { public static void main(String[] args) { System.out.print('2+1='); int two = 2, three = two + 1; System.out.println(three); } }",8,64.22,216,141,108,432.89,324,497.11,FALSE,FALSE
179,12,BODY,2+1=3,8,4.22,24,5,108,536.89,132,541.11,FALSE,FALSE
186,2,BODY,if (!!(e instanceof String s)) { counter += s.length(); } else { System.out.println(e);  // s not in scope },8,44.22,216,108,90,73.89,306,118.11,FALSE,FALSE
189,4,BODY,class Test1 { public static void main(String[] args) { int i; for (int i = 0; i < 10; i++) System.out.println(i); } },8,64.22,216,117,108,140.89,324,205.11,FALSE,FALSE
189,6,BODY,class Test2 { public static void main(String[] args) { int i; class Local { { for (int i = 0; i < 10; i++) System.out.println(i); } } new Local(); } },8,114.22,216,150,108,316.89,324,431.11,FALSE,FALSE
189,8,BODY,class Test3 { public static void main(String[] args) { for (int i = 0; i < 10; i++) System.out.print(i + ' '); for (int i = 10; i > 0; i--) System.out.print(i + ' '); System.out.println(); } },8,84.22,216,192,108,480.89,324,565.11,FALSE,FALSE
190,2,BODY,0 1 2 3 4 5 6 7 8 9 10 9 8 7 6 5 4 3 2 1,8,4.22,192,40,108,73.89,300,78.11,FALSE,FALSE
190,4,BODY,"class Point { int x, y; Point(int x, int y) { this.x = x; this.y = y; } }  class Test4 { static void test(Object a, Object b, Object c) { if (a instanceof Point p) { System.out.println('a is a point ('+p.x+','+p.y+')'); } if (b instanceof Point p){ System.out.println('b is a point ('+p.x+','+p.y+')'); } else if (c instanceof Point p) { System.out.println('c is a point ('+p.x+','+p.y+')'); } }  public static void main(String[] args) { Point p = new Point(2,3); Point q = new Point(4,5); Point r = new Point(6,7); test(p, q, r); } }",8,234.22,316.8,534,108,127.89,424.8,362.11,FALSE,FALSE
190,6,BODY,"class Point { int x, y; Point(int x, int y) { this.x = x; this.y = y; } }  class Test5 { static void test(Object a, Object b, Object c) { if (a instanceof Point p) { System.out.println('a is a point ('+p.x+','+p.y+')');  if (b instanceof Point p) {  // compile-time error System.out.println('b is a point ('+p.x+','+p.y+')'); } } }  public static void main(String[] args) { Point p = new Point(2,3); Point q = new Point(4,5);",8,184.22,340.8,425,108,411.89,448.8,596.11,FALSE,FALSE
191,2,BODY,"Point r = new Point(6,7); test(p, q, r);  if (new Object() instanceof Point q)  // compile-time error System.out.println('I get your point'); } }",8,64.22,326.4,145,108,73.89,434.4,138.11,FALSE,FALSE
192,4,BODY,"class Test { static int x = 1; public static void main(String[] args) { int x = 0; System.out.print('x=' + x); System.out.println(', Test.x=' + Test.x); } }",8,74.22,240,156,108,366.89,348,441.11,FALSE,FALSE
192,6,BODY,"x=0, Test.x=1",8,4.22,62.4,13,108,480.89,170.4,485.11,FALSE,FALSE
193,3,BODY,"class Pair { Object first, second; public Pair(Object first, Object second) { this.first = first; this.second = second; } }",8,64.22,225.6,123,108,289.89,333.6,354.11,FALSE,FALSE
193,6,BODY,"import java.util.*;  class Vector { int[] val = { 1 , 2 }; }  class Test { public static void main(String[] args) { Vector v = new Vector(); System.out.println(v.val[0]); } }",8,114.22,216,174,108,444.89,324,559.11,FALSE,FALSE
194,2,BODY,1,8,4.22,4.8,1,108,73.89,112.8,78.11,FALSE,FALSE
201,5,BODY,package org.rpgpoet; import java.util.Random; public interface Music { Random[] wizards = new Random[4]; },8,24.22,288,106,108,358.89,396,383.11,FALSE,FALSE
201,7,BODY,package bazola; class Gabriel { static int n = org.rpgpoet.Music.wizards.length; },8,34.22,254.4,82,108,422.89,362.4,457.11,FALSE,FALSE
201,9,BODY,org.rpgpoet.Music.wizards org.rpgpoet.Music org.rpgpoet org,8,34.22,120,59,108,506.89,228,541.11,FALSE,FALSE
204,5,BODY,class Box<T> { T val; Box(T t) { val = t; }  static Box<T> empty() {  // compile-time error return new Box<>(null); }  static <U> Box<U> make(U val) { interface Checker { void check(U val);  // compile-time error }  class NullChecker implements Checker { public void check(U val) { if (val == null) { throw new IllegalArgumentException(); } } }  new NullChecker().check(val); return new Box<U>(val); } },8,244.22,278.4,403,108,161.89,386.4,406.11,FALSE,FALSE
205,4,BODY,class Test { public static void main(String[] args) { java.util.Date date = new java.util.Date(System.currentTimeMillis()); System.out.println(date.toLocaleString()); } },8,64.22,288,170,108,155.76,396,219.98,FALSE,FALSE
205,6,BODY,Sun Jan 21 22:56:29 1996,8,4.22,115.2,24,108,259.76,223.2,263.98,FALSE,FALSE
207,4,BODY,class Test { static int v; static final int f = 3; public static void main(String[] args) { int i; i = 1; v = 2; f = 33;  // compile-time error System.out.println(i + ' ' + v + ' ' + f); } },8,104.22,244.8,190,108,136.89,352.8,241.11,FALSE,FALSE
207,6,BODY,1 2 3,8,4.22,24,5,108,320.89,132,325.11,FALSE,FALSE
207,8,BODY,"class Test { static String a; String b;  String concat1() { return a + b; }  static String concat2() { return a + b;  // compile-time error }  int index() { interface I { class Matcher { void check() { if (a == null || b == null) {  // compile-time error throw new IllegalArgumentException(); } } int match(String s, String t) { return s.indexOf(t); } }",8,244.22,297.6,353,108,357.89,405.6,602.11,FALSE,FALSE
208,2,BODY,"}  I.Matcher matcher = new I.Matcher(); matcher.check(); return matcher.match(a, b); } }",8,64.22,182.4,88,108,73.89,290.4,138.11,FALSE,FALSE
208,5,BODY,class Test { public static void main(String[] args) { String first = args[0];  class Checker { void checkWhitespace(int x) { String arg = args[x]; if (!arg.trim().equals(arg)) { throw new IllegalArgumentException(); } }  static void checkFlag(int x) { String arg = args[x];  // compile-time error if (!arg.startsWith('-')) { throw new IllegalArgumentException(); } }  static void checkFirst() { Runnable r = new Runnable() { public void run() { if (first == null) {  // compile-time error throw new IllegalArgumentException(); } } }; r.run(); } }  final Checker c = new Checker(); c.checkFirst(); for (int i = 1; i < args.length; i++) { Runnable r = () -> { c.checkWhitespace(i);  // compile-time error c.checkFlag(i);  // compile-time error };,8,374.22,331.2,744,108,218.89,439.2,593.11,FALSE,FALSE
209,2,BODY,} } },8,24.22,48,5,108,73.89,156,98.11,FALSE,FALSE
211,4,BODY,"class Point { int x, y; static int nPoints; }  class Test { public static void main(String[] args) { int i = 0; i.x++;        // compile-time error Point p = new Point(); p.nPoints();  // compile-time error } }",8,124.22,216,210,108,174.89,324,299.11,FALSE,FALSE
211,8,BODY,class Foo<T> { public static int classVar = 42; },8,24.22,172.8,49,108,415.89,280.8,440.11,FALSE,FALSE
211,10,BODY,Foo<String>.classVar = 91; // illegal,8,4.22,177.6,37,108,479.89,285.6,484.11,FALSE,FALSE
211,12,BODY,Foo.classVar = 91;,8,4.22,86.4,18,108,523.89,194.4,528.11,FALSE,FALSE
212,5,BODY,"class Super { void f2(String s)       {} void f3(String s)       {} void f3(int i1, int i2) {} }  class Test { void f1(int i) {} void f2(int i) {} void f3(int i) {}  void m() { new Super() { { f1(0);  // OK, resolves to Test.f1(int) f2(0);  // compile-time error f3(0);  // compile-time error } }; } }",8,204.22,268.8,301,108,313.89,376.8,518.11,FALSE,FALSE
215,6,BODY,package points; class PointVec { Point[] vec; },8,14.22,148.8,47,108,513.89,256.8,528.11,FALSE,FALSE
215,8,BODY,"package points; public class Point { protected int x, y; public void move(int dx, int dy) { x += dx; y += dy; }",8,34.22,283.2,111,108,567.89,391.2,602.11,FALSE,FALSE
216,2,BODY,public int getX() { return x; } public int getY() { return y; } },8,24.22,172.8,65,108,73.89,280.8,98.11,FALSE,FALSE
216,6,BODY,"package points; public class Point { int x, y; public void move(int dx, int dy) { x += dx; y += dy; moves++; } public static int moves = 0; }",8,84.22,187.2,141,108,346.89,295.2,431.11,FALSE,FALSE
216,10,BODY,"package points; public class Point { public int x, y; public void move(int dx, int dy) { x += dx; y += dy; } }",8,44.22,283.2,110,108,557.89,391.2,602.11,FALSE,FALSE
217,2,BODY,"class PointList { Point next, prev; }",8,24.22,105.6,37,108,73.89,213.6,98.11,FALSE,FALSE
217,5,BODY,package pointsUser; import points.Point; class Test2 { public static void main(String[] args) { Point p = new Point(); System.out.println(p.x + ' ' + p.y); } },8,74.22,216,159,108,281.89,324,356.11,FALSE,FALSE
218,3,BODY,"package morepoints; public class PlusPoint extends points.Point { public void move(int dx, int dy) { super.move(dx, dy);  // compile-time error moveAlso(dx, dy); } }",8,64.22,244.8,165,108,115.89,352.8,180.11,FALSE,FALSE
218,5,BODY,"import points.Point; import morepoints.PlusPoint; class Test { public static void main(String[] args) { PlusPoint pp = new PlusPoint(); pp.move(1, 1); } }",8,74.22,216,154,108,239.89,324,314.11,FALSE,FALSE
218,9,BODY,"class Point { Point() { setMasterID(); } int x, y; private int ID; private static int masterID = 0; private void setMasterID() { ID = masterID++; } }",8,64.22,249.6,149,108,430.89,357.6,495.11,FALSE,FALSE
220,5,BODY,"package points; public class Point { protected int x, y; void warp(threePoint.Point3d a) { if (a.z > 0)  // compile-time error: cannot access a.z a.delta(this); } }",8,74.22,302.4,164,108,301.89,410.4,376.11,FALSE,FALSE
220,7,BODY,package threePoint; import points.Point; public class Point3d extends Point { protected int z; public void delta(Point p) { p.x += this.x;  // compile-time error: cannot access p.x p.y += this.y;  // compile-time error: cannot access p.y } public void delta3d(Point3d q) { q.x += this.x; q.y += this.y; q.z += this.z; } },8,134.22,312,321,108,415.89,420,550.11,FALSE,FALSE
222,5,BODY,package points;,8,4.22,76.8,15,108,597.89,184.8,602.11,FALSE,FALSE
223,2,BODY,"class Point    { int x, y; } class PointVec { Point[] vec; }",8,14.22,148.8,60,108,73.89,256.8,88.11,FALSE,FALSE
223,6,BODY,package p; class O1 { class I {} } class O2 extends O1 {},8,24.22,115.2,57,108,204.89,223.2,229.11,FALSE,FALSE
227,2,BODY,package vector; public class Vector { Object[] vec; },8,14.22,177.6,53,90,73.89,267.6,88.11,FALSE,FALSE
233,5,BODY,"class FirstCall { public static void main(String[] args) { System.out.println('Mr. Watson, come here. ' + 'I want you.'); } }",8,54.22,254.4,125,108,340.89,362.4,395.11,FALSE,FALSE
236,7,BODY,import java.util.Vector; class Vector { Object[] vec; },8,14.22,144,55,108,464.89,252,479.11,FALSE,FALSE
236,9,BODY,import java.util.Vector; import myVector.Vector;,8,14.22,115.2,48,108,518.89,223.2,533.11,FALSE,FALSE
236,11,BODY,package myVector; public class Vector { Object[] vec; },8,14.22,177.6,55,108,572.89,285.6,587.11,FALSE,FALSE
237,4,BODY,import java.util; class Test { util.Random generator; } // incorrect: compile-time error,8,24.22,177.6,88,108,152.89,285.6,177.11,FALSE,FALSE
237,7,BODY,package Vector; public class Mosquito { int capacity; },8,14.22,187.2,55,108,271.89,295.2,286.11,FALSE,FALSE
237,10,BODY,class java.util.Vector class Vector.Mosquito,8,14.22,105.6,44,108,469.89,213.6,484.11,FALSE,FALSE
238,4,BODY,import java.util.*;,8,4.22,91.2,19,108,373.89,199.2,378.11,FALSE,FALSE
241,4,BODY,"package test; import java.util.Vector; class Point { int x, y; } interface Point {  // compile-time error #1 int getR(); int getTheta(); } class Vector { Point[] pts; }  // compile-time error #2",8,94.22,264,194,108,319.89,372,414.11,FALSE,FALSE
241,6,BODY,package test; import java.util.*; class Vector {}  // not a compile-time error,8,24.22,211.2,78,108,525.89,319.2,550.11,FALSE,FALSE
242,2,BODY,"package points; class Point { int x, y;           // coordinates PointColor color;   // color of this point Point next;         // next point with this color static int nPoints; } class PointColor { Point first;        // first point with this color PointColor(int color) { this.color = color; } private int color;  // color components }",8,114.22,264,337,108,94.89,372,209.11,FALSE,FALSE
242,6,BODY,"package vista; class Point { int x, y; }",8,14.22,120,40,108,353.89,228,368.11,FALSE,FALSE
246,2,BODY,uses com.example.foo.spi.Intf; provides com.example.foo.spi.Intf with com.example.foo.Impl; },8,24.22,307.2,93,90,83.89,397.2,108.11,FALSE,FALSE
247,6,BODY,module m.A { requires m.B; } module m.B { requires transitive m.C; } module m.C { requires transitive m.D; } module m.D { exports p; },8,144.22,139.2,134,108,282.89,247.2,427.11,FALSE,FALSE
247,8,BODY,package p; public class Point {},8,14.22,100.8,32,108,466.89,208.8,481.11,FALSE,FALSE
247,10,BODY,package client; import p.Point; public class Test { public static void main(String[] args) { System.out.println(new Point()); } },8,64.22,216,129,108,530.89,324,595.11,FALSE,FALSE
248,3,BODY,javac --module-source-path . -d . --module m.D javac --module-source-path . -d . --module m.C javac --module-source-path . -d . --module m.B javac --module-source-path . -d . --module m.A,8,34.22,220.8,187,108,105.89,328.8,140.11,FALSE,FALSE
248,5,BODY,java --module-path . --module m.A/client.Test,8,4.22,216,45,108,179.89,324,184.11,FALSE,FALSE
257,4,BODY,"abstract class Point { int x = 1, y = 1; void move(int dx, int dy) { x += dx; y += dy; alert(); } abstract void alert(); } abstract class ColoredPoint extends Point { int color; } class SimplePoint extends Point { void alert() { } }",8,144.22,211.2,232,108,155.89,319.2,300.11,FALSE,FALSE
257,6,BODY,Point p = new Point();,8,4.22,105.6,22,108,401.89,213.6,406.11,FALSE,FALSE
257,8,BODY,Point p = new SimplePoint();,8,4.22,134.4,28,108,465.89,242.4,470.11,FALSE,FALSE
257,11,BODY,interface Colorable { void setColor(int color); } abstract class Colored implements Colorable { public abstract int setColor(int color); },8,54.22,220.8,138,108,540.89,328.8,595.11,FALSE,FALSE
261,4,BODY,"interface ConvertibleTo<T> { T convert(); } class ReprChange<T extends ConvertibleTo<S>, S extends ConvertibleTo<T>> { T t; void set(S s) { t = s.convert();    } S get()       { return t.convert(); } }",8,84.22,230.4,201,108,126.89,338.4,211.11,FALSE,FALSE
261,6,BODY,"class Seq<T> { T      head; Seq<T> tail;  Seq() { this(null, null); } Seq(T head, Seq<T> tail) { this.head = head; this.tail = tail; } boolean isEmpty() { return tail == null; }  class Zipper<S> { Seq<Pair<T,S>> zip(Seq<S> that) { if (isEmpty() || that.isEmpty()) { return new Seq<Pair<T,S>>(); } else { Seq<T>.Zipper<S> tailZipper = tail.new Zipper<S>(); return new Seq<Pair<T,S>>( new Pair<T,S>(head, that.head), tailZipper.zip(that.tail)); } } } } class Pair<T, S> { T fst; S snd; Pair(T f, S s) { fst = f; snd = s; } } class Test { public static void main(String[] args) { Seq<String> strs = new Seq<String>( 'a', new Seq<String>('b', new Seq<String>()));",8,354.22,254.4,659,108,247.89,362.4,602.11,FALSE,FALSE
262,2,BODY,"Seq<Number> nums = new Seq<Number>( new Integer(1), new Seq<Number>(new Double(1.5), new Seq<Number>()));  Seq<String>.Zipper<Number> zipper = strs.new Zipper<Number>();  Seq<Pair<String,Number>> combined = zipper.zip(nums); } }",8,124.22,254.4,228,108,73.89,362.4,198.11,FALSE,FALSE
262,6,BODY,class HasStatic { static int j = 100; }  class Outer {,8,44.22,115.2,54,108,556.89,223.2,601.11,FALSE,FALSE
263,2,BODY,"class Inner extends HasStatic { static { System.out.println('Hello from Outer.Inner'); }  static       int x = 3; static final int y = 4;  static void hello() { System.out.println('Hello from Outer.Inner.hello'); }  static class VeryNestedButNotInner extends NestedButNotInner {} }  static class NestedButNotInner { int z = Inner.x; }  interface NeverInner {}  // Implicitly static, so never inner }",8,214.22,316.8,399,108,73.89,424.8,288.11,FALSE,FALSE
265,6,BODY,class Outer { int i = 100; static void classMethod() { final int l = 200; class LocalInStaticContext { int k = i;  // Compile-time error int m = l;  // OK } },8,84.22,220.8,158,108,517.89,328.8,602.11,FALSE,FALSE
266,2,BODY,void foo() { class Local {  // A local class int j = i; } } },8,54.22,192,61,108,73.89,300,128.11,FALSE,FALSE
266,4,BODY,class WithDeepNesting { boolean toBe; WithDeepNesting(boolean b) { toBe = b; }  class Nested { boolean theQuestion; class DeeplyNested { DeeplyNested(){ theQuestion = toBe || !toBe; } } } },8,124.22,216,189,108,289.89,324,414.11,FALSE,FALSE
268,4,BODY,"class Point { int x, y; } final class ColoredPoint extends Point { int color; } class Colored3DPoint extends ColoredPoint { int z; }  // error",8,24.22,297.6,142,108,126.89,405.6,151.11,FALSE,FALSE
268,7,BODY,"class Point { int x, y; } class ColoredPoint extends Point { int color; } final class Colored3dPoint extends ColoredPoint { int z; }",8,24.22,278.4,132,108,313.89,386.4,338.11,FALSE,FALSE
269,4,BODY,"class Point extends ColoredPoint { int x, y; } class ColoredPoint extends Point { int color; }",8,14.22,225.6,94,108,155.39,333.6,169.61,FALSE,FALSE
269,10,BODY,"class Redundant implements java.lang.Cloneable, Cloneable { int x; }",8,24.22,288,68,108,545.89,396,570.11,FALSE,FALSE
271,2,BODY,class PaintedPoint extends ColoredPoint implements Paintable { Finish finish; public void setFinish(Finish finish) { this.finish = finish; } public Finish getFinish() { return finish; } },8,64.22,302.4,187,108,73.89,410.4,138.11,FALSE,FALSE
271,5,BODY,interface I<T> {} class B implements I<Integer> {} class C extends B implements I<String> {},8,24.22,196.8,92,108,304.89,304.8,329.11,FALSE,FALSE
271,9,BODY,"interface Colorable { void setColor(int color); int getColor(); } class Point { int x, y; }; class ColoredPoint extends Point implements Colorable {",8,54.22,268.8,148,108,547.89,376.8,602.11,FALSE,FALSE
272,2,BODY,int color; },8,14.22,72,12,108,73.89,180,88.11,FALSE,FALSE
272,4,BODY,"interface Fish  { int getNumberOfScales(); } interface Piano { int getNumberOfScales(); } class Tuna implements Fish, Piano { // You can tune a piano, but can you tuna fish? public int getNumberOfScales() { return 91; } }",8,54.22,249.6,221,108,169.89,357.6,224.11,FALSE,FALSE
272,6,BODY,"interface Fish       { int    getNumberOfScales(); } interface StringBass { double getNumberOfScales(); } class Bass implements Fish, StringBass { // This declaration cannot be correct, // no matter what type is used. public ?? getNumberOfScales() { return 91; } }",8,64.22,254.4,264,108,305.89,362.4,370.11,FALSE,FALSE
275,6,BODY,class Point {,8,4.22,67.2,13,108,597.89,175.2,602.11,FALSE,FALSE
276,2,BODY,"int x, y; private Point() { reset(); } Point(int x, int y) { this.x = x; this.y = y; } private void reset() { this.x = 0; this.y = 0; } } class ColoredPoint extends Point { int color; void clear() { reset(); }  // error } class Test { public static void main(String[] args) { ColoredPoint c = new ColoredPoint(0, 0);  // error c.reset();  // error } }",8,144.22,283.2,351,108,73.89,391.2,218.11,FALSE,FALSE
276,4,BODY,ColoredPoint() { super(); },8,4.22,129.6,27,108,341.89,237.6,346.11,FALSE,FALSE
276,8,BODY,"package points; public class Point { int x, y; public void move(int dx, int dy) { x += dx; y += dy; } }",8,44.22,283.2,103,108,504.89,391.2,549.11,FALSE,FALSE
276,10,BODY,package points;,8,4.22,76.8,15,108,588.89,184.8,593.11,FALSE,FALSE
277,2,BODY,"public class Point3d extends Point { int z; public void move(int dx, int dy, int dz) { x += dx; y += dy; z += dz; } }",8,54.22,225.6,117,108,73.89,333.6,128.11,FALSE,FALSE
277,4,BODY,"import points.Point3d; class Point4d extends Point3d { int w; public void move(int dx, int dy, int dz, int dw) { x += dx; y += dy; z += dz; w += dw; // compile-time errors } }",8,64.22,321.6,175,108,167.89,429.6,232.11,FALSE,FALSE
277,6,BODY,"import points.Point3d; class Point4d extends Point3d { int w; public void move(int dx, int dy, int dz, int dw) { super.move(dx, dy, dz); w += dw; } }",8,64.22,259.2,149,108,323.89,367.2,388.11,FALSE,FALSE
278,3,BODY,"class Test extends points.Point { public void moveBack(int dx, int dy) { x -= dx; y -= dy; useCount++; totalUseCount++; } }",8,44.22,264,123,108,95.89,372,140.11,FALSE,FALSE
278,5,BODY,"class Point { int x, y; void move(int dx, int dy) { x += dx; y += dy; totalMoves++; } private static int totalMoves; void printMoves() { System.out.println(totalMoves); } } class Point3d extends Point { int z; void move(int dx, int dy, int dz) { super.move(dx, dy); z += dz; totalMoves++; // error } }",8,134.22,288,301,108,188.89,396,323.11,FALSE,FALSE
278,9,BODY,"package points; public class Point { public int x, y; public void move(int dx, int dy) { x += dx; y += dy; } }",8,64.22,187.2,110,108,511.89,295.2,576.11,FALSE,FALSE
279,2,BODY,"package morePoints; class Point3d extends points.Point { public int z; public void move(int dx, int dy, int dz) { super.move(dx, dy); z += dz; } public void move(int dx, int dy) { move(dx, dy, 0); } } public class OnePoint { public static points.Point getOne() { return new Point3d(); } }",8,144.22,225.6,288,108,73.89,333.6,218.11,FALSE,FALSE
279,4,BODY,"package morePoints; public class Point4d extends Point3d { public int w; public void move(int dx, int dy, int dz, int dw) { super.move(dx, dy, dz); w += dw; } }",8,64.22,264,160,108,421.89,372,486.11,FALSE,FALSE
282,5,BODY,interface Frob  { float v = 2.0f; } class SuperTest { int   v = 3; } class Test extends SuperTest implements Frob { public static void main(String[] args) { new Test().printV(); } void printV() { System.out.println(v); } },8,74.22,225.6,222,108,401.89,333.6,476.11,FALSE,FALSE
282,7,BODY,interface Frob  { float v = 2.0f; } class SuperTest { int   v = 3; },8,14.22,172.8,68,108,587.89,280.8,602.11,FALSE,FALSE
283,2,BODY,class Test extends SuperTest implements Frob { public static void main(String[] args) { new Test().printV(); } void printV() { System.out.println((super.v + Frob.v)/2); } },8,74.22,240,172,108,73.89,348,148.11,FALSE,FALSE
283,4,BODY,2.5,8,4.22,14.4,3,108,187.89,122.4,192.11,FALSE,FALSE
283,6,BODY,"interface Color        { int RED=0, GREEN=1,  BLUE=2;  } interface TrafficLight { int RED=0, YELLOW=1, GREEN=2; } class Test implements Color, TrafficLight { public static void main(String[] args) { System.out.println(GREEN);  // compile-time error System.out.println(RED);    // compile-time error } }",8,74.22,278.4,302,108,251.89,386.4,326.11,FALSE,FALSE
285,3,BODY,"class Point { int x, y, useCount; Point(int x, int y) { this.x = x; this.y = y; } static final Point origin = new Point(0, 0); } class Test { public static void main(String[] args) { Point p = new Point(1,1); Point q = new Point(2,2); p.x = 3; p.y = 3; p.useCount++; p.origin.useCount++; System.out.println('(' + q.x + ',' + q.y + ')'); System.out.println(q.useCount); System.out.println(q.origin == Point.origin); System.out.println(q.origin.useCount); } }",8,184.22,273.6,457,108,94.89,381.6,279.11,FALSE,FALSE
285,5,BODY,"(2,2) 0 true 1",8,34.22,24,14,108,318.89,132,353.11,FALSE,FALSE
285,7,BODY,q.origin==Point.origin,8,4.22,105.6,22,108,452.89,213.6,457.11,FALSE,FALSE
285,9,BODY,p.origin.useCount++;,8,4.22,96,20,108,496.89,204,501.11,FALSE,FALSE
285,12,BODY,class Point { static int x = 2; },8,24.22,105.6,33,108,571.89,213.6,596.11,FALSE,FALSE
286,2,BODY,class Test extends Point { static double x = 4.7; public static void main(String[] args) { new Test().printX(); } void printX() { System.out.println(x + ' ' + super.x); } },8,84.22,225.6,172,108,73.89,333.6,158.11,FALSE,FALSE
286,4,BODY,4.7 2,8,4.22,24,5,108,197.89,132,202.11,FALSE,FALSE
286,6,BODY,class Point { static int x = 2; } class Test extends Point { public static void main(String[] args) { new Test().printX(); } void printX() { System.out.println(x + ' ' + super.x); } },8,104.22,225.6,183,108,281.89,333.6,386.11,FALSE,FALSE
286,8,BODY,2 2,8,4.22,14.4,3,108,445.89,122.4,450.11,FALSE,FALSE
286,10,BODY,class Point { int x = 2; } class Test extends Point { double x = 4.7; void printBoth() { System.out.println(x + ' ' + super.x); } public static void main(String[] args) { Test sample = new Test(); sample.printBoth(); System.out.println(sample.x + ' ' + ((Point)sample).x);,8,114.22,307.2,272,108,487.89,415.2,602.11,FALSE,FALSE
287,2,BODY,} },8,14.22,28.8,3,108,73.89,136.8,88.11,FALSE,FALSE
287,4,BODY,4.7 2 4.7 2,8,14.22,24,11,108,127.89,132,142.11,FALSE,FALSE
287,6,BODY,class Point { static int x = 2; } class Test extends Point { void printBoth() { System.out.println(x + ' ' + super.x); } public static void main(String[] args) { Test sample = new Test(); sample.printBoth(); System.out.println(sample.x + ' ' + ((Point)sample).x); } },8,124.22,307.2,267,108,335.89,415.2,460.11,FALSE,FALSE
287,8,BODY,2 2 2 2,8,14.22,14.4,7,108,549.89,122.4,564.11,FALSE,FALSE
288,5,BODY,"class Point { int x, y; transient float rho, theta; }",8,34.22,148.8,53,108,326.15,256.8,360.37,FALSE,FALSE
289,4,BODY,"class Test { static int i = 0, j = 0; static void one() { i++; j++; } static void two() { System.out.println('i=' + i + ' j=' + j); } }",8,64.22,240,135,108,130.89,348,195.11,FALSE,FALSE
289,6,BODY,"class Test { static int i = 0, j = 0; static synchronized void one() { i++; j++; } static synchronized void two() { System.out.println('i=' + i + ' j=' + j); } }",8,64.22,240,161,108,286.89,348,351.11,FALSE,FALSE
289,8,BODY,"class Test { static volatile int i = 0, j = 0; static void one() { i++; j++; } static void two() { System.out.println('i=' + i + ' j=' + j); } }",8,64.22,240,144,108,442.89,348,507.11,FALSE,FALSE
291,3,BODY,"class Point { int x = 1, y = 5; } class Test { public static void main(String[] args) { Point p = new Point(); System.out.println(p.x + ', ' + p.y); } }",8,84.22,220.8,152,108,94.89,328.8,179.11,FALSE,FALSE
291,5,BODY,"1, 5",8,4.22,19.2,4,108,218.89,127.2,223.11,FALSE,FALSE
291,8,BODY,class Test { float f = j; static int j = 1; },8,34.22,105.6,45,108,283.89,213.6,318.11,FALSE,FALSE
292,5,BODY,class Test1 { int i = j;  // compile-time error: // incorrect forward reference int j = 1; },8,44.22,225.6,92,108,273.89,333.6,318.11,FALSE,FALSE
292,7,BODY,class Test2 { Test2() { k = 2; } int j = 1; int i = j; int k; },8,54.22,110.4,63,108,357.89,218.4,412.11,FALSE,FALSE
292,9,BODY,class Z { static int i = j + 2; static int j = 4; },8,34.22,129.6,51,108,493.89,237.6,528.11,FALSE,FALSE
292,11,BODY,"class Z { static { i = j + 2; } static int i, j; static { j = 4; }",8,34.22,124.8,66,108,567.89,232.8,602.11,FALSE,FALSE
293,2,BODY,},8,4.22,4.8,1,108,73.89,112.8,78.11,FALSE,FALSE
293,4,BODY,class Z { static int peek() { return j; } static int i = peek(); static int j = 1; } class Test { public static void main(String[] args) { System.out.println(Z.i); } },8,94.22,216,167,108,117.89,324,212.11,FALSE,FALSE
293,6,BODY,0,8,4.22,4.8,1,108,251.89,112.8,256.11,FALSE,FALSE
293,8,BODY,class UseBeforeDeclaration { static { x = 100; // ok - assignment int y = x + 1; // error - read before declaration int v = x = 3; // ok - x at left hand side of assignment int z = UseBeforeDeclaration.x * 2; // ok - not accessed via simple name  Object o = new Object() { void foo() { x++; } // ok - occurs in a different class { x++; } // ok - occurs in a different class }; }  { j = 200; // ok - assignment j = j + 1; // error - right hand side reads before declaration int k = j = j + 1; // error - illegal forward reference to j int n = j = 300;,8,264.22,297.6,550,108,337.89,405.6,602.11,FALSE,FALSE
294,2,BODY,// ok - j at left hand side of assignment int h = j++; // error - read before declaration int l = this.j * 3; // ok - not accessed via simple name  Object o = new Object() { void foo(){ j++; } // ok - occurs in a different class { j = j + 1; } // ok - occurs in a different class }; }  int w = x = 3; // ok - x at left hand side of assignment int p = x; // ok - instance initializers may access static fields  static int u = (new Object() { int bar() { return x; } }).bar(); // ok - occurs in a different class  static int x;  int m = j = 4; // ok - j at left hand side of assignment int o = (new Object() { int bar() { return j; } }).bar(); // ok - occurs in a different class int j; },8,314.22,292.8,686,108,73.89,400.8,388.11,FALSE,FALSE
299,2,BODY,},8,4.22,4.8,1,90,73.89,94.8,78.11,FALSE,FALSE
299,6,BODY,"class Point { int x, y; abstract void move(int dx, int dy); void move(int dx, int dy) { x += dx; y += dy; } }",8,44.22,249.6,109,108,379.89,357.6,424.11,FALSE,FALSE
300,2,BODY,List toList(Collection c) {...} },8,14.22,168,33,90,73.89,258,88.11,FALSE,FALSE
300,4,BODY,class CollectionConverter { <T> List<T> toList(Collection<T> c) {...} },8,24.22,216,71,90,137.89,306,162.11,FALSE,FALSE
301,6,BODY,"class BufferEmpty extends Exception { BufferEmpty() { super(); } BufferEmpty(String s) { super(s); } } class BufferError extends Exception { BufferError() { super(); } BufferError(String s) { super(s); } } interface Buffer { char get() throws BufferEmpty, BufferError; } abstract class InfiniteBuffer implements Buffer { public abstract char get() throws BufferError; }",8,134.22,244.8,369,108,299.89,352.8,434.11,FALSE,FALSE
301,10,BODY,"abstract class Point { int x, y; public abstract String toString(); }",8,34.22,187.2,69,108,550.89,295.2,585.11,FALSE,FALSE
302,3,BODY,class ColoredPoint extends Point { int color; public String toString() { return super.toString() + ': color ' + color;  // error } },8,54.22,307.2,132,108,115.89,415.2,170.11,FALSE,FALSE
302,5,BODY,"abstract class Point { int x, y; public abstract String toString(); protected String objString() { return super.toString(); } } class ColoredPoint extends Point { int color; public String toString() { return objString() + ': color ' + color;  // correct } }",8,104.22,297.6,257,108,239.89,405.6,344.11,FALSE,FALSE
304,4,BODY,"package java.io; public class RandomAccessFile implements DataOutput, DataInput { . . . public native void open(String name, boolean writeable) throws IOException; public native int readBytes(byte[] b, int off, int len) throws IOException; public native void writeBytes(byte[] b, int off, int len) throws IOException; public native long getFilePointer() throws IOException; public native void seek(long pos) throws IOException; public native long length() throws IOException; public native void close() throws IOException; }",8,144.22,292.8,524,90,190.02,382.8,334.24,FALSE,FALSE
304,8,BODY,class Test {,8,4.22,62.4,12,108,597.89,170.4,602.11,FALSE,FALSE
305,2,BODY,int count; synchronized void bump() { count++; } static int classCount; static synchronized void classBump() { classCount++; } },8,84.22,206.4,128,108,73.89,314.4,158.11,FALSE,FALSE
305,5,BODY,public class Box { private Object boxContents; public synchronized Object get() { Object contents = boxContents; boxContents = null; return contents; } public synchronized boolean put(Object contents) { if (boxContents != null) return false; boxContents = contents; return true; } },8,124.22,264,282,108,373.89,372,498.11,FALSE,FALSE
308,6,BODY,import java.io.FileNotFoundException;  interface PrivilegedExceptionAction<E extends Exception> { void run() throws E; } class AccessController { public static <E extends Exception> Object doPrivileged(PrivilegedExceptionAction<E> action) throws E { action.run(); return 'success'; } } class Test { public static void main(String[] args) { try { AccessController.doPrivileged( new PrivilegedExceptionAction<FileNotFoundException>() { public void run() throws FileNotFoundException { // ... delete a file ... } }); } catch (FileNotFoundException f) { /* Do something */ } } },8,234.22,345.6,574,108,336.89,453.6,571.11,FALSE,FALSE
310,6,BODY,"interface I1 { int foo(); }  interface I2 { int foo(); }  abstract class Test implements I1, I2 {}",8,84.22,192,98,108,439.89,300,524.11,FALSE,FALSE
312,8,BODY,"class Point { int x = 0, y = 0; void move(int dx, int dy) { x += dx; y += dy; } } class SlowPoint extends Point { int xLimit, yLimit; void move(int dx, int dy) { super.move(limit(dx, xLimit), limit(dy, yLimit)); } static int limit(int d, int limit) {",8,94.22,278.4,250,108,507.89,386.4,602.11,FALSE,FALSE
313,2,BODY,return d > limit ? limit : d < -limit ? -limit : d; } },8,24.22,288,55,108,73.89,396,98.11,FALSE,FALSE
313,6,BODY,"import java.io.IOException; import java.io.OutputStream;  class BufferOutput { private OutputStream o; BufferOutput(OutputStream o) { this.o = o; } protected byte[] buf = new byte[512]; protected int pos = 0; public void putchar(char c) throws IOException { if (pos == buf.length) flush(); buf[pos++] = (byte)c; } public void putstr(String s) throws IOException { for (int i = 0; i < s.length(); i++) putchar(s.charAt(i)); } public void flush() throws IOException { o.write(buf, 0, pos); pos = 0; } } class LineBufferOutput extends BufferOutput { LineBufferOutput(OutputStream o) { super(o); } public void putchar(char c) throws IOException { super.putchar(c); if (c == '\n') flush(); } } class Test { public static void main(String[] args) throws IOException { LineBufferOutput lbo = new LineBufferOutput(System.out); lbo.putstr('lbo\nlbo'); System.out.print('print\n'); lbo.putstr('\n'); } }",8,354.22,312,893,108,234.89,420,589.11,FALSE,FALSE
314,3,BODY,lbo print lbo,8,24.22,24,13,108,95.89,132,120.11,FALSE,FALSE
315,6,BODY,"class Super { static String greeting() { return 'Goodnight'; } String name() { return 'Richard'; } } class Sub extends Super { static String greeting() { return 'Hello'; } String name() { return 'Dick'; } } class Test { public static void main(String[] args) { Super s = new Sub(); System.out.println(s.greeting() + ', ' + s.name()); } }",8,134.22,288,337,108,213.89,396,348.11,FALSE,FALSE
315,8,BODY,"Goodnight, Dick",8,4.22,72,15,108,387.89,180,392.11,FALSE,FALSE
317,5,BODY,class C implements Cloneable { C copy() throws CloneNotSupportedException { return (C)clone(); } } class D extends C implements Cloneable { D copy() throws CloneNotSupportedException { return (D)clone(); } },8,94.22,235.2,207,108,294.89,343.2,389.11,FALSE,FALSE
317,9,BODY,class StringSorter { // turns a collection of strings into a sorted list List toList(Collection c) {...} },8,34.22,264,106,108,485.89,372,520.11,FALSE,FALSE
317,11,BODY,class Overrider extends StringSorter { List toList(Collection c) {...} },8,24.22,182.4,72,108,559.89,290.4,584.11,FALSE,FALSE
318,3,BODY,class StringSorter { // turns a collection of strings into a sorted list List<String> toList(Collection<String> c) {...} },8,34.22,264,122,108,95.89,372,130.11,FALSE,FALSE
318,7,BODY,"class BadPointException extends Exception { BadPointException() { super(); } BadPointException(String s) { super(s); } } class Point { int x, y; void move(int dx, int dy) { x += dx; y += dy; } } class CheckedPoint extends Point { void move(int dx, int dy) throws BadPointException { if ((x + dx) < 0 || (y + dy) < 0) throw new BadPointException(); x += dx; y += dy; } }",8,144.22,273.6,369,108,246.89,381.6,391.11,FALSE,FALSE
318,9,BODY,"class CheckedPoint extends Point { void move(int dx, int dy) { if ((x + dx) < 0 || (y + dy) < 0) throw new BadPointException(); x += dx; y += dy; } }",8,64.22,206.4,149,108,492.89,314.4,557.11,FALSE,FALSE
319,4,BODY,class C<T> { T id (T x) {...} } class D extends C<String> { Object id(Object x) {...} },8,54.22,139.2,87,108,120.89,247.2,175.11,FALSE,FALSE
319,6,BODY,class C<T> { T id(T x) {...} } interface I<T> { T id(T x); } class D extends C<String> implements I<Integer> { public String  id(String x)  {...} public Integer id(Integer x) {...} },8,94.22,235.2,182,108,326.89,343.2,421.11,FALSE,FALSE
321,4,BODY,"class Point { float x, y; void move(int dx, int dy) { x += dx; y += dy; } void move(float dx, float dy) { x += dx; y += dy; } public String toString() { return '('+x+','+y+')'; } }",8,54.22,273.6,180,108,310.89,381.6,365.11,FALSE,FALSE
321,7,BODY,"class Point { int x = 0, y = 0; void move(int dx, int dy) { x += dx; y += dy; } int color; } class RealPoint extends Point { float x = 0.0f, y = 0.0f; void move(int dx, int dy) { move((float)dx, (float)dy); } void move(float dx, float dy) { x += dx; y += dy; }",8,84.22,297.6,260,108,517.89,405.6,602.11,FALSE,FALSE
322,2,BODY,},8,4.22,4.8,1,108,73.89,112.8,78.11,FALSE,FALSE
322,4,BODY,"class Point { int x = 0, y = 0, color; void move(int dx, int dy) { x += dx; y += dy; } int getX() { return x; } int getY() { return y; } } class RealPoint extends Point { float x = 0.0f, y = 0.0f; void move(int dx, int dy) { move((float)dx, (float)dy); } void move(float dx, float dy) { x += dx; y += dy; } float getX() { return x; } float getY() { return y; } }",8,124.22,297.6,362,108,253.89,405.6,378.11,FALSE,FALSE
322,6,BODY,"class Point { int x = 0, y = 0; void move(int dx, int dy) { x += dx; y += dy; } int getX() { return x; } int getY() { return y; } int color; } class RealPoint extends Point { float x = 0.0f, y = 0.0f; void move(int dx, int dy) { move((float)dx, (float)dy); } void move(float dx, float dy) { x += dx; y += dy; } int getX() { return (int)Math.floor(x); }",8,114.22,297.6,352,108,479.89,405.6,594.11,FALSE,FALSE
323,2,BODY,int getY() { return (int)Math.floor(y); } },8,14.22,220.8,43,108,73.89,328.8,88.11,FALSE,FALSE
323,4,BODY,"class Test { public static void main(String[] args) { RealPoint rp = new RealPoint(); Point p = rp; rp.move(1.71828f, 4.14159f); p.move(1, -1); show(p.x, p.y); show(rp.x, rp.y); show(p.getX(), p.getY()); show(rp.getX(), rp.getY()); } static void show(int x, int y) { System.out.println('(' + x + ', ' + y + ')'); } static void show(float x, float y) { System.out.println('(' + x + ', ' + y + ')'); } }",8,174.22,259.2,401,108,169.89,367.2,344.11,FALSE,FALSE
323,6,BODY,"(0, 0) (2.7182798, 3.14159) (2, 3) (2, 3)",8,34.22,96,41,108,383.89,204,418.11,FALSE,FALSE
327,4,BODY,"class Point { int x, y; Point(int x, int y) { this.x = x; this.y = y; } }",8,34.22,249.6,73,108,264.89,357.6,299.11,FALSE,FALSE
330,9,BODY,"class Point { int x, y; Point(int x, int y) { this.x = x; this.y = y; } }",8,34.22,249.6,73,108,567.89,357.6,602.11,FALSE,FALSE
331,2,BODY,"class ColoredPoint extends Point { static final int WHITE = 0, BLACK = 1; int color; ColoredPoint(int x, int y) { this(x, y, WHITE); } ColoredPoint(int x, int y, int color) { super(x, y); this.color = color; } }",8,104.22,211.2,211,108,73.89,319.2,178.11,FALSE,FALSE
334,5,BODY,"class Point { int x, y; Point(int x, int y) { this.x = x; this.y = y; } } class ColoredPoint extends Point { static final int WHITE = 0, BLACK = 1; int color; ColoredPoint(int x, int y) { this(x, y, color);  // Changed to color from WHITE } ColoredPoint(int x, int y, int color) { super(x, y); this.color = color; } }",8,144.22,283.2,317,108,184.89,391.2,329.11,FALSE,FALSE
334,9,BODY,class Outer { class Inner {} } class ChildOfInner extends Outer.Inner { ChildOfInner() { (new Outer()).super(); } },8,54.22,220.8,115,108,505.89,328.8,560.11,FALSE,FALSE
335,3,BODY,class Outer { int secret = 5; class Inner { int  getSecret()      { return secret; } void setSecret(int s) { secret = s; } } } class ChildOfInner extends Outer.Inner { ChildOfInner(Outer x) { x.super(); } }  public class Test { public static void main(String[] args) { Outer x = new Outer(); ChildOfInner a = new ChildOfInner(x); ChildOfInner b = new ChildOfInner(x); System.out.println(b.getSecret()); a.setSecret(6); System.out.println(b.getSecret()); } },8,204.22,235.2,457,108,125.89,343.2,330.11,FALSE,FALSE
335,5,BODY,5 6,8,14.22,4.8,3,108,369.89,112.8,384.11,FALSE,FALSE
336,5,BODY,"public class Point { int x, y; }",8,24.22,96,32,108,362.89,204,387.11,FALSE,FALSE
336,10,BODY,package p1; public class Outer { protected class Inner {} },8,34.22,139.2,59,108,567.89,247.2,602.11,FALSE,FALSE
337,2,BODY,package p2; class SonOfOuter extends p1.Outer { void foo() { new Inner();  // compile-time access error } },8,54.22,244.8,107,108,73.89,352.8,128.11,FALSE,FALSE
337,6,BODY,class ClassOnly { private ClassOnly() { } static String just = 'only the lonely'; },8,34.22,206.4,83,108,375.89,314.4,410.11,FALSE,FALSE
337,8,BODY,"package just; public class PackageOnly { PackageOnly() { } String[] justDesserts = { 'cheesecake', 'ice cream' }; }",8,44.22,278.4,115,108,449.89,386.4,494.11,FALSE,FALSE
341,6,BODY,"enum Coin { PENNY(1), NICKEL(5), DIME(10), QUARTER(25); Coin(int value) { this.value = value; }  private final int value; public int value() { return value; } }",8,64.22,230.4,160,108,386.89,338.4,451.11,FALSE,FALSE
341,10,BODY,import java.util.HashMap; import java.util.Map;,8,24.22,124.8,47,108,577.89,232.8,602.11,FALSE,FALSE
342,2,BODY,"enum Color { RED, GREEN, BLUE; Color() { colorMap.put(toString(), this); }  static final Map<String,Color> colorMap = new HashMap<String,Color>(); }",8,64.22,230.4,148,108,73.89,338.4,138.11,FALSE,FALSE
343,4,BODY,"public class Test { enum Season { WINTER, SPRING, SUMMER, FALL }  public static void main(String[] args) { for (Season s : Season.values()) System.out.println(s); } }",8,74.22,235.2,166,108,219.89,343.2,294.11,FALSE,FALSE
343,6,BODY,WINTER SPRING SUMMER FALL,8,34.22,28.8,25,108,333.89,136.8,368.11,FALSE,FALSE
343,9,BODY,"class Test { enum CoinColor { COPPER, NICKEL, SILVER }  static CoinColor color(Coin c) { switch (c) { case PENNY: return CoinColor.COPPER; case NICKEL: return CoinColor.NICKEL; case DIME: case QUARTER: return CoinColor.SILVER; default: throw new AssertionError('Unknown coin: ' + c); } }",8,154.22,307.2,287,108,447.89,415.2,602.11,FALSE,FALSE
344,2,BODY,public static void main(String[] args) { for (Coin c : Coin.values()) System.out.println(c + '\t\t' + c.value() + '\t' + color(c)); } },8,54.22,292.8,135,108,73.89,400.8,128.11,FALSE,FALSE
344,4,BODY,PENNY           1       COPPER NICKEL          5       NICKEL DIME            10      SILVER QUARTER         25      SILVER,8,34.22,144,123,108,167.89,252,202.11,FALSE,FALSE
344,7,BODY,"enum Operation { PLUS { double eval(double x, double y) { return x + y; } }, MINUS { double eval(double x, double y) { return x - y; } }, TIMES { double eval(double x, double y) { return x * y; } }, DIVIDED_BY { double eval(double x, double y) { return x / y; } };  // Each constant supports an arithmetic operation abstract double eval(double x, double y);  public static void main(String[] args) { double x = Double.parseDouble(args[0]); double y = Double.parseDouble(args[1]); for (Operation op : Operation.values()) System.out.println(x + ' ' + op + ' ' + y + ' = ' + op.eval(x, y)); } }",8,244.22,278.4,591,108,273.89,386.4,518.11,FALSE,FALSE
345,5,BODY,"import java.util.ArrayList; import java.util.List;  class Card implements Comparable<Card>, java.io.Serializable { public enum Rank { DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN,JACK, QUEEN, KING, ACE }  public enum Suit { CLUBS, DIAMONDS, HEARTS, SPADES }  private final Rank rank; private final Suit suit; public Rank rank() { return rank; } public Suit suit() { return suit; }  private Card(Rank rank, Suit suit) { if (rank == null || suit == null) throw new NullPointerException(rank + ', ' + suit); this.rank = rank; this.suit = suit; }  public String toString() { return rank + ' of ' + suit; }  // Primary sort on suit, secondary sort on rank public int compareTo(Card c) { int suitCompare = suit.compareTo(c.suit); return (suitCompare != 0 ? suitCompare : rank.compareTo(c.rank)); }  private static final List<Card> prototypeDeck = new ArrayList<Card>(52);  static { for (Suit suit : Suit.values()) for (Rank rank : Rank.values()) prototypeDeck.add(new Card(rank, suit)); }  // Returns a new deck public static List<Card> newDeck() { return new ArrayList<Card>(prototypeDeck);",8,434.22,312,1095,108,162.89,420,597.11,FALSE,FALSE
346,2,BODY,} },8,14.22,28.8,3,108,73.89,136.8,88.11,FALSE,FALSE
346,4,BODY,"import java.util.ArrayList; import java.util.Collections; import java.util.List;  class Deal { public static void main(String[] args) { int numHands     = Integer.parseInt(args[0]); int cardsPerHand = Integer.parseInt(args[1]); List<Card> deck  = Card.newDeck(); Collections.shuffle(deck); for (int i=0; i < numHands; i++) System.out.println(dealHand(deck, cardsPerHand)); }  /** * Returns a new ArrayList consisting of the last n * elements of deck, which are removed from deck. * The returned list is sorted using the elements' * natural ordering. */ public static <E extends Comparable<E>> ArrayList<E> dealHand(List<E> deck, int n) { int          deckSize = deck.size(); List<E>      handView = deck.subList(deckSize - n, deckSize); ArrayList<E> hand = new ArrayList<E>(handView); handView.clear(); Collections.sort(hand); return hand; } }",8,294.22,336,843,108,147.89,444,442.11,FALSE,FALSE
346,6,BODY,"java Deal 4 3 [DEUCE of CLUBS, SEVEN of CLUBS, QUEEN of DIAMONDS] [NINE of HEARTS, FIVE of SPADES, ACE of SPADES] [THREE of HEARTS, SIX of HEARTS, TEN of SPADES] [TEN of CLUBS, NINE of DIAMONDS, THREE of SPADES]",8,44.22,244.8,211,108,481.89,352.8,526.11,FALSE,FALSE
354,2,BODY,"R r2 = new R(r1.c1(), r1.c2(), ..., r1.cn());",8,4.22,216,45,90,73.89,306,78.11,FALSE,FALSE
354,4,BODY,"record SmallPoint(int x, int y) { public int x() { return this.x < 100 ? this.x : 100; } public int y() { return this.y < 100 ? this.y : 100; }  public static void main(String[] args) { SmallPoint p1 = new SmallPoint(200,300); SmallPoint p2 = new SmallPoint(200,300); System.out.println(p1.equals(p2));  // prints true  SmallPoint p3 = new SmallPoint(p1.x(), p1.y()); System.out.println(p1.equals(p3));  // prints false } }",8,124.22,288,423,90,167.89,378,292.11,FALSE,FALSE
369,5,BODY,"interface BaseColors { int RED = 1, GREEN = 2, BLUE = 4; } interface RainbowColors extends BaseColors { int YELLOW = 3, ORANGE = 5, INDIGO = 6, VIOLET = 7; } interface PrintColors extends BaseColors { int YELLOW = 8, CYAN = 16, MAGENTA = 32; } interface LotsOfColors extends RainbowColors, PrintColors { int FUCHSIA = 17, VERMILION = 43, CHARTREUSE = RED+90; }",8,114.22,288,360,108,208.89,396,323.11,FALSE,FALSE
370,4,BODY,interface Test { float f = j; int   j = 1; int   k = k + 1; },8,44.22,100.8,61,108,309.89,208.8,354.11,FALSE,FALSE
373,2,BODY,"interface Top { default String name() { return 'unnamed'; } } interface Left extends Top { default String name() { return getClass().getName(); } } interface Right extends Top {} interface Bottom extends Left, Right {}",8,84.22,278.4,218,90,73.89,368.4,158.11,FALSE,FALSE
376,5,BODY,"interface PointInterface { void move(int dx, int dy); } interface RealPointInterface extends PointInterface { void move(float dx, float dy); void move(double dx, double dy); }",8,64.22,259.2,175,108,286.89,367.2,351.11,FALSE,FALSE
379,2,BODY,"@interface A2 {}  /* Illegal: an annotation interface cannot be a local interface */  class D { @interface A3 {}  /* Illegal: an annotation interface cannot be specified anywhere within the body of local class D */  class E { @interface A4 {} /* Illegal: an annotation interface cannot be specified anywhere within the body of local class D, even as a member of a class E nested in D */ } } } }",8,164.22,340.8,394,90,73.89,430.8,238.11,FALSE,FALSE
382,6,BODY,/** * An annotation with this type indicates that the * specification of the annotated API element is * preliminary and subject to change. */ @interface Preliminary {},8,54.22,249.6,167,108,286.39,357.6,340.61,FALSE,FALSE
382,9,BODY,/** * Associates a copyright notice with the annotated API element. */ @interface Copyright { String value(); },8,54.22,312,111,108,411.89,420,466.11,FALSE,FALSE
382,11,BODY,/** * Associates a list of endorsers with the annotated class. */ @interface Endorsers { String[] value(); },8,54.22,288,108,108,515.89,396,570.11,FALSE,FALSE
383,2,BODY,interface Formatter {}  // Designates a formatter to pretty-print the annotated class @interface PrettyPrinter { Class<? extends Formatter> value(); },8,54.22,297.6,150,108,73.89,405.6,128.11,FALSE,FALSE
383,4,BODY,"/** * Indicates the author of the annotated program element. */ @interface Author { Name value(); } /** * A person's name.  This annotation interface is not * designed to be used directly to annotate program elements, * but to define elements of other annotation interfaces. */ @interface Name { String first(); String last(); }",8,144.22,302.4,328,108,177.89,410.4,322.11,FALSE,FALSE
383,6,BODY,"@interface Quality { enum Level { BAD, INDIFFERENT, GOOD } Level value(); }",8,34.22,201.6,75,108,381.89,309.6,416.11,FALSE,FALSE
384,7,BODY,@interface RequestForEnhancement { int    id();       // No default - must be specified in // each annotation String synopsis(); // No default - must be specified in // each annotation String engineer()  default '[unassigned]'; String date()      default '[unimplemented]'; },8,74.22,292.8,275,108,378.89,400.8,453.11,FALSE,FALSE
386,7,BODY,import java.lang.annotation.Repeatable;  @Repeatable(FooContainer.class) @interface Foo {}  @interface FooContainer { Object[] value(); },8,54.22,216,137,108,248.89,324,303.11,FALSE,FALSE
387,6,BODY,import java.lang.annotation.ElementType; import java.lang.annotation.Repeatable; import java.lang.annotation.Target;  @Target(ElementType.TYPE) @Repeatable(FooContainer.class) @interface Foo {}  @Target(ElementType.ANNOTATION_TYPE) @interface FooContainer { Foo[] value(); },8,114.22,196.8,274,108,266.89,304.8,381.11,FALSE,FALSE
387,9,BODY,@Foo @Foo interface Intf {},8,14.22,81.6,27,108,494.89,189.6,509.11,FALSE,FALSE
388,5,BODY,import java.lang.annotation.Repeatable;  // Foo: Repeatable annotation interface @Repeatable(FooContainer.class) @interface Foo { int value(); }  // FooContainer: Containing annotation interface of Foo // Also a repeatable annotation interface itself @Repeatable(FooContainerContainer.class) @interface FooContainer { Foo[] value(); }  // FooContainerContainer: Containing annotation interface // of FooContainer @interface FooContainerContainer { FooContainer[] value(); },8,134.22,288,473,108,372.89,396,507.11,FALSE,FALSE
388,7,BODY,@FooContainer({@Foo(1)}) @FooContainer({@Foo(2)}) class Test {},8,14.22,240,63,108,556.89,348,571.11,FALSE,FALSE
392,4,BODY,public boolean equals(Foo that) { ... },8,4.22,187.2,39,90,177.02,277.2,181.24,FALSE,FALSE
393,4,BODY,class Beep { @Override protected Object clone() {..} },8,4.22,259.2,54,90,211.89,349.2,216.11,FALSE,FALSE
396,5,BODY,"public static <T> boolean addAll(Collection<? super T> c, T... elements)",8,14.22,230.4,72,90,469.02,320.4,483.24,FALSE,FALSE
400,9,BODY,"@RequestForEnhancement( id       = 2868724, synopsis = 'Provide time-travel functionality', engineer = 'Mr. Peabody', date     = '4/1/2004' ) public static void travelThroughTime(Date destination) { ... }",8,64.22,297.6,204,108,422.89,405.6,487.11,FALSE,FALSE
401,9,BODY,@Preliminary public class TimeTravel { ... },8,4.22,211.2,44,108,298.89,319.2,303.11,FALSE,FALSE
401,15,BODY,"@Copyright('2002 Yoyodyne Propulsion Systems, Inc.') public class OscillationOverthruster { ... }",8,14.22,249.6,97,108,587.89,357.6,602.11,FALSE,FALSE
402,3,BODY,"@Endorsers({'Children', 'Unscrupulous dentists'}) public class Lollipop { ... }",8,14.22,235.2,79,108,95.89,343.2,110.11,FALSE,FALSE
402,5,BODY,@Endorsers('Epicurus') public class Pleasure { ... },8,14.22,139.2,52,108,159.89,247.2,174.11,FALSE,FALSE
402,7,BODY,class GorgeousFormatter implements Formatter { ... } @PrettyPrinter(GorgeousFormatter.class) public class Petunia { ... } // Illegal; String is not a subtype of Formatter @PrettyPrinter(String.class) public class Begonia { ... },8,74.22,249.6,228,108,223.89,357.6,298.11,FALSE,FALSE
402,9,BODY,"@Author(@Name(first = 'Joe', last = 'Hacker')) public class BitTwiddle { ... }",8,14.22,220.8,78,108,337.89,328.8,352.11,FALSE,FALSE
402,11,BODY,@Quality(Quality.Level.GOOD) public class Karma { ... },8,14.22,134.4,55,108,401.89,242.4,416.11,FALSE,FALSE
403,3,BODY,@C int @A [] @B [] f;,8,4.22,100.8,21,90,167.89,190.8,172.11,FALSE,FALSE
409,6,BODY,interface Runnable { void run(); },8,24.22,96,34,108,315.89,204,340.11,FALSE,FALSE
409,8,BODY,interface NonFunc { boolean equals(Object obj); },8,24.22,148.8,49,108,389.89,256.8,414.11,FALSE,FALSE
409,10,BODY,"interface Func extends NonFunc { int compare(String o1, String o2); }",8,24.22,182.4,69,108,463.89,290.4,488.11,FALSE,FALSE
409,12,BODY,"interface Comparator<T> { boolean equals(Object obj); int compare(T o1, T o2); }",8,34.22,148.8,80,108,537.89,256.8,572.11,FALSE,FALSE
410,3,BODY,interface Foo { int m(); Object clone(); },8,34.22,91.2,42,108,115.89,199.2,150.11,FALSE,FALSE
410,6,BODY,"interface X { int m(Iterable<String> arg); } interface Y { int m(Iterable<String> arg); } interface Z extends X, Y {}",8,24.22,211.2,117,108,244.89,319.2,269.11,FALSE,FALSE
410,8,BODY,"interface X { Iterable m(Iterable<String> arg); } interface Y { Iterable<String> m(Iterable arg); } interface Z extends X, Y {}",8,24.22,235.2,127,108,318.89,343.2,343.11,FALSE,FALSE
410,10,BODY,"interface X { int m(Iterable<String> arg); } interface Y { int m(Iterable<Integer> arg); } interface Z extends X, Y {} interface X { int m(Iterable<String> arg, Class c); } interface Y { int m(Iterable arg, Class<?> c); } interface Z extends X, Y {} interface X<T> { void m(T arg); } interface Y<T> { void m(T arg); } interface Z<A, B> extends X<A>, Y<B> {}",8,104.22,254.4,357,108,422.89,362.4,527.11,FALSE,FALSE
411,2,BODY,"interface X { long m(); } interface Y { int  m(); } interface Z extends X, Y {}",8,24.22,129.6,79,108,73.89,237.6,98.11,FALSE,FALSE
411,4,BODY,"interface Foo<T, N extends Number> { void m(T arg); void m(N arg); } interface Bar extends Foo<String, Integer> {} interface Baz extends Foo<Integer, Integer> {}",8,54.22,220.8,161,108,187.89,328.8,242.11,FALSE,FALSE
411,6,BODY,"interface Exec { <T> T execute(Action<T> a); } // Functional interface X { <T> T execute(Action<T> a); } interface Y { <S> S execute(Action<S> a); } interface Exec extends X, Y {} // Functional: signatures are logically 'the same' interface X { <T>   T execute(Action<T> a); } interface Y { <S,T> S execute(Action<S> a); } interface Exec extends X, Y {} // Error: different signatures, same erasure",8,114.22,249.6,398,108,291.89,357.6,406.11,FALSE,FALSE
411,9,BODY,"interface I    { Object m(Class c); } interface J<S> { S m(Class<?> c); } interface K<T> { T m(Class<?> c); } interface Functional<S,T> extends I, J<S>, K<T> {}",8,34.22,240,160,108,510.89,348,545.11,FALSE,FALSE
414,6,BODY,interface X { void m() throws IOException; } interface Y { void m() throws EOFException; } interface Z { void m() throws ClassNotFoundException; },8,24.22,264,146,108,401.89,372,426.11,FALSE,FALSE
414,8,BODY,"interface XY extends X, Y {}",8,4.22,134.4,28,108,465.89,242.4,470.11,FALSE,FALSE
414,10,BODY,()->void throws EOFException,8,4.22,134.4,28,108,509.89,242.4,514.11,FALSE,FALSE
414,12,BODY,"interface XYZ extends X, Y, Z {}",8,4.22,153.6,32,108,553.89,261.6,558.11,FALSE,FALSE
414,14,BODY,()->void (throws nothing),8,4.22,120,25,108,597.89,228,602.11,FALSE,FALSE
415,3,BODY,"interface A { List<String> foo(List<String> arg) throws IOException, SQLTransientException; } interface B { List foo(List<String> arg) throws EOFException, SQLException, TimeoutException; } interface C { List foo(List arg) throws Exception; }",8,104.22,278.4,242,108,95.89,386.4,200.11,FALSE,FALSE
415,5,BODY,"interface D extends A, B {}",8,4.22,129.6,27,108,239.89,237.6,244.11,FALSE,FALSE
415,7,BODY,"(List<String>)->List<String> throws EOFException, SQLTransientException",8,14.22,211.2,71,108,283.89,319.2,298.11,FALSE,FALSE
415,9,BODY,"interface E extends A, B, C {}",8,4.22,144,30,108,337.89,252,342.11,FALSE,FALSE
415,11,BODY,"(List)->List throws EOFException, SQLTransientException",8,4.22,264,55,108,381.89,372,386.11,FALSE,FALSE
416,4,BODY,"interface G1 { <E extends Exception> Object m() throws E; } interface G2 { <F extends Exception> String m() throws Exception; } interface G extends G1, G2 {}",8,64.22,259.2,157,108,130.89,367.2,195.11,FALSE,FALSE
416,6,BODY,<F extends Exception> ()->String throws F,8,4.22,196.8,41,108,234.89,304.8,239.11,FALSE,FALSE
419,2,BODY,"short     s,         // scalar short aas[][];   // array of array of short Object[]  ao,        // array of Object otherAo;   // array of Object Collection<?>[] ca;  // array of Collection of unknown type",8,44.22,283.2,204,108,73.89,391.2,118.11,FALSE,FALSE
419,4,BODY,"Exception ae[]  = new Exception[3]; Object aao[][]  = new Exception[2][3]; int[] factorial = { 1, 1, 2, 6, 24, 120, 720, 5040 }; char ac[]       = { 'n', 'o', 't', ' ', 'a', ' ', 'S', 't', 'r', 'i', 'n', 'g' }; String[] aas    = { 'array', 'of', 'String', };",8,54.22,254.4,258,108,167.89,362.4,222.11,FALSE,FALSE
420,2,BODY,"byte[] rowvector, colvector, matrix[];",8,4.22,182.4,38,108,73.89,290.4,78.11,FALSE,FALSE
420,4,BODY,"byte rowvector[], colvector[], matrix[][];",8,4.22,201.6,42,108,117.89,309.6,122.11,FALSE,FALSE
420,6,BODY,"int a, b[], c[][];",8,4.22,86.4,18,108,171.89,194.4,176.11,FALSE,FALSE
420,8,BODY,int a; int[] b; int[][] c;,8,24.22,48,26,108,215.89,156,240.11,FALSE,FALSE
420,11,BODY,float[][][][] f; float[][][][][] g; float[][][] h;,8,24.22,86.4,50,108,343.89,194.4,368.11,FALSE,FALSE
420,13,BODY,void m(int @A [] @B []  x) {} void n(int @A [] @B ... y) {},8,14.22,139.2,59,108,417.89,247.2,432.11,FALSE,FALSE
420,15,BODY,int @A [] f @B []; int @B [] @A [] g;,8,14.22,86.4,37,108,471.89,194.4,486.11,FALSE,FALSE
421,6,BODY,class Gauss { public static void main(String[] args) { int[] ia = new int[101]; for (int i = 0; i < ia.length; i++) ia[i] = i; int sum = 0; for (int e : ia) sum += e; System.out.println(sum); } },8,84.22,264,195,108,431.89,372,516.11,FALSE,FALSE
421,8,BODY,5050,8,4.22,19.2,4,108,555.89,127.2,560.11,FALSE,FALSE
423,3,BODY,true java.lang.ArrayStoreException: Point,8,14.22,172.8,41,108,95.89,280.8,110.11,FALSE,FALSE
424,4,BODY,"class Test { public static void main(String[] args) { int[][] ia = { { 1, 2 }, null }; for (int[] ea : ia) { for (int e: ea) { System.out.println(e); } } } }",8,94.22,216,157,108,421.89,324,516.11,FALSE,FALSE
424,6,BODY,1 2,8,14.22,4.8,3,108,555.89,112.8,570.11,FALSE,FALSE
425,7,BODY,"class Test1 { public static void main(String[] args) { int[] ia1 = { 1, 2 }; int[] ia2 = ia1.clone(); System.out.print((ia1 == ia2) + ' '); ia1[1]++; System.out.println(ia2[1]); } }",8,84.22,220.8,181,108,484.89,328.8,569.11,FALSE,FALSE
426,2,BODY,false 2,8,4.22,33.6,7,108,73.89,141.6,78.11,FALSE,FALSE
426,6,BODY,"class Test2 { public static void main(String[] args) throws Throwable { int[][] ia = { { 1, 2 }, null }; int[][] ja = ia.clone(); System.out.print((ia == ja) + ' '); System.out.println(ia[0] == ja[0] && ia[1] == ja[1]); } }",8,74.22,297.6,223,108,184.89,405.6,259.11,FALSE,FALSE
426,8,BODY,false true,8,4.22,48,10,108,298.89,156,303.11,FALSE,FALSE
426,11,BODY,class Test1 { public static void main(String[] args) { int[] ia = new int[3]; System.out.println(ia.getClass()); System.out.println(ia.getClass().getSuperclass()); for (Class<?> c : ia.getClass().getInterfaces()) System.out.println('Superinterface: ' + c); },8,74.22,283.2,258,108,527.89,391.2,602.11,FALSE,FALSE
427,2,BODY,},8,4.22,4.8,1,108,73.89,112.8,78.11,FALSE,FALSE
427,4,BODY,class [I class java.lang.Object Superinterface: interface java.lang.Cloneable Superinterface: interface java.io.Serializable,8,34.22,220.8,124,108,117.89,328.8,152.11,FALSE,FALSE
427,7,BODY,class Test2 { public static void main(String[] args) { int[] ia = new int[3]; int[] ib = new int[6]; System.out.println(ia == ib); System.out.println(ia.getClass() == ib.getClass()); } },8,74.22,288,186,108,222.89,396,297.11,FALSE,FALSE
427,9,BODY,false true,8,14.22,24,10,108,336.89,132,351.11,FALSE,FALSE
436,7,BODY,import java.io.FileNotFoundException; import java.io.IOException;,8,14.22,182.4,65,108,587.89,290.4,602.11,FALSE,FALSE
437,2,BODY,"class StaticallyThrownExceptionsIncludeSubtypes { public static void main(String[] args) { try { throw new FileNotFoundException(); } catch (IOException ioe) { // 'catch IOException' catches IOException // and any subtype. }  try { throw new FileNotFoundException(); // Statement 'can throw' FileNotFoundException. // It is not the case that statement 'can throw' // a subtype or supertype of FileNotFoundException. } catch (FileNotFoundException fnfe) { // ... Handle exception ... } catch (IOException ioe) { // Legal, but compilers are encouraged to give // warnings as of Java SE 7, because all subtypes of // IOException that the try block 'can throw' have // already been caught by the prior catch clause. }  try { m(); // m's declaration says 'throws IOException', so // m 'can throw' IOException. It is not the case // that m 'can throw' a subtype or supertype of // IOException (e.g. Exception). } catch (FileNotFoundException fnfe) { // Legal, because the dynamic type of the exception // might be FileNotFoundException. } catch (IOException ioe) { // Legal, because the dynamic type of the exception // might be a different subtype of IOException. } catch (Throwable t) { // Can always catch Throwable. } }  static void m() throws IOException { throw new FileNotFoundException(); } }",8,444.22,316.8,1294,108,73.89,424.8,518.11,FALSE,FALSE
438,2,BODY,try { ... } catch (Foo f) { ... } catch (Bar | SubclassOfFoo e) { ... },8,24.22,177.6,71,90,73.89,267.6,98.11,FALSE,FALSE
440,2,BODY,class TestException extends Exception { TestException()         { super(); } TestException(String s) { super(s); } }  class Test { public static void main(String[] args) { for (String arg : args) { try { thrower(arg); System.out.println('Test \'' + arg + '\' didn't throw an exception'); } catch (Exception e) { System.out.println('Test \'' + arg + '\' threw a ' + e.getClass() + '\n    with message: ' + e.getMessage()); } } } static int thrower(String s) throws TestException { try { if (s.equals('divide')) { int i = 0; return i/i; } if (s.equals('null')) { s = null; return s.length(); } if (s.equals('test')) { throw new TestException('Test message'); } return 0; } finally { System.out.println('[thrower(\'' + s + '\') done]'); } } },8,384.22,326.4,739,108,73.89,434.4,458.11,FALSE,FALSE
440,4,BODY,divide null not test,8,4.22,96,20,108,497.89,204,502.11,FALSE,FALSE
441,2,BODY,[thrower('divide') done] Test 'divide' threw a class java.lang.ArithmeticException with message: / by zero [thrower('null') done] Test 'null' threw a class java.lang.NullPointerException with message: null [thrower('not') done] Test 'not' didn't throw an exception [thrower('test') done] Test 'test' threw a class TestException with message: Test message,8,104.22,273.6,354,108,73.89,381.6,178.11,FALSE,FALSE
452,4,BODY,class Super { static { System.out.print('Super '); } } class One { static { System.out.print('One '); } } class Two extends Super { static { System.out.print('Two '); } } class Test { public static void main(String[] args) { One o = null; Two t = new Two(); System.out.println((Object)o == (Object)t); } },8,154.22,249.6,305,108,184.89,357.6,339.11,FALSE,FALSE
452,6,BODY,Super Two false,8,4.22,72,15,108,378.89,180,383.11,FALSE,FALSE
452,9,BODY,class Super { static int taxi = 1729; } class Sub extends Super { static { System.out.print('Sub '); } } class Test { public static void main(String[] args) { System.out.println(Sub.taxi); } },8,104.22,216,192,108,453.89,324,558.11,FALSE,FALSE
452,11,BODY,1729,8,4.22,19.2,4,108,597.89,127.2,602.11,FALSE,FALSE
453,4,BODY,"interface I { int i = 1, ii = Test.out('ii', 2); } interface J extends I { int j = Test.out('j', 3), jj = Test.out('jj', 4); } interface K extends J { int k = Test.out('k', 5); } class Test { public static void main(String[] args) { System.out.println(J.i); System.out.println(K.j); } static int out(String s, int i) { System.out.println(s + '=' + i); return i; } }",8,184.22,259.2,365,108,126.89,367.2,311.11,FALSE,FALSE
453,6,BODY,1 j=3 jj=4 3,8,34.22,19.2,12,108,350.89,127.2,385.11,FALSE,FALSE
457,9,BODY,"class Point { int x, y; Point() { x = 1; y = 1; }",8,24.22,144,49,108,577.89,252,602.11,FALSE,FALSE
458,2,BODY,} class ColoredPoint extends Point { int color = 0xFF00FF; } class Test { public static void main(String[] args) { ColoredPoint cp = new ColoredPoint(); System.out.println(cp.color); } },8,94.22,220.8,186,108,73.89,328.8,168.11,FALSE,FALSE
458,4,BODY,ColoredPoint() { super(); },8,4.22,129.6,27,108,247.89,237.6,252.11,FALSE,FALSE
458,6,BODY,Point() { super(); x = 1; y = 1; },8,4.22,163.2,34,108,321.89,271.2,326.11,FALSE,FALSE
458,8,BODY,Object() { },8,4.22,57.6,12,108,417.89,165.6,422.11,FALSE,FALSE
458,11,BODY,class Super {,8,4.22,67.2,13,108,596.89,175.2,601.11,FALSE,FALSE
459,2,BODY,"Super() { printThree(); } void printThree() { System.out.println('three'); } } class Test extends Super { int three = (int)Math.PI;  // That is, 3 void printThree() { System.out.println(three); }  public static void main(String[] args) { Test t = new Test(); t.printThree(); } }",8,114.22,264,278,108,73.89,372,188.11,FALSE,FALSE
459,4,BODY,0 3,8,14.22,4.8,3,108,227.89,112.8,242.11,FALSE,FALSE
479,8,BODY,class Hyper { char h = 'h'; } class Super extends Hyper { char s = 's'; } class Test extends Super { public static void printH(Hyper h) { System.out.println(h.h); } public static void main(String[] args) { printH(new Super()); } },8,94.22,216,230,108,419.89,324,514.11,FALSE,FALSE
479,10,BODY,h,8,4.22,4.8,1,108,553.89,112.8,558.11,FALSE,FALSE
479,12,BODY,class Super { char s = 's'; },8,4.22,139.2,29,108,597.89,247.2,602.11,FALSE,FALSE
480,3,BODY,s,8,4.22,4.8,1,108,167.89,112.8,172.11,FALSE,FALSE
480,7,BODY,try { failByThrowingAorB(); } catch (A|B e) { ... },8,44.22,120,51,108,342.89,228,387.11,FALSE,FALSE
481,5,BODY,class Hyper { void hello() { System.out.println('hello from Hyper'); } } class Super extends Hyper { void hello() { System.out.println('hello from Super'); } } class Test { public static void main(String[] args) { new Super().hello(); } },8,104.22,292.8,238,108,324.89,400.8,429.11,FALSE,FALSE
481,7,BODY,hello from Super,8,4.22,76.8,16,108,468.89,184.8,473.11,FALSE,FALSE
481,9,BODY,class Super extends Hyper {},8,4.22,134.4,28,108,512.89,242.4,517.11,FALSE,FALSE
481,11,BODY,hello from Hyper,8,4.22,76.8,16,108,566.89,184.8,571.11,FALSE,FALSE
482,4,BODY,class Hyper { void hello() { System.out.println('hello from Hyper'); } } class Super extends Hyper { } class Test extends Super { public static void main(String[] args) { new Test().hello(); } void hello() { super.hello(); } },8,114.22,292.8,226,108,194.89,400.8,309.11,FALSE,FALSE
482,6,BODY,hello from Hyper,8,4.22,76.8,16,108,348.89,184.8,353.11,FALSE,FALSE
482,8,BODY,class Super extends Hyper { void hello() { System.out.println('hello from Super'); } },8,24.22,292.8,86,108,392.89,400.8,417.11,FALSE,FALSE
482,10,BODY,hello from Super,8,4.22,76.8,16,108,466.89,184.8,471.11,FALSE,FALSE
483,5,BODY,"package points; public class Point { public int x, y; protected void print() { System.out.println('(' + x + ',' + y + ')'); } }",8,64.22,254.4,127,108,213.89,362.4,278.11,FALSE,FALSE
483,7,BODY,class Test extends points.Point { public static void main(String[] args) { Test t = new Test(); t.print(); } protected void print() { System.out.println('Test'); } },8,84.22,216,165,108,317.89,324,402.11,FALSE,FALSE
483,9,BODY,Test,8,4.22,19.2,4,108,441.89,127.2,446.11,FALSE,FALSE
484,4,BODY,class Hyper { String h = 'hyper'; } class Super extends Hyper { String s = 'super'; } class Test { public static void main(String[] args) { System.out.println(new Super().h); } },8,64.22,240,178,108,365.89,348,430.11,FALSE,FALSE
484,6,BODY,hyper,8,4.22,24,5,108,469.89,132,474.11,FALSE,FALSE
484,8,BODY,class Super extends Hyper { String s = 'super'; int h = 0; },8,34.22,134.4,60,108,513.89,242.4,548.11,FALSE,FALSE
484,10,BODY,hyper,8,4.22,24,5,108,597.89,132,602.11,FALSE,FALSE
485,3,BODY,class Hyper { String h = 'Hyper'; } class Super extends Hyper { } class Test extends Super { public static void main(String[] args) { String s = new Test().h; System.out.println(s); } },8,74.22,216,185,108,167.89,324,242.11,FALSE,FALSE
485,5,BODY,Hyper,8,4.22,24,5,108,281.89,132,286.11,FALSE,FALSE
485,8,BODY,Hyper,8,4.22,24,5,108,379.89,132,384.11,FALSE,FALSE
486,5,BODY,class Super { char s; } class Test extends Super { public static void main(String[] args) { Super x = new Super(); x.s = 'a'; System.out.println(x.s); } },8,74.22,216,154,108,272.89,324,347.11,FALSE,FALSE
486,7,BODY,a,8,4.22,4.8,1,108,386.89,112.8,391.11,FALSE,FALSE
486,9,BODY,class Super { final char s = 'b'; },8,4.22,168,35,108,430.89,276,435.11,FALSE,FALSE
490,5,BODY,class Super { void out() { System.out.println('Out'); } } class Test extends Super { public static void main(String[] args) { Test t = new Test(); System.out.println('Way '); t.out(); } },8,74.22,278.4,187,108,358.89,386.4,433.11,FALSE,FALSE
490,7,BODY,Way Out,8,14.22,14.4,7,108,472.89,122.4,487.11,FALSE,FALSE
490,9,BODY,abstract class Super { abstract void out(); },8,24.22,120,45,108,526.89,228,551.11,FALSE,FALSE
491,4,BODY,class Super { void out() { System.out.println('out'); } } class Test extends Super { public static void main(String[] args) { Test t = new Test(); t.out(); } void out() { super.out(); } },8,74.22,278.4,187,108,208.89,386.4,283.11,FALSE,FALSE
491,6,BODY,out,8,4.22,14.4,3,108,322.89,122.4,327.11,FALSE,FALSE
491,8,BODY,class Super { final void out() { System.out.println('!'); } },8,4.22,292.8,61,108,366.89,400.8,371.11,FALSE,FALSE
493,4,BODY,class Super { static void out(float f) { System.out.println('float'); } } class Test { public static void main(String[] args) { Super.out(2); } },8,94.22,216,145,108,158.89,324,253.11,FALSE,FALSE
493,6,BODY,float,8,4.22,24,5,108,292.89,132,297.11,FALSE,FALSE
493,8,BODY,class Super { static void out(float f) { System.out.println('float'); } static void out(int i)   { System.out.println('int');   } },8,34.22,297.6,131,108,336.89,405.6,371.11,FALSE,FALSE
493,10,BODY,float,8,4.22,24,5,108,420.89,132,425.11,FALSE,FALSE
493,12,BODY,int,8,4.22,14.4,3,108,464.89,122.4,469.11,FALSE,FALSE
496,5,BODY,interface I { void hello(); } class Test implements I { public static void main(String[] args) { I anI = new Test(); anI.hello(); } public void hello() { System.out.println('hello'); } },8,74.22,273.6,186,108,341.89,381.6,416.11,FALSE,FALSE
496,7,BODY,hello,8,4.22,24,5,108,455.89,132,460.11,FALSE,FALSE
496,9,BODY,interface I {},8,4.22,67.2,14,108,499.89,175.2,504.11,FALSE,FALSE
497,5,BODY,"interface Painter { default void draw() { System.out.println('Here's a picture...'); } }  interface Cowboy {}  public class CowboyArtist implements Cowboy, Painter { public static void main(String... args) { new CowboyArtist().draw(); } }",8,124.22,264,238,108,433.89,372,558.11,FALSE,FALSE
497,7,BODY,Here's a picture...,8,4.22,91.2,19,108,597.89,199.2,602.11,FALSE,FALSE
498,3,BODY,interface Cowboy { default void draw() { System.out.println('Bang!'); } },8,44.22,177.6,73,108,95.89,285.6,140.11,FALSE,FALSE
503,4,BODY,"class Global { class Cyclic {}  void foo() { new Cyclic(); // create a Global.Cyclic class Cyclic extends Cyclic {} // circular definition  { class Local {} { class Local {} // compile-time error } class Local {} // compile-time error class AnotherLocal { void bar() { class Local {} // ok } } } class Local {} // ok, not in scope of prior Local } }",8,214.22,297.6,349,108,241.89,405.6,456.11,FALSE,FALSE
505,4,BODY,"var a = 1;            // Legal var b = 2, c = 3.0;   // Illegal: multiple declarators var d[] = new int[4]; // Illegal: extra bracket pairs var e;                // Illegal: no initializer var f = { 6 };        // Illegal: array initializer var g = (g = 7);      // Illegal: self reference in initializer",8,54.22,302.4,304,108,446.89,410.4,501.11,FALSE,FALSE
506,6,BODY,"var a = 1;                // a has type 'int' var b = java.util.List.of(1, 2);  // b has type 'List<Integer>' var c = 'x'.getClass();   // c has type 'Class<? extends String>' // (see JLS 15.12.2.6) var d = new Object() {};  // d has the type of the anonymous class var e = (CharSequence & Comparable<String>) 'x'; // e has type CharSequence & Comparable<String> var f = () -> 'hello';    // Illegal: lambda not in an assignment context var g = null;             // Illegal: null type",8,84.22,350.4,484,108,443.89,458.4,528.11,FALSE,FALSE
510,5,BODY,"class Test { char[] value; int offset, count; int indexOf(TestString str, int fromIndex) { char[] v1 = value, v2 = str.value; int max = offset + (count - str.count); int start = offset + ((fromIndex < 0) ? 0 : fromIndex); i: for (int i = start; i <= max; i++) { int n = str.count, j = i, k = str.offset; while (n-- != 0) { if (v1[j++] != v2[k++]) continue i; } return i - offset; } return -1; }",8,174.22,307.2,394,108,427.89,415.2,602.11,FALSE,FALSE
511,2,BODY,},8,4.22,4.8,1,108,73.89,112.8,78.11,FALSE,FALSE
521,2,BODY,},8,4.22,4.8,1,100,73.89,104.8,78.11,FALSE,FALSE
522,4,BODY,int i = ...; switch(i) { default -> System.out.println('Some other integer'); case 42 -> // allowed System.out.println('42'); },8,64.22,235.2,127,90,293.89,325.2,358.11,FALSE,FALSE
523,2,BODY,System.out.println(i + 1);            // Error! Can be reached // without matching the // pattern `Integer i` default: },8,44.22,336,120,90,73.89,426,118.11,FALSE,FALSE
524,2,BODY,switch (obj) { case null: case R():                       // Multiple case labels System.out.println('Either null or an R'); break; default: },8,64.22,283.2,142,90,73.89,373.2,138.11,FALSE,FALSE
527,2,BODY,"sealed interface I permits A, B, C {} final class A   implements I {} final class B   implements I {} record C(int j) implements I {}  // Implicitly final record Box(I i) {} int testExhaustiveRecordPatterns(Box b) { return switch (b) {     // Exhaustive! case Box(A a) -> 0; case Box(B b) -> 1; case Box(C c) -> 2; }; }",8,124.22,249.6,319,90,73.89,339.6,198.11,FALSE,FALSE
532,2,BODY,case String s -> System.out.println('A string!'); },8,14.22,254.4,51,90,73.89,344.4,88.11,FALSE,FALSE
534,2,BODY,} public static void main(String[] args) { howMany(3); howMany(2); howMany(1); } },8,64.22,216,82,108,73.89,324,138.11,FALSE,FALSE
534,4,BODY,many too many one too many,8,24.22,57.6,26,108,187.89,165.6,212.11,FALSE,FALSE
534,6,BODY,"class TwoMany { static void howMany(int k) { switch (k) { case 1: System.out.println('one'); break;  // exit the switch case 2: System.out.println('two'); break;  // exit the switch case 3: System.out.println('many'); break;  // not needed, but good style } } static void howManyAgain(int k) { switch (k) { case 1 -> System.out.println('one'); case 2 -> System.out.println('two'); case 3 -> System.out.println('many'); } } public static void main(String[] args) { howMany(1); howMany(2); howMany(3); howManyAgain(1); howManyAgain(2); howManyAgain(3); } }",8,264.22,278.4,554,108,271.89,386.4,536.11,FALSE,FALSE
535,2,BODY,one two many one two many,8,54.22,19.2,25,108,73.89,127.2,128.11,FALSE,FALSE
538,8,BODY,"public static String toHexString(int i) { StringBuffer buf = new StringBuffer(8); do { buf.append(Character.forDigit(i & 0xF, 16)); i >>>= 4; } while (i != 0); return buf.reverse().toString(); }",8,74.22,249.6,194,108,370.89,357.6,445.11,FALSE,FALSE
545,7,BODY,int sum(int[] a) { int sum = 0; for (int i : a) sum += i; return sum; },8,44.22,139.2,71,108,548.89,247.2,593.11,FALSE,FALSE
546,4,BODY,"Map<String, Integer> histogram = ...; double total = 0; for (int i : histogram.values()) total += i; for (Map.Entry<String, Integer> e : histogram.entrySet()) System.out.println(e.getKey() + ' ' + e.getValue() / total); }",8,64.22,307.2,221,108,130.89,415.2,195.11,FALSE,FALSE
547,6,BODY,"class Graph { int[][] edges; public Graph(int[][] edges) { this.edges = edges; }  public Graph loseEdges(int i, int j) { int n = edges.length; int[][] newedges = new int[n][]; for (int k = 0; k < n; ++k) { edgelist: { int z; search: { if (k == i) { for (z = 0; z < edges[k].length; ++z) { if (edges[k][z] == j) break search; } } else if (k == j) { for (z = 0; z < edges[k].length; ++z) { if (edges[k][z] == i) break search; } }  // No edge to be deleted; share this list. newedges[k] = edges[k]; break edgelist;",8,254.22,268.8,511,108,338.89,376.8,593.11,FALSE,FALSE
548,2,BODY,"} //search  // Copy the list, omitting the edge at position z. int   m  = edges[k].length - 1; int[] ne = new int[m]; System.arraycopy(edges[k], 0, ne, 0, z); System.arraycopy(edges[k], z+1, ne, z, m-z); newedges[k] = ne; } //edgelist } return new Graph(newedges); } }",8,124.22,302.4,268,108,73.89,410.4,198.11,FALSE,FALSE
549,6,BODY,"class Graph { int[][] edges; public Graph(int[][] edges) { this.edges = edges; }  public Graph loseEdges(int i, int j) { int n = edges.length; int[][] newedges = new int[n][]; edgelists: for (int k = 0; k < n; ++k) { int z; search: { if (k == i) { for (z = 0; z < edges[k].length; ++z) { if (edges[k][z] == j) break search; } } else if (k == j) { for (z = 0; z < edges[k].length; ++z) { if (edges[k][z] == i) break search; } }",8,204.22,268.8,426,108,391.89,376.8,596.11,FALSE,FALSE
550,2,BODY,"// No edge to be deleted; share this list. newedges[k] = edges[k]; continue edgelists; } //search  // Copy the list, omitting the edge at position z. int   m  = edges[k].length - 1; int[] ne = new int[m]; System.arraycopy(edges[k], 0, ne, 0, z); System.arraycopy(edges[k], z+1, ne, z, m-z); newedges[k] = ne; } //edgelists return new Graph(newedges); } }",8,154.22,302.4,354,108,73.89,410.4,228.11,FALSE,FALSE
554,5,BODY,class Test { public static void main(String[] args) { Test t = new Test(); synchronized(t) { synchronized(t) { System.out.println('made it!'); } } } },8,94.22,230.4,150,108,332.89,338.4,427.11,FALSE,FALSE
554,7,BODY,made it!,8,4.22,38.4,8,108,466.89,146.4,471.11,FALSE,FALSE
559,2,BODY,public static void main(String[] args) { try { blowUp(); } catch (RuntimeException r) { System.out.println('Caught RuntimeException'); } catch (BlewIt b) { System.out.println('Caught BlewIt'); } } },8,104.22,283.2,198,108,73.89,391.2,178.11,FALSE,FALSE
559,4,BODY,Caught BlewIt,8,4.22,62.4,13,108,247.89,170.4,252.11,FALSE,FALSE
560,6,BODY,class BlewIt extends Exception { BlewIt() { } BlewIt(String s) { super(s); } } class Test { static void blowUp() throws BlewIt { throw new NullPointerException();,8,64.22,201.6,162,108,537.89,309.6,602.11,FALSE,FALSE
561,2,BODY,} public static void main(String[] args) { try { blowUp(); } catch (BlewIt b) { System.out.println('Caught BlewIt'); } finally { System.out.println('Uncaught Exception'); } } },8,104.22,259.2,176,108,73.89,367.2,178.11,FALSE,FALSE
561,4,BODY,Uncaught Exception Exception in thread 'main' java.lang.NullPointerException at Test.blowUp(Test.java:7) at Test.main(Test.java:11),8,34.22,273.6,131,108,217.89,381.6,252.11,FALSE,FALSE
568,8,BODY,"class Test { enum Day { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY }  public int calculate(Day d) { return switch (d) { case SATURDAY, SUNDAY -> d.ordinal(); default -> { int len = d.toString().length(); yield len*len; }",8,124.22,259.2,240,108,476.89,367.2,601.11,FALSE,FALSE
569,2,BODY,}; } },8,24.22,52.8,6,108,73.89,160.8,98.11,FALSE,FALSE
574,9,BODY,class Flags { static final boolean DEBUG = true; } class Test { public static void main(String[] args) { if (Flags.DEBUG),8,34.22,244.8,121,108,564.89,352.8,599.11,FALSE,FALSE
575,2,BODY,System.out.println('DEBUG is true'); } },8,24.22,235.2,40,108,73.89,343.2,98.11,FALSE,FALSE
575,4,BODY,DEBUG is true,8,4.22,62.4,13,108,137.89,170.4,142.11,FALSE,FALSE
575,6,BODY,class Flags { static final boolean DEBUG = false; },8,4.22,244.8,51,108,181.89,352.8,186.11,FALSE,FALSE
575,8,BODY,DEBUG is true,8,4.22,62.4,13,108,235.89,170.4,240.11,FALSE,FALSE
575,10,BODY,interface Flags { boolean DEBUG = true; } class Test { public static void main(String[] args) { if (Flags.DEBUG) System.out.println('DEBUG is true'); } },8,64.22,235.2,153,108,311.89,343.2,376.11,FALSE,FALSE
594,5,BODY,class Test1 { public static void main(String[] args) { int i = 2; int j = (i=3) * i; System.out.println(j); } },8,64.22,216,111,108,184.89,324,249.11,FALSE,FALSE
594,7,BODY,9,8,4.22,4.8,1,108,288.89,112.8,293.11,FALSE,FALSE
594,11,BODY,class Test2 { public static void main(String[] args) { int a = 9; a += (a = 3);  // first example System.out.println(a); int b = 9; b = b + (b = 3);  // second example System.out.println(b); } },8,94.22,216,194,108,399.89,324,494.11,FALSE,FALSE
594,13,BODY,12 12,8,14.22,9.6,5,108,533.89,117.6,548.11,FALSE,FALSE
595,3,BODY,class Test3 { public static void main(String[] args) { int j = 1; try { int i = forgetIt() / (j = 2); } catch (Exception e) { System.out.println(e); System.out.println('Now j = ' + j); } } static int forgetIt() throws Exception { throw new Exception('I'm outta here!'); } },8,134.22,230.4,273,108,94.89,338.4,229.11,FALSE,FALSE
595,5,BODY,java.lang.Exception: I'm outta here! Now j = 1,8,14.22,172.8,46,108,268.89,280.8,283.11,FALSE,FALSE
595,8,BODY,class Test { public static void main(String[] args) { int divisor = 0; try { int i = 1 / (divisor * loseBig()); } catch (Exception e) { System.out.println(e); } } static int loseBig() throws Exception { throw new Exception('Shuffle off to Buffalo!'); },8,114.22,268.8,252,108,487.89,376.8,602.11,FALSE,FALSE
596,2,BODY,},8,4.22,4.8,1,108,73.89,112.8,78.11,FALSE,FALSE
596,4,BODY,java.lang.Exception: Shuffle off to Buffalo!,8,4.22,211.2,44,108,117.89,319.2,122.11,FALSE,FALSE
596,6,BODY,java.lang.ArithmeticException: / by zero,8,4.22,192,40,108,161.89,300,166.11,FALSE,FALSE
597,2,BODY,System.out.println(4.0 * d * 0.5); System.out.println(2.0 * d); } },8,34.22,206.4,67,90,73.89,296.4,108.11,FALSE,FALSE
597,9,BODY,"class Test1 { public static void main(String[] args) { String s = 'going, '; print3(s, s, s = 'gone'); } static void print3(String a, String b, String c) { System.out.println(a + b + c); } }",8,84.22,264,190,108,441.89,372,526.11,FALSE,FALSE
597,11,BODY,"going, going, gone",8,4.22,86.4,18,108,565.89,194.4,570.11,FALSE,FALSE
598,3,BODY,"class Test2 { static int id; public static void main(String[] args) { try { test(id = 1, oops(), id = 3); } catch (Exception e) { System.out.println(e + ', id=' + id); } } static int test(int a, int b, int c) { return a + b + c; } static int oops() throws Exception { throw new Exception('oops'); } }",8,154.22,240,300,108,94.89,348,249.11,FALSE,FALSE
598,5,BODY,"java.lang.Exception: oops, id=1",8,4.22,148.8,31,108,288.89,256.8,293.11,FALSE,FALSE
602,4,BODY,class IntVector { int[] v; boolean equals(IntVector other) { if (this == other) return true; if (v.length != other.v.length) return false; for (int i = 0; i < v.length; i++) { if (v[i] != other.v[i]) return false; } return true; } },8,124.22,240,232,108,187.89,348,312.11,FALSE,FALSE
615,4,BODY,"class List { int value; List next; static List head = new List(0); List(int n) { value = n; next = head; head = this; } } class Test { public static void main(String[] args) { int id = 0, oldid = 0; try { for (;;) { ++id; new List(oldid = id); } } catch (Error e) { List.head = null; System.out.println(e.getClass() + ', ' + (oldid==id)); } } }",8,194.22,321.6,344,108,162.89,429.6,357.11,FALSE,FALSE
615,6,BODY,"class java.lang.OutOfMemoryError, false",8,4.22,187.2,39,108,396.89,295.2,401.11,FALSE,FALSE
620,4,BODY,"class Test1 { public static void main(String[] args) { int     i  = 4; int[][] ia = new int[i][i=3]; System.out.println( '[' + ia.length + ',' + ia[0].length + ']'); } }",8,74.22,273.6,169,108,130.89,381.6,205.11,FALSE,FALSE
620,6,BODY,"[4,3]",8,4.22,24,5,108,244.89,132,249.11,FALSE,FALSE
620,8,BODY,"class Test2 { public static void main(String[] args) { int[][] a = { { 00, 01 }, { 10, 11 } }; int i = 99; try { a[val()][i = 1]++; } catch (Exception e) { System.out.println(e + ', i=' + i); } } static int val() throws Exception { throw new Exception('unimplemented'); } }",8,134.22,230.4,273,108,330.89,338.4,465.11,FALSE,FALSE
620,10,BODY,"java.lang.Exception: unimplemented, i=99",8,4.22,192,40,108,504.89,300,509.11,FALSE,FALSE
620,14,BODY,float[][] matrix = new float[3][3];,8,4.22,168,35,108,595.89,276,600.11,FALSE,FALSE
621,3,BODY,float[][] matrix = new float[3][]; for (int d = 0; d < matrix.length; d++) matrix[d] = new float[3];,8,24.22,187.2,100,108,95.89,295.2,120.11,FALSE,FALSE
621,5,BODY,Age[][][][][] Aquarius = new Age[6][10][8][12][];,8,4.22,235.2,49,108,159.89,343.2,164.11,FALSE,FALSE
621,7,BODY,Age[][][][][] Aquarius = new Age[6][][][][]; for (int d1 = 0; d1 < Aquarius.length; d1++) { Aquarius[d1] = new Age[10][][][]; for (int d2 = 0; d2 < Aquarius[d1].length; d2++) { Aquarius[d1][d2] = new Age[8][][]; for (int d3 = 0; d3 < Aquarius[d1][d2].length; d3++) { Aquarius[d1][d2][d3] = new Age[12][]; } } },8,94.22,297.6,310,108,203.89,405.6,298.11,FALSE,FALSE
621,9,BODY,"Age[] Hair = { new Age('quartz'), new Age('topaz') }; Aquarius[1][9][6][9] = Hair;",8,14.22,254.4,82,108,387.89,362.4,402.11,FALSE,FALSE
621,11,BODY,float[][] triang = new float[100][]; for (int i = 0; i < triang.length; i++) triang[i] = new float[i+1];,8,24.22,187.2,104,108,441.89,295.2,466.11,FALSE,FALSE
622,3,BODY,"class Test3 { public static void main(String[] args) { int len = 0, oldlen = 0; Object[] a = new Object[0]; try { for (;;) { ++len; Object[] temp = new Object[oldlen = len]; temp[0] = a; a = temp; } } catch (Error e) { System.out.println(e + ', ' + (oldlen==len)); } } }",8,154.22,278.4,270,108,94.89,386.4,249.11,FALSE,FALSE
622,5,BODY,"java.lang.OutOfMemoryError, true",8,4.22,153.6,32,108,288.89,261.6,293.11,FALSE,FALSE
623,6,BODY,"class Test1 { public static void main(String[] args) { int[] a = { 11, 12, 13, 14 };",8,24.22,216,84,108,577.89,324,602.11,FALSE,FALSE
624,2,BODY,"int[] b = { 0, 1, 2, 3 }; System.out.println(a[(a=b)[3]]); } }",8,34.22,196.8,62,108,73.89,304.8,108.11,FALSE,FALSE
624,7,BODY,"class Test2 { public static void main(String[] args) { int index = 1; try { skedaddle()[index=2]++; } catch (Exception e) { System.out.println(e + ', index=' + index); } } static int[] skedaddle() throws Exception { throw new Exception('Ciao'); } }",8,124.22,268.8,248,108,248.89,376.8,373.11,FALSE,FALSE
624,9,BODY,"java.lang.Exception: Ciao, index=1",8,4.22,163.2,34,108,412.89,271.2,417.11,FALSE,FALSE
624,13,BODY,"class Test3 { public static void main(String[] args) { int index = 1; try { nada()[index=2]++; } catch (Exception e) { System.out.println(e + ', index=' + index);",8,64.22,268.8,162,108,533.89,376.8,598.11,FALSE,FALSE
625,2,BODY,} } static int[] nada() { return null; } },8,34.22,196.8,42,108,73.89,304.8,108.11,FALSE,FALSE
625,4,BODY,"java.lang.NullPointerException, index=2",8,4.22,187.2,39,108,147.89,295.2,152.11,FALSE,FALSE
625,6,BODY,class Test4 { public static void main(String[] args) { int[] a = null; try { int i = a[vamoose()]; System.out.println(i); } catch (Exception e) { System.out.println(e); } } static int vamoose() throws Exception { throw new Exception('Twenty-three skidoo!'); } },8,134.22,254.4,261,108,201.89,362.4,336.11,FALSE,FALSE
625,8,BODY,java.lang.Exception: Twenty-three skidoo!,8,4.22,196.8,41,108,375.89,304.8,380.11,FALSE,FALSE
627,5,BODY,"class S           { int x = 0; } class T extends S { int x = 1; } class Test1 { public static void main(String[] args) { T t = new T(); System.out.println('t.x=' + t.x + when('t', t)); S s = new S(); System.out.println('s.x=' + s.x + when('s', s)); s = t; System.out.println('s.x=' + s.x + when('s', s)); } static String when(String name, Object t) { return ' when ' + name + ' holds a ' + t.getClass() + ' at run time.'; } }",8,154.22,278.4,425,108,328.89,386.4,483.11,FALSE,FALSE
627,7,BODY,t.x=1 when t holds a class T at run time. s.x=0 when s holds a class S at run time. s.x=0 when s holds a class T at run time.,8,24.22,196.8,125,108,522.89,304.8,547.11,FALSE,FALSE
628,3,BODY,"class S           { int x = 0; int z() { return x; } } class T extends S { int x = 1; int z() { return x; } } class Test2 { public static void main(String[] args) { T t = new T(); System.out.println('t.z()=' + t.z() + when('t', t)); S s = new S(); System.out.println('s.z()=' + s.z() + when('s', s)); s = t; System.out.println('s.z()=' + s.z() + when('s', s)); } static String when(String name, Object t) { return ' when ' + name + ' holds a ' + t.getClass() + ' at run time.'; } }",8,154.22,292.8,481,108,125.89,400.8,280.11,FALSE,FALSE
628,5,BODY,t.z()=1 when t holds a class T at run time. s.z()=0 when s holds a class S at run time. s.z()=1 when s holds a class T at run time.,8,24.22,206.4,131,108,319.89,314.4,344.11,FALSE,FALSE
628,9,BODY,class Test3 { static String mountain = 'Chocorua'; static Test3 favorite(){ System.out.print('Mount '); return null; } public static void main(String[] args) { System.out.println(favorite().mountain); } },8,94.22,235.2,204,108,470.89,343.2,565.11,FALSE,FALSE
629,2,BODY,Mount Chocorua,8,4.22,67.2,14,108,73.89,175.2,78.11,FALSE,FALSE
630,5,BODY,interface I           { int x = 0; } class T1 implements I { int x = 1; } class T2 extends T1   { int x = 2; } class T3 extends T2 { int x = 3; void test() { System.out.println('x=\t\t'          + x); System.out.println('super.x=\t\t'    + super.x); System.out.println('((T2)this).x=\t' + ((T2)this).x); System.out.println('((T1)this).x=\t' + ((T1)this).x); System.out.println('((I)this).x=\t'  + ((I)this).x); } } class Test { public static void main(String[] args) { new T3().test(); } },8,174.22,297.6,489,108,164.89,405.6,339.11,FALSE,FALSE
630,7,BODY,x=              3 super.x=        2 ((T2)this).x=   2 ((T1)this).x=   1 ((I)this).x=    0,8,44.22,81.6,89,108,378.89,189.6,423.11,FALSE,FALSE
634,2,BODY,interface Superinterface { default void foo() { System.out.println('Hi'); } } class Subclass2 implements Superinterface { void foo() { throw new UnsupportedOperationException(); } void tweak() { Superinterface.super.foo();  // Gets the 'println' behavior } },8,104.22,321.6,258,90,73.89,411.6,178.11,FALSE,FALSE
636,4,BODY,class Doubler { static int two()      { return two(1); } private static int two(int i) { return 2*i;    } } class Test extends Doubler { static long two(long j) { return j+j; }  public static void main(String[] args) { System.out.println(two(3)); System.out.println(Doubler.two(3)); // compile-time error } },8,114.22,316.8,308,108,298.89,424.8,413.11,FALSE,FALSE
636,6,BODY,"class ColoredPoint { int x, y; byte color;",8,24.22,100.8,42,108,568.89,208.8,593.11,FALSE,FALSE
637,2,BODY,void setColor(byte color) { this.color = color; } } class Test { public static void main(String[] args) { ColoredPoint cp = new ColoredPoint(); byte color = 37; cp.setColor(color); cp.setColor(37);  // compile-time error } },8,94.22,259.2,224,108,73.89,367.2,168.11,FALSE,FALSE
637,4,BODY,void setColor(int color) { this.color = (byte)color; },8,4.22,259.2,54,108,309.89,367.2,314.11,FALSE,FALSE
637,6,BODY,"class Point { int x, y; } class ColoredPoint extends Point { int color; } class Test { static void test(ColoredPoint p, Point q) { System.out.println('(ColoredPoint, Point)'); } static void test(Point p, ColoredPoint q) { System.out.println('(Point, ColoredPoint)'); } public static void main(String[] args) { ColoredPoint cp = new ColoredPoint(); test(cp, cp);  // compile-time error } }",8,134.22,254.4,388,108,353.89,362.4,488.11,FALSE,FALSE
637,8,BODY,"static void test(ColoredPoint p, ColoredPoint q) { System.out.println('(ColoredPoint, ColoredPoint)'); }",8,24.22,264,104,108,569.89,372,594.11,FALSE,FALSE
638,4,BODY,"class Point { int x, y; } class ColoredPoint extends Point { int color; } class Test { static int test(ColoredPoint p) { return p.color; } static String test(Point p) { return 'Point'; } public static void main(String[] args) { ColoredPoint cp = new ColoredPoint(); String s = test(cp);  // compile-time error } }",8,134.22,249.6,313,108,126.89,357.6,261.11,FALSE,FALSE
638,8,BODY,"package points; public class Point { public int x, y; public Point(int x, int y) { this.x = x; this.y = y; } public String toString() { return toString(''); } public String toString(String s) { return '(' + x + ',' + y + s + ')'; } }",8,84.22,283.2,233,108,449.89,391.2,534.11,FALSE,FALSE
638,10,BODY,package points; public class ColoredPoint extends Point { public static final int,8,24.22,201.6,81,108,573.89,309.6,598.11,FALSE,FALSE
639,2,BODY,"RED = 0, GREEN = 1, BLUE = 2; public static String[] COLORS = { 'red', 'green', 'blue' };  public byte color; public ColoredPoint(int x, int y, int color) { super(x, y); this.color = (byte)color; }  /** Copy all relevant fields of the argument into this ColoredPoint object. */ public void adopt(Point p) { x = p.x; y = p.y; }  public String toString() { String s = ',' + COLORS[color]; return super.toString(s); } }",8,184.22,259.2,416,108,73.89,367.2,258.11,FALSE,FALSE
639,4,BODY,"import points.*; class Test { public static void main(String[] args) { ColoredPoint cp = new ColoredPoint(6, 6, ColoredPoint.RED); ColoredPoint cp2 = new ColoredPoint(3, 3, ColoredPoint.GREEN); cp.adopt(cp2); System.out.println('cp: ' + cp); } }",8,104.22,268.8,245,108,297.89,376.8,402.11,FALSE,FALSE
639,6,BODY,"cp: (3,3,red)",8,4.22,62.4,13,108,441.89,170.4,446.11,FALSE,FALSE
640,2,BODY,public void adopt(ColoredPoint p) { adopt((Point)p); color = p.color; },8,34.22,168,71,108,73.89,276,108.11,FALSE,FALSE
640,4,BODY,"cp: (3,3,red)",8,4.22,62.4,13,108,157.89,170.4,162.11,FALSE,FALSE
640,6,BODY,"cp: (3,3,green)",8,4.22,72,15,108,241.89,180,246.11,FALSE,FALSE
640,8,BODY,public void adopt(Point p) { if (p instanceof ColoredPoint) color = ((ColoredPoint)p).color; x = p.x; y = p.y; },8,44.22,192,112,108,315.89,300,360.11,FALSE,FALSE
655,6,BODY,class Test1 { static void mountain() { System.out.println('Monadnock'); },8,34.22,196.8,73,108,567.89,304.8,602.11,FALSE,FALSE
656,2,BODY,static Test1 favorite(){ System.out.print('Mount '); return null; } public static void main(String[] args) { favorite().mountain(); } },8,74.22,216,135,108,73.89,324,148.11,FALSE,FALSE
656,4,BODY,Mount Monadnock,8,4.22,72,15,108,187.89,180,192.11,FALSE,FALSE
656,8,BODY,class Test2 { public static void main(String[] args) { String s = 'one'; if (s.startsWith(s = 'two')) System.out.println('oops'); } },8,64.22,216,133,108,320.89,324,385.11,FALSE,FALSE
660,8,BODY,"class Point { final int EDGE = 20; int x, y; void move(int dx, int dy) {",8,34.22,153.6,72,108,560.89,261.6,595.11,FALSE,FALSE
661,2,BODY,x += dx; y += dy; if (Math.abs(x) >= EDGE || Math.abs(y) >= EDGE) clear(); } void clear() { System.out.println('\tPoint clear'); x = 0; y = 0; } } class ColoredPoint extends Point { int color; void clear() { System.out.println('\tColoredPoint clear'); super.clear(); color = 0; } },8,164.22,268.8,281,108,73.89,376.8,238.11,FALSE,FALSE
661,4,BODY,"class Test1 { public static void main(String[] args) { Point p = new Point(); System.out.println('p.move(20,20):'); p.move(20, 20);  ColoredPoint cp = new ColoredPoint(); System.out.println('cp.move(20,20):'); cp.move(20, 20);  p = new ColoredPoint(); System.out.println('p.move(20,20), p colored:'); p.move(20, 20); } }",8,144.22,273.6,320,108,349.89,381.6,494.11,FALSE,FALSE
662,2,BODY,"p.move(20,20): Point clear cp.move(20,20): ColoredPoint clear Point clear p.move(20,20), p colored: ColoredPoint clear Point clear",8,74.22,124.8,130,108,73.89,232.8,148.11,FALSE,FALSE
662,6,BODY,class T1 { String s() { return '1'; } } class T2 extends T1 { String s() { return '2'; } } class T3 extends T2 { String s() { return '3'; } void test() { System.out.println('s()=\t\t'          + s()); System.out.println('super.s()=\t'      + super.s()); System.out.println('((T2)this).s()=\t' + ((T2)this).s()); System.out.println('((T1)this).s()=\t' + ((T1)this).s()); } } class Test2 { public static void main(String[] args) { T3 t3 = new T3(); t3.test(); } },8,204.22,316.8,461,108,346.89,424.8,551.11,FALSE,FALSE
663,2,BODY,s()=            3 super.s()=      2 ((T2)this).s()= 3 ((T1)this).s()= 3,8,34.22,81.6,71,108,73.89,189.6,108.11,FALSE,FALSE
664,5,BODY,abstract class C<T> { abstract T id(T x); } class D extends C<String> { String id(String x) { return x; } },8,54.22,182.4,107,108,194.89,290.4,249.11,FALSE,FALSE
667,2,BODY,String::length             // instance method System::currentTimeMillis  // static method List<String>::size  // explicit type arguments for generic type List::size          // inferred type arguments for generic type int[]::clone T::tvarMember System.out::println 'abc'::length foo[x]::bar (test ? list.replaceAll(String::trim) : list) :: iterator super::toString,8,114.22,302.4,364,90,73.89,392.4,188.11,FALSE,FALSE
673,2,BODY,"void test() { Fun<C, Integer> f1 = C::size; // OK: reference is to instance method size() } }",8,54.22,268.8,93,90,73.89,358.8,128.11,FALSE,FALSE
678,3,BODY,k,8,4.54,3.66,1,177.36,193.21,181.02,197.75,FALSE,TRUE
678,5,BODY,k-1,8,4.54,10.54,3,92.8,219.21,103.34,223.75,FALSE,TRUE
678,6,BODY,k,8,4.54,3.66,1,428.34,219.21,432,223.75,FALSE,TRUE
689,4,BODY,class Test1 { public static void main(String[] args) { int a = 5%3;  // 2 int b = 5/3;  // 1 System.out.println('5%3 produces ' + a + ' (note that 5/3 produces ' + b + ')');  int c = 5%(-3);  // 2 int d = 5/(-3);  // -1 System.out.println('5%(-3) produces ' + c + ' (note that 5/(-3) produces ' + d + ')');  int e = (-5)%3;  // -2 int f = (-5)/3;  // -1 System.out.println('(-5)%3 produces ' + e + ' (note that (-5)/3 produces ' + f + ')');  int g = (-5)%(-3);  // -2 int h = (-5)/(-3);  // 1 System.out.println('(-5)%(-3) produces ' + g + ' (note that (-5)/(-3) produces ' + h + ')'); } },8,224.22,350.4,589,108,355.89,458.4,580.11,FALSE,FALSE
690,2,BODY,5%3 produces 2 (note that 5/3 produces 1) 5%(-3) produces 2 (note that 5/(-3) produces -1) (-5)%3 produces -2 (note that (-5)/3 produces -1) (-5)%(-3) produces -2 (note that (-5)/(-3) produces 1),8,34.22,259.2,195,108,73.89,367.2,108.11,FALSE,FALSE
690,5,BODY,class Test2 { public static void main(String[] args) { double a = 5.0%3.0;  // 2.0,8,24.22,216,82,108,577.89,324,602.11,FALSE,FALSE
691,2,BODY,System.out.println('5.0%3.0 produces ' + a);  double b = 5.0%(-3.0);  // 2.0 System.out.println('5.0%(-3.0) produces ' + b);  double c = (-5.0)%3.0;  // -2.0 System.out.println('(-5.0)%3.0 produces ' + c);  double d = (-5.0)%(-3.0);  // -2.0 System.out.println('(-5.0)%(-3.0) produces ' + d); } },8,114.22,283.2,296,108,73.89,391.2,188.11,FALSE,FALSE
692,6,BODY,'The square root of 2 is ' + Math.sqrt(2),8,4.22,196.8,41,108,350.89,304.8,355.11,FALSE,FALSE
692,8,BODY,'The square root of 2 is 1.4142135623730952',8,4.22,211.2,44,108,394.89,319.2,399.11,FALSE,FALSE
692,10,BODY,a + b + c,8,4.22,43.2,9,108,458.89,151.2,463.11,FALSE,FALSE
692,12,BODY,(a + b) + c,8,4.22,52.8,11,108,502.89,160.8,507.11,FALSE,FALSE
692,14,BODY,1 + 2 + ' fiddlers',8,4.22,91.2,19,108,546.89,199.2,551.11,FALSE,FALSE
692,16,BODY,'3 fiddlers',8,4.22,57.6,12,108,590.89,165.6,595.11,FALSE,FALSE
693,3,BODY,'fiddlers ' + 1 + 2,8,4.22,91.2,19,108,95.89,199.2,100.11,FALSE,FALSE
693,5,BODY,'fiddlers 12',8,4.22,62.4,13,108,139.89,170.4,144.11,FALSE,FALSE
694,2,BODY,"3 bottles of slime on the wall, 3 bottles of slime; You take one down and pass it around: 2 bottles of slime on the wall! 2 bottles of slime on the wall, 2 bottles of slime; You take one down and pass it around: 1 bottle of slime on the wall! 1 bottle of slime on the wall, 1 bottle of slime; You take one down and pass it around: No bottles of slime on the wall!",8,134.22,177.6,363,108,73.89,285.6,208.11,FALSE,FALSE
694,4,BODY,'You take one down and pass it around:',8,4.22,187.2,39,108,267.89,295.2,272.11,FALSE,FALSE
696,6,BODY,s,8,4.54,3.21,1,198.62,550.11,201.83,554.65,FALSE,TRUE
699,6,BODY,"class Point   { int x, y; } class Element { int atomicNumber; }",8,14.22,172.8,63,108,587.89,280.8,602.11,FALSE,FALSE
700,2,BODY,class Test { public static void main(String[] args) { Point   p = new Point(); Element e = new Element(); if (e instanceof Point) {  // compile-time error System.out.println('I get your point!'); p = (Point)e;  // compile-time error } } },8,94.22,273.6,238,108,73.89,381.6,168.11,FALSE,FALSE
700,4,BODY,"class Point extends Element { int x, y; }",8,4.22,196.8,41,108,247.89,304.8,252.11,FALSE,FALSE
700,6,BODY,import java.util.ArrayList; import java.util.List;  class Test2 { public static void main(String[] args) { List<Integer> x = new ArrayList<Integer>();  if (x instanceof ArrayList<Integer>) {  // OK System.out.println('ArrayList of Integers'); } if (x instanceof ArrayList<String>) {  // error System.out.println('ArrayList of Strings'); } if (x instanceof ArrayList<Object>) {  // error System.out.println('ArrayList of Objects'); } } },8,174.22,273.6,436,108,393.89,381.6,568.11,FALSE,FALSE
705,2,BODY,0xff00 | 0xf0f0,8,4.22,72,15,90,73.89,162,78.11,FALSE,FALSE
716,4,BODY,"Class<? super Integer> choose(boolean b, Class<Integer> c1, Class<Number> c2) { return b ? c1 : c2; }",8,44.22,235.2,101,90,201.89,325.2,246.11,FALSE,FALSE
719,7,BODY,"class ArrayReferenceThrow extends RuntimeException { } class IndexThrow          extends RuntimeException { } class RightHandSideThrow  extends RuntimeException { }  class IllustrateSimpleArrayAssignment { static Object[] objects = { new Object(), new Object() }; static Thread[] threads = { new Thread(), new Thread() };  static Object[] arrayThrow() { throw new ArrayReferenceThrow(); } static int indexThrow() { throw new IndexThrow(); } static Thread rightThrow() { throw new RightHandSideThrow(); } static String name(Object q) { String sq = q.getClass().getName(); int k = sq.lastIndexOf('.'); return (k < 0) ? sq : sq.substring(k+1); }",8,224.22,297.6,642,108,377.89,405.6,602.11,FALSE,FALSE
720,2,BODY,"static void testFour(Object[] x, int j, Object y) { String sx = x == null ? 'null' : name(x[0]) + 's'; String sy = name(y); System.out.println(); try { System.out.print(sx + '[throw]=throw => '); x[indexThrow()] = rightThrow(); System.out.println('Okay!'); } catch (Throwable e) { System.out.println(name(e)); } try { System.out.print(sx + '[throw]=' + sy + ' => '); x[indexThrow()] = y; System.out.println('Okay!'); } catch (Throwable e) { System.out.println(name(e)); } try { System.out.print(sx + '[' + j + ']=throw => '); x[j] = rightThrow(); System.out.println('Okay!'); } catch (Throwable e) { System.out.println(name(e)); } try { System.out.print(sx + '[' + j + ']=' + sy + ' => '); x[j] = y; System.out.println('Okay!'); } catch (Throwable e) { System.out.println(name(e)); } }  public static void main(String[] args) { try { System.out.print('throw[throw]=throw => '); arrayThrow()[indexThrow()] = rightThrow(); System.out.println('Okay!'); } catch (Throwable e) { System.out.println(name(e)); } try { System.out.print('throw[throw]=Thread => '); arrayThrow()[indexThrow()] = new Thread(); System.out.println('Okay!'); } catch (Throwable e) { System.out.println(name(e)); } try { System.out.print('throw[1]=throw => '); arrayThrow()[1] = rightThrow(); System.out.println('Okay!'); } catch (Throwable e) { System.out.println(name(e)); } try { System.out.print('throw[1]=Thread => '); arrayThrow()[1] = new Thread(); System.out.println('Okay!'); } catch (Throwable e) { System.out.println(name(e)); }  testFour(null, 1, new StringBuffer()); testFour(null, 9, new Thread()); testFour(objects, 1, new StringBuffer()); testFour(objects, 1, new Thread()); testFour(objects, 9, new StringBuffer());",8,524.22,312,1700,108,73.89,420,598.11,FALSE,FALSE
721,2,BODY,"testFour(objects, 9, new Thread()); testFour(threads, 1, new StringBuffer()); testFour(threads, 1, new Thread()); testFour(threads, 9, new StringBuffer()); testFour(threads, 9, new Thread()); } }",8,64.22,240,195,108,73.89,348,138.11,FALSE,FALSE
722,2,BODY,throw[throw]=throw => ArrayReferenceThrow throw[throw]=Thread => ArrayReferenceThrow throw[1]=throw => ArrayReferenceThrow throw[1]=Thread => ArrayReferenceThrow null[throw]=throw => IndexThrow null[throw]=StringBuffer => IndexThrow null[1]=throw => RightHandSideThrow null[1]=StringBuffer => NullPointerException null[throw]=throw => IndexThrow null[throw]=Thread => IndexThrow null[9]=throw => RightHandSideThrow null[9]=Thread => NullPointerException Objects[throw]=throw => IndexThrow Objects[throw]=StringBuffer => IndexThrow Objects[1]=throw => RightHandSideThrow Objects[1]=StringBuffer => Okay! Objects[throw]=throw => IndexThrow Objects[throw]=Thread => IndexThrow Objects[1]=throw => RightHandSideThrow Objects[1]=Thread => Okay! Objects[throw]=throw => IndexThrow Objects[throw]=StringBuffer => IndexThrow Objects[9]=throw => RightHandSideThrow Objects[9]=StringBuffer => ArrayIndexOutOfBoundsException Objects[throw]=throw => IndexThrow Objects[throw]=Thread => IndexThrow Objects[9]=throw => RightHandSideThrow Objects[9]=Thread => ArrayIndexOutOfBoundsException Threads[throw]=throw => IndexThrow Threads[throw]=StringBuffer => IndexThrow Threads[1]=throw => RightHandSideThrow Threads[1]=StringBuffer => ArrayStoreException Threads[throw]=throw => IndexThrow Threads[throw]=Thread => IndexThrow Threads[1]=throw => RightHandSideThrow Threads[1]=Thread => Okay! Threads[throw]=throw => IndexThrow Threads[throw]=StringBuffer => IndexThrow Threads[9]=throw => RightHandSideThrow Threads[9]=StringBuffer => ArrayIndexOutOfBoundsException Threads[throw]=throw => IndexThrow Threads[throw]=Thread => IndexThrow Threads[9]=throw => RightHandSideThrow Threads[9]=Thread => ArrayIndexOutOfBoundsException,8,534.22,273.6,1711,108,73.89,381.6,608.11,FALSE,FALSE
723,3,BODY,Threads[1]=StringBuffer => ArrayStoreException,8,4.22,220.8,46,108,95.89,328.8,100.11,FALSE,FALSE
725,5,BODY,"class ArrayReferenceThrow extends RuntimeException { } class IndexThrow          extends RuntimeException { } class RightHandSideThrow  extends RuntimeException { }  class IllustrateCompoundArrayAssignment { static String[] strings = { 'Simon', 'Garfunkel' }; static double[] doubles = { Math.E, Math.PI };  static String[] stringsThrow() { throw new ArrayReferenceThrow(); } static double[] doublesThrow() { throw new ArrayReferenceThrow(); } static int indexThrow() {",8,144.22,268.8,469,108,457.89,376.8,602.11,FALSE,FALSE
726,2,BODY,"throw new IndexThrow(); } static String stringThrow() { throw new RightHandSideThrow(); } static double doubleThrow() { throw new RightHandSideThrow(); } static String name(Object q) { String sq = q.getClass().getName(); int k = sq.lastIndexOf('.'); return (k < 0) ? sq : sq.substring(k+1); }  static void testEight(String[] x, double[] z, int j) { String sx = (x == null) ? 'null' : 'Strings'; String sz = (z == null) ? 'null' : 'doubles'; System.out.println(); try { System.out.print(sx + '[throw]+=throw => '); x[indexThrow()] += stringThrow(); System.out.println('Okay!'); } catch (Throwable e) { System.out.println(name(e)); } try { System.out.print(sz + '[throw]+=throw => '); z[indexThrow()] += doubleThrow(); System.out.println('Okay!'); } catch (Throwable e) { System.out.println(name(e)); } try { System.out.print(sx + '[throw]+=\'heh\' => '); x[indexThrow()] += 'heh'; System.out.println('Okay!'); } catch (Throwable e) { System.out.println(name(e)); } try { System.out.print(sz + '[throw]+=12345 => '); z[indexThrow()] += 12345; System.out.println('Okay!'); } catch (Throwable e) { System.out.println(name(e)); } try { System.out.print(sx + '[' + j + ']+=throw => '); x[j] += stringThrow(); System.out.println('Okay!'); } catch (Throwable e) { System.out.println(name(e)); } try { System.out.print(sz + '[' + j + ']+=throw => '); z[j] += doubleThrow(); System.out.println('Okay!'); } catch (Throwable e) { System.out.println(name(e)); } try { System.out.print(sx + '[' + j + ']+=\'heh\' => '); x[j] += 'heh'; System.out.println('Okay!'); } catch (Throwable e) { System.out.println(name(e)); }",8,524.22,302.4,1604,108,73.89,410.4,598.11,FALSE,FALSE
727,2,BODY,"try { System.out.print(sz + '[' + j + ']+=12345 => '); z[j] += 12345; System.out.println('Okay!'); } catch (Throwable e) { System.out.println(name(e)); } }  public static void main(String[] args) { try { System.out.print('throw[throw]+=throw => '); stringsThrow()[indexThrow()] += stringThrow(); System.out.println('Okay!'); } catch (Throwable e) { System.out.println(name(e)); } try { System.out.print('throw[throw]+=throw => '); doublesThrow()[indexThrow()] += doubleThrow(); System.out.println('Okay!'); } catch (Throwable e) { System.out.println(name(e)); } try { System.out.print('throw[throw]+=\'heh\' => '); stringsThrow()[indexThrow()] += 'heh'; System.out.println('Okay!'); } catch (Throwable e) { System.out.println(name(e)); } try { System.out.print('throw[throw]+=12345 => '); doublesThrow()[indexThrow()] += 12345; System.out.println('Okay!'); } catch (Throwable e) { System.out.println(name(e)); } try { System.out.print('throw[1]+=throw => '); stringsThrow()[1] += stringThrow(); System.out.println('Okay!'); } catch (Throwable e) { System.out.println(name(e)); } try { System.out.print('throw[1]+=throw => '); doublesThrow()[1] += doubleThrow(); System.out.println('Okay!'); } catch (Throwable e) { System.out.println(name(e)); } try { System.out.print('throw[1]+=\'heh\' => '); stringsThrow()[1] += 'heh'; System.out.println('Okay!'); } catch (Throwable e) { System.out.println(name(e)); } try { System.out.print('throw[1]+=12345 => '); doublesThrow()[1] += 12345; System.out.println('Okay!'); } catch (Throwable e) { System.out.println(name(e)); } testEight(null, null, 1); testEight(null, null, 9); testEight(strings, doubles, 1); testEight(strings, doubles, 9); }",8,524.22,302.4,1683,108,73.89,410.4,598.11,FALSE,FALSE
728,2,BODY,},8,4.22,4.8,1,108,73.89,112.8,78.11,FALSE,FALSE
728,4,BODY,throw[throw]+=throw => ArrayReferenceThrow throw[throw]+=throw => ArrayReferenceThrow throw[throw]+='heh' => ArrayReferenceThrow throw[throw]+=12345 => ArrayReferenceThrow throw[1]+=throw => ArrayReferenceThrow throw[1]+=throw => ArrayReferenceThrow throw[1]+='heh' => ArrayReferenceThrow throw[1]+=12345 => ArrayReferenceThrow null[throw]+=throw => IndexThrow null[throw]+=throw => IndexThrow null[throw]+='heh' => IndexThrow null[throw]+=12345 => IndexThrow null[1]+=throw => NullPointerException null[1]+=throw => NullPointerException null[1]+='heh' => NullPointerException null[1]+=12345 => NullPointerException null[throw]+=throw => IndexThrow null[throw]+=throw => IndexThrow null[throw]+='heh' => IndexThrow null[throw]+=12345 => IndexThrow null[9]+=throw => NullPointerException null[9]+=throw => NullPointerException null[9]+='heh' => NullPointerException null[9]+=12345 => NullPointerException Strings[throw]+=throw => IndexThrow doubles[throw]+=throw => IndexThrow Strings[throw]+='heh' => IndexThrow doubles[throw]+=12345 => IndexThrow Strings[1]+=throw => RightHandSideThrow doubles[1]+=throw => RightHandSideThrow Strings[1]+='heh' => Okay! doubles[1]+=12345 => Okay! Strings[throw]+=throw => IndexThrow doubles[throw]+=throw => IndexThrow Strings[throw]+='heh' => IndexThrow doubles[throw]+=12345 => IndexThrow Strings[9]+=throw => ArrayIndexOutOfBoundsException doubles[9]+=throw => ArrayIndexOutOfBoundsException Strings[9]+='heh' => ArrayIndexOutOfBoundsException doubles[9]+=12345 => ArrayIndexOutOfBoundsException,8,434.22,244.8,1533,108,117.89,352.8,552.11,FALSE,FALSE
729,2,BODY,Strings[1]+=throw => RightHandSideThrow doubles[1]+=throw => RightHandSideThrow,8,14.22,187.2,79,108,73.89,295.2,88.11,FALSE,FALSE
729,5,BODY,class Test { public static void main(String[] args) { int k = 1; int[] a = { 1 }; k += (k = 4) * (k + 2); a[0] += (a[0] = 4) * (a[0] + 2); System.out.println('k==' + k + ' and a[0]==' + a[0]); } },8,84.22,297.6,196,108,191.89,405.6,276.11,FALSE,FALSE
729,7,BODY,k==25 and a[0]==25,8,4.22,86.4,18,108,315.89,194.4,320.11,FALSE,FALSE
729,9,BODY,k += (k = 4) * (k + 2); a[0] += (a[0] = 4) * (a[0] + 2);,8,14.22,153.6,56,108,421.89,261.6,436.11,FALSE,FALSE
729,11,BODY,k = k + (k = 4) * (k + 2); a[0] = a[0] + (a[0] = 4) * (a[0] + 2);,8,14.22,182.4,65,108,475.89,290.4,490.11,FALSE,FALSE
737,2,BODY,"void m2(int x) { int y; y = 1; foo(() -> x+y); // Legal: x and y are both effectively final. } void m3(int x) { int y; if (...) y = 1; foo(() -> x+y); // Illegal: y is effectively final, but not definitely assigned. } void m4(int x) { int y; if (...) y = 1; else y = 2; foo(() -> x+y); // Legal: x and y are both effectively final. } void m5(int x) { int y; if (...) y = 1; y = 2; foo(() -> x+y); // Illegal: y is not effectively final. } void m6(int x) { foo(() -> x+1); x++; // Illegal: x is not effectively final. } void m7(int x) { foo(() -> x=1); // Illegal: x is not effectively final. } void m8() { int y; foo(() -> y=1); // Illegal: y is not definitely assigned before the lambda. } void m9(String[] arr) { for (String s : arr) { foo(() -> s); // Legal: s is effectively final // (it is a new variable on each iteration) } }",8,524.22,326.4,832,90,73.89,416.4,598.11,FALSE,FALSE
738,2,BODY,"void m10(String[] arr) { for (int i = 0; i < arr.length; i++) { foo(() -> arr[i]); // Illegal: i is not effectively final // (it is not final, and is incremented) } }",8,64.22,230.4,166,90,83.89,320.4,148.11,FALSE,FALSE
746,3,BODY,true (short)(1*2*3*4*5*6) Integer.MAX_VALUE / 2 2.0 * Math.PI 'The integer ' + Long.MAX_VALUE + ' is mighty big.',8,44.22,244.8,113,108,94.89,352.8,139.11,FALSE,FALSE
748,4,BODY,{ int k; if (v > 0 && (k = System.in.read()) >= 0) System.out.println(k); },8,44.22,216,75,108,221.89,324,266.11,FALSE,FALSE
748,6,BODY,v > 0 && (k = System.in.read()) >= 0,8,4.22,172.8,36,108,305.89,280.8,310.11,FALSE,FALSE
748,8,BODY,{ int k; while (true) { k = n; if (k >= 5) break; n = 6; } System.out.println(k); },8,84.22,124.8,83,108,381.89,232.8,466.11,FALSE,FALSE
748,10,BODY,{ int k; while (n < 4) { k = n; if (k >= 5) break;,8,44.22,124.8,50,108,557.89,232.8,602.11,FALSE,FALSE
749,1,BODY,n = 6; } System.out.println(k);  /* k is not 'definitely assigned' before this statement */ },8,44.22,292.8,93,108,73.89,400.8,118.11,FALSE,FALSE
749,5,BODY,{ int k; int n = 5; if (n > 2) k = 3; System.out.println(k);  /* k is not 'definitely assigned' before this statement */ },8,74.22,292.8,122,108,214.89,400.8,289.11,FALSE,FALSE
749,7,BODY,void flow(boolean flag) { int k; if (flag) k = 3; else k = 4; System.out.println(k); },8,74.22,124.8,86,108,390.89,232.8,465.11,FALSE,FALSE
749,9,BODY,void flow(boolean flag) { int k; if (flag) k = 3; if (!flag) k = 4; System.out.println(k);  /* k is not 'definitely assigned' before this statement */,8,74.22,292.8,150,108,524.89,400.8,599.11,FALSE,FALSE
750,1,BODY,},8,4.22,4.8,1,108,73.89,112.8,78.11,FALSE,FALSE
750,6,BODY,void unflow(boolean flag) { final int k; if (flag) { k = 3; System.out.println(k); } if (!flag) { k = 4; System.out.println(k);  /* k is not 'definitely unassigned' before this statement */ } },8,114.22,321.6,193,108,328.89,429.6,443.11,FALSE,FALSE
781,2,BODY,while (!this.done) Thread.sleep(1000);,8,14.22,110.4,38,90,73.89,200.4,88.11,FALSE,FALSE
790,2,BODY,1: B = 1; 3: A = 2; 2: r2 = A;  // sees initial write of 0 4: r1 = B;  // sees initial write of 0,8,34.22,182.4,97,108,73.89,290.4,108.11,FALSE,FALSE
790,4,BODY,1: r2 = A;  // sees write of A = 2 3: r1 = B;  // sees write of B = 1 2: B = 1; 4: A = 2;,8,34.22,163.2,89,108,147.89,271.2,182.11,FALSE,FALSE
793,9,BODY,r1 = x;  // sees write of x = 1 y = 1; r2 = y;  // sees write of y = 1 x = 1;,8,34.22,148.8,77,108,505.89,256.8,540.11,FALSE,FALSE
797,5,BODY,class FinalFieldExample { final int x; int y; static FinalFieldExample f;  public FinalFieldExample() { x = 3; y = 4; }  static void writer() { f = new FinalFieldExample(); }  static void reader() { if (f != null) { int i = f.x;  // guaranteed to see 3 int j = f.y;  // could see 0 } } },8,204.22,244.8,287,108,168.89,352.8,373.11,FALSE,FALSE
797,9,BODY,Global.s = '/tmp/usr'.substring(4);,8,4.22,168,35,108,531.89,276,536.11,FALSE,FALSE
797,11,BODY,String myS = Global.s; if (myS.equals('/tmp'))System.out.println(myS);,8,14.22,225.6,70,108,575.89,333.6,590.11,FALSE,FALSE
799,6,BODY,class A { final int x; A() { x = 1; }  int f() {,8,64.22,81.6,48,108,537.89,189.6,602.11,FALSE,FALSE
800,2,BODY,"return d(this,this); }  int d(A a1, A a2) { int i = a1.x; g(a1); int j = a2.x; return j - i; }  static void g(A a) { // uses reflection to change a.x to 2 } }",8,134.22,225.6,158,108,73.89,333.6,208.11,FALSE,FALSE
802,2,BODY,return; } v++; counts[id] = v; } }  public static void main(String[] args) { for (int i = 0; i < LENGTH; ++i) (threads[i] = new WordTearing(i)).start(); } },8,114.22,268.8,156,108,73.89,376.8,188.11,FALSE,FALSE
812,7,BODY,k,8,4.6,4.13,1,339.64,495.11,343.76,499.72,FALSE,FALSE
812,8,BODY,k,8,4.6,4.13,1,195.1,508.11,199.23,512.72,FALSE,FALSE
812,9,BODY,k,8,4.6,4.13,1,408.19,508.11,412.32,512.72,FALSE,FALSE
812,10,BODY,k,8,4.6,4.13,1,385.38,521.11,389.51,525.72,FALSE,FALSE
838,7,BODY,"import java.util.function.UnaryOperator; record Mapper<T>(T in, T out) implements UnaryOperator<T> { public T apply(T arg) { return in.equals(arg) ? out : null; } } class IllustrateRecordPatternTypeInference{ void test(UnaryOperator<? extends CharSequence> op) { if (op instanceof Mapper(var in, var out)) { boolean shorter = out.length() < in.length(); } } }",8,144.22,283.2,359,108,349.38,391.2,493.6,FALSE,FALSE
422,7,BODY,"Example 10.5-1. ArrayStoreException class Point { int x, y; } class ColoredPoint extends Point { int color; } class Test { public static void main(String[] args) { ColoredPoint[] cpa = new ColoredPoint[10]; Point[] pa = cpa; System.out.println(pa[1] == null); try { pa[0] = new Point(); } catch (ArrayStoreException e) { System.out.println(e); } } }",7.99,153.49,262.8,349,90,448.62,352.8,602.11,FALSE,FALSE
76,8,BODY,Emax Emin,6.75,22.2,16.74,9,74.25,295.85,90.99,318.05,FALSE,TRUE
792,3,BODY,iCi,6.67,4.77,33.85,3,110.99,390.92,144.84,395.69,FALSE,TRUE
792,4,BODY,iCi,6.67,4.77,32.62,3,109.77,409.92,142.4,414.69,FALSE,TRUE
792,5,BODY,iCi,6.67,4.77,29.57,3,106.72,460.92,136.28,465.69,FALSE,TRUE
792,6,BODY,i-1Ci-1,6.29,4.77,42.31,7,109.16,479.92,151.47,484.69,FALSE,TRUE
56,4,BODY,0b0111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111L,6,3.56,332.1,82,82,155.23,414.1,158.79,FALSE,FALSE
56,6,BODY,0b1000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000L,6,3.56,332.1,82,82,257.23,414.1,260.79,FALSE,FALSE
56,7,BODY,0b1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111L,6,3.56,332.1,82,82,346.23,414.1,349.79,FALSE,FALSE
709,3,BODY,byteshortcharint,6,3.16,249.32,16,140.59,245.28,389.9,248.45,FALSE,FALSE
709,4,BODY,3rd →,6,4.23,17.79,5,74.25,247.45,92.04,251.69,TRUE,FALSE
709,5,BODY,2nd ↓,6,4.23,16.02,5,74.25,267.19,90.27,271.43,TRUE,FALSE
709,6,BODY,"bytebyteshortbnp(byte,char)byte | bnp(byte,int)",6,3.63,340.18,47,74.25,285.25,414.43,288.88,FALSE,FALSE
709,7,BODY,"Bytebyteshortbnp(Byte,char)byte | bnp(Byte,int)",6,3.63,340.18,47,74.25,302.25,414.43,305.88,FALSE,FALSE
709,8,BODY,"shortshortshortbnp(short,char)short | bnp(short,int)",6,3.63,343.78,52,74.25,319.75,418.03,323.38,FALSE,FALSE
709,9,BODY,"Shortshortshortbnp(Short,char)short | bnp(Short,int)",6,3.63,343.78,52,74.25,336.75,418.03,340.38,FALSE,FALSE
709,10,BODY,"charbnp(char,byte)bnp(char,short)charchar | bnp(char,int)",6,3.63,340.18,57,74.25,354.25,414.43,357.88,FALSE,FALSE
709,11,BODY,"Characterbnp(Character,byte)bnp(Character,short)charchar | bnp(Character,int)",6,3.63,349.18,77,74.25,371.25,423.43,374.88,FALSE,FALSE
709,12,BODY,"intbyte | bnp(int,byte)short | bnp(int,short)char | bnp(int,char)int",6,3.63,315.65,68,74.25,388.75,389.9,392.38,FALSE,FALSE
709,13,BODY,"Integerbnp(Integer,byte)bnp(Integer,short)bnp(Integer,char)int",6,3.63,315.65,62,74.25,405.75,389.9,409.38,FALSE,FALSE
709,14,BODY,"longbnp(long,byte)bnp(long,short)bnp(long,char)bnp(long,int)",6,3.63,330.71,60,74.25,423.25,404.96,426.88,FALSE,FALSE
709,15,BODY,"Longbnp(Long,byte)bnp(Long,short)bnp(Long,char)bnp(Long,int)",6,3.63,330.71,60,74.25,440.25,404.96,443.88,FALSE,FALSE
709,16,BODY,"floatbnp(float,byte)bnp(float,short)bnp(float,char)bnp(float,int)",6,3.63,332.51,65,74.25,457.75,406.76,461.38,FALSE,FALSE
709,17,BODY,"Floatbnp(Float,byte)bnp(Float,short)bnp(Float,char)bnp(Float,int)",6,3.63,332.51,65,74.25,474.75,406.76,478.38,FALSE,FALSE
709,18,BODY,"doublebnp(double,byte)bnp(double,short)bnp(double,char)bnp(double,int)",6,3.63,334.31,70,74.25,492.25,408.56,495.88,FALSE,FALSE
709,19,BODY,"Doublebnp(Double,byte)bnp(Double,short)bnp(Double,char)bnp(Double,int)",6,3.63,334.31,70,74.25,509.25,408.56,512.88,FALSE,FALSE
709,20,BODY,"booleanlub(Boolean,Byte)lub(Boolean,Short)lub(Boolean,Character)lub(Boolean,Integer)",6,3.63,342.58,84,74.25,526.75,416.83,530.38,FALSE,FALSE
709,21,BODY,"Booleanlub(Boolean,Byte)lub(Boolean,Short)lub(Boolean,Character)lub(Boolean,Integer)",6,3.63,342.58,84,74.25,543.75,416.83,547.38,FALSE,FALSE
709,22,BODY,"nulllub(null,Byte)lub(null,Short)lub(null,Character)lub(null,Integer)",6,3.63,337.18,69,74.25,561.25,411.43,564.88,FALSE,FALSE
709,23,BODY,"Objectlub(Object,Byte)lub(Object,Short)lub(Object,Character)lub(Object,Integer)",6,3.63,340.78,79,74.25,578.25,415.03,581.88,FALSE,FALSE
710,3,BODY,longfloatdoubleboolean,6,3.17,259.67,22,144.8,96.28,404.47,99.45,FALSE,FALSE
710,4,BODY,3rd →,6,4.23,17.79,5,74.25,98.45,92.04,102.69,TRUE,FALSE
710,5,BODY,2nd ↓,6,4.23,16.02,5,74.25,118.2,90.27,122.43,TRUE,FALSE
710,6,BODY,"bytebnp(byte,long)bnp(byte,float)bnp(byte,double)lub(Byte,Boolean)",6,3.63,344.56,66,74.25,136.25,418.81,139.88,FALSE,FALSE
710,7,BODY,"Bytebnp(Byte,long)bnp(Byte,float)bnp(Byte,double)lub(Byte,Boolean)",6,3.63,344.56,66,74.25,153.25,418.81,156.88,FALSE,FALSE
710,8,BODY,"shortbnp(short,long)bnp(short,float)bnp(short,double)lub(Short,Boolean)",6,3.63,346.36,71,74.25,170.75,420.61,174.38,FALSE,FALSE
710,9,BODY,"Shortbnp(Short,long)bnp(Short,float)bnp(Short,double)lub(Short,Boolean)",6,3.63,346.36,71,74.25,187.75,420.61,191.38,FALSE,FALSE
710,10,BODY,"charbnp(char,long)bnp(char,float)bnp(char,double)lub(Character,Boolean)",6,3.63,353.56,71,74.25,205.25,427.81,208.88,FALSE,FALSE
710,11,BODY,"Characterbnp(Character,long)bnp(Character,float)bnp(Character,double)lub(Character,Boolean)",6,3.63,353.56,91,74.25,222.25,427.81,225.88,FALSE,FALSE
710,12,BODY,"intbnp(int,long)bnp(int,float)bnp(int,double)lub(Integer,Boolean)",6,3.63,349.96,65,74.25,239.75,424.21,243.38,FALSE,FALSE
710,13,BODY,"Integerbnp(Integer,long)bnp(Integer,float)bnp(Integer,double)lub(Integer,Boolean)",6,3.63,349.96,81,74.25,256.75,424.21,260.38,FALSE,FALSE
710,14,BODY,"longlongbnp(long,float)bnp(long,double)lub(Long,Boolean)",6,3.63,344.56,56,74.25,274.25,418.81,277.88,FALSE,FALSE
710,15,BODY,"Longlongbnp(Long,float)bnp(Long,double)lub(Long,Boolean)",6,3.63,344.56,56,74.25,291.25,418.81,294.88,FALSE,FALSE
710,16,BODY,"floatbnp(float,long)floatbnp(float,double)lub(Float,Boolean)",6,3.63,346.36,60,74.25,308.75,420.61,312.38,FALSE,FALSE
710,17,BODY,"Floatbnp(Float,long)floatbnp(Float,double)lub(Float,Boolean)",6,3.63,346.36,60,74.25,325.75,420.61,329.38,FALSE,FALSE
710,18,BODY,"doublebnp(double,long)bnp(double,float)doublelub(Double,Boolean)",6,3.63,348.16,64,74.25,343.25,422.41,346.88,FALSE,FALSE
710,19,BODY,"Doublebnp(Double,long)bnp(Double,float)doublelub(Double,Boolean)",6,3.63,348.16,64,74.25,360.25,422.41,363.88,FALSE,FALSE
710,20,BODY,"booleanlub(Boolean,Long)lub(Boolean,Float)lub(Boolean,Double)boolean",6,3.63,330.22,68,74.25,377.75,404.47,381.38,FALSE,FALSE
710,21,BODY,"Booleanlub(Boolean,Long)lub(Boolean,Float)lub(Boolean,Double)boolean",6,3.63,330.22,68,74.25,394.75,404.47,398.38,FALSE,FALSE
710,22,BODY,"nulllub(null,Long)lub(null,Float)lub(null,Double)lub(null,Boolean)",6,3.63,344.56,66,74.25,412.25,418.81,415.88,FALSE,FALSE
710,23,BODY,"Objectlub(Object,Long)lub(Object,Float)lub(Object,Double)lub(Object,Boolean)",6,3.63,348.16,76,74.25,429.25,422.41,432.88,FALSE,FALSE
711,3,BODY,ByteShortCharacterInteger,6,3.17,262.67,25,136.8,96.28,399.47,99.45,FALSE,FALSE
711,4,BODY,3rd →,6,4.23,17.79,5,74.25,98.45,92.04,102.69,TRUE,FALSE
711,5,BODY,2nd ↓,6,4.23,16.02,5,74.25,118.2,90.27,122.43,TRUE,FALSE
711,6,BODY,"bytebyteshortbnp(byte,Character)bnp(byte,Integer)",6,3.63,340.28,49,74.25,136.25,414.53,139.88,FALSE,FALSE
711,7,BODY,"ByteByteshortbnp(Byte,Character)bnp(Byte,Integer)",6,3.63,340.28,49,74.25,153.25,414.53,156.88,FALSE,FALSE
711,8,BODY,"shortshortshortbnp(short,Character)bnp(short,Integer)",6,3.63,342.08,53,74.25,170.75,416.33,174.38,FALSE,FALSE
711,9,BODY,"ShortshortShortbnp(Short,Character)bnp(Short,Integer)",6,3.63,342.08,53,74.25,187.75,416.33,191.38,FALSE,FALSE
711,10,BODY,"charbnp(char,Byte)bnp(char,Short)charbnp(char,Integer)",6,3.63,340.28,54,74.25,205.25,414.53,208.88,FALSE,FALSE
711,11,BODY,"Characterbnp(Character,Byte)bnp(Character,Short)Characterbnp(Character,Integer)",6,3.63,349.28,79,74.25,222.25,423.53,225.88,FALSE,FALSE
711,12,BODY,"intbyte | bnp(int,Byte)short | bnp(int,Short)char | bnp(int,Character)int",6,3.63,318.02,73,74.25,239.75,392.27,243.38,FALSE,FALSE
711,13,BODY,"Integerbnp(Integer,Byte)bnp(Integer,Short)bnp(Integer,Character)Integer",6,3.63,325.22,71,74.25,256.75,399.47,260.38,FALSE,FALSE
711,14,BODY,"longbnp(long,Byte)bnp(long,Short)bnp(long,Character)bnp(long,Integer)",6,3.63,340.28,69,74.25,274.25,414.53,277.88,FALSE,FALSE
711,15,BODY,"Longbnp(Long,Byte)bnp(Long,Short)bnp(Long,Character)bnp(Long,Integer)",6,3.63,340.28,69,74.25,291.25,414.53,294.88,FALSE,FALSE
711,16,BODY,"floatbnp(float,Byte)bnp(float,Short)bnp(float,Character)bnp(float,Integer)",6,3.63,342.08,74,74.25,308.75,416.33,312.38,FALSE,FALSE
711,17,BODY,"Floatbnp(Float,Byte)bnp(Float,Short)bnp(Float,Character)bnp(Float,Integer)",6,3.63,342.08,74,74.25,325.75,416.33,329.38,FALSE,FALSE
711,18,BODY,"doublebnp(double,Byte)bnp(double,Short)bnp(double,Character)bnp(double,Integer)",6,3.63,343.88,79,74.25,343.25,418.13,346.88,FALSE,FALSE
711,19,BODY,"Doublebnp(Double,Byte)bnp(Double,Short)bnp(Double,Character)bnp(Double,Integer)",6,3.63,343.88,79,74.25,360.25,418.13,363.88,FALSE,FALSE
711,20,BODY,"booleanlub(Boolean,Byte)lub(Boolean,Short)lub(Boolean,Character)lub(Boolean,Integer)",6,3.63,344.96,84,74.25,377.75,419.21,381.38,FALSE,FALSE
711,21,BODY,"Booleanlub(Boolean,Byte)lub(Boolean,Short)lub(Boolean,Character)lub(Boolean,Integer)",6,3.63,344.96,84,74.25,394.75,419.21,398.38,FALSE,FALSE
711,22,BODY,nullByteShortCharacterInteger,6,3.17,325.22,29,74.25,412.25,399.47,415.42,FALSE,FALSE
711,23,BODY,"Objectlub(Object,Byte)lub(Object,Short)lub(Object,Character)lub(Object,Integer)",6,3.63,343.16,79,74.25,429.25,417.41,432.88,FALSE,FALSE
712,3,BODY,LongFloatDoubleBoolean,6,3.17,259.67,22,144.8,96.28,404.47,99.45,FALSE,FALSE
712,4,BODY,3rd →,6,4.23,17.79,5,74.25,98.45,92.04,102.69,TRUE,FALSE
712,5,BODY,2nd ↓,6,4.23,16.02,5,74.25,118.2,90.27,122.43,TRUE,FALSE
712,6,BODY,"bytebnp(byte,Long)bnp(byte,Float)bnp(byte,Double)lub(Byte,Boolean)",6,3.63,344.56,66,74.25,136.25,418.81,139.88,FALSE,FALSE
712,7,BODY,"Bytebnp(Byte,Long)bnp(Byte,Float)bnp(Byte,Double)lub(Byte,Boolean)",6,3.63,344.56,66,74.25,153.25,418.81,156.88,FALSE,FALSE
712,8,BODY,"shortbnp(short,Long)bnp(short,Float)bnp(short,Double)lub(Short,Boolean)",6,3.63,346.36,71,74.25,170.75,420.61,174.38,FALSE,FALSE
712,9,BODY,"Shortbnp(Short,Long)bnp(Short,Float)bnp(Short,Double)lub(Short,Boolean)",6,3.63,346.36,71,74.25,187.75,420.61,191.38,FALSE,FALSE
712,10,BODY,"charbnp(char,Long)bnp(char,Float)bnp(char,Double)lub(Character,Boolean)",6,3.63,353.56,71,74.25,205.25,427.81,208.88,FALSE,FALSE
712,11,BODY,"Characterbnp(Character,Long)bnp(Character,Float)bnp(Character,Double)lub(Character,Boolean)",6,3.63,353.56,91,74.25,222.25,427.81,225.88,FALSE,FALSE
712,12,BODY,"intbnp(int,Long)bnp(int,Float)bnp(int,Double)lub(Integer,Boolean)",6,3.63,349.96,65,74.25,239.75,424.21,243.38,FALSE,FALSE
712,13,BODY,"Integerbnp(Integer,Long)bnp(Integer,Float)bnp(Integer,Double)lub(Integer,Boolean)",6,3.63,349.96,81,74.25,256.75,424.21,260.38,FALSE,FALSE
712,14,BODY,"longlongbnp(long,Float)bnp(long,Double)lub(Long,Boolean)",6,3.63,344.56,56,74.25,274.25,418.81,277.88,FALSE,FALSE
712,15,BODY,"LongLongbnp(Long,Float)bnp(Long,Double)lub(Long,Boolean)",6,3.63,344.56,56,74.25,291.25,418.81,294.88,FALSE,FALSE
712,16,BODY,"floatbnp(float,Long)floatbnp(float,Double)lub(Float,Boolean)",6,3.63,346.36,60,74.25,308.75,420.61,312.38,FALSE,FALSE
712,17,BODY,"Floatbnp(Float,Long)Floatbnp(Float,Double)lub(Float,Boolean)",6,3.63,346.36,60,74.25,325.75,420.61,329.38,FALSE,FALSE
712,18,BODY,"doublebnp(double,Long)bnp(double,Float)doublelub(Double,Boolean)",6,3.63,348.16,64,74.25,343.25,422.41,346.88,FALSE,FALSE
712,19,BODY,"Doublebnp(Double,Long)bnp(Double,Float)Doublelub(Double,Boolean)",6,3.63,348.16,64,74.25,360.25,422.41,363.88,FALSE,FALSE
712,20,BODY,"booleanlub(Boolean,Long)lub(Boolean,Float)lub(Boolean,Double)boolean",6,3.63,330.22,68,74.25,377.75,404.47,381.38,FALSE,FALSE
712,21,BODY,"Booleanlub(Boolean,Long)lub(Boolean,Float)lub(Boolean,Double)Boolean",6,3.63,330.22,68,74.25,394.75,404.47,398.38,FALSE,FALSE
712,22,BODY,nullLongFloatDoubleBoolean,6,3.17,330.22,26,74.25,412.25,404.47,415.42,FALSE,FALSE
712,23,BODY,"Objectlub(Object,Long)lub(Object,Float)lub(Object,Double)lub(Object,Boolean)",6,3.63,348.16,76,74.25,429.25,422.41,432.88,FALSE,FALSE
713,3,BODY,null,6,3.17,14.4,4,208.8,96.28,223.2,99.45,FALSE,FALSE
713,4,BODY,Object,6,3.17,21.6,6,349.08,96.28,370.67,99.45,FALSE,FALSE
713,5,BODY,3rd →,6,4.23,17.79,5,74.25,98.45,92.04,102.69,TRUE,FALSE
713,6,BODY,2nd ↓,6,4.23,16.02,5,74.25,118.2,90.27,122.43,TRUE,FALSE
713,7,BODY,byte,6,3.16,14.4,4,74.25,136.25,88.65,139.41,FALSE,FALSE
713,8,BODY,"lub(Byte,null)lub(Byte,Object)",6,3.63,190.54,30,194.47,136.25,385.01,139.88,FALSE,FALSE
713,9,BODY,Byte,6,3.16,14.4,4,74.25,153.25,88.65,156.42,FALSE,FALSE
713,10,BODY,Byte,6,3.16,14.4,4,208.8,153.25,223.2,156.42,FALSE,FALSE
713,11,BODY,"lub(Byte,Object)",6,3.63,50.26,16,334.74,153.25,385.01,156.88,FALSE,FALSE
713,12,BODY,short,6,3.16,18,5,74.25,170.75,92.25,173.91,FALSE,FALSE
713,13,BODY,"lub(Short,null)lub(Short,Object)",6,3.63,194.14,32,192.67,170.75,386.81,174.38,FALSE,FALSE
713,14,BODY,Short,6,3.16,18,5,74.25,187.75,92.25,190.91,FALSE,FALSE
713,15,BODY,Short,6,3.16,18,5,207,187.75,225,190.91,FALSE,FALSE
713,16,BODY,"lub(Short,Object)",6,3.63,53.86,17,332.95,187.75,386.81,191.38,FALSE,FALSE
713,17,BODY,"charlub(Character,null)lub(Character,Object)",6,3.63,319.76,44,74.25,205.25,394.01,208.88,FALSE,FALSE
713,18,BODY,"CharacterCharacterlub(Character,Object)",6,3.63,319.76,39,74.25,222.25,394.01,225.88,FALSE,FALSE
713,19,BODY,int,6,3.16,10.8,3,74.25,239.75,85.05,242.91,FALSE,FALSE
713,20,BODY,"lub(Integer,null)lub(Integer,Object)",6,3.63,201.34,36,189.07,239.75,390.41,243.38,FALSE,FALSE
713,21,BODY,Integer,6,3.17,25.2,7,74.25,256.75,99.45,259.92,FALSE,FALSE
713,22,BODY,Integer,6,3.17,25.2,7,203.4,256.75,228.6,259.92,FALSE,FALSE
713,23,BODY,"lub(Integer,Object)",6,3.63,61.06,19,329.35,256.75,390.41,260.38,FALSE,FALSE
713,24,BODY,long,6,3.17,14.4,4,74.25,274.25,88.65,277.42,FALSE,FALSE
713,25,BODY,"lub(Long,null)lub(Long,Object)",6,3.63,190.54,30,194.47,274.25,385.01,277.88,FALSE,FALSE
713,26,BODY,Long,6,3.17,14.4,4,74.25,291.25,88.65,294.42,FALSE,FALSE
713,27,BODY,Long,6,3.17,14.4,4,208.8,291.25,223.2,294.42,FALSE,FALSE
713,28,BODY,"lub(Long,Object)",6,3.63,50.26,16,334.74,291.25,385.01,294.88,FALSE,FALSE
713,29,BODY,float,6,3.17,18,5,74.25,308.75,92.25,311.92,FALSE,FALSE
713,30,BODY,"lub(Float,null)lub(Float,Object)",6,3.63,194.14,32,192.67,308.75,386.81,312.38,FALSE,FALSE
713,31,BODY,Float,6,3.17,18,5,74.25,325.75,92.25,328.92,FALSE,FALSE
713,32,BODY,Float,6,3.17,18,5,207,325.75,225,328.92,FALSE,FALSE
713,33,BODY,"lub(Float,Object)",6,3.63,53.86,17,332.95,325.75,386.81,329.38,FALSE,FALSE
713,34,BODY,"doublelub(Double,null)lub(Double,Object)",6,3.63,314.36,40,74.25,343.25,388.61,346.88,FALSE,FALSE
713,35,BODY,Double,6,3.17,21.6,6,74.25,360.25,95.85,363.42,FALSE,FALSE
713,36,BODY,Double,6,3.17,21.6,6,205.2,360.25,226.8,363.42,FALSE,FALSE
713,37,BODY,"lub(Double,Object)",6,3.63,57.46,18,331.14,360.25,388.61,363.88,FALSE,FALSE
713,38,BODY,"booleanlub(Boolean,null)lub(Boolean,Object)",6,3.63,316.16,43,74.25,377.75,390.41,381.38,FALSE,FALSE
713,39,BODY,Boolean,6,3.17,25.2,7,74.25,394.75,99.45,397.92,FALSE,FALSE
713,40,BODY,Boolean,6,3.17,25.2,7,203.4,394.75,228.6,397.92,FALSE,FALSE
713,41,BODY,"lub(Boolean,Object)",6,3.63,61.06,19,329.35,394.75,390.41,398.38,FALSE,FALSE
713,42,BODY,null,6,3.17,14.4,4,74.25,412.25,88.65,415.42,FALSE,FALSE
713,43,BODY,null,6,3.17,14.4,4,208.8,412.25,223.2,415.42,FALSE,FALSE
713,44,BODY,"lub(null,Object)",6,3.63,50.26,16,334.74,412.25,385.01,415.88,FALSE,FALSE
713,45,BODY,Object,6,3.17,21.6,6,74.25,429.25,95.85,432.42,FALSE,FALSE
713,46,BODY,Object,6,3.17,21.6,6,205.2,429.25,226.8,432.42,FALSE,FALSE
713,47,BODY,Object,6,3.17,21.6,6,349.08,429.25,370.67,432.42,FALSE,FALSE
17,2,BODY,®,5,3.07,4.18,1,126.72,218.16,130.9,221.23,FALSE,FALSE
24,3,BODY,®,5,3.02,4.18,1,218.5,298.86,222.68,301.89,FALSE,TRUE
24,4,BODY,®,5,3.02,4.18,1,427.82,311.86,432,314.89,FALSE,TRUE
24,5,BODY,®,5,3.02,4.18,1,269.62,408.86,273.8,411.89,FALSE,TRUE
26,4,BODY,®,5,3.02,4.18,1,427.82,255.86,432,258.89,FALSE,TRUE
